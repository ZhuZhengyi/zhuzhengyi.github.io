# 并发模型

## Actor 模型

### 简介

Actors 模型(Actor model)首先是由 Carl Hewitt 在 1973 定义， 由 Erlang OTP (Open Telecom Platform) 推广，其 消息传递更加符合面向对象的原始意图。 Actors 属于并发组件模型 ，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。

传统多数流行的语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors 使用消息模型，每个 Actors 在同一时间处理最多一个消息，可以发送消息给其他 Actors，保证了[单独写原则 ](https://www.jdon.com/performance/singlewriter.html)。从而巧妙避免了多线程写争夺。

### 特点

- 隔离计算实体

- "Share nothing"
* 没有任何地方同步

* 异步消息传递

* 不可变的消息 消息模型类似 mailbox / queue

### 原理

![image-20190705165231907](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/12-20-48-59-image-20190705165231907.png)

在 Actor 模型中，主角是 Actor，类似一种 worker，Actor 彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的：

![image-20190705154201375](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/12-20-48-26-image-20190705154201375.png)

Actor 模型描述了一组为了避免并发编程的常见问题的公

1.所有 Actor 状态是 Actor 本地的，外部无法访问。
　　 2.Actor 必须只有

### 优点

1)将消息收发、线程调度、处理竞争和同步的所有复杂逻辑都委托给了 Actor 框架本身，而且对应用来说是透明的，我们可以认为 Actor 只是一个实现了 Runnable 接口的对象。关注多线程并发问题时，只需要关注多个 Actor 之间的消息流即可。 2)符合 Actor 模型的程序很容易进行测试，因为任意一个 Actor 都可以被单独进行单元测试。如果测试案例覆盖了该 Actor 所能响应的所有类型的消息，我们就可以确定该 Actor 的代码十分可靠。

### 缺点

1. Actor 完全避免共享并且仅通过消息来进行交流，使得程序失去了精细化并发调控能力，所以不适合实施细粒度的并行且可能导致系统响应时延的增加。如果在 Actor 程序中引入一些并行框架，就可能会导致系统的不确定性。
   2）尽管使用 Actor 模型的程序 比使用线程和锁模型的程序更容易调试，Actor 模型仍会碰到死锁这一类的共性问题，也会碰到一些 Actor 模型独有的问题（例如信箱移溢出）。

## CSP

![image-20190705154252953](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/12-20-47-31-image-20190705154252953.png)

### Acotr 模型和 CSP 模型区别

- Actor 之间直接通讯，而 CSP 是通过 Channel 通讯，
- 在耦合度上两者是有区别的，后者更加松耦合。
- 在 CSP 消息交换是同步的(即两个流程的执行"接触点"的，在此他们交换消息)，而 Actor 模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。

![image-20190705154059737](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/12-20-47-36-image-20190705154059737.png)
