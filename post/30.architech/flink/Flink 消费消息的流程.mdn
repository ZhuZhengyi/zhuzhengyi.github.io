# Flink消息消费流程

## 简介

1. 准备一个ResultPartition；  

2. 通知JobMaster；  

3. JobMaster通知下游节点；如果下游节点尚未部署，则部署之；  

4. 下游节点向上游请求数据  

5. 开始传输数据

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/03-21-34-50-2022-01-03-21-34-42-image.png)

### 数据跨 task 传输

1. 数据在本operator处理完后，交给RecordWriter。每条记录都要选择一个下游节点，所以要经过ChannelSelector。

2. 每个channel都有一个serializer（我认为这应该是为了避免多线程写的麻烦），把这条Record序列化为ByteBuffer

3. 接下来数据被写入ResultPartition下的各个subPartition里，此时该数据已经存入DirectBuffer（MemorySegment）

4. 单独的线程控制数据的flush速度，一旦触发flush，则通过Netty的nio通道向对端写入

5. 对端的netty client接收到数据，decode出来，把数据拷贝到buffer里，然后通知InputChannel

6. 有可用的数据时，下游算子从阻塞醒来，从InputChannel取出buffer，再解序列化成record，交给算子执行用户代码

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/03-21-39-06-2022-01-03-21-39-02-image.png)

## 参考

1. [一文搞定 Flink 消费消息的全流程_shengjk1的博客-CSDN博客_flink阻塞消费](https://blog.csdn.net/jsjsjs1789/article/details/106526982)
