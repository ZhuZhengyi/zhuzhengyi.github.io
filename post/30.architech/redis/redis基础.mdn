# Redis基础

## 简介

* Redis（Remote Dictionary Server，远程数据服务）是一款用C语言编写的内存高速缓存key-value存储系统；

* 支持丰富的数据类型，如：String、list、set、zset、hash；

* 可用于缓存，事件发布或订阅，高速队列等场景；

* 支持网络，提供字符串，哈希，列表，队列，集合结构直接存取；

* 基于内存，可持久化；

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/06-21-28-48-2022-01-06-21-28-45-image.png)

## 特性

- **性能优异**： 读110000次/s,写81000次/s ；
- **数据类型丰富**：支持Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- **原子性**：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
- **丰富的特性**：Redis支持 publish/subscribe, 通知, key 过期等特性。
- **持久化**：Redis支持RDB, AOF等持久化方式
- **发布订阅**：Redis支持发布/订阅模式
- **分布式**：Redis Cluster

## 数据类型

* 所有的key（键）都是字符串；

| 结构类型          | 结构存储的值                | 结构的读写能力                                                              |
| ------------- | --------------------- | -------------------------------------------------------------------- |
| **String字符串** | 可以是字符串、整数或浮点数         | 对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；                                 |
| **List**      | 一个链表，链表上的每个节点都包含一个字符串 | 对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；                             |
| **Set**       | 包含字符串的无序集合            | 字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等                          |
| **Hash**      | 包含键值对的无序散列表           | 包含方法有添加、获取、删除单个元素                                                    |
| **Zset有序集合**  | 和散列一样，用于存储键值对         | 字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素 |

## 架构

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/08-00-52-53-2022-01-08-00-52-49-image.png)

 Redis 发起请求命令的工作原理：

1. Redis 服务器启动，开启主线程事件循环（Event Loop），注册 `acceptTcpHandler` 连接应答处理器到用户配置的监听端口对应的文件描述符，等待新连接到来；
2. 客户端和服务端建立网络连接；
3. `acceptTcpHandler` 被调用，主线程使用 AE 的 API 将 `readQueryFromClient` 命令读取处理器绑定到新连接对应的文件描述符上，并初始化一个 `client` 绑定这个客户端连接；
4. 客户端发送请求命令，触发读就绪事件，主线程调用 `readQueryFromClient` 通过 socket 读取客户端发送过来的命令存入 `client->querybuf` 读入缓冲区；
5. 接着调用 `processInputBuffer`，在其中使用 `processInlineBuffer` 或者 `processMultibulkBuffer` 根据 Redis 协议解析命令，最后调用 `processCommand` 执行命令；
6. 根据请求命令的类型（SET, GET, DEL, EXEC 等），分配相应的命令执行器去执行，最后调用 `addReply` 函数族的一系列函数将响应数据写入到对应 `client` 的写出缓冲区：`client->buf` 或者 `client->reply` ，`client->buf` 是首选的写出缓冲区，固定大小 16KB，一般来说可以缓冲足够多的响应数据，但是如果客户端在时间窗口内需要响应的数据非常大，那么则会自动切换到 `client->reply` 链表上去，使用链表理论上能够保存无限大的数据（受限于机器的物理内存），最后把 `client` 添加进一个 LIFO 队列 `clients_pending_write`；
7. 在事件循环（Event Loop）中，主线程执行 `beforeSleep` --> `handleClientsWithPendingWrites`，遍历 `clients_pending_write` 队列，调用 `writeToClient` 把 `client` 的写出缓冲区里的数据回写到客户端，如果写出缓冲区还有数据遗留，则注册 `sendReplyToClient` 命令回复处理器到该连接的写就绪事件，等待客户端可写时在事件循环中再继续回写残余的响应数据。

https://segmentfault.com/img/remote/1460000039223698/view

## 配置

```shell
## 设置用户
> acl setuser user01 on >passwd01 allcommands allkeys

## 用户认证
> auth user01 passwd01
```

## 参考

1. [♥Redis教程 - Redis知识体系详解♥ | Java 全栈知识体系](https://pdai.tech/md/db/nosql-redis/db-redis-overview.html)

2. https://segmentfault.com/a/1190000039223696

3. [ACL – Redis](https://redis.io/topics/acl)

4. 
