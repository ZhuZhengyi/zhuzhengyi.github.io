# Go内存管理

## Go内部内存结构

首先，让我们看看Go内部的内存结构是什么样子的。

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-44-10-2020-03-10-19-07-25-image.png)

Go运行时将Goroutines（G）调度到逻辑处理器（P）上执行。每个P都有一台逻辑机器（M）。在这篇文章中，我们将使用P、M和G。如果您不熟悉Go调度程序，请先阅读 **《Go调度程序：Ms，Ps和Gs》** 。

## Goroutine调度原理

每个Go程序进程都由操作系统（OS）分配了一些虚拟内存，这是该进程可以访问的全部内存。在这个虚拟内存中实际正在使用的内存称为Resident Set（驻留内存)。该空间由内部内存结构管理，如下所示：

Go内部内存结构原理图

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-44-18-2020-03-10-19-08-20-image.png)

Go将内存划分和分组为页(page)，

这与我们在前几章中看到的 **JVM** 和 **V8** 的内存结构完全不同。如您所见，这里没有分代内存。Go的内存分配器是基于 **TCMalloc** （Thread Cache Malloc）实现的。

让我们看看Go独特的内存构造是什么样子的：

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-44-25-2020-03-10-19-09-10-image.png)

### 页堆page heap（mheap）

这里是Go存储动态数据（在编译时无法计算大小的任何数据）的地方。它是最大的内存块，也是进行垃圾收集（GC）的地方。

驻留内存(resident set)被划分为每个大小为8KB的页，并由一个全局 **mheap对象** 管理。

大对象（大小> 32kb的对象）直接从mheap分配。这些大对象申请请求是以获取中央锁(central lock)为代价的，因此在任何给定时间点只能满足一个P的请求。

mheap通过将页归类为不同结构进行管理的：

* mspan：mspan是mheap中管理的内存页的最基本结构。这是一个双向链接列表，其中包含起始页面的地址，span size class和span中的页面数量。像TCMalloc一样，Go将内存页按大小分为67个不同类别，大小从8字节到32KB

## mspan结构

每个span存在两个，一个span用于带指针的对象（scan class），一个用于无指针的对象（noscan class）。这在GC期间有帮助，因为noscan类查找活动对象时无需遍历span。

* mcentral：mcentral将相同大小级别的span归类在一起。每个mcentral包含两个mspanList：empty：双向span链表，包括没有空闲对象的span或缓存mcache中的span。当此处的span被释放时，它将被移至non-empty span链表。non-empty：有空闲对象的span双向链表。当从mcentral请求新的span，mcentral将从该链表中获取span并将其移入empty span链表。

如果mcentral没有可用的span，它将向mheap请求新页。

* arena：堆在已分配的虚拟内存中根据需要增长和缩小。当需要更多内存时，mheap从虚拟内存中以每块64MB（对于64位体系结构）为单位获取新内存， 这块内存被称为 **arena** 。这块内存也会被划分页并映射到span。
* mcache：这是一个非常有趣的构造。mcache是提供给P（逻辑处理器）的高速缓存，用于存储小对象（对象大小<= 32Kb）。尽管这类似于线程堆栈，但它是堆的一部分，用于动态数据。所有类大小的mcache包含scan和noscan类型mspan。Goroutine可以从mcache没有任何锁的情况下获取内存，因为一次P只能有一个锁G。因此，这更有效。mcache从mcentral需要时请求新的span。

### 栈

这是栈存储区，每个Goroutine（G）有一个栈。在这里存储了静态数据，包括函数栈帧，静态结构，原生类型值和指向动态结构的指针。这与分配给每个P的mcache不是一回事。

Go内存使用（栈与堆）
-----------

现在我们已经清楚了内存的组织方式，现在让我们看看程序执行时Go是如何使用Stack和Heap的。

我们使用下面的这个Go程序，代码没有针对正确性进行优化，因此可以忽略诸如不必要的中间变量之类的问题，因此，重点是可视化栈和堆内存的使用情况。

```go
    package main

    import "fmt"

    type Employee struct {
        name   string
        salary int
        sales  int
        bonus  int
    }

    const BONUS_PERCENTAGE = 10

    func getBonusPercentage(salary int) int {
        percentage := (salary * BONUS_PERCENTAGE) / 100
        return percentage
    }

    func findEmployeeBonus(salary, noOfSales int) int {
        bonusPercentage := getBonusPercentage(salary)
        bonus := bonusPercentage * noOfSales
        return bonus
    }

    func main() {
        var john = Employee{"John", 5000, 5, 0}
        john.bonus = findEmployeeBonus(john.salary, john.sales)
        fmt.Println(john.bonus)
    }
```

与许多垃圾回收语言相比，Go的一个主要区别是许多对象直接在程序栈上分配。Go编译器使用一种称为 **“逃逸分析”** 的过程来查找其生命周期在编译时已知的对象，并将它们分配在栈上，而不是在垃圾回收的堆内存中。在编译过程中，Go进行了逃逸分析，以确定哪些可以放入栈（静态数据），哪些需要放入堆（动态数据）。我们可以通过运行带有 -gcflags '-m' 标志的go build命令来查看分析的细节。对于上面的代码，它将输出如下内容：

```bash
    ❯ go build -gcflags '-m' gc.go
    # command-line-arguments
    temp/gc.go:14:6: can inline getBonusPercentage
    temp/gc.go:19:6: can inline findEmployeeBonus
    temp/gc.go:20:39: inlining call to getBonusPercentage
    temp/gc.go:27:32: inlining call to findEmployeeBonus
    temp/gc.go:27:32: inlining call to getBonusPercentage
    temp/gc.go:28:13: inlining call to fmt.Println
    temp/gc.go:28:18: john.bonus escapes to heap
    temp/gc.go:28:13: io.Writer(os.Stdout) escapes to heap
    temp/gc.go:28:13: main []interface {} literal does not escape
    <autogenerated>:1: os.(*File).close .this does not escape
```

可视化程序执行过程中栈和堆的使用

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-44-35-8f0714db-666d-40bb-bbdb-a97874896ef0.gif)

正如你看到的：

* main函数被保存栈中的“main栈帧”中
* 每个函数调用都作为一个栈帧块被添加到堆中
* 包括参数和返回值在内的所有静态变量都保存在函数的栈帧块内
* 无论类型如何，所有静态值都直接存储在栈中。这也适用于全局范畴
* 所有动态类型都在堆上创建，并且被栈上的指针所引用。小于32Kb的对象由P的mcache分配。这同样适用于全局范畴
* 具有静态数据的结构体保留在栈上，直到在该位置将任何动态值添加到该结构中为止。该结构被移到堆上。
* 从当前函数调用的函数被推入堆顶部
* 当函数返回时，其栈帧将从栈中删除
* 一旦主过程(main)完成，堆上的对象将不再具有来自Stack的指针的引用，并成为孤立对象

栈是由操作系统自动管理的，而不是Go本身。因此，我们不必担心栈。另一方面，堆并不是由操作系统自动管理的，并且由于其具有最大的内存空间并保存动态数据，因此它可能会成倍增长，从而导致我们的程序随着时间耗尽内存。随着时间的流逝，它也变得支离破碎，使应用程序变慢。解决这些问题是垃圾收集的初衷。

Go内存管理
------

Go的内存管理包括在需要内存时自动分配内存，在不再需要内存时进行垃圾回收。这是由标准库完成的(译注：应该是运行时完成的)。与C/C++不同，开发人员不必处理它，并且Go进行的基础管理得到了高效的优化。

### 内存分配

许多采用垃圾收集的编程语言都使用分代内存结构来使收集高效，同时进行压缩以减少碎片。正如我们前面所看到的，Go在这里采用了不同的方法，Go在构造内存方面有很大的不同。Go使用线程本地缓存(thread local cache)来加速小对象分配，并维护着scan/noscan的span来加速GC。这种结构以及整个过程避免了碎片，从而在GC期间无需做紧缩处理。

Go根据对象的大小决定对象的分配过程，分为三类：

* Tiny（size <16B）：使用mcache的微小分配器分配大小小于16个字节的对象。这是高效的，并且在单个16字节块上可完成多个微小分配。

* Small（尺寸16B〜32KB）：大小在16个字节和32k字节之间的对象被分配在G运行所在的P的mcache的对应的mspan size class上。在微小型和小型对象分配中，如果mspan的列表为空，分配器将从mheap获取大量的页面用于mspan。如果mheap为空或没有足够大的页面满足分配请求，那么它将从操作系统中分配一组新的页（至少1MB）。

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/03/10-19-13-29-96c13703-d760-41f6-9399-c54d5d678bef.gif?token=AARMIEQA4P4BEYPQMJ4O2OS6M53JU)

* 大对象（大小> 32KB）：大于32 KB的对象直接分配在mheap的相应大小类上(size class)。如果mheap为空或没有足够大的页面满足分配请求，则它将从操作系统中分配一组新的页（至少1MB）。

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-44-41-a744f6f0-831f-4897-9955-b21eb4e06e42.gif)

大对象分配

## 垃圾收集(GC)

Go通过垃圾回收机制管理堆内存。简单来说，它释放了孤儿对象(orphan object)使用的内存，从而为创建新对象的分配腾出了空间。

从Go 1.12版本开始，Go使用了非分代的、并发的、基于三色标记和清除的垃圾回收器。收集过程大致如下所示：

当完成一定百分比（GC百分比）的堆分配，GC过程就开始了。收集器将在不同工作阶段执行不同的工作：

* 标记设置（mark setup, stw）：GC启动时，收集器将打开写屏障(write barrier)，以便可以在下一个并发阶段维护数据完整性。此步骤需要非常小的暂停(stw)，因此每个正在运行的Goroutine都会暂停以启用此功能，然后继续。
* 标记（并发执行的）：打开写屏障后，实际的标记过程将并行启动，这个过程将使用可用CPU能力的25%。对应的P将保留，直到该标记过程完成。这个过程是使用专用的Goroutines完成的。在这个过程中，GC标记了堆中的活动对象(被任何活动的Goroutine的栈中引用的）。当采集花费更长的时间时，该过程可以从应用程序中征用活动的Goroutine来辅助标记过程。这称为 **Mark Assist** 。
* 标记终止（stw）：标记一旦完成，每个活动的Goroutine都会暂停，写入屏障将关闭，清理任务将开始执行。GC还会在此处计算下一个GC目标。完成此操作后，保留的P的会释放回应用程序。
* 清除（并发）：当完成收集并尝试分配后，清除过程开始将未标记为活动的对象回收。清除的内存量与分配的内存量是同步的(即回收后的内存马上可以被再分配了)。

让我们在一个Goroutine中看看这个过程。为了简洁起见，将对象的数量保持较小。

* 标记过程选择GC root并将其着色为黑色，并以深度优先的树状方式遍历该该根节点里面的指针，将遇到的每个对象都标记为灰色
* 当它到达noscan span中的某个对象或某个对象不再有指针时，它完成了这个根节点的标记操作并选取下一个GC root对象
* 当扫描完所有GC root节点之后，它将选取灰色对象，并以类似方式继续遍历其指针
* 如果在打开写屏障时，指向对象的指针发生任何变化，则该对象将变为灰色，以便GC对其进行重新扫描
* 当不再有灰色对象留下时，标记过程完成，并且写屏障被关闭
* 当分配开始时(因为写屏障关闭了)，清除过程也会同步进行

我们看到这里有一些停止世界(stop)的过程，但是通常这个过程非常快，在大多数情况下可以忽略不计。对象的着色在span的gcmarkBits属性中进行。
