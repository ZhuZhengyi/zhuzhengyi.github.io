# 图解 Golang 的 GC 算法

## 简介

虽然 Golang 的 GC 自打一开始，就被人所诟病，但是经过这么多年的发展，Golang 的 GC 已经改善了非常多，变得非常优秀了。

以下是 Golang GC 算法的里程碑：

- v1.1 STW

- v1.3 Mark STW, Sweep 并行

- v1.5 三色标记法

- v1.8 hybrid write barrier

经典的 GC 算法有三种： `引用计数(reference counting)`、 `标记-清扫(mark&sweep)`、 `复制收集(CopyandCollection)`。

Golang 的 GC 算法主要是基于 `标记-清扫(markandsweep)`算法，并在此基础上做了改进。

## 标记-清扫(Mark And Sweep)算法

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/11/11-19-30-30-go-gc-gif.webp)

法主要有两个主要的步骤：

- 标记(Mark phase)：找出不可达的对象，然后做上标记。

- 清除(Sweep phase)：回收标记好的对象。

操作非常简单，但是有一点需要额外注意：mark and sweep 算法在执行的时候，需要程序暂停！即 `stop the world`。
也就是说，这段时间程序会卡在哪儿。故中文翻译成 `卡顿`。

开始标记，程序暂停。程序和对象的此时关系是这样的：

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-46-55-go-gc01.png)

然后开始标记，process 找出它所有可达的对象，并做上标记。如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje63ibrVyulmXcjp1oXDOPO4dVZvVts5K9zJIHha5apibSWdd1nnV8m54Dw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

标记完了之后，然后开始清除未标记的对象：

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6XMjDBzQIniaYNIAwf1yvh8SJBYibdmLzTJ1gKao6zicl7hZbo3JTSXRibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

然后垃圾清除了，变成了下图这样。

最后，停止暂停，让程序继续跑。然后循环重复这个过程，直到 process 生命周期结束。

### 标记-清扫(Mark And Sweep)算法存在什么问题？

标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：

- STW，stop the world；让程序暂停，程序出现卡顿。

- 标记需要扫描整个 heap

- 清除数据会产生 heap 碎片

这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。

Go 是如何面对并这个问题的呢？

## 三色并发标记法

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/11/11-19-35-58-go-gc-3-color.webp)

Golang 的三色标记法的大体流程：

首先：程序创建的对象都标记为白色。

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6aQjX1iaPgmDiaNohGeekUxH2a0HXAJ4PhaduibBibh6CbOJtea4eR4js1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

gc 开始：扫描所有可到达的对象，标记为灰色

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6ELwZkSkibBYotZhyAGB9rIpMzibt48gSO9ltq9D5iaTL133GtUlLbnKSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje62yaMUvD35Oibk6icTD5Kl4pib7553lpgz1VFLJSPOLicb8YAqPPyfQjBFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje61oYDvicEpYp9uicHHbuoQxb2ewbDNicTMvqzQIkQ2T2EwOYogCrJefZVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

此时，gc 回收白色对象。

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6xRZbJ1fpRVB9x3Nj7rAfVZrQdNHB77wEu6WtnpNicibria7bzu8MAlnRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

最后，将所有黑色对象变为白色，并重复以上所有过程。

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6lqEagViaWUTxzw0hL7AfA51QykcBpg0Dbz6zLw8K19IXBhe3L6O0Ljg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

好了，大体的流程就是这样的，让我们回到刚才的问题：Go 是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？

## gc 和用户逻辑如何并行操作？

标记-清除(mark and sweep)算法的 STW(stop the world)操作，就是 runtime 把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。

Go 如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。
我们知道 Golang 三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以： `清除操作和用户逻辑可以并发。`

标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？

### process 新生成对象的时候，GC 该如何操作呢？不会乱吗？

我们看如下图，在此状态下：process 程序又新生成了一个对象，我们设想会变成这样：

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6GsPbtM8PqZVZUibpZQYiaPUAoqFZrJBVQvOvLuiaGInvYDibs9icmr6TA5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

但是这样显然是不对的，因为按照三色标记法的步骤，这样新生成的对象 A 最后会被清除掉，这样会影响程序逻辑。

Golang 为了解决这个问题，引入了 `写屏障`这个机制。
写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。
通俗的讲：就是在 gc 跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的 stw，然后对对象进行标记)

在上述情况中， `新生成的对象，一律都标位灰色！`即下图：

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6qKxHooLKicibBCia4pZibcGicxSyz0NYQMRmFEQNWSVXE5kff6VMa3U4ia6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 那么，灰色或者黑色对象的引用改为白色对象的时候，Golang 是该如何操作的？

看如下图，一个黑色对象引用了曾经标记的白色对象。

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6RpJAciaTibYnOuiaFaLnh7t03sraj0wKjqmmhKdPdrD7G7jgPWiabSdGhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这时候，写屏障机制被触发，向 GC 发送信号，GC 重新扫描对象并标位灰色。

![](https://mmbiz.qpic.cn/mmbiz_png/W4ZicqIeQOOcoiaib0sp1y04XNwibewvHje6EibfZpRonwcHOqibibBEicVyPnzu3t1fmGTbvugQ1jxJicrnrxVdXwNRxDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

因此，gc 一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。

## 参考文献

- Golang’s Real-time GC in Theory and PracticeGolang's realtime garbage collector[Golang 垃圾回收剖析](https://mp.weixin.qq.com/s?__biz=MzU4ODczMDg5Ng==&mid=2247483688&idx=1&sn=46742e533886fe8b2fb91d79cf5144eb&scene=21#wechat_redirect)
- [深入Golang Runtime之Golang GC的过去,当前与未来 - 简书](https://www.jianshu.com/p/bfc3c65c05d1)
- 
