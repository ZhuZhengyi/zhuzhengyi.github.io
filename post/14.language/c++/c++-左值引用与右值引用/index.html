<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>C++11左值与右值 - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="C++11左值与右值 简介 在C++11之前，表达式的值按出现在=的位置不同可简单分为左值和右值2种； 在C++11中，为了实现函数参数传递的零拷">
<meta name=keywords content="Hugo,theme,jane">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/14.language/c++/c++-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.2f6e4d7e6e51da09470910b5f0d41a7d2c517dbe97416dd268a18bb7334c4ff8.css integrity="sha256-L25Nfm5R2glHCRC18NQafSxRfb6XQW3SaKGLtzNMT/g=" media=screen crossorigin=anonymous>
<meta property="og:title" content="C++11左值与右值">
<meta property="og:description" content="C++11左值与右值 简介 在C++11之前，表达式的值按出现在=的位置不同可简单分为左值和右值2种； 在C++11中，为了实现函数参数传递的零拷">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/14.language/c++/c++-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-04-26T00:00:00+00:00">
<meta property="article:modified_time" content="2022-04-26T00:00:00+00:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="C++11左值与右值">
<meta itemprop=description content="C++11左值与右值 简介 在C++11之前，表达式的值按出现在=的位置不同可简单分为左值和右值2种； 在C++11中，为了实现函数参数传递的零拷"><meta itemprop=datePublished content="2022-04-26T00:00:00+00:00">
<meta itemprop=dateModified content="2022-04-26T00:00:00+00:00">
<meta itemprop=wordCount content="4240">
<meta itemprop=keywords content="language,c++,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="C++11左值与右值">
<meta name=twitter:description content="C++11左值与右值 简介 在C++11之前，表达式的值按出现在=的位置不同可简单分为左值和右值2种； 在C++11中，为了实现函数参数传递的零拷"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=mobile-menu-item>
<a id=openSearchMobile class="mobile-menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<div class=modal-dialog>
<div class=modal-content>
<div id=closeSearch title=Close class=close>X</div>
<div class=modal-header>
<div class=modal-title>Search</div>
</div>
<div class=modal-body>
<script>(function(){var c='002186711602136249422:q1gkomof_em',a=document.createElement('script'),b;a.type='text/javascript',a.async=!0,a.src=(document.location.protocol=='https:'?'https:':'http:')+'//cse.google.com/cse.js?cx='+c,b=document.getElementsByTagName('script')[0],b.parentNode.insertBefore(a,b)})()</script>
<gcse:search></gcse:search>
</div>
</div>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=openSearch class="menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>C++11左值与右值</h1>
<div class=post-meta>
<time datetime=2022-04-26 class=post-time>
2022-04-26
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/language/> language </a>
<a href=https://justice.bj.cn/categories/c++/> c++ </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#简介>简介</a>
<ul>
<li><a href=#左值右值>左值、右值</a></li>
</ul>
</li>
<li><a href=#左值引用>左值引用</a>
<ul>
<li><a href=#右值引用>右值引用</a></li>
<li><a href=#stdmove>std::move</a></li>
<li><a href=#完美转发>完美转发</a></li>
<li><a href=#返回值优化>返回值优化</a></li>
</ul>
</li>
<li><a href=#参考>参考</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=c11左值与右值>C++11左值与右值</h1>
<h2 id=简介>简介</h2>
<p>在C++11之前，表达式的值按出现在<code>=</code>的位置不同可简单分为<code>左值</code>和<code>右值</code>2种；</p>
<p>在C++11中，为了实现函数参数传递的零拷贝开销，对值类型进行了更详细的划分：</p>
<ul>
<li><strong>glvalue</strong>（泛左值）：拥有身份的表达式，“泛化的”左值，包括左值或将亡值；</li>
<li><strong>lvalue</strong>（左值）：拥有身份且不可被移动值，用于标识一个函数或对象，是在表达式（不一定是赋值表达式）后依然存在的持久对象。左值可以出现在<code>=</code>的左边）；</li>
<li><strong>xvalue</strong>（将亡值）：一个接近声明周期末尾的对象。将亡值是某些涉及右值引用的表达式的结果，拥有身份且可被移动的表达式；</li>
<li><strong>prvalue</strong>（纯右值）：是不拥有身份且可被移动的表达式，非将亡值的右值；</li>
<li><strong>rvalue</strong>（右值）：是可移动的表达式值，在表达式结束后就不再存在的临时对象；包括将亡值、临时对象或其子对象、不关联对象的值，右值是等号右边的值；</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>拥有ID</th>
<th>可移动</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>glvalue</td>
<td>是</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lvalue</td>
<td>是</td>
<td>否</td>
<td></td>
<td></td>
</tr>
<tr>
<td>xvalue</td>
<td>是</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>prvalue</td>
<td>否</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>rvalue</td>
<td>-</td>
<td>是</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img src=/Users/justice/tmp/notebook-img/2021-12-11-09-39-48-image.png alt></p>
<h3 id=左值右值>左值、右值</h3>
<h4 id=左值lvalue>左值(lvalue)</h4>
<ul>
<li>
<p>拥有身份（identity）且不可被移动的值；</p>
</li>
<li>
<p>可以放到等号左边；</p>
</li>
<li>
<p>可以获取内存地址(拥有id)并安全(不可被移动)的使用它；</p>
</li>
<li>
<p>常见的左值：</p>
<ul>
<li>
<p>已命名的变量或常量；</p>
</li>
<li>
<p>函数名；</p>
</li>
<li>
<p>返回左值引用的函数调用；</p>
</li>
<li>
<p>前置自增自减表达式++i、&ndash;i；</p>
</li>
<li>
<p>赋值表达式或赋值运算符连接的表达式(a=b, a += b等)；</p>
</li>
<li>
<p>解引用表达式<code>*p</code>;</p>
</li>
<li>
<p>字符串字面值"abcd";</p>
</li>
</ul>
</li>
</ul>
<h4 id=右值rvalue>右值(rvalue)</h4>
<ul>
<li>
<p>可被移动的值；</p>
</li>
<li>
<p>不能取地址,没有名字;</p>
</li>
</ul>
<ul>
<li>
<p>右值包含：</p>
<ul>
<li>
<p>纯右值：可移动且拥有ID；</p>
</li>
<li>
<p>将亡值：可移动且不拥有ID；</p>
</li>
</ul>
</li>
</ul>
<h4 id=纯右值prvalue>纯右值(prvalue)</h4>
<ul>
<li>不拥有ID且可被移动的值；</li>
<li>纯右值包括：
<ul>
<li>运算表达式产生的临时变量；</li>
<li>不和对象关联的原始字面量；</li>
<li>非引用返回的临时变量；</li>
<li>lambda表达式等；</li>
</ul>
</li>
</ul>
<p>举例：</p>
<ul>
<li>除字符串字面值外的字面值；</li>
<li>返回非引用类型的函数调用；</li>
<li>后置自增自减表达式i++、i&ndash;；</li>
<li>算术表达式(a+b, a*b, a&&b, a==b等)；</li>
<li>this指针；</li>
<li>所有内建数值运算表达式：<code>a + b, a % b, a & b, a &lt;&lt; b</code></li>
<li>取址表达式:<code>&a</code>;</li>
</ul>
<h4 id=将亡值xvalue>将亡值(xvalue)</h4>
<ul>
<li>
<p>拥有ID且可被移动的值；</p>
</li>
<li>
<p>将亡值是即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值；</p>
</li>
<li>
<p>在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期；</p>
</li>
<li>
<p>常用来完成移动构造或者移动赋值的特殊任务；</p>
</li>
<li>
<p>将亡值包括：</p>
<ul>
<li>
<p>将要被移动的对象；</p>
</li>
<li>
<p>T&&函数的返回值；</p>
</li>
<li>
<p>std::move函数的返回值；</p>
</li>
<li>
<p>转换为T&&类型转换函数的返回值；</p>
</li>
</ul>
</li>
</ul>
<p>举例：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
    <span class=n>xxx</span><span class=p>;</span>
<span class=p>};</span>
<span class=n>A</span> <span class=n>a</span><span class=p>;</span>                           <span class=c1>// a是左值
</span><span class=c1></span><span class=k>auto</span> <span class=n>c</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>         <span class=c1>// c是将亡值
</span><span class=c1></span><span class=k>auto</span> <span class=n>d</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&amp;&amp;&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>  <span class=c1>// d是将亡值
</span></code></pre></td></tr></table>
</div>
</div><h2 id=左值引用>左值引用</h2>
<p>先看一下传统的左值引用。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
<span class=kt>int</span> <span class=o>&amp;</span><span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>  <span class=c1>// 定义一个左值引用变量
</span><span class=c1></span><span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>      <span class=c1>// 通过左值引用修改引用内存的值
</span></code></pre></td></tr></table>
</div>
</div><p>左值引用在汇编层面其实和普通的指针是一样的；定义引用变量必须初始化，因为引用其实就是一个别名，需要告诉编译器定义的是谁的引用。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>int</span> <span class=o>&amp;</span><span class=n>var</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>           <span class=c1>//错误， 10是立即数，无法取地址；
</span><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>var</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>     <span class=c1>//正确， 常引用参数临时变量保存10，可取地址，但只能读取，无法修改var值；
</span></code></pre></td></tr></table>
</div>
</div><p>根据上述分析，得出如下结论：</p>
<ul>
<li>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>
但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。</li>
</ul>
<p>那么C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。</p>
<h3 id=右值引用>右值引用</h3>
<p>从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；</p>
<p>而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及const对象)。</p>
<p>定义右值引用的格式如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=o>&lt;</span><span class=n>TYPE_NAME</span><span class=o>&gt;</span> <span class=o>&amp;&amp;</span> <span class=o>&lt;</span><span class=n>ref_name</span><span class=o>&gt;</span> <span class=o>=</span> <span class=err>右值表达式</span><span class=p>;</span>
</code></pre></td></tr></table>
</div>
</div><p>右值引用是C++ 11新增的特性，所以C++ 98的引用为左值引用。</p>
<p>右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=k>const</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>var</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>     <span class=c1>//常量引用只能读取，无法修改var值；
</span><span class=c1></span><span class=kt>int</span> <span class=o>&amp;&amp;</span><span class=n>var</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>          <span class=c1>//右值引用可以进行读写操作；
</span></code></pre></td></tr></table>
</div>
</div><p>右值引用充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。</p>
<h3 id=stdmove>std::move</h3>
<p><code>std::move</code>将左值强转为可以被移动的右值（将亡值）引用，指示了该对象可移动，从而使得我们可以通过右值引用的方式继续使用该对象，以用于移动语义。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// simple impl
</span><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
<span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;&amp;</span> <span class=n>move</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;&amp;&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>参数<code>T &&t</code>并不是代表右值引用，而是转发引用（也叫万能引用）。</p>
</li>
<li>
<p>转发引用既能是右值引用，也可以是左值引用，这与类型推导和引用折叠有关。</p>
</li>
<li>
<p>如果用右值初始化转发引用，那么得到的是右值引用。</p>
</li>
<li>
<p>如果用左值初始化转发引用，那么得到的是左值引用。</p>
</li>
</ul>
<p>用C++实现一个简单的顺序栈：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=k>class</span> <span class=nc>Stack</span>
<span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=c1>// 构造
</span><span class=c1></span>    <span class=n>Stack</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>1000</span><span class=p>)</span> 
        <span class=o>:</span><span class=n>msize</span><span class=p>(</span><span class=n>size</span><span class=p>),</span> <span class=n>mtop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Stack(int)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=n>mpstack</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>size</span><span class=p>];</span>
    <span class=p>}</span>

    <span class=c1>// 析构
</span><span class=c1></span>    <span class=o>~</span><span class=n>Stack</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~Stack()&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>delete</span><span class=p>[]</span><span class=n>mpstack</span><span class=p>;</span>
        <span class=n>mpstack</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// 拷贝构造
</span><span class=c1></span>    <span class=n>Stack</span><span class=p>(</span><span class=k>const</span> <span class=n>Stack</span> <span class=o>&amp;</span><span class=n>src</span><span class=p>)</span>
        <span class=o>:</span><span class=n>msize</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>msize</span><span class=p>),</span> <span class=n>mtop</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>mtop</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Stack(const Stack&amp;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=n>mpstack</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>src</span><span class=p>.</span><span class=n>msize</span><span class=p>];</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>mtop</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>mpstack</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>mpstack</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// 赋值重载
</span><span class=c1></span>    <span class=n>Stack</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Stack</span> <span class=o>&amp;</span><span class=n>src</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;operator=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>src</span><span class=p>)</span>
             <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>

        <span class=k>delete</span><span class=p>[]</span><span class=n>mpstack</span><span class=p>;</span>

        <span class=n>msize</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>msize</span><span class=p>;</span>
        <span class=n>mtop</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>mtop</span><span class=p>;</span>
        <span class=n>mpstack</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>src</span><span class=p>.</span><span class=n>msize</span><span class=p>];</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>mtop</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>mpstack</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>mpstack</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=nf>getSize</span><span class=p>()</span> 
    <span class=p>{</span>
        <span class=k>return</span> <span class=n>msize</span><span class=p>;</span>
    <span class=p>}</span>
<span class=k>private</span><span class=o>:</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>mpstack</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>mtop</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>msize</span><span class=p>;</span>
<span class=p>};</span>

<span class=n>Stack</span> <span class=nf>GetStack</span><span class=p>(</span><span class=n>Stack</span> <span class=o>&amp;</span><span class=n>stack</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>Stack</span> <span class=n>tmp</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=n>getSize</span><span class=p>());</span>
    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>Stack</span> <span class=n>s</span><span class=p>;</span>
    <span class=n>s</span> <span class=o>=</span> <span class=n>GetStack</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>Stack</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>             <span class=c1>// 构造s
</span><span class=c1></span><span class=n>Stack</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>             <span class=c1>// 构造tmp
</span><span class=c1></span><span class=n>Stack</span><span class=p>(</span><span class=k>const</span> <span class=n>Stack</span><span class=o>&amp;</span><span class=p>)</span>    <span class=c1>// tmp拷贝构造main函数栈帧上的临时对象
</span><span class=c1></span><span class=o>~</span><span class=n>Stack</span><span class=p>()</span>               <span class=c1>// tmp析构
</span><span class=c1></span><span class=k>operator</span><span class=o>=</span>              <span class=c1>// 临时对象赋值给s
</span><span class=c1></span><span class=o>~</span><span class=n>Stack</span><span class=p>()</span>               <span class=c1>// 临时对象析构
</span><span class=c1></span><span class=o>~</span><span class=n>Stack</span><span class=p>()</span>               <span class=c1>// s析构
</span></code></pre></td></tr></table>
</div>
</div><p>为了解决浅拷贝问题，为类提供了自定义的拷贝构造函数和赋值运算符重载函数，并且这两个函数内部实现都是非常的耗费时间和资源(首先开辟较大的空间，然后将数据逐个复制)，我们通过上述运行结果发现了两处使用了拷贝构造和赋值重载，分别是tmp拷贝构造main函数栈帧上的临时对象、临时对象赋值给s，其中tmp和临时对象都在各自的操作结束后便销毁了，使得程序效率非常低下。</p>
<p>那么我们为了提高效率，是否可以把tmp持有的内存资源直接给临时对象？是否可以把临时对象的资源直接给s？</p>
<p>在C++11中，我们可以解决上述问题，方式是提供带右值引用参数的拷贝构造函数和赋值运算符重载函数.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// 带右值引用参数的拷贝构造函数
</span><span class=c1></span><span class=n>Stack</span><span class=p>(</span><span class=n>Stack</span> <span class=o>&amp;&amp;</span><span class=n>src</span><span class=p>)</span>
    <span class=o>:</span><span class=n>msize</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>msize</span><span class=p>),</span> <span class=n>mtop</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>mtop</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Stack(Stack&amp;&amp;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>

    <span class=cm>/*此处没有重新开辟内存拷贝数据，把src的资源直接给当前对象，再把src置空*/</span>
    <span class=n>mpstack</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>mpstack</span><span class=p>;</span>  
    <span class=n>src</span><span class=p>.</span><span class=n>mpstack</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// 带右值引用参数的赋值运算符重载函数
</span><span class=c1></span><span class=n>Stack</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Stack</span> <span class=o>&amp;&amp;</span><span class=n>src</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;operator=(Stack&amp;&amp;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>

    <span class=k>if</span><span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>src</span><span class=p>)</span>
        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>

    <span class=k>delete</span><span class=p>[]</span><span class=n>mpstack</span><span class=p>;</span>

    <span class=n>msize</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>msize</span><span class=p>;</span>
    <span class=n>mtop</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>mtop</span><span class=p>;</span>

    <span class=cm>/*此处没有重新开辟内存拷贝数据，把src的资源直接给当前对象，再把src置空*/</span>
    <span class=n>mpstack</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>mpstack</span><span class=p>;</span>
    <span class=n>src</span><span class=p>.</span><span class=n>mpstack</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>

    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>Stack</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>             <span class=c1>// 构造s
</span><span class=c1></span><span class=n>Stack</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>             <span class=c1>// 构造tmp
</span><span class=c1></span><span class=n>Stack</span><span class=p>(</span><span class=n>Stack</span><span class=o>&amp;&amp;</span><span class=p>)</span>         <span class=c1>// 调用带右值引用的拷贝构造函数，直接将tmp的资源给临时对象
</span><span class=c1></span><span class=o>~</span><span class=n>Stack</span><span class=p>()</span>               <span class=c1>// tmp析构
</span><span class=c1></span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Stack</span><span class=o>&amp;&amp;</span><span class=p>)</span>     <span class=c1>// 调用带右值引用的赋值运算符重载函数，直接将临时对象资源给s
</span><span class=c1></span><span class=o>~</span><span class=n>Stack</span><span class=p>()</span>               <span class=c1>// 临时对象析构
</span><span class=c1></span><span class=o>~</span><span class=n>Stack</span><span class=p>()</span>               <span class=c1>// s析构
</span></code></pre></td></tr></table>
</div>
</div><p>程序自动调用了带右值引用的拷贝构造函数和赋值运算符重载函数，使得程序的效率得到了很大的提升，因为并没有重新开辟内存拷贝数据。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>mpstack</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>mpstack</span><span class=p>;</span>  
</code></pre></td></tr></table>
</div>
</div><p>可以直接赋值的原因是临时对象即将销毁，不会出现浅拷贝的问题，我们直接把临时对象持有的资源赋给新对象就可以了。</p>
<p>所以，临时量都会自动匹配右值引用版本的成员方法，旨在提高内存资源使用效率。</p>
<p>带右值引用参数的拷贝构造和赋值重载函数，又叫移动构造函数和移动赋值函数，这里的移动指的是把临时量的资源移动给了当前对象，临时对象就不持有资源，为nullptr了，实际上没有进行任何的数据移动，没发生任何的内存开辟和数据拷贝。</p>
<h3 id=完美转发>完美转发</h3>
<p>完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>PrintV</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;lvalue&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>PrintV</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;rvalue&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
<span class=kt>void</span> <span class=n>Test</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>PrintV</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
    <span class=n>PrintV</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>));</span>

    <span class=n>PrintV</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>t</span><span class=p>));</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>Test</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=c1>// lvalue rvalue rvalue
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>Test</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// lvalue lvalue rvalue
</span><span class=c1></span>    <span class=n>Test</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>));</span> <span class=c1>// lvalue rvalue rvalue
</span><span class=c1></span>    <span class=n>Test</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>));</span> <span class=c1>// lvalue lvalue rvalue
</span><span class=c1></span>    <span class=n>Test</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&amp;&amp;&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>));</span> <span class=c1>// lvalue rvalue rvalue
</span><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>Test(1)：1是右值，模板中T &&t这种为万能引用，右值1传到Test函数中变成了右值引用，但是调用PrintV()时候，t变成了左值，因为它变成了一个拥有名字的变量，所以打印lvalue，而PrintV(std::forward(t))时候，会进行完美转发，按照原来的类型转发，所以打印rvalue，PrintV(std::move(t))毫无疑问会打印rvalue。</p>
</li>
<li>
<p>Test(a)：a是左值，模板中T &&这种为万能引用，左值a传到Test函数中变成了左值引用，所以有代码中打印。</p>
</li>
<li>
<p>Test(std::forward(a))：转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值。</p>
</li>
</ul>
<h3 id=返回值优化>返回值优化</h3>
<p>返回值优化(RVO)是一种C++编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。</p>
<p>那什么时候编译器会进行返回值优化呢?</p>
<ul>
<li>
<p>return的值类型与函数的返回值类型相同</p>
</li>
<li>
<p>return的是一个局部对象</p>
</li>
</ul>
<p>看几个例子:</p>
<p>示例1：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>return_vector</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>tmp</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;&amp;</span><span class=n>rval_ref</span> <span class=o>=</span> <span class=n>return_vector</span><span class=p>();</span>
</code></pre></td></tr></table>
</div>
</div><p>不会触发RVO，拷贝构造了一个临时的对象，临时对象的生命周期和rval_ref绑定，等价于下面这段代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>rval_ref</span> <span class=o>=</span> <span class=n>return_vector</span><span class=p>();</span>
</code></pre></td></tr></table>
</div>
</div><p>示例2：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;&amp;</span> <span class=n>return_vector</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>tmp</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;&amp;</span><span class=n>rval_ref</span> <span class=o>=</span> <span class=n>return_vector</span><span class=p>();</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码会造成运行时错误，因为rval_ref引用了被析构的tmp。讲道理来说这段代码是错的，但我自己运行过程中却成功了，我没有那么幸运，这里不纠结，继续向下看什么时候会触发RVO。</p>
<p>示例3：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>return_vector</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>tmp</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
<span class=p>}</span>
<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;&amp;</span><span class=n>rval_ref</span> <span class=o>=</span> <span class=n>return_vector</span><span class=p>();</span>
</code></pre></td></tr></table>
</div>
</div><p>和示例1类似，std::move一个临时对象是没有必要的，也会忽略掉返回值优化。</p>
<p>最好的代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>return_vector</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>tmp</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span>
    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>rval_ref</span> <span class=o>=</span> <span class=n>return_vector</span><span class=p>();</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码会触发RVO，不拷贝也不移动，不生成临时对象。</p>
<h2 id=参考>参考</h2>
<ol>
<li>
<p><a href=https://www.cnblogs.com/ishen/p/13771991.html>C++: 左值引用(&), 右值引用(&&),万能引用(template &&)详解 与 完美转发(forward) 实现剖析 - woder - 博客园</a></p>
</li>
<li>
<p><a href=https://www.zhihu.com/question/454291992>https://www.zhihu.com/question/454291992</a></p>
</li>
<li>
<p><a href=https://www.zhihu.com/question/363686723>https://www.zhihu.com/question/363686723</a></p>
</li>
<li>
<p><a href=https://zhuanlan.zhihu.com/p/374392832>什么是move？理解C++ Value categories，move， move in Rust</a></p>
</li>
</ol>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2022-04-26
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/language/>language</a>
<a href=https://justice.bj.cn/tags/c++/>c++</a>
</div>
<nav class=post-nav>
<a class=next href=/post/14.language/c++/c++%E5%9F%BA%E7%A1%80/>
<span class="next-text nav-default">C++基础</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2022
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script>$("#openSearch, #openSearchMobile").click(function(){$(".modal-dialog").addClass("visible")}),$("#closeSearch").click(function(){$(".modal-dialog").removeClass("visible")}),$(document).click(function(a){$(a.target).closest(".modal-content, #openSearch, #openSearchMobile").length||$("body").find(".modal-dialog").removeClass("visible")})</script>
<script src=/js/https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js></script>
<script src=/js/l2d.js></script>
</body>
</html>