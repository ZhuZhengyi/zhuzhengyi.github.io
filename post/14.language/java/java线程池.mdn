# Java线程池

## 简介

创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。

可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。

线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。

## java线程实现方式

Thread、Runnable、Callable

```java
//实现Runnable接口的类将被Thread执行，表示一个基本任务
public interface Runnable {
    //run方法就是它所有内容，就是实际执行的任务
    public abstract void run();
}

//Callable同样是任务，与Runnable接口的区别在于它接口泛型，同时它执行任务候带有返回值；
//Callable的使用通过外层封装成Future来使用
public interface Callable<V> {
    //相对于run方法，call方法带有返回值
    V call() throws Exception;
}
```

Java标准库提供了`ExecutorService`接口表示线程池；

```java
// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务:
executor.submit(task1);
executor.submit(task2);
executor.submit(task3);
executor.submit(task4);
executor.submit(task5);
```

`ExecutorService`是接口，Java标准库提供的几个常用实现类有：

- FixedThreadPool：线程数固定的线程池；
- CachedThreadPool：线程数根据任务动态调整的线程池；
- SingleThreadExecutor：仅单线程执行的线程池。

## Executor

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/03-17-27-59-2022-01-03-17-27-55-image.png)

## 原理

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/03-17-19-56-2022-01-03-17-19-48-image.png)

线程池的状态：

RUNNING = ­1 << COUNT_BITS; //高3位为111
SHUTDOWN = 0 << COUNT_BITS; //高3位为000
STOP = 1 << COUNT_BITS; //高3位为001
TIDYING = 2 << COUNT_BITS; //高3位为010
TERMINATED = 3 << COUNT_BITS; //高3位为011

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/03-19-51-15-2022-01-03-19-51-02-image.png)

## 线程池的使用

```java
//
public class RunTask implements Runnable {
    public void run() {
        System.out.println("Thread name:"+Thread.currentThread().getName());
    }
}

public class ExecutorSample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        for (int i=0;i<20;i++){
            //提交任务无返回值
            executor.execute(new RunTask());
            //任务执行完成后有返回值
            Future<Object> future = executor.submit(new RunTask());
        }
    }
}
```

### ThreadPoolExecutor

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         threadFactory, defaultHandler);
}
```

- corePoolSize：线程池中的核心线程数。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。
- maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。
- keepAliveTime：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize时候，如果这时候没有新的任务提交，核心线程外的线程不会立即被销毁，而是会等待，直到等待的时间超过了keepAliveTime  
  unit：keepAliveTime的单位时间
- workQueue：用于保存等待被执行的任务的阻塞队列，且任务必须实现Runnable接口，在JDK中提供了如下阻塞队列：  
  ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务。  
  LinkedBlockingQueue：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue。  
  SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue。
- PriorityBlockingQueue：具有优先级的无界阻塞队列。
- threadFactory：ThreadFactory 类型的变量，用来创建新线程。默认使用ThreadFactory.defaultThreadFactory来创建线程， 会使新创建线程具有相同的NORM_PRIORITY优先级并且都是非守护线程，同时也设置了线程名称。
- handler：线程池的饱和策略。当阻塞队列满了，且没有空闲的工作队列，如果继续提交任务，必须采用一种策略处理该任务.

## 参考

1. [使用线程池 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849)

2. [Executor线程池只看这一篇就够了 - 掘金](https://juejin.cn/post/6844903920511221768)

3. 
