<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>Rust 异步编程 - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="Rust 异步编程 简介 异步编程经历了三个阶段： 第一阶段：异步回调模式，存在回调地狱问题； 第二阶段：nodejs 中的Promise/Future模式，">
<meta name=keywords content="Hugo,theme,jane">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/14.language/rust/rust%E5%BC%82%E6%AD%A5/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.2f6e4d7e6e51da09470910b5f0d41a7d2c517dbe97416dd268a18bb7334c4ff8.css integrity="sha256-L25Nfm5R2glHCRC18NQafSxRfb6XQW3SaKGLtzNMT/g=" media=screen crossorigin=anonymous>
<meta property="og:title" content="Rust 异步编程">
<meta property="og:description" content="Rust 异步编程 简介 异步编程经历了三个阶段： 第一阶段：异步回调模式，存在回调地狱问题； 第二阶段：nodejs 中的Promise/Future模式，">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/14.language/rust/rust%E5%BC%82%E6%AD%A5/"><meta property="article:section" content="post">
<meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="Rust 异步编程">
<meta itemprop=description content="Rust 异步编程 简介 异步编程经历了三个阶段： 第一阶段：异步回调模式，存在回调地狱问题； 第二阶段：nodejs 中的Promise/Future模式，">
<meta itemprop=wordCount content="5296">
<meta itemprop=keywords content="language,rust,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Rust 异步编程">
<meta name=twitter:description content="Rust 异步编程 简介 异步编程经历了三个阶段： 第一阶段：异步回调模式，存在回调地狱问题； 第二阶段：nodejs 中的Promise/Future模式，"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=mobile-menu-item>
<a id=openSearchMobile class="mobile-menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<div class=modal-dialog>
<div class=modal-content>
<div id=closeSearch title=Close class=close>X</div>
<div class=modal-header>
<div class=modal-title>Search</div>
</div>
<div class=modal-body>
<script>(function(){var c='002186711602136249422:q1gkomof_em',a=document.createElement('script'),b;a.type='text/javascript',a.async=!0,a.src=(document.location.protocol=='https:'?'https:':'http:')+'//cse.google.com/cse.js?cx='+c,b=document.getElementsByTagName('script')[0],b.parentNode.insertBefore(a,b)})()</script>
<gcse:search></gcse:search>
</div>
</div>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=openSearch class="menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>Rust 异步编程</h1>
<div class=post-meta>
<time datetime=0001-01-01 class=post-time>
0001-01-01
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/language/> language </a>
<a href=https://justice.bj.cn/categories/rust/> rust </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#简介>简介</a></li>
<li><a href=#rust协程>Rust协程</a></li>
<li><a href=#generator生成器>Generator（生成器）</a></li>
<li><a href=#future>Future</a></li>
<li><a href=#sendsync>Send&Sync</a></li>
<li><a href=#context>Context</a></li>
<li><a href=#runtime>Runtime</a>
<ul>
<li><a href=#执行流程>执行流程</a></li>
<li><a href=#总结>总结</a></li>
</ul>
</li>
<li><a href=#executor>Executor</a></li>
<li><a href=#常见的executor>常见的Executor</a></li>
<li><a href=#reactor>Reactor</a></li>
<li><a href=#stream>Stream</a></li>
<li><a href=#sink>Sink</a></li>
<li><a href=#timer>Timer</a></li>
<li><a href=#组合子>组合子</a></li>
<li><a href=#asyncawait>Async/Await</a></li>
<li><a href=#pin>Pin</a></li>
<li><a href=#总结-1>总结</a>
<ul>
<li><a href=#注意的地方>注意的地方</a></li>
</ul>
</li>
<li><a href=#参考>参考</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=rust-异步编程>Rust 异步编程</h1>
<h2 id=简介>简介</h2>
<p>异步编程经历了三个阶段：</p>
<ul>
<li>
<p>第一阶段：异步回调模式，存在回调地狱问题；</p>
</li>
<li>
<p>第二阶段：nodejs 中的<code>Promise/Future</code>模式，代码冗余；</p>
</li>
<li>
<p>第三阶段：基于协程的<code>async/await</code>方式；</p>
</li>
</ul>
<p>Rust 异步是在最近的版本(1.39)中才稳定下来。</p>
<h2 id=rust协程>Rust协程</h2>
<p>基于<code>async/await</code>的异步解决方案需要协程支持。</p>
<p>协程的实现一般有两种：</p>
<ul>
<li>
<p>有栈协程（Stackful）: 每个协程分配独立的栈来保存协程上下文，golang的协程就是有栈协程；</p>
</li>
<li>
<p>无栈协程（Stackless）: 基于状态机，不需要独立栈。</p>
</li>
</ul>
<p>Rust协程采用无栈协程。通过<code>Generator</code>实现；</p>
<h2 id=generator生成器>Generator（生成器）</h2>
<p>生成器</p>
<h2 id=future>Future</h2>
<ul>
<li>
<p><code>Future</code> 是一个<code>trait</code>，表示一个异步调用的对象（异步调用的结果是一个未来期望）。</p>
</li>
<li>
<p>当发起一次请求时，将立即获得一个 <code>Future</code> 对象; 而一旦请求完成，<code>Future</code>将返回任何响应可能包含的值；</p>
</li>
<li>
<p><code>Future</code>需要程序主动去<code>poll</code>(轮询)才能获取到最终的结果，每一次轮询的结果可能是<code>Ready</code>或者<code>Pending</code>。</p>
<ul>
<li>
<p><code>Ready</code>: 当前<code>Future</code>已完成，代码逻辑可以向下执行；</p>
</li>
<li>
<p><code>Pending</code>: 当前<code>Future</code>并未执行完成，代码不能向下执行，</p>
</li>
</ul>
</li>
<li>
<p><code>Runtime</code>中的<code>Executor</code>需要不停的去执行<code>Future</code>的<code>poll</code>操作，直至<code>Future</code>返回<code>Ready</code>可以向下执行为止。</p>
</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Poll</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Ready</span><span class=p>(</span><span class=n>T</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Pending</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Future</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>      </span><span class=c1>//
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>poll</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Pin</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>cx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Context</span><span class=o>&lt;</span><span class=na>&#39;_</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Poll</span><span class=o>&lt;</span><span class=n>Self</span>::<span class=n>Output</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h2 id=sendsync>Send&Sync</h2>
<ul>
<li>
<p><code>Send</code>: 将计算中的<em>传递数据</em>抽象到另一个并发计算 (我们称其为接收方)，而对于发送方，将无法再次访问它;</p>
</li>
<li>
<p><code>Sync</code>: 在程序的两个并发部分之间共享数据;</p>
</li>
</ul>
<h2 id=context>Context</h2>
<p><code>Context</code>提供了对<code>Future</code>进行调度的功能。目前<code>Context</code>作为一个结构体，有一个核心成员<code>Waker</code>，用来唤醒绑定的<code>Future</code>. 未来不排除在<code>Context</code>添加新的字段。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Context</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>waker</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>Waker</span><span class=p>,</span><span class=w>
</span><span class=w> 
</span><span class=w>    </span><span class=n>_marker</span>: <span class=nc>PhantomData</span><span class=o>&lt;</span><span class=k>fn</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=p>())</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=p>()</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Waker</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>waker</span>: <span class=nc>RawWaker</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Waker</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// 唤醒绑定在 Waker 上的数据，通常是 Future
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>wake</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>wake_by_ref</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>will_wake</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Waker</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>from_raw</span><span class=p>(</span><span class=n>waker</span>: <span class=nc>RawWaker</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Waker</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>RawWaker</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// A data pointer, which can be used to store arbitrary data as required
</span><span class=sd></span><span class=w>    </span><span class=sd>/// by the executor. This could be e.g. a type-erased pointer to an `Arc`
</span><span class=sd></span><span class=w>    </span><span class=sd>/// that is associated with the task.
</span><span class=sd></span><span class=w>    </span><span class=sd>/// The value of this field gets passed to all functions that are part of
</span><span class=sd></span><span class=w>    </span><span class=sd>/// the vtable as the first parameter.
</span><span class=sd></span><span class=w>    </span><span class=n>data</span>: <span class=o>*</span><span class=k>const</span><span class=w> </span><span class=p>(),</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Virtual function pointer table that customizes the behavior of this waker.
</span><span class=sd></span><span class=w>    </span><span class=n>vtable</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=n>RawWakerVTable</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=sd>/// RawWaker 行为的虚函数表
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>RawWakerVTable</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>clone</span>: <span class=nc>unsafe</span><span class=w> </span><span class=k>fn</span><span class=p>(</span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=p>())</span><span class=w> </span>-&gt; <span class=nc>RawWaker</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>wake</span>: <span class=nc>unsafe</span><span class=w> </span><span class=k>fn</span><span class=p>(</span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=p>()),</span><span class=w>
</span><span class=w>    </span><span class=n>wake_by_ref</span>: <span class=nc>unsafe</span><span class=w> </span><span class=k>fn</span><span class=p>(</span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=p>()),</span><span class=w>
</span><span class=w>    </span><span class=n>drop</span>: <span class=nc>unsafe</span><span class=w> </span><span class=k>fn</span><span class=p>(</span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=p>()),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h2 id=runtime>Runtime</h2>
<p><code>Runtime</code>  由两部分组成，<code>Executor</code>和<code>Reactor</code>。</p>
<ul>
<li>
<p><code>Executor</code>: 执行器, 负责调度<code>Future</code>，没有任何阻塞的等待，循环执行一系列就绪的<code>Future</code>，当<code>Future</code>返回<code>pending</code>的时候，会将<code>Future</code>转移到<code>Reactor</code>上等待进一步的唤醒。</p>
</li>
<li>
<p><code>Reactor</code>: 反应器, 负责执行<code>Future</code>，轮询并唤醒挂载的事件，并执行对应的<code>wake</code>方法，通常来说，<code>wake</code>会将<code>Future</code>的状态变更为就绪，同时将<code>Future</code>放到<code>Executor</code>的队列中等待执行。</p>
</li>
</ul>
<h3 id=执行流程>执行流程</h3>
<p>下面的序列图大概简单的描绘了<code>Future</code>在<code>Executor</code>和<code>Reactor</code>之间来回转移的流程与状态变化。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    Executor-&gt;&gt;Reactor: Pending Future
    deactivate Executor
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor-&gt;&gt;Executor: Ready Future
    deactivate Reactor
    activate Executor
    deactivate Executor
</code></pre></td></tr></table>
</div>
</div><p>上面说明了一个简单的<code>Future</code>的执行，如果是一个比较复杂的<code>Future</code>的话，比如中间会有多次<code>IO</code>操作的话，那么流程时怎么样的呢？看下面一段代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>read_and_write</span><span class=p>(</span><span class=n>s</span>: <span class=nc>TcpStream</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>w</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>split</span><span class=p>();</span><span class=w>
</span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>read</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>  </span><span class=n>buffer</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=s>&#34;Hello,world&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>  </span><span class=n>w</span><span class=p>.</span><span class=n>write_all</span><span class=p>(</span><span class=n>buffer</span><span class=p>.</span><span class=n>as_bytes</span><span class=p>()).</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>对应的执行流程为：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    deactivate Executor
    Executor-&gt;&gt;Reactor: Pending on r.read()
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor-&gt;&gt;Executor: r.read() is ready
    Note left of Executor: Execute current Future
    deactivate Reactor
    Executor-&gt;&gt;Reactor: Pending on w.write_all()
    Note left of Executor: Execute other Future
    activate Reactor
    deactivate Reactor
    Reactor-&gt;&gt;Executor: w.write_all() is ready
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>上面的这些例子系统中只展示了一个<code>Future</code>的执行情况，真实的生产环境中，可能有数十万的<code>Future</code>同时在执行，<code>Executor</code>和<code>Reactor</code>的调度模型要更复杂一些。</p>
</blockquote>
<h3 id=总结>总结</h3>
<p>一句话概括<code>Runtime</code>:</p>
<ul>
<li>
<p><code>Future</code>不能马上返回值的时候，会被交给<code>Reactor</code>;</p>
</li>
<li>
<p><code>Future</code>的值准备就绪后，调用<code>wake</code>传递给<code>Executor</code>执行;</p>
</li>
<li>
<p>反复执行，直至整个<code>Future</code>返回<code>Ready</code>。</p>
</li>
</ul>
<h2 id=executor>Executor</h2>
<p><code>Executor</code>的实现可以是单线程与线程池两个版本，两种实现间各有优劣，单线程少了数据的竞争，但是吞吐量却容易达到瓶颈，线程池的实现可以提高吞吐量，但是却要处理数据的竞争冲突。下面我们以<a href=https://github.com/async-rs/async-std><code>async-std</code></a>来分析基于线程池的实现：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// The state of an executor.
</span><span class=sd></span><span class=k>struct</span> <span class=nc>Pool</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// 全局任务队列
</span><span class=sd></span><span class=w>    </span><span class=n>injector</span>: <span class=nc>Injector</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// 线程的本地队列，用来进行任务的偷取
</span><span class=sd></span><span class=w>    </span><span class=n>stealers</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Stealer</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// 存放空闲的线程，用来后续的唤醒并执行任务
</span><span class=sd></span><span class=w>    </span><span class=n>sleepers</span>: <span class=nc>Sleepers</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// 全局的线程池
</span><span class=c1></span><span class=k>static</span><span class=w> </span><span class=n>POOL</span>: <span class=nc>Lazy</span><span class=o>&lt;</span><span class=n>Pool</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Lazy</span>::<span class=n>new</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>num_threads</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>num_cpus</span>::<span class=n>get</span><span class=p>().</span><span class=n>max</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stealers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// Spawn worker threads.
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>num_threads</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>worker</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Worker</span>::<span class=n>new_fifo</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=n>stealers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>worker</span><span class=p>.</span><span class=n>stealer</span><span class=p>());</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>proc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Processor</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>worker</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>slot</span>: <span class=nc>Cell</span>::<span class=n>new</span><span class=p>(</span><span class=nb>None</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>slot_runs</span>: <span class=nc>Cell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>thread</span>::<span class=n>Builder</span>::<span class=n>new</span><span class=p>()</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>name</span><span class=p>(</span><span class=s>&#34;async-std/executor&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>())</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>spawn</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PROCESSOR</span><span class=p>.</span><span class=n>with</span><span class=p>(</span><span class=o>|</span><span class=n>p</span><span class=o>|</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>proc</span><span class=p>));</span><span class=w>
</span><span class=w>                </span><span class=n>abort_on_panic</span><span class=p>(</span><span class=n>main_loop</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=p>})</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;cannot start a thread driving tasks&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>Pool</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>injector</span>: <span class=nc>Injector</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>stealers</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>sleepers</span>: <span class=nc>Sleepers</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>});</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=sd>/// 工作线程的状态
</span><span class=sd></span><span class=k>struct</span> <span class=nc>Processor</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// 本地任务队列
</span><span class=sd></span><span class=w>    </span><span class=n>worker</span>: <span class=nc>Worker</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// 存放了比本地队列中任务优先级更高的任务，通常第一次spawn会放到这里，
</span><span class=sd></span><span class=w>    </span><span class=sd>/// 执行一次poll来快速判断状态，对于无阻塞的任务更高效，不需要等待。
</span><span class=sd></span><span class=w>    </span><span class=n>slot</span>: <span class=nc>Cell</span><span class=o>&lt;</span><span class=nb>Option</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// How many times in a row tasks have been taked from the slot rather than the queue.
</span><span class=sd></span><span class=w>    </span><span class=n>slot_runs</span>: <span class=nc>Cell</span><span class=o>&lt;</span><span class=kt>u32</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main_loop</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>find_runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>task</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>task</span><span class=p>.</span><span class=n>run</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=c1>// 实际上，这里根据空循环的次数，会陷入睡眠状态或出让CPU资源，直到新的task来唤醒。
</span><span class=c1></span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>find_runnable</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>Task</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// 优先从本地的队列中获取
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>task</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>get_local</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>task</span><span class=p>.</span><span class=n>is_some</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>task</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// 其次从全局队列中获取
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>task</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>get_global</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>task</span><span class=p>.</span><span class=n>is_some</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>task</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// 最后尝试从其他线程的本地队列中偷取
</span><span class=c1></span><span class=w>    </span><span class=n>steal_other</span><span class=p>()</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=sd>/// 安排新的任务到Executor的执行队列中
</span><span class=sd></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>schedule</span><span class=p>(</span><span class=n>task</span>: <span class=nc>Runnable</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>PROCESSOR</span><span class=p>.</span><span class=n>with</span><span class=p>(</span><span class=o>|</span><span class=n>proc</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// If the current thread is a worker thread, store it into its task slot or push it into
</span><span class=c1></span><span class=w>        </span><span class=c1>// its local task queue. Otherwise, push it into the global task queue.
</span><span class=c1></span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>proc</span><span class=p>.</span><span class=n>get</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=c1>// 如果当前线程为worker线程，插入到当前线程的第一优先级任务槽
</span><span class=c1></span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>proc</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=c1>// Replace the task in the slot.
</span><span class=c1></span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>task</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>proc</span><span class=p>.</span><span class=n>slot</span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>task</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=c1>// 尝试把任务的优先级提升到最高，并把上一个优先级最高的任务放到当前线程任务队列
</span><span class=c1></span><span class=w>                    </span><span class=c1>// If the slot already contained a task, push it into the local task queue.
</span><span class=c1></span><span class=w>                    </span><span class=n>proc</span><span class=p>.</span><span class=n>worker</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>task</span><span class=p>);</span><span class=w>
</span><span class=w>                    </span><span class=n>POOL</span><span class=p>.</span><span class=n>sleepers</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=c1>// 如果当前线程不是worker线程的话，放到全局队列
</span><span class=c1></span><span class=w>            </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=c1>// 将任务放到全局队列中
</span><span class=c1></span><span class=w>                </span><span class=n>POOL</span><span class=p>.</span><span class=n>injector</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>task</span><span class=p>);</span><span class=w>
</span><span class=w>                </span><span class=c1>// 尝试唤醒一个睡眠的worker线程
</span><span class=c1></span><span class=w>                </span><span class=n>POOL</span><span class=p>.</span><span class=n>sleepers</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>})</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>这里做了大量的简化，整个 Executor 是一个线程池，每个线程都在不断的寻找可执行的 task，然后执行，然后再找下一个 task，再执行，永远重复。</p>
<blockquote>
<p>从上面的 main_loop 中可以看到，cpu 并不是一直毫无意义的空转，中间会有一些策略来优化 cpu 的使用。</p>
</blockquote>
<h2 id=常见的executor>常见的Executor</h2>
<ul>
<li>
<p>tokio：</p>
</li>
<li>
<p>async-std：</p>
</li>
<li>
<p>smol：</p>
</li>
</ul>
<h2 id=reactor>Reactor</h2>
<p><code>Reactor</code>作为反应器，上面同时挂载了成千上万个待唤醒的事件， 这里使用了<a href=https://github.com/%E2%80%83tokio-rs/mio><code>mio</code></a>统一封装了操作系统的多路复用<code>API</code>。在<code>Linux</code>中使用的是<a href=https://zh.wikipedia.org/wiki/Epoll><code>Epoll</code></a>，在<code>Mac</code>中使用的则是<a href=https://zh.wikipedia.org/wiki/Kqueue><code>Kqueue</code></a>，具体的实现在此不多说。</p>
<p>在 Future 的基础上，出现了<code>AsyncRead/AsyncWrite/AsyncSeek</code>等抽象来描述 IO 操作，在执行对应的<code>Read/Write/Seek</code>操作时，如果底层的数据尚未准备好，会把所在的 Future 注册至 Reactor。Reactor 的流程如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>poll</span><span class=p>.</span><span class=n>poll</span><span class=p>(</span><span class=o>&amp;</span><span class=n>events</span><span class=p>,</span><span class=w> </span><span class=n>timeout</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>event</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>events</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>event</span><span class=p>.</span><span class=n>is_readable</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=n>waker</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>event</span><span class=p>.</span><span class=n>readers</span><span class=p>.</span><span class=n>wakers</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>waker</span><span class=p>.</span><span class=n>wake</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>event</span><span class=p>.</span><span class=n>is_writeable</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=n>waker</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>event</span><span class=p>.</span><span class=n>writers</span><span class=p>.</span><span class=n>wakers</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>waker</span><span class=p>.</span><span class=n>wake</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p><code>Reactor</code>会不断的<code>poll</code>就绪的事件，然后依次唤醒绑定在事件上的<code>waker</code>，<code>waker</code>唤醒的时候会把对应的<code>task</code>移动到<code>Executor</code>的就绪队列上安排执行。</p>
<blockquote>
<p>结合<code>Executor</code>的运作原理不难发现，<code>Executor</code>肯定不会<code>poll</code>到未就绪的<code>task</code>，因为只有就绪的任务才会被<code>Reactor</code>放到<code>Executor</code>的执行队列中，<code>Executor</code>的资源利用率再一次被提高，这就是整个异步体系的高明之处。</p>
</blockquote>
<h2 id=stream>Stream</h2>
<p><code>Future</code>是异步开发中最基础的概念了，如果说<code>Future</code>代表了一次性的异步值，那么<code>Stream</code>则代表了一系列的异步值。<code>Future</code>是 1，<code>Stream</code>是 0，1 或者 N。 签名如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Stream</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>poll_next</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Pin</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>cx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Context</span><span class=o>&lt;</span><span class=na>&#39;_</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Poll</span><span class=o>&lt;</span><span class=nb>Option</span><span class=o>&lt;</span><span class=n>Self</span>::<span class=n>Item</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p><code>Stream</code>对应了同步原语中的<code>Iterator</code>的概念，回忆一下，是不是连签名都是如此的相像呢！</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p><code>Stream</code>用来抽象源源不断的数据源，当然也可以断（当  <code>poll</code>  到  <code>None</code>  的时候）。可以用来抽象  <code>Websocket Connection</code>  读取端，在<code>Websokcet</code>中，服务端源源不断的接受客户端的值并处理，直至客户端断开连接。更进一步的抽象，<code>MQ</code>中的<code>Consumer</code>, <code>Tcp</code>中接收方，都可以看作是一个<code>Stream</code>, 因此<code>Stream</code>的抽象对异步编程意义非凡。</p>
<blockquote>
<p>思考: 除了上面的几种情况，还有什么可以抽象成<code>Stream</code>模型呢？</p>
</blockquote>
<h2 id=sink>Sink</h2>
<p>有了代表一次性的异步值<code>Future</code>, 也有了代表可重复的异步值的<code>Stream</code>, 因此，需要有一个代表一次或多次的异步值的通道，也就是接下来的<code>Sink</code>。通常来说, <code>Sink</code>可以来抽象网络连接的写入端，消息队列中的  <code>Producer</code>。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Sink</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Error</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>poll_ready</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Pin</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>cx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Context</span><span class=o>&lt;</span><span class=na>&#39;_</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Poll</span><span class=o>&lt;</span><span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>Self</span>::<span class=n>Error</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>start_send</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Pin</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>item</span>: <span class=nc>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>Self</span>::<span class=n>Error</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>poll_flush</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Pin</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>cx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Context</span><span class=o>&lt;</span><span class=na>&#39;_</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Poll</span><span class=o>&lt;</span><span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>Self</span>::<span class=n>Error</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>poll_close</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Pin</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>cx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Context</span><span class=o>&lt;</span><span class=na>&#39;_</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Poll</span><span class=o>&lt;</span><span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>Self</span>::<span class=n>Error</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>在 Sink 的上层，我们可以封装  <code>send</code>  以及  <code>send_all</code>  等方法，用来抽象对应的  <code>Future</code>  与  <code>Stream</code>.</p>
<h2 id=timer>Timer</h2>
<p>很多情况下，我们希望可以延时执行一些操作，比如定时发送邮件，每隔一段时间生成一次报表。我们首先想到不就是<code>sleep</code>一段时间就行了，下面的代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>get_next_day</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Time</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>thread</span>::<span class=n>sleep</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>hour</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>24</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>current_time</span><span class=p>()</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>run_every_hour</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>thread</span>::<span class=n>sleep</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>hour</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>do_something</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>是不是很机智呢！😂😂😂！ 遗憾的是，我们写完这段代码，提交后，还没上线，估计就要滚蛋了。因此，我们想要的是一个不阻塞当前线程的定时器，定时器到期自动唤醒并执行之后的操作。</p>
<p>不同于<code>Tcp/Udp/Uds</code>，<code>mio</code>没有提供对<code>Timer</code>的封装。</p>
<p>通常来说，对定时器的处理要么是<em>时间轮</em>，要么<em>堆</em>，要么<em>红黑树</em>(时间复杂度更为平均<code>O(log n)</code>)。时间轮比较典型的案例就是在<code>Kafka</code>中的使用了，<code>Go Runtime</code>  用的则是堆，红黑树和堆的实现大致相同。</p>
<ol>
<li>时间轮算法可以想象做钟表，每一格存储了到期的定时器，因此时间轮的最小精度为每一格所代表的时间(因此时间轮算法不适合用于对精度要求高的场景)。如果定时器的时间超过时间轮所能表示的时间怎么办呢，也简单，可以通过两种方式来优化。</li>
</ol>
<ul>
<li>
<p>多级时间轮来优化，可以想象，在钟表上，秒针每走一圈，分针走一格，同理分针走一圈，时针走一格，因此多级时间轮中，第一级的时间最为精确，第二级次之，第三级再次之&mldr;, 超过某一级时间轮所能表示的事件后，将定时器放到下一级时间轮中。</p>
</li>
<li>
<p>超过时间轮所能表示的时间范围后，对时间取余，插入到余数所在的格子中，这样一来，每个格子中存放的定时器需要加入轮数的记录，用来表明还差多少轮才能执行。每个格子中在插入新的定时器时，可以使用堆来堆定时器进行排序。</p>
</li>
</ul>
<ol start=2>
<li>堆定时器(红黑树定时器)</li>
</ol>
<p>使用最小堆来维护所有的定时器。一个工作线程不断的从堆里面寻找最近的定时器，如果定时器的时间比当前时间小，则唤醒该定时器对应的 task，如果未达到设定的时间，则进行<code>Thread::park(deadline-now)</code>操作，让出当前 cpu 一段时间。</p>
<blockquote>
<p>目前 futures-timer 的实现为全剧唯一的一个堆。存在可优化空间, 比如  <code>Go 1.14</code>  的实现，把定时器提交到当前 worker thread 的本地堆里面，用来避免锁竞争，提高性能。</p>
</blockquote>
<h2 id=组合子>组合子</h2>
<p>上面定义了实现异步的最基本概念，<code>Future</code>, <code>Stream</code>以及<code>Sink</code>。</p>
<p>但是很多情况下，我们直接使用它们来构建我们的应用是非常困难的，例如：多个互为竞争关系的<code>Future</code>，我们只需其中任意一个<code>Future</code>返回即可，能想到的做法是，我们不断的遍历所有的<code>Future</code>，直到某一个返回<code>Ready</code>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>futures</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=n>is_ready</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=n>output</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>我们可以把上面的逻辑给包装一下，提供一个名为<code>select!(futures...)</code>的宏，<code>select</code>便可作为一个组合子而存在。类似的组合子还有很多，比如<code>join(futures...)</code>，等待所有<code>Future</code>完成。</p>
<p>更多的可以参考<a href=https://docs.rs/futures-util/0.3.4/futures_util/><code>futures-util</code></a>.</p>
<h2 id=asyncawait>Async/Await</h2>
<p>上面所有的概念共同组成了<code>Rust</code>的异步生态，那么现在想象一下，如何获取一个<code>Future</code>运行的结果呢。一个可能的做法如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>f</span>::<span class=n>poll</span><span class=p>(</span><span class=n>cx</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Poll</span>::<span class=n>Ready</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>Poll</span>::<span class=n>Pending</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>如果每次都要用户这么做的话，将会是多么痛苦的一件事儿呀，还不如用注册回调函数来实现异步呢！</p>
<p>有没有更精炼的方式来获取<code>Future</code>的值呢，这就是<code>async/await</code>出现的原因了。本质上来说，<code>async/await</code>就是上面代码段的一个语法糖，是用户使用起来更加的自然。上面的代码可以替换成：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>async</code> 关键字用于修饰函数，将函数返回值替换为一个对应的<code>Future</code>；</p>
</li>
<li>
<p><code>await</code>: 用于处理调用async函数，其将调用替换为一段async状态机；</p>
</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>//await
</span><span class=c1></span><span class=k>await</span><span class=o>!</span><span class=p>(</span><span class=cp>$future</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=cp>$future</span><span class=p>.</span><span class=n>poll</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Poll</span>::<span class=n>Pending</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kr>yield</span><span class=w> </span><span class=n>Poll</span>::<span class=n>Pending</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>Poll</span>::<span class=n>Ready</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>break</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h2 id=pin>Pin</h2>
<h2 id=总结-1>总结</h2>
<p>虽然上面提到了各种各样的概念，但是仔细捋一下，便会发现整个异步可以分为三层：</p>
<ol>
<li><code>Future/Stream/Sink</code>，<code>Reactor/Executor</code>直接作用于前面的三种类型。此层是为底层，一般用户很少接触，库的开发者接触较多。</li>
<li>组合子层，为了提供更为复杂的操作，诞生了一系列的异步组合子，使得异步变得更利于使用，用户会使用这些组合子来完成各种各样的逻辑。</li>
<li><code>async/await</code>，准确的说，这层远没有上面两层来的重要，但是依然不可或缺，这层使得异步的开发变得轻而易举。</li>
</ol>
<h3 id=注意的地方>注意的地方</h3>
<ol>
<li>不要在任何异步函数中执行任何阻塞操作，不仅仅是<code>thread::sleep</code>, 还有标准库的<code>Tcp/Udp</code>, 以及<code>sync</code>中的<code>channel</code>, <code>Mutex</code>, <code>RWLock</code>  都不应该继续使用，除非你知道你在干什么！替换为<code>async-std</code>  与  <code>futures</code>中实现的版本。</li>
<li>如非必要，不要自己尝试去实现<code>Future</code>，自己实现的没有触发<code>wake</code>操作的话，将永远不会唤醒，取而代之，用已经实现好的<code>Future</code>进行组合。</li>
<li>使用<code>async/await</code>代替所有需要异步等待的点，这将会极大的简化你的代码。</li>
</ol>
<h2 id=参考>参考</h2>
<ol>
<li><a href=https://blog.fun4go.top/Rust%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8Efuture.html>https://blog.fun4go.top/Rust%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8Efuture.html</a></li>
<li><a href=https://rustmagazine.github.io/rust_magazine_2021/chapter_3/rust-to-system-essence-concurrent.html>透过 Rust 探索系统的本原：并发篇 - Rust精选</a></li>
<li><a href=https://zhuanlan.zhihu.com/p/97574385>零成本异步I/O</a></li>
<li><a href=https://blog.csdn.net/gengzhikui1992/article/details/115638777>rust异步编程&ndash;理解并发/多线程/回调/异步/future/promise/async/await/tokio_网络安全研究-CSDN博客_rust异步编程</a></li>
<li></li>
</ol>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
0001-01-01
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/language/>language</a>
<a href=https://justice.bj.cn/tags/rust/>rust</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/14.language/rust/01.rust%E5%9F%BA%E7%A1%80/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">Rust 基础</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/14.language/rust/02.rust%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/>
<span class="next-text nav-default">Rust 数据类型</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2021
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script>$("#openSearch, #openSearchMobile").click(function(){$(".modal-dialog").addClass("visible")}),$("#closeSearch").click(function(){$(".modal-dialog").removeClass("visible")}),$(document).click(function(a){$(a.target).closest(".modal-content, #openSearch, #openSearchMobile").length||$("body").find(".modal-dialog").removeClass("visible")})</script>
</body>
</html>