# Rust å¼‚æ­¥ç¼–ç¨‹

## ç®€ä»‹

å¼‚æ­¥ç¼–ç¨‹ç»å†äº†ä¸‰ä¸ªé˜¶æ®µï¼š

* ç¬¬ä¸€é˜¶æ®µï¼šå¼‚æ­¥å›è°ƒæ¨¡å¼ï¼Œå­˜åœ¨å›è°ƒåœ°ç‹±é—®é¢˜ï¼›

* ç¬¬äºŒé˜¶æ®µï¼šnodejs ä¸­çš„`Promise/Future`æ¨¡å¼ï¼Œä»£ç å†—ä½™ï¼›

* ç¬¬ä¸‰é˜¶æ®µï¼šåŸºäºåç¨‹çš„`async/await`æ–¹å¼ï¼›

Rust å¼‚æ­¥æ˜¯åœ¨æœ€è¿‘çš„ç‰ˆæœ¬(1.39)ä¸­æ‰ç¨³å®šä¸‹æ¥ã€‚

## Ruståç¨‹

åŸºäº`async/await`çš„å¼‚æ­¥è§£å†³æ–¹æ¡ˆéœ€è¦åç¨‹æ”¯æŒã€‚

åç¨‹çš„å®ç°ä¸€èˆ¬æœ‰ä¸¤ç§ï¼š

* æœ‰æ ˆåç¨‹ï¼ˆStackfulï¼‰: æ¯ä¸ªåç¨‹åˆ†é…ç‹¬ç«‹çš„æ ˆæ¥ä¿å­˜åç¨‹ä¸Šä¸‹æ–‡ï¼Œgolangçš„åç¨‹å°±æ˜¯æœ‰æ ˆåç¨‹ï¼›

* æ— æ ˆåç¨‹ï¼ˆStacklessï¼‰: åŸºäºçŠ¶æ€æœºï¼Œä¸éœ€è¦ç‹¬ç«‹æ ˆã€‚

Ruståç¨‹é‡‡ç”¨æ— æ ˆåç¨‹ã€‚é€šè¿‡`Generator`å®ç°ï¼›

## Generatorï¼ˆç”Ÿæˆå™¨ï¼‰

ç”Ÿæˆå™¨

## Future

* `Future`Â æ˜¯ä¸€ä¸ª`trait`ï¼Œè¡¨ç¤ºä¸€ä¸ªå¼‚æ­¥è°ƒç”¨çš„å¯¹è±¡ï¼ˆå¼‚æ­¥è°ƒç”¨çš„ç»“æœæ˜¯ä¸€ä¸ªæœªæ¥æœŸæœ›ï¼‰ã€‚

* å½“å‘èµ·ä¸€æ¬¡è¯·æ±‚æ—¶ï¼Œå°†ç«‹å³è·å¾—ä¸€ä¸ª `Future` å¯¹è±¡; è€Œä¸€æ—¦è¯·æ±‚å®Œæˆï¼Œ`Future`å°†è¿”å›ä»»ä½•å“åº”å¯èƒ½åŒ…å«çš„å€¼ï¼›

* `Future`éœ€è¦ç¨‹åºä¸»åŠ¨å»`poll`(è½®è¯¢)æ‰èƒ½è·å–åˆ°æœ€ç»ˆçš„ç»“æœï¼Œæ¯ä¸€æ¬¡è½®è¯¢çš„ç»“æœå¯èƒ½æ˜¯`Ready`æˆ–è€…`Pending`ã€‚
  
  * `Ready`:  å½“å‰`Future`å·²å®Œæˆï¼Œä»£ç é€»è¾‘å¯ä»¥å‘ä¸‹æ‰§è¡Œï¼›
  
  * `Pending`: å½“å‰`Future`å¹¶æœªæ‰§è¡Œå®Œæˆï¼Œä»£ç ä¸èƒ½å‘ä¸‹æ‰§è¡Œï¼Œ

* `Runtime`ä¸­çš„`Executor`éœ€è¦ä¸åœçš„å»æ‰§è¡Œ`Future`çš„`poll`æ“ä½œï¼Œç›´è‡³`Future`è¿”å›`Ready`å¯ä»¥å‘ä¸‹æ‰§è¡Œä¸ºæ­¢ã€‚

```rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}

pub trait Future {
    type Output;      //
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

## Context

`Context`æä¾›äº†å¯¹`Future`è¿›è¡Œè°ƒåº¦çš„åŠŸèƒ½ã€‚ç›®å‰`Context`ä½œä¸ºä¸€ä¸ªç»“æ„ä½“ï¼Œæœ‰ä¸€ä¸ªæ ¸å¿ƒæˆå‘˜`Waker`ï¼Œç”¨æ¥å”¤é†’ç»‘å®šçš„`Future`. æœªæ¥ä¸æ’é™¤åœ¨`Context`æ·»åŠ æ–°çš„å­—æ®µã€‚

```rust
pub struct Context<'a> {
    waker: &'a Waker,

    _marker: PhantomData<fn(&'a ()) -> &'a ()>,
}
```

```rust
pub struct Waker {
    waker: RawWaker,
}

impl Waker {
    /// å”¤é†’ç»‘å®šåœ¨ Waker ä¸Šçš„æ•°æ®ï¼Œé€šå¸¸æ˜¯ Future
    pub fn wake(self) {}
    pub fn wake_by_ref(&self) {}
    pub fn will_wake(&self, other: &Waker) -> bool {}

    pub unsafe fn from_raw(waker: RawWaker) -> Waker {}
}

pub struct RawWaker {
    /// A data pointer, which can be used to store arbitrary data as required
    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`
    /// that is associated with the task.
    /// The value of this field gets passed to all functions that are part of
    /// the vtable as the first parameter.
    data: *const (),
    /// Virtual function pointer table that customizes the behavior of this waker.
    vtable: &'static RawWakerVTable,
}

/// RawWaker è¡Œä¸ºçš„è™šå‡½æ•°è¡¨
pub struct RawWakerVTable {
    clone: unsafe fn(*const ()) -> RawWaker,
    wake: unsafe fn(*const ()),
    wake_by_ref: unsafe fn(*const ()),
    drop: unsafe fn(*const ()),
}
```

## Runtime

`Runtime`Â  ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼Œ`Executor`å’Œ`Reactor`ã€‚

* `Executor`: æ‰§è¡Œå™¨, è´Ÿè´£è°ƒåº¦`Future`ï¼Œæ²¡æœ‰ä»»ä½•é˜»å¡çš„ç­‰å¾…ï¼Œå¾ªç¯æ‰§è¡Œä¸€ç³»åˆ—å°±ç»ªçš„`Future`ï¼Œå½“`Future`è¿”å›`pending`çš„æ—¶å€™ï¼Œä¼šå°†`Future`è½¬ç§»åˆ°`Reactor`ä¸Šç­‰å¾…è¿›ä¸€æ­¥çš„å”¤é†’ã€‚

* `Reactor`: ååº”å™¨, è´Ÿè´£æ‰§è¡Œ`Future`ï¼Œè½®è¯¢å¹¶å”¤é†’æŒ‚è½½çš„äº‹ä»¶ï¼Œå¹¶æ‰§è¡Œå¯¹åº”çš„`wake`æ–¹æ³•ï¼Œé€šå¸¸æ¥è¯´ï¼Œ`wake`ä¼šå°†`Future`çš„çŠ¶æ€å˜æ›´ä¸ºå°±ç»ªï¼ŒåŒæ—¶å°†`Future`æ”¾åˆ°`Executor`çš„é˜Ÿåˆ—ä¸­ç­‰å¾…æ‰§è¡Œã€‚

### æ‰§è¡Œæµç¨‹

ä¸‹é¢çš„åºåˆ—å›¾å¤§æ¦‚ç®€å•çš„æç»˜äº†`Future`åœ¨`Executor`å’Œ`Reactor`ä¹‹é—´æ¥å›è½¬ç§»çš„æµç¨‹ä¸çŠ¶æ€å˜åŒ–ã€‚

```mermaid
sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    Executor->>Reactor: Pending Future
    deactivate Executor
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor->>Executor: Ready Future
    deactivate Reactor
    activate Executor
    deactivate Executor
```

ä¸Šé¢è¯´æ˜äº†ä¸€ä¸ªç®€å•çš„`Future`çš„æ‰§è¡Œï¼Œå¦‚æœæ˜¯ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„`Future`çš„è¯ï¼Œæ¯”å¦‚ä¸­é—´ä¼šæœ‰å¤šæ¬¡`IO`æ“ä½œçš„è¯ï¼Œé‚£ä¹ˆæµç¨‹æ—¶æ€ä¹ˆæ ·çš„å‘¢ï¼Ÿçœ‹ä¸‹é¢ä¸€æ®µä»£ç ï¼š

```rust
async fn read_and_write(s: TcpStream) {
  let (mut r, mut w) = s.split();
  let mut buffer = r.read().await.unwrap();
  buffer.append("Hello,world");
  w.write_all(buffer.as_bytes()).await.unwrap();
}
```

å¯¹åº”çš„æ‰§è¡Œæµç¨‹ä¸ºï¼š

```mermaid
sequenceDiagram
    participant Executor
    participant Reactor
    activate Executor
    deactivate Executor
    Executor->>Reactor: Pending on r.read()
    Note left of Executor: Execute other Future
    activate Reactor
    Reactor->>Executor: r.read() is ready
    Note left of Executor: Execute current Future
    deactivate Reactor
    Executor->>Reactor: Pending on w.write_all()
    Note left of Executor: Execute other Future
    activate Reactor
    deactivate Reactor
    Reactor->>Executor: w.write_all() is ready
```

> ä¸Šé¢çš„è¿™äº›ä¾‹å­ç³»ç»Ÿä¸­åªå±•ç¤ºäº†ä¸€ä¸ª`Future`çš„æ‰§è¡Œæƒ…å†µï¼ŒçœŸå®çš„ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œå¯èƒ½æœ‰æ•°åä¸‡çš„`Future`åŒæ—¶åœ¨æ‰§è¡Œï¼Œ`Executor`å’Œ`Reactor`çš„è°ƒåº¦æ¨¡å‹è¦æ›´å¤æ‚ä¸€äº›ã€‚

### æ€»ç»“

ä¸€å¥è¯æ¦‚æ‹¬`Runtime`:

* `Future`ä¸èƒ½é©¬ä¸Šè¿”å›å€¼çš„æ—¶å€™ï¼Œä¼šè¢«äº¤ç»™`Reactor`;

* `Future`çš„å€¼å‡†å¤‡å°±ç»ªåï¼Œè°ƒç”¨`wake`ä¼ é€’ç»™`Executor`æ‰§è¡Œ;

* åå¤æ‰§è¡Œï¼Œç›´è‡³æ•´ä¸ª`Future`è¿”å›`Ready`ã€‚

## æ‰§è¡Œå™¨(Executor)

`Executor`çš„å®ç°å¯ä»¥æ˜¯å•çº¿ç¨‹ä¸çº¿ç¨‹æ± ä¸¤ä¸ªç‰ˆæœ¬ï¼Œä¸¤ç§å®ç°é—´å„æœ‰ä¼˜åŠ£ï¼Œå•çº¿ç¨‹å°‘äº†æ•°æ®çš„ç«äº‰ï¼Œä½†æ˜¯ååé‡å´å®¹æ˜“è¾¾åˆ°ç“¶é¢ˆï¼Œçº¿ç¨‹æ± çš„å®ç°å¯ä»¥æé«˜ååé‡ï¼Œä½†æ˜¯å´è¦å¤„ç†æ•°æ®çš„ç«äº‰å†²çªã€‚ä¸‹é¢æˆ‘ä»¬ä»¥[`async-std`](https://github.com/async-rs/async-std)æ¥åˆ†æåŸºäºçº¿ç¨‹æ± çš„å®ç°ï¼š

```rust
/// The state of an executor.
struct Pool {
    /// å…¨å±€ä»»åŠ¡é˜Ÿåˆ—
    injector: Injector<Runnable>,

    /// çº¿ç¨‹çš„æœ¬åœ°é˜Ÿåˆ—ï¼Œç”¨æ¥è¿›è¡Œä»»åŠ¡çš„å·å–
    stealers: Vec<Stealer<Runnable>>,

    /// å­˜æ”¾ç©ºé—²çš„çº¿ç¨‹ï¼Œç”¨æ¥åç»­çš„å”¤é†’å¹¶æ‰§è¡Œä»»åŠ¡
    sleepers: Sleepers,
}

// å…¨å±€çš„çº¿ç¨‹æ± 
static POOL: Lazy<Pool> = Lazy::new(|| {
    let num_threads = num_cpus::get().max(1);
    let mut stealers = Vec::new();

    // Spawn worker threads.
    for _ in 0..num_threads {
        let worker = Worker::new_fifo();
        stealers.push(worker.stealer());

        let proc = Processor {
            worker,
            slot: Cell::new(None),
            slot_runs: Cell::new(0),
        };

        thread::Builder::new()
            .name("async-std/executor".to_string())
            .spawn(|| {
                let _ = PROCESSOR.with(|p| p.set(proc));
                abort_on_panic(main_loop);
            })
            .expect("cannot start a thread driving tasks");
    }

    Pool {
        injector: Injector::new(),
        stealers,
        sleepers: Sleepers::new(),
    }
});

/// å·¥ä½œçº¿ç¨‹çš„çŠ¶æ€
struct Processor {
    /// æœ¬åœ°ä»»åŠ¡é˜Ÿåˆ—
    worker: Worker<Runnable>,

    /// å­˜æ”¾äº†æ¯”æœ¬åœ°é˜Ÿåˆ—ä¸­ä»»åŠ¡ä¼˜å…ˆçº§æ›´é«˜çš„ä»»åŠ¡ï¼Œé€šå¸¸ç¬¬ä¸€æ¬¡spawnä¼šæ”¾åˆ°è¿™é‡Œï¼Œ
    /// æ‰§è¡Œä¸€æ¬¡pollæ¥å¿«é€Ÿåˆ¤æ–­çŠ¶æ€ï¼Œå¯¹äºæ— é˜»å¡çš„ä»»åŠ¡æ›´é«˜æ•ˆï¼Œä¸éœ€è¦ç­‰å¾…ã€‚
    slot: Cell<Option<Runnable>>,

    /// How many times in a row tasks have been taked from the slot rather than the queue.
    slot_runs: Cell<u32>,
}

fn main_loop() {
    loop {
        match find_runnable() {
            Some(task) => task.run();
            None => {
                // å®é™…ä¸Šï¼Œè¿™é‡Œæ ¹æ®ç©ºå¾ªç¯çš„æ¬¡æ•°ï¼Œä¼šé™·å…¥ç¡çœ çŠ¶æ€æˆ–å‡ºè®©CPUèµ„æºï¼Œç›´åˆ°æ–°çš„taskæ¥å”¤é†’ã€‚
            }
        }
    }
}

fn find_runnable() -> Option<Task> {
    // ä¼˜å…ˆä»æœ¬åœ°çš„é˜Ÿåˆ—ä¸­è·å–
    let task = get_local();
    if task.is_some() {
        return task;
    }
    // å…¶æ¬¡ä»å…¨å±€é˜Ÿåˆ—ä¸­è·å–
    let task = get_global();
    if task.is_some() {
        return task;
    }
    // æœ€åå°è¯•ä»å…¶ä»–çº¿ç¨‹çš„æœ¬åœ°é˜Ÿåˆ—ä¸­å·å–
    steal_other()
}

/// å®‰æ’æ–°çš„ä»»åŠ¡åˆ°Executorçš„æ‰§è¡Œé˜Ÿåˆ—ä¸­
pub(crate) fn schedule(task: Runnable) {
    PROCESSOR.with(|proc| {
        // If the current thread is a worker thread, store it into its task slot or push it into
        // its local task queue. Otherwise, push it into the global task queue.
        match proc.get() {
            // å¦‚æœå½“å‰çº¿ç¨‹ä¸ºworkerçº¿ç¨‹ï¼Œæ’å…¥åˆ°å½“å‰çº¿ç¨‹çš„ç¬¬ä¸€ä¼˜å…ˆçº§ä»»åŠ¡æ§½
            Some(proc) => {
                // Replace the task in the slot.
                if let Some(task) = proc.slot.replace(Some(task)) {
                    // å°è¯•æŠŠä»»åŠ¡çš„ä¼˜å…ˆçº§æå‡åˆ°æœ€é«˜ï¼Œå¹¶æŠŠä¸Šä¸€ä¸ªä¼˜å…ˆçº§æœ€é«˜çš„ä»»åŠ¡æ”¾åˆ°å½“å‰çº¿ç¨‹ä»»åŠ¡é˜Ÿåˆ—
                    // If the slot already contained a task, push it into the local task queue.
                    proc.worker.push(task);
                    POOL.sleepers.notify_one();
                }
            }
            None => {  // å¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯workerçº¿ç¨‹çš„è¯ï¼Œæ”¾åˆ°å…¨å±€é˜Ÿåˆ—       
                POOL.injector.push(task);    // å°†ä»»åŠ¡æ”¾åˆ°å…¨å±€é˜Ÿåˆ—ä¸­
                POOL.sleepers.notify_one();  // å°è¯•å”¤é†’ä¸€ä¸ªç¡çœ çš„workerçº¿ç¨‹
            }
        }
    })
}
```

æ•´ä¸ª Executor æ˜¯ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½åœ¨ä¸æ–­çš„å¯»æ‰¾å¯æ‰§è¡Œçš„ taskï¼Œç„¶åæ‰§è¡Œï¼Œç„¶åå†æ‰¾ä¸‹ä¸€ä¸ª taskï¼Œå†æ‰§è¡Œï¼Œæ°¸è¿œé‡å¤ã€‚

> ä»ä¸Šé¢çš„ main_loop ä¸­å¯ä»¥çœ‹åˆ°ï¼Œcpu å¹¶ä¸æ˜¯ä¸€ç›´æ¯«æ— æ„ä¹‰çš„ç©ºè½¬ï¼Œä¸­é—´ä¼šæœ‰ä¸€äº›ç­–ç•¥æ¥ä¼˜åŒ– cpu çš„ä½¿ç”¨ã€‚

### å¸¸è§çš„Executor

* tokioï¼š

* async-stdï¼š

* smolï¼š

![loading-ag-1103]()

## Reactor

`Reactor`ä½œä¸ºååº”å™¨ï¼Œä¸Šé¢åŒæ—¶æŒ‚è½½äº†æˆåƒä¸Šä¸‡ä¸ªå¾…å”¤é†’çš„äº‹ä»¶ï¼Œ è¿™é‡Œä½¿ç”¨äº†[`mio`](https://github.com/%E2%80%83tokio-rs/mio)ç»Ÿä¸€å°è£…äº†æ“ä½œç³»ç»Ÿçš„å¤šè·¯å¤ç”¨`API`ã€‚åœ¨`Linux`ä¸­ä½¿ç”¨çš„æ˜¯[`Epoll`](https://zh.wikipedia.org/wiki/Epoll)ï¼Œåœ¨`Mac`ä¸­ä½¿ç”¨çš„åˆ™æ˜¯[`Kqueue`](https://zh.wikipedia.org/wiki/Kqueue)ï¼Œå…·ä½“çš„å®ç°åœ¨æ­¤ä¸å¤šè¯´ã€‚

åœ¨ Future çš„åŸºç¡€ä¸Šï¼Œå‡ºç°äº†`AsyncRead/AsyncWrite/AsyncSeek`ç­‰æŠ½è±¡æ¥æè¿° IO æ“ä½œï¼Œåœ¨æ‰§è¡Œå¯¹åº”çš„`Read/Write/Seek`æ“ä½œæ—¶ï¼Œå¦‚æœåº•å±‚çš„æ•°æ®å°šæœªå‡†å¤‡å¥½ï¼Œä¼šæŠŠæ‰€åœ¨çš„ Future æ³¨å†Œè‡³ Reactorã€‚Reactor çš„æµç¨‹å¦‚ä¸‹:

```rust
loop {
    poll.poll(&events, timeout);
    for event in events.iter() {
        if (event.is_readable()) {
            for waker in event.readers.wakers {
                waker.wake();
            }
        }
        if (event.is_writeable()) {
            for waker in event.writers.wakers {
                waker.wake();
            }
        }
    }
}
```

`Reactor`ä¼šä¸æ–­çš„`poll`å°±ç»ªçš„äº‹ä»¶ï¼Œç„¶åä¾æ¬¡å”¤é†’ç»‘å®šåœ¨äº‹ä»¶ä¸Šçš„`waker`ï¼Œ`waker`å”¤é†’çš„æ—¶å€™ä¼šæŠŠå¯¹åº”çš„`task`ç§»åŠ¨åˆ°`Executor`çš„å°±ç»ªé˜Ÿåˆ—ä¸Šå®‰æ’æ‰§è¡Œã€‚

> ç»“åˆ`Executor`çš„è¿ä½œåŸç†ä¸éš¾å‘ç°ï¼Œ`Executor`è‚¯å®šä¸ä¼š`poll`åˆ°æœªå°±ç»ªçš„`task`ï¼Œå› ä¸ºåªæœ‰å°±ç»ªçš„ä»»åŠ¡æ‰ä¼šè¢«`Reactor`æ”¾åˆ°`Executor`çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­ï¼Œ`Executor`çš„èµ„æºåˆ©ç”¨ç‡å†ä¸€æ¬¡è¢«æé«˜ï¼Œè¿™å°±æ˜¯æ•´ä¸ªå¼‚æ­¥ä½“ç³»çš„é«˜æ˜ä¹‹å¤„ã€‚

## Stream

`Future`ä»£è¡¨äº†ä¸€æ¬¡æ€§çš„å¼‚æ­¥å€¼ï¼Œ`Stream`ä»£è¡¨äº†ä¸€ç³»åˆ—è¿ç»­çš„å¼‚æ­¥å€¼ã€‚`Future`æ˜¯ 1ï¼Œ`Stream`æ˜¯ 0ï¼Œ1 æˆ–è€… Nã€‚ ç­¾åå¦‚ä¸‹ï¼š

```rust
pub trait Stream {
    type Item;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;
}
```

`Stream`å¯¹åº”äº†åŒæ­¥åŸè¯­ä¸­çš„`Iterator`çš„æ¦‚å¿µï¼Œå›å¿†ä¸€ä¸‹ï¼Œæ˜¯ä¸æ˜¯è¿ç­¾åéƒ½æ˜¯å¦‚æ­¤çš„ç›¸åƒå‘¢ï¼

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

`Stream`ç”¨æ¥æŠ½è±¡æºæºä¸æ–­çš„æ•°æ®æºï¼Œå½“ç„¶ä¹Ÿå¯ä»¥æ–­ï¼ˆå½“ Â `poll`Â  åˆ° Â `None`Â  çš„æ—¶å€™ï¼‰ã€‚å¯ä»¥ç”¨æ¥æŠ½è±¡ Â `Websocket Connection`Â  è¯»å–ç«¯ï¼Œåœ¨`Websokcet`ä¸­ï¼ŒæœåŠ¡ç«¯æºæºä¸æ–­çš„æ¥å—å®¢æˆ·ç«¯çš„å€¼å¹¶å¤„ç†ï¼Œç›´è‡³å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ã€‚æ›´è¿›ä¸€æ­¥çš„æŠ½è±¡ï¼Œ`MQ`ä¸­çš„`Consumer`,Â `Tcp`ä¸­æ¥æ”¶æ–¹ï¼Œéƒ½å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ª`Stream`, å› æ­¤`Stream`çš„æŠ½è±¡å¯¹å¼‚æ­¥ç¼–ç¨‹æ„ä¹‰éå‡¡ã€‚

> æ€è€ƒ: é™¤äº†ä¸Šé¢çš„å‡ ç§æƒ…å†µï¼Œè¿˜æœ‰ä»€ä¹ˆå¯ä»¥æŠ½è±¡æˆ`Stream`æ¨¡å‹å‘¢ï¼Ÿ

## Sink

`Future`ä»£è¡¨ä¸€æ¬¡æ€§çš„å¼‚æ­¥å€¼, `Stream`ä»£è¡¨å¯é‡å¤çš„å¼‚æ­¥å€¼, Â `Sink`ä»£è¡¨ä¸€æ¬¡æˆ–å¤šæ¬¡çš„å¼‚æ­¥å€¼çš„é€šé“, æŠ½è±¡ç½‘ç»œè¿æ¥çš„å†™å…¥ç«¯ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„ Â `Producer`ã€‚

```rust
pub trait Sink<Item> {
    type Error;

    fn poll_ready(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
    fn start_send(self: Pin<&mut Self>, item: Item) -> Result<(), Self::Error>;
    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
    fn poll_close(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>>;
}
```

åœ¨ Sink çš„ä¸Šå±‚ï¼Œæˆ‘ä»¬å¯ä»¥å°è£… Â `send`Â  ä»¥åŠ Â `send_all`Â  ç­‰æ–¹æ³•ï¼Œç”¨æ¥æŠ½è±¡å¯¹åº”çš„ Â `Future`Â  ä¸ Â `Stream`.

## Timer

å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥å»¶æ—¶æ‰§è¡Œä¸€äº›æ“ä½œï¼Œæ¯”å¦‚å®šæ—¶å‘é€é‚®ä»¶ï¼Œæ¯éš”ä¸€æ®µæ—¶é—´ç”Ÿæˆä¸€æ¬¡æŠ¥è¡¨ã€‚æˆ‘ä»¬é¦–å…ˆæƒ³åˆ°ä¸å°±æ˜¯`sleep`ä¸€æ®µæ—¶é—´å°±è¡Œäº†ï¼Œä¸‹é¢çš„ä»£ç ï¼š

```rust
pub fn get_next_day() -> Time {
    thread::sleep(Duration::hour * 24);
    current_time()
}

pub fn run_every_hour() {
    for thread::sleep(Duration::hour) {
        do_something();
    }
}
```

æ˜¯ä¸æ˜¯å¾ˆæœºæ™ºå‘¢ï¼ğŸ˜‚ğŸ˜‚ğŸ˜‚ï¼ é—æ†¾çš„æ˜¯ï¼Œæˆ‘ä»¬å†™å®Œè¿™æ®µä»£ç ï¼Œæäº¤åï¼Œè¿˜æ²¡ä¸Šçº¿ï¼Œä¼°è®¡å°±è¦æ»šè›‹äº†ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æƒ³è¦çš„æ˜¯ä¸€ä¸ªä¸é˜»å¡å½“å‰çº¿ç¨‹çš„å®šæ—¶å™¨ï¼Œå®šæ—¶å™¨åˆ°æœŸè‡ªåŠ¨å”¤é†’å¹¶æ‰§è¡Œä¹‹åçš„æ“ä½œã€‚

ä¸åŒäº`Tcp/Udp/Uds`ï¼Œ`mio`æ²¡æœ‰æä¾›å¯¹`Timer`çš„å°è£…ã€‚

é€šå¸¸æ¥è¯´ï¼Œå¯¹å®šæ—¶å™¨çš„å¤„ç†è¦ä¹ˆæ˜¯*æ—¶é—´è½®*ï¼Œè¦ä¹ˆ*å †*ï¼Œè¦ä¹ˆ*çº¢é»‘æ ‘*(æ—¶é—´å¤æ‚åº¦æ›´ä¸ºå¹³å‡`O(log n)`)ã€‚æ—¶é—´è½®æ¯”è¾ƒå…¸å‹çš„æ¡ˆä¾‹å°±æ˜¯åœ¨`Kafka`ä¸­çš„ä½¿ç”¨äº†ï¼Œ`Go Runtime`Â  ç”¨çš„åˆ™æ˜¯å †ï¼Œçº¢é»‘æ ‘å’Œå †çš„å®ç°å¤§è‡´ç›¸åŒã€‚

1. æ—¶é—´è½®ç®—æ³•å¯ä»¥æƒ³è±¡åšé’Ÿè¡¨ï¼Œæ¯ä¸€æ ¼å­˜å‚¨äº†åˆ°æœŸçš„å®šæ—¶å™¨ï¼Œå› æ­¤æ—¶é—´è½®çš„æœ€å°ç²¾åº¦ä¸ºæ¯ä¸€æ ¼æ‰€ä»£è¡¨çš„æ—¶é—´(å› æ­¤æ—¶é—´è½®ç®—æ³•ä¸é€‚åˆç”¨äºå¯¹ç²¾åº¦è¦æ±‚é«˜çš„åœºæ™¯)ã€‚å¦‚æœå®šæ—¶å™¨çš„æ—¶é—´è¶…è¿‡æ—¶é—´è½®æ‰€èƒ½è¡¨ç¤ºçš„æ—¶é—´æ€ä¹ˆåŠå‘¢ï¼Œä¹Ÿç®€å•ï¼Œå¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼æ¥ä¼˜åŒ–ã€‚
- å¤šçº§æ—¶é—´è½®æ¥ä¼˜åŒ–ï¼Œå¯ä»¥æƒ³è±¡ï¼Œåœ¨é’Ÿè¡¨ä¸Šï¼Œç§’é’ˆæ¯èµ°ä¸€åœˆï¼Œåˆ†é’ˆèµ°ä¸€æ ¼ï¼ŒåŒç†åˆ†é’ˆèµ°ä¸€åœˆï¼Œæ—¶é’ˆèµ°ä¸€æ ¼ï¼Œå› æ­¤å¤šçº§æ—¶é—´è½®ä¸­ï¼Œç¬¬ä¸€çº§çš„æ—¶é—´æœ€ä¸ºç²¾ç¡®ï¼Œç¬¬äºŒçº§æ¬¡ä¹‹ï¼Œç¬¬ä¸‰çº§å†æ¬¡ä¹‹..., è¶…è¿‡æŸä¸€çº§æ—¶é—´è½®æ‰€èƒ½è¡¨ç¤ºçš„äº‹ä»¶åï¼Œå°†å®šæ—¶å™¨æ”¾åˆ°ä¸‹ä¸€çº§æ—¶é—´è½®ä¸­ã€‚

- è¶…è¿‡æ—¶é—´è½®æ‰€èƒ½è¡¨ç¤ºçš„æ—¶é—´èŒƒå›´åï¼Œå¯¹æ—¶é—´å–ä½™ï¼Œæ’å…¥åˆ°ä½™æ•°æ‰€åœ¨çš„æ ¼å­ä¸­ï¼Œè¿™æ ·ä¸€æ¥ï¼Œæ¯ä¸ªæ ¼å­ä¸­å­˜æ”¾çš„å®šæ—¶å™¨éœ€è¦åŠ å…¥è½®æ•°çš„è®°å½•ï¼Œç”¨æ¥è¡¨æ˜è¿˜å·®å¤šå°‘è½®æ‰èƒ½æ‰§è¡Œã€‚æ¯ä¸ªæ ¼å­ä¸­åœ¨æ’å…¥æ–°çš„å®šæ—¶å™¨æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å †æ¥å †å®šæ—¶å™¨è¿›è¡Œæ’åºã€‚
2. å †å®šæ—¶å™¨(çº¢é»‘æ ‘å®šæ—¶å™¨)

ä½¿ç”¨æœ€å°å †æ¥ç»´æŠ¤æ‰€æœ‰çš„å®šæ—¶å™¨ã€‚ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ä¸æ–­çš„ä»å †é‡Œé¢å¯»æ‰¾æœ€è¿‘çš„å®šæ—¶å™¨ï¼Œå¦‚æœå®šæ—¶å™¨çš„æ—¶é—´æ¯”å½“å‰æ—¶é—´å°ï¼Œåˆ™å”¤é†’è¯¥å®šæ—¶å™¨å¯¹åº”çš„ taskï¼Œå¦‚æœæœªè¾¾åˆ°è®¾å®šçš„æ—¶é—´ï¼Œåˆ™è¿›è¡Œ`Thread::park(deadline-now)`æ“ä½œï¼Œè®©å‡ºå½“å‰ cpu ä¸€æ®µæ—¶é—´ã€‚

> ç›®å‰ futures-timer çš„å®ç°ä¸ºå…¨å±€å”¯ä¸€çš„ä¸€ä¸ªå †ã€‚å­˜åœ¨å¯ä¼˜åŒ–ç©ºé—´, æ¯”å¦‚ Â `Go 1.14`Â  çš„å®ç°ï¼ŒæŠŠå®šæ—¶å™¨æäº¤åˆ°å½“å‰ worker thread çš„æœ¬åœ°å †é‡Œé¢ï¼Œç”¨æ¥é¿å…é”ç«äº‰ï¼Œæé«˜æ€§èƒ½ã€‚

## ç»„åˆå­

ä¸Šé¢å®šä¹‰äº†å®ç°å¼‚æ­¥çš„æœ€åŸºæœ¬æ¦‚å¿µï¼Œ`Future`,Â `Stream`ä»¥åŠ`Sink`ã€‚

ä½†æ˜¯å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨å®ƒä»¬æ¥æ„å»ºæˆ‘ä»¬çš„åº”ç”¨æ˜¯éå¸¸å›°éš¾çš„ï¼Œä¾‹å¦‚ï¼šå¤šä¸ªäº’ä¸ºç«äº‰å…³ç³»çš„`Future`ï¼Œæˆ‘ä»¬åªéœ€å…¶ä¸­ä»»æ„ä¸€ä¸ª`Future`è¿”å›å³å¯ï¼Œèƒ½æƒ³åˆ°çš„åšæ³•æ˜¯ï¼Œæˆ‘ä»¬ä¸æ–­çš„éå†æ‰€æœ‰çš„`Future`ï¼Œç›´åˆ°æŸä¸€ä¸ªè¿”å›`Ready`:

```rust
loop {
    for f in futures {
        if f.is_ready() {
            return f.output();
        }
    }
}
```

æˆ‘ä»¬å¯ä»¥æŠŠä¸Šé¢çš„é€»è¾‘ç»™åŒ…è£…ä¸€ä¸‹ï¼Œæä¾›ä¸€ä¸ªåä¸º`select!(futures...)`çš„å®ï¼Œ`select`ä¾¿å¯ä½œä¸ºä¸€ä¸ªç»„åˆå­è€Œå­˜åœ¨ã€‚ç±»ä¼¼çš„ç»„åˆå­è¿˜æœ‰å¾ˆå¤šï¼Œæ¯”å¦‚`join(futures...)`ï¼Œç­‰å¾…æ‰€æœ‰`Future`å®Œæˆã€‚

æ›´å¤šçš„å¯ä»¥å‚è€ƒ[`futures-util`](https://docs.rs/futures-util/0.3.4/futures_util/).

## Async/Await

ä¸Šé¢æ‰€æœ‰çš„æ¦‚å¿µå…±åŒç»„æˆäº†`Rust`çš„å¼‚æ­¥ç”Ÿæ€ï¼Œé‚£ä¹ˆç°åœ¨æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚ä½•è·å–ä¸€ä¸ª`Future`è¿è¡Œçš„ç»“æœå‘¢ã€‚ä¸€ä¸ªå¯èƒ½çš„åšæ³•å¦‚ä¸‹ï¼š

```rust
loop {
    match f::poll(cx) {
        Poll::Ready(x) => return x;
        Poll::Pending => {}
    }
}
```

å¦‚æœæ¯æ¬¡éƒ½è¦ç”¨æˆ·è¿™ä¹ˆåšçš„è¯ï¼Œå°†ä¼šæ˜¯å¤šä¹ˆç—›è‹¦çš„ä¸€ä»¶äº‹å„¿å‘€ï¼Œè¿˜ä¸å¦‚ç”¨æ³¨å†Œå›è°ƒå‡½æ•°æ¥å®ç°å¼‚æ­¥å‘¢ï¼

æœ‰æ²¡æœ‰æ›´ç²¾ç‚¼çš„æ–¹å¼æ¥è·å–`Future`çš„å€¼å‘¢ï¼Œè¿™å°±æ˜¯`async/await`å‡ºç°çš„åŸå› äº†ã€‚æœ¬è´¨ä¸Šæ¥è¯´ï¼Œ`async/await`å°±æ˜¯ä¸Šé¢ä»£ç æ®µçš„ä¸€ä¸ªè¯­æ³•ç³–ï¼Œæ˜¯ç”¨æˆ·ä½¿ç”¨èµ·æ¥æ›´åŠ çš„è‡ªç„¶ã€‚ä¸Šé¢çš„ä»£ç å¯ä»¥æ›¿æ¢æˆï¼š

```rust
let x = f.await;
```

* `async` å…³é”®å­—ç”¨äºä¿®é¥°å‡½æ•°ï¼Œå°†å‡½æ•°è¿”å›å€¼æ›¿æ¢ä¸ºä¸€ä¸ªå¯¹åº”çš„`Future`ï¼›

* `await`: ç”¨äºå¤„ç†è°ƒç”¨asyncå‡½æ•°ï¼Œå…¶å°†è°ƒç”¨æ›¿æ¢ä¸ºä¸€æ®µasyncçŠ¶æ€æœºï¼›

```rust
//await
await!($future) => {
    loop {
        match $future.poll() {
            Poll::Pending => yield Poll::Pending,
            Poll::Ready(value) => break value,
        }
    }
}
```

## Pin

## æ€»ç»“

è™½ç„¶ä¸Šé¢æåˆ°äº†å„ç§å„æ ·çš„æ¦‚å¿µï¼Œä½†æ˜¯ä»”ç»†æ‹ä¸€ä¸‹ï¼Œä¾¿ä¼šå‘ç°æ•´ä¸ªå¼‚æ­¥å¯ä»¥åˆ†ä¸ºä¸‰å±‚ï¼š

1. `Future/Stream/Sink`ï¼Œ`Reactor/Executor`ç›´æ¥ä½œç”¨äºå‰é¢çš„ä¸‰ç§ç±»å‹ã€‚æ­¤å±‚æ˜¯ä¸ºåº•å±‚ï¼Œä¸€èˆ¬ç”¨æˆ·å¾ˆå°‘æ¥è§¦ï¼Œåº“çš„å¼€å‘è€…æ¥è§¦è¾ƒå¤šã€‚
2. ç»„åˆå­å±‚ï¼Œä¸ºäº†æä¾›æ›´ä¸ºå¤æ‚çš„æ“ä½œï¼Œè¯ç”Ÿäº†ä¸€ç³»åˆ—çš„å¼‚æ­¥ç»„åˆå­ï¼Œä½¿å¾—å¼‚æ­¥å˜å¾—æ›´åˆ©äºä½¿ç”¨ï¼Œç”¨æˆ·ä¼šä½¿ç”¨è¿™äº›ç»„åˆå­æ¥å®Œæˆå„ç§å„æ ·çš„é€»è¾‘ã€‚
3. `async/await`ï¼Œå‡†ç¡®çš„è¯´ï¼Œè¿™å±‚è¿œæ²¡æœ‰ä¸Šé¢ä¸¤å±‚æ¥çš„é‡è¦ï¼Œä½†æ˜¯ä¾ç„¶ä¸å¯æˆ–ç¼ºï¼Œè¿™å±‚ä½¿å¾—å¼‚æ­¥çš„å¼€å‘å˜å¾—è½»è€Œæ˜“ä¸¾ã€‚

### æ³¨æ„çš„åœ°æ–¹

1. ä¸è¦åœ¨ä»»ä½•å¼‚æ­¥å‡½æ•°ä¸­æ‰§è¡Œä»»ä½•é˜»å¡æ“ä½œï¼Œä¸ä»…ä»…æ˜¯`thread::sleep`, è¿˜æœ‰æ ‡å‡†åº“çš„`Tcp/Udp`, ä»¥åŠ`sync`ä¸­çš„`channel`,Â `Mutex`,Â `RWLock`Â  éƒ½ä¸åº”è¯¥ç»§ç»­ä½¿ç”¨ï¼Œé™¤éä½ çŸ¥é“ä½ åœ¨å¹²ä»€ä¹ˆï¼æ›¿æ¢ä¸º`async-std`Â  ä¸ Â `futures`ä¸­å®ç°çš„ç‰ˆæœ¬ã€‚
2. å¦‚éå¿…è¦ï¼Œä¸è¦è‡ªå·±å°è¯•å»å®ç°`Future`ï¼Œè‡ªå·±å®ç°çš„æ²¡æœ‰è§¦å‘`wake`æ“ä½œçš„è¯ï¼Œå°†æ°¸è¿œä¸ä¼šå”¤é†’ï¼Œå–è€Œä»£ä¹‹ï¼Œç”¨å·²ç»å®ç°å¥½çš„`Future`è¿›è¡Œç»„åˆã€‚
3. ä½¿ç”¨`async/await`ä»£æ›¿æ‰€æœ‰éœ€è¦å¼‚æ­¥ç­‰å¾…çš„ç‚¹ï¼Œè¿™å°†ä¼šæå¤§çš„ç®€åŒ–ä½ çš„ä»£ç ã€‚

## å‚è€ƒ

1. https://blog.fun4go.top/Rust%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8Efuture.html
2. [é€è¿‡ Rust æ¢ç´¢ç³»ç»Ÿçš„æœ¬åŸï¼šå¹¶å‘ç¯‡ - Rustç²¾é€‰](https://rustmagazine.github.io/rust_magazine_2021/chapter_3/rust-to-system-essence-concurrent.html)
3. [é›¶æˆæœ¬å¼‚æ­¥I/O](https://zhuanlan.zhihu.com/p/97574385)
4. [rustå¼‚æ­¥ç¼–ç¨‹--ç†è§£å¹¶å‘/å¤šçº¿ç¨‹/å›è°ƒ/å¼‚æ­¥/future/promise/async/await/tokio_ç½‘ç»œå®‰å…¨ç ”ç©¶-CSDNåšå®¢_rustå¼‚æ­¥ç¼–ç¨‹](https://blog.csdn.net/gengzhikui1992/article/details/115638777)
5. https://github.com/rustcc/writing-an-os-in-rust/blob/master/12-async-await.md
6. https://wiki.brewlin.com/wiki/compiler/rust%E5%8D%8F%E7%A8%8B_%E8%B0%83%E5%BA%A6%E5%99%A8%E5%AE%9E%E7%8E%B0/
