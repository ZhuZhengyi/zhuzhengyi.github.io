# Rust æ•°æ®ç±»å‹

## ç®€ä»‹

Rust çš„æ•°æ®åˆ†ä¸º `æ ‡é‡(scalar)`ã€`å¤åˆ(compound)`å’Œ `é›†åˆ`3 ç§ç±»å‹ï¼š

| **ç±»å‹å†™æ³•**                                | **æè¿°**                                                                               | **å€¼ä¸¾ä¾‹**                                                                                  |
| ------------------------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| i8, i16, i32, i64,`<br>`u8, u16, u32, u64   | i:å¸¦ç¬¦å· `<br>`u:æ— ç¬¦å· `<br>`æ•°å­—ä»£è¡¨å­˜å‚¨ä½æ•°                                         | 42,`<br>`-5i8, 0x400u16, 0o100i16,`<br>`20_922_789_888_000u64,`<br>`b'\*' (u8 byte literal) |
| isize, usize                                | å¸¦ç¬¦å·/æ— ç¬¦å· æ•´å‹ `<br>`å­˜å‚¨ä½æ•°ä¸ç³»ç»Ÿä½æ•°ç›¸åŒ `<br>`(32 æˆ– 64 ä½æ•´æ•°)                | 137,`<br>`-0b0101_0010isize,`<br>`0xffff_fc00usize                                          |
| f32, f64                                    | IEEE æ ‡å‡†çš„æµ®ç‚¹æ•°ï¼Œå•ç²¾åº¦/åŒç²¾åº¦                                                       | 1.61803, 3.14f32,`<br>`6.0221e23f64                                                         |
| bool                                        | å¸ƒå°”å‹                                                                                 | true, false                                                                                 |
| char                                        | Unicode å­—ç¬¦ `<br>`å­˜å‚¨ç©ºé—´å›ºå®šä¸º 4 å­—ç¬¦                                               | '\*', '\n', 'å­—', '\x7f', '\u{CA0}'                                                         |
| (char, u8, i32)                             | å…ƒç»„ tupleï¼šå¯ä»¥å­˜å‚¨å¤šç§ç±»å‹                                                           | ('%', 0x7f, -1)                                                                             |
| ()                                          | å•å…ƒç±»å‹ï¼Œå®é™…ä¸Šæ˜¯ç©º tuple                                                             | ()                                                                                          |
| struct S{x: f32, y: f32 }                   | å‘½åå…ƒç´ ç»“æ„ä½“ï¼Œæ•°æ®æˆå‘˜æœ‰å˜é‡åçš„ç»“æ„ä½“                                               | struct S { x: 120.0, y: 209.0 }                                                             |
| struct T(i32, char)                         | å…ƒç»„ç»“æ„ä½“ï¼Œæ•°æ®æˆå‘˜æ— åç§°ï¼Œå½¢å¦‚å…ƒç»„ï¼Œä¸å¯ä¸å…ƒç»„æ··æ·†                                   | struct T(120, 'X')                                                                          |
| struct E                                    | å•å…ƒå‹ç»“æ„ä½“ï¼Œæ²¡æœ‰æ•°æ®æˆå‘˜                                                             | E                                                                                           |
| enum Attend {`<br>`OnTime, Late(u32)`<br>`} | æšä¸¾ç±»å‹ï¼Œæšä¸¾ç±»å‹é»˜è®¤æ²¡æœ‰æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰çš„è¿ç®—ï¼Œæ›´æ²¡æœ‰æ¯”è¾ƒå¤§å°                           | Attend::Late(5),`<br>`Attend::OnTime                                                        |
| Box `<Attend>`                              | Box æŒ‡é’ˆç±»å‹ï¼ŒæŒ‡å‘å †å†…å­˜ä¸­çš„ä¸€ä¸ªæ³›å‹å€¼                                                 | Box::new(Late(15))                                                                          |
| &i32, &mut i32                              | åªè¯»å¼•ç”¨å’Œå¯å˜å¼•ç”¨ï¼Œç‰©æ‰€æœ‰æƒï¼Œç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡æ‰€æŒ‡å‘çš„å€¼ã€‚`<br>`åªè¯»å¼•ç”¨ä¹Ÿå«å…±äº«å¼•ç”¨ï¼Œ | &s.y, &mut v                                                                                |
| String                                      | å­—ç¬¦ä¸²ï¼ŒUTF-8 æ ¼å¼å­˜å‚¨ï¼Œé•¿åº¦å¯å˜                                                       | "ç¼–ç¨‹".to_string()`<br>`to_string å‡½æ•°è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹                                    |
| &str                                        | str çš„å¼•ç”¨ï¼ŒæŒ‡å‘ UTF-8 æ–‡æœ¬çš„æŒ‡é’ˆï¼Œæ— æ‰€æœ‰æƒ                                            | "ãã°: soba", &s[0..12]                                                                     |
| [f64; 4], [u8; 256]                         | æ•°ç»„ï¼Œå›ºå®šé•¿åº¦ï¼Œå†…éƒ¨æ•°æ®ç±»å‹å¿…é¡»ä¸€è‡´                                                   | [1.0, 0.0, 0.0, 1.0],`<br>`[b' '; 256]                                                      |
| Vec `<f64>`                                 | Vector å‘é‡ï¼Œå¯å˜é•¿åº¦ï¼Œå†…éƒ¨æ•°æ®ç±»å‹å¿…é¡»ä¸€è‡´                                            | vec![0.367, 2.718, 7.389]                                                                   |
| &[u8..u8],`<br>`&mut [u8..u8]               | åˆ‡ç‰‡å¼•ç”¨ï¼Œé€šè¿‡èµ·å§‹ç´¢å¼•å’Œé•¿åº¦æŒ‡å‘æ•°ç»„æˆ–å‘é‡çš„ä¸€éƒ¨åˆ†è¿ç»­å…ƒç´                              | &v[10..20], &mut a[..]                                                                      |
| &Any, &mut Read                             | traid å¯¹è±¡ï¼šå®ç°äº†æŸ trait å†…æ–¹æ³•çš„å¯¹è±¡ `<br>`ç¤ºä¾‹ä¸­ Anyã€Read éƒ½æ˜¯ trait              | value as &Any,`<br>`&mut file as &mut Read                                                  |
| fn(&str, usize) ->`<br>`isize               | å‡½æ•°ç±»å‹ï¼Œå¯ä»¥ç†è§£ä¸ºå‡½æ•°æŒ‡é’ˆ                                                           | i32::saturating_add                                                                         |
| é—­åŒ…                                        | é—­åŒ…                                                                                   | \|a, b\| a*a + b*b                                                                          |

ä¸Šè¡¨ä¸­æ²¡æœ‰ byte ç±»å‹ï¼Œæ˜¯å› ä¸º Rust å‹æ ¹å°±æ²¡æœ‰ byte ç±»å‹ï¼Œå®é™…ä¸Šç­‰äº u8ï¼Œåœ¨ä¸€èˆ¬è®¡ç®—ä¸­è®¤ä¸ºæ˜¯ u8ï¼Œ

åœ¨æ–‡ä»¶æˆ–ç½‘ç»œä¸­è¯»å†™æ•°æ®æ—¶ç»å¸¸ç§°ä¸º byte æµã€‚

## æ ‡é‡ç±»å‹(scalar)

æ ‡é‡ç±»å‹è¡¨ç¤ºä¸€ä¸ªå•ç‹¬çš„å€¼ï¼ŒåŒ…æ‹¬ï¼š

- **å¸ƒå°”ç±»å‹(bool)**
- **æ•°å€¼(numeir)**
- **å­—ç¬¦ (char)**

### å¸ƒå°”ç±»å‹(bool)

- bool ç±»å‹å ä¸€ä¸ª byte, ä»è€Œå…è®¸æŒ‡é’ˆæŒ‡å‘å…¶åœ°å€ï¼›
- bool å‹å–å€¼: `true`, `false`ï¼›
- `as`è¿ç®—ç¬¦å¯ä»¥å°† bool å€¼è½¬æ¢ä¸ºæ•´æ•°ç±»å‹ï¼Œfalse -> 0ï¼Œtrue è½¬æ¢ä¸º 1ï¼›
- `as`ä¸ä¼šä»æ•°å€¼ç±»å‹è½¬æ¢ä¸º bool

```rust
let b1: bool = true;
let b2 = !b1;
let b3 = 1 > 0;
let i = b1 as u8;     // bool -> u8
// let b = i as bool  // u8 -> bool éæ³•
println!("{} {} {}", b1, b2, b3);    //true, false, true
```

### æ•°å€¼ç±»å‹(numeric)

- ä¸å…è®¸éšå¼è½¬æ¢ï¼›
- å¦‚æœéœ€è¦è°ƒç”¨ç±»å‹çš„æ–¹æ³•, åœ¨æœ‰äºŒæ„çš„æƒ…å†µä¸‹å¿…é¡»æ˜¾å¼è½¬æ¢, ä¾‹å¦‚åŠ åç¼€: `(2.0_f64).sqrt()`ï¼›
- `bool`, `char`, `enum` å¯ä»¥è½¬æ¢ä¸ºä»»æ„æ•´å‹ `integer`, ä½†åå‘è½¬æ¢ä¸è¡Œ, å”¯ä¸€ä¾‹å¤–æ˜¯ `u8`è½¬ `char`ï¼›
- æœ‰ç¬¦å·æ•´å½¢ï¼š `i8, i16, i32, i64`;
- æ— ç¬¦å·æ•´å½¢ï¼š `u8, u16, u32, u64`;
- å¸¦ç¬¦å·/æ— ç¬¦å·æ•´å‹, å­˜å‚¨ä½æ•°ä¸ç³»ç»Ÿä½æ•°ç›¸åŒï¼š `isize, usize`;
- å•/åŒç²¾åº¦æµ®ç‚¹å‹ï¼š `f32, f64`ï¼›
- å¸¦ç¬¦å·æ•´å‹ï¼Œä½¿ç”¨æœ€é«˜ä¸€ä½ï¼ˆbitï¼‰è¡¨ç¤ºä¸ºç¬¦å·ï¼Œ0 ä¸ºæ­£æ•°ï¼Œ1 ä¸ºè´Ÿæ•°ï¼Œå…¶ä»–ä½æ˜¯æ•°å€¼ï¼Œç”¨è¡¥ç è¡¨ç¤ºï¼›
- Rust è¦æ±‚æ•°ç»„çš„ç´¢å¼•å¿…é¡»æ˜¯ usize ç±»å‹ï¼Œåœ¨ä¸€äº›æ•°æ®ç»“æ„ä¸­ï¼Œæ•°ç»„å’Œå‘é‡çš„å…ƒç´ æ•°ä¹Ÿæ˜¯ usize å‹ï¼›
- æ•°å€¼ç±»å‹å¯ä»¥é€šè¿‡ `as`è¿ç®—ç¬¦è¿›è¡Œè½¬æ¢ï¼›
- `as`è¿ç®—ç¬¦åœ¨è½¬æ¢æ—¶ï¼Œå¯¹å­˜å‚¨çš„æ•°å­—å¹¶ä¸æ”¹åŠ¨ï¼Œåªæ˜¯æŠŠæ•°è¯»å‡ºæ¥çš„æ—¶å€™è¿›è¡Œæˆªå–ã€æ‰©å±•ã€æˆ–å†³å®šæ˜¯å¦é‡‡ç”¨è¡¥ç ç¿»è¯‘ï¼›
- f32 å’Œ f64 ç±»å‹éƒ½å®šä¹‰äº†ä¸€äº›ç‰¹æ®Šå€¼å¸¸é‡ï¼šÂ INFINITYï¼ˆæ— ç©·å¤§ï¼‰ã€ NEG_INFINITY (è´Ÿæ— ç©·)ã€NAN (éæ•°å­—)ã€MINï¼ˆæœ€å°å€¼ï¼‰ã€MAX (æœ€å¤§å€¼)ã€‚std::f32::consts å’Œ std::f64::consts æ¨¡å—å®šä¹‰äº†ä¸€äº›å¸¸é‡ï¼šEï¼ˆè‡ªç„¶å¯¹æ•°ï¼‰ã€PIï¼ˆåœ†å‘¨ç‡ï¼‰ã€SQRT_2ï¼ˆ2 çš„å¹³æ–¹æ ¹ï¼‰ç­‰ç­‰ã€‚

å„æ•´æ•°ç±»å‹çš„å–å€¼èŒƒå›´ï¼š

- u8ï¼šÂ Â Â Â [0, 2^8Â â€“1] (0Â ~ 255)
- u16ï¼š [0, 2^16-1] (0Â ~ 65,535)
- u32ï¼š [0, 2^32-1] (0Â ~ 4,294,967,295)
- u64ï¼š [0, 2^64-1] (0Â ~ 18,446,744,073,709,551,615ï¼Œçº¦ 1.8 åƒäº¿äº¿)
- i8ï¼šã€€ [âˆ’2^7, 2^7Â âˆ’1] (âˆ’128Â ~ 127)
- i16ï¼šã€€[âˆ’2^15, 2^15Â âˆ’1] (âˆ’32,768Â ~ 32,767)
- i32ï¼šã€€[âˆ’2^31, 2^31Â âˆ’1] (âˆ’2,147,483,648Â ~ 2,147,483,647)
- i64ï¼šã€€[âˆ’2^63Â , 2^63Â âˆ’1] (âˆ’9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)
- usizeï¼š[0,2^32Â âˆ’1] (32 ä½ç³»ç»Ÿ) æˆ– [0, 2^64Â âˆ’1] (64 ä½ç³»ç»Ÿ)
- isizeï¼šã€€ âˆ’2^31Â  è‡³ 2^31Â âˆ’1, or âˆ’2^63Â  è‡³ 2^63Â âˆ’1

```rust
// int
let big_val = std::i32::MAX; //MAX æ˜¯std::i32ä¸­å®šä¹‰çš„å¸¸é‡ï¼Œè¡¨ç¤ºi32å‹çš„æœ€å¤§å€¼ï¼Œå³231-1
let neg_inf = std::f32::NEG_INFINITY; //è´Ÿæ— ç©·å¤§ï¼›
let x = big_val + 1;         // å‘ç”Ÿå¼‚å¸¸ panic: arithmetic operation overflowed
// æ•´å½¢è¿›åˆ¶
let u07 = 0xFF_u32;          //0x 16è¿›åˆ¶
let u08 = 0o7777_u32;        //0o 8è¿›åˆ¶
let u09 = 0b01_10_00_u8;     //0b 2è¿›åˆ¶
println!("{} {} {}",u07,u08,u09);    //255 4095 24
// as
assert_eq!(  10_i8 as u16,    10_u16); // æ­£æ•°å€¼ç”±å°‘ä½æ•°è½¬å…¥å¤šä½æ•°
assert_eq!( 2525_u16 as i16, 2525_i16); // æ­£æ•°å€¼åŒä½æ•°è½¬æ¢
assert_eq!(  -1_i16 as i32,    -1_i32); // è´Ÿæ•°å°‘ä½è½¬å¤šä½æ‰§è¡Œç¬¦å·ä½æ‰©å±•
assert_eq!(65535_u16 as i32, 65535_i32); // æ­£æ•°å°‘ä½è½¬å¤šä½æ‰§è¡Œ0ä½æ‰©å±•ï¼ˆä¹Ÿå¯ä»¥ç†è§£ä¸ºç¬¦å·ä½æ‰©å±•ï¼‰
//ç”±å¤šä½æ•°è½¬å°‘ä½æ•°ï¼Œä¼šæˆªæ‰å¤šä½æ•°çš„é«˜ä½ï¼Œç›¸å½“äºå¤šä½æ•°é™¤ä»¥2^Nçš„å–æ¨¡ï¼Œå…¶ä¸­Næ˜¯å°‘ä½æ•°çš„ä½æ•°
assert_eq!( 1000_i16 as u8, 232_u8); //1000çš„äºŒè¿›åˆ¶æ˜¯0000 0011 1110 1000ï¼Œæˆªæ‰å·¦ä¾§8ä½ï¼Œç•™ä¸‹å³ä¾§8ä½ï¼Œæ˜¯232
assert_eq!(65535_u32 as i16, -1_i16); //65535çš„äºŒè¿›åˆ¶,16ä¸ª0å’Œ16ä¸ª1ï¼Œæˆªæ‰é«˜ä½çš„16ä¸ª0ï¼Œå‰©ä¸‹çš„å…¨æ˜¯1ï¼Œå…¨1çš„æœ‰ç¬¦å·è¡¥ç æ˜¯-1

//åŒä½æ•°çš„å¸¦ç¬¦å·å’Œæ— ç¬¦å·ç›¸äº’è½¬åŒ–ï¼Œå­˜å‚¨çš„æ•°å­—å¹¶ä¸åŠ¨ï¼Œåªæ˜¯è§£é‡Šçš„æ–¹æ³•ä¸ä¸€æ ·
//æ— ç¬¦å·æ•°ï¼Œå°±æ˜¯è¿™ä¸ªå€¼ï¼›è€Œæœ‰ç¬¦å·æ•°ï¼Œéœ€è¦ç”¨è¡¥ç æ¥ç¿»è¯‘
assert_eq!(-1_i8  as u8, 255_u8);  //æœ‰ç¬¦å·è½¬æ— ç¬¦å·
assert_eq!(255_u8 as i8, -1_i8);  //æ— ç¬¦å·è½¬æœ‰ç¬¦å·
// float
assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.); // å¹³æ–¹æ ¹ï¼Œæ­¤å¤–è¿˜æœ‰sin()ã€ln()ç­‰è¯¸å¤šæ•°å­¦è®¡ç®—æ–¹æ³•
assert_eq!(-3.7f64.floor(),  -4.0);  //å‘ä¸‹å–æ•´ï¼Œè¿˜æœ‰ceil()æ–¹æ³•æ˜¯å‘ä¸Šå–æ•´ï¼Œround()æ–¹æ³•æ˜¯å››èˆäº”å…¥ï¼‰
assert_eq!(1.2f32.max(2.2), 2,2); //æ¯”è¾ƒè¿”å›æœ€å¤§å€¼ï¼Œmin()æ–¹æ³•æ˜¯å–æœ€å°å€¼
assert_eq!(-3.7f64.trunc(), -3.0);  //åˆ é™¤å°æ•°éƒ¨åˆ†ï¼Œæ³¨æ„å’Œfloorã€ceilçš„åŒºåˆ«
assert!((-1. / std::f32::INFINITY).is_sign_negative()); //æ˜¯å¦ä¸ºè´Ÿå€¼ï¼Œæ³¨æ„-0.0ä¹Ÿç®—è´Ÿå€¼
```

### ä½è¿ç®—

| åå­— | è¿ç®—ç¬¦ | è¯´æ˜                                           | èŒƒä¾‹              |
| :--- | :----- | :--------------------------------------------- | :---------------- |
| ä½ä¸ | &      | ç›¸åŒä½éƒ½æ˜¯ 1 åˆ™è¿”å› 1 å¦åˆ™è¿”å› 0               | A & B ==`2`       |
| ä½æˆ– | \|     | ç›¸åŒä½åªè¦æœ‰ä¸€ä¸ªæ˜¯ 1 åˆ™è¿”å› 1 å¦åˆ™è¿”å› 0       | A\|B = 3          |
| å¼‚æˆ– | ^      | ç›¸åŒä½ä¸ç›¸åŒåˆ™è¿”å› 1 å¦åˆ™è¿”å› 0                | A ^ B =Â 1         |
| ä½é | !      | æŠŠä½ä¸­çš„ 1 æ¢æˆ 0 ï¼Œ 0 æ¢æˆ 1                  | (!B) ç»“æœ -4      |
| å·¦ç§» | <<     | æ“ä½œæ•°ä¸­çš„æ‰€æœ‰ä½å‘å·¦ç§»åŠ¨æŒ‡å®šä½æ•°ï¼Œå³è¾¹çš„ä½è¡¥ 0 | (A << 1) ç»“æœä¸º 4 |
| å³ç§» | >>     | æ“ä½œæ•°ä¸­çš„æ‰€æœ‰ä½å‘å³ç§»åŠ¨æŒ‡å®šä½æ•°ï¼Œå·¦è¾¹çš„ä½è¡¥ 0 | (A >> 1) ç»“æœä¸º 1 |

### byte å­—é¢é‡

- Rust æ²¡æœ‰ byte ç±»å‹ï¼Œu8 ç±»å‹ç›¸å½“äº byte ç±»å‹;
- byte å­—é¢é‡ï¼Œè¡¨ç¤º ASCII å­—ç¬¦ï¼›
- ä¹¦å†™æ–¹å¼: `b'x'`ï¼Œb è¡¨ç¤ºæ˜¯ byteï¼›

| ASCII å­—ç¬¦ | byte å­—é¢é‡çš„ä¹¦å†™ | ç›¸å½“äºçš„æ•°å€¼ |
| ---------- | ----------------- | ------------ |
| å•å¼•å· Â  ' | b'\''             | 39_u8        |
| åæ–œæ  \   | b'\\'             | 92_u8        |
| æ¢è¡Œ       | b'\n'             | 10_u8        |
| å›è½¦       | b'\r'             | 13_u8        |
| åˆ¶è¡¨ç¬¦ Tab | b'\t'             | 9_u8         |

### å­—ç¬¦(char)

- Rust çš„ char è¡¨ç¤ºä¸€ä¸ª Unicode å­—ç¬¦ï¼›
- æ¯ä¸ª char å›ºå®šä¸º 4 ä¸ª byteï¼Œ32bitï¼›
- UNICODE ç¼–ç ;
- char ä¸èƒ½å’Œä»»ä½•å…¶ä»–ç±»å‹ä¹‹é—´è¿›è¡Œéšå¼è½¬æ¢;
- ä½¿ç”¨ `as`è¿ç®—ç¬¦å°† char è½¬æ¢ä¸ºæ•´æ•°ç±»å‹ï¼›
- å¯¹äºå°äº 32 ä½çš„ç±»å‹ï¼Œå­—ç¬¦å€¼çš„é«˜ä½å°†è¢«æˆªæ–­ï¼š
- åªæœ‰ u8 èƒ½ç”¨ as è½¬æ¢ä¸º charã€‚
- å¦‚æœæƒ³ç”¨ u32 ä½è½¬æ¢ä¸º charï¼Œå¯ä»¥ç”¨ std åº“é‡Œçš„ `std::char::from_u32()`å‡½æ•°ï¼Œè¿”å›å€¼æ˜¯ `Option<char>`ç±»å‹
- char ç±»å‹çš„ä¹¦å†™æ˜¯ç”¨å•å¼•å·å¼•èµ·æ¥ï¼Œå­—ç¬¦ä¸²æ˜¯ç”¨åŒå¼•å·å¼•èµ·æ¥ï¼š
- char ç±»å‹çš„å€¼åŒ…å«èŒƒå›´ä¸º 0x0000 åˆ° 0xD7FF æˆ– 0xE000 åˆ° 0x10FFFF çš„ Unicode ç ä½ã€‚
- å¯¹äºå…¶ä»–æ•°å€¼ï¼ŒRust ä¼šè®¤ä¸ºæ˜¯æ— æ•ˆçš„ char ç±»å‹ï¼Œå‡ºç°ç¼–è¯‘å¼‚å¸¸ã€‚

```rust
assert_eq!('*' as i32, 42);    // char -> i32
assert_eq!('à² ' as u16, 0xca0);
assert_eq!('à² ' as i8, -0x60); // U+0CA0 è¢«æˆªæ–­ä¸º8ä½å¸¦ç¬¦å·æ•´å‹

//std::charæ¨¡å—ä¸­æœ‰å¾ˆå¤šæœ‰ç”¨çš„charæ–¹æ³•/å‡½æ•°ï¼š
assert_eq!('*'.is_alphabetic(), false);  //æ£€æŸ¥æ˜¯å¦æ˜¯å­—æ¯
assert_eq!('Î²'.is_alphabetic(), true);
assert_eq!('8'.to_digit(10),  Some(8));  //æ£€æŸ¥æ˜¯å¦æ•°å­—
assert_eq!('à² '.len_utf8(), 3);  //ç”¨utf-8æ ¼å¼è¡¨ç¤ºçš„è¯ï¼Œå æ®å‡ ä¸ªå­—èŠ‚
assert_eq!(std::char::from_digit(2,  10), Some('2'));  //æ•°å­—è½¬æ¢ä¸ºcharï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯è¿›åˆ¶

// char -> Integer
println!("{}", 'æˆ‘' as i32);     // 25105
println!("{}", 'æ˜¯' as u16);     // 26159
println!("{}", 'æ˜¯' as u8);      // 47ï¼Œè¢«æˆªæ–­äº†

// u8 -> char
println!("{}", 97_u8 as char);    // 'a'

// std::char
use std::char;

// digit -> char
println!("{}", char::from_u32(0x2764).unwrap());  // â¤
assert_eq!(char::from_u32(0x110000), None);  // true

println!("{}", char::from_digit(4,10).unwrap());  // '4'
println!("{}", char::from_digit(11,16).unwrap()); // 'b'
assert_eq!(char::from_digit(11,10),None); // true
```

char ç±»å‹ä¸ byte å­—é¢é‡ï¼ŒString ç±»å‹åŒºåˆ«ï¼š

- `'C'`: char ç±»å‹ï¼Œåœ¨ stack ä¸Šå¼€è¾Ÿ 4 å­—èŠ‚ç©ºé—´ï¼ŒæŠŠå­—æ¯ C çš„ Unicode ç  `0x 00 00 00 43`å­˜å…¥ï¼›
- `b'C'`ï¼šbyte å‹ï¼Œåœ¨ stack ä¸Šå¼€è¾Ÿ 1 å­—èŠ‚ç©ºé—´ï¼ŒæŠŠå­—æ¯ C çš„ ASCII ç  `0x43`å­˜å…¥ï¼›
- `"C"`ï¼šString, åœ¨ heap å†…å­˜ä¸Šå¼€è¾Ÿ N å­—èŠ‚ç©ºé—´ï¼ˆN ä¸€èˆ¬æ˜¯å­—æ¯ C çš„å­—èŠ‚æ•° 1ï¼‰ï¼Œç„¶ååœ¨ stack å†…å­˜ä¸Šå¼€è¾Ÿ 12 å­—èŠ‚ç©ºé—´ï¼ˆæ­¤å¤„ä»¥ 32 ä½å¹³å°ä¸ºä¾‹ï¼‰:
  - 4 ä¸ªå­—èŠ‚å­˜æ”¾å †å†…å­˜æ”¾ç½®æ•°æ®çš„æŒ‡é’ˆï¼Œ
  - 4 ä¸ªå­—èŠ‚å­˜æ”¾å­—ç¬¦ä¸²åœ¨å†…å­˜ä¸­å¼€è¾Ÿçš„ç©ºé—´ Nï¼›
  - 4 ä¸ªå­—èŠ‚å­˜æ”¾å­—ç¬¦ä¸²å½“å‰ä½¿ç”¨çš„ç©ºé—´ï¼›

## å¤åˆç±»å‹

å¤åˆ(compound)ç±»å‹ç”±å¤šä¸ªå€¼ç»„åˆè€Œæˆã€‚å¤åˆç±»å‹åŒ…æ‹¬ï¼š

- `Tuple`: å¤šä¸ªç±»å‹çš„å€¼ç»„åˆè¿›ä¸€ä¸ªç±»å‹;
- `Struct`:
- `Enum`: å¤šç§æ•°å€¼ä¸­çš„ä¸€ç§;
- `Union`:

### å…ƒç»„(Tuple)

å…ƒç»„æ˜¯ä¸€ä¸ªå°†å¤šä¸ªå…¶ä»–ç±»å‹çš„å€¼ç»„åˆè¿›ä¸€ä¸ªå¤åˆç±»å‹çš„ä¸»è¦æ–¹å¼ã€‚

- åŒ…å«åœ¨ `()`ä¸­çš„ `,`åˆ†éš”çš„å€¼åˆ—è¡¨ `(T1, T2, ...)`ï¼›
- å…ƒç»„é•¿åº¦å›ºå®šï¼Œé•¿åº¦ä¸ä¼šå¢å¤§æˆ–ç¼©å°ï¼›
- å…ƒç»„åˆ†é…åœ¨æ ˆç©ºé—´ï¼›

```rust
// å…ƒç»„å®šä¹‰
let tup1: (i32, f64, u8) = (500, 6.4, 1);
let tup2 = (500, 6.4, 1);
// å…ƒç»„è§£æ„
let (x, y, z) = tup1;
// ç´¢å¼•è®¿é—®
let five_hundred = tup2.0;
let six_point_four = tup2.1;
let one = tup3.2;
```

### ç»“æ„ä½“(Struct)

Rust ä¸­çš„ç»“æ„ä½“

Rust æä¾›äº† 3 ç§ç»“æ„ä½“ï¼š

- **å…·åç»“æ„ä½“**ï¼šç»“æ„ä½“çš„æ¯ä¸ªå­—æ®µæ‹¥æœ‰åç§°ï¼›
- **å…ƒç»„ç»“æ„ä½“**: ç»“æ„ä½“çš„å­—æ®µæ²¡æœ‰åç§°ï¼›
- **å•å…ƒç»“æ„ä½“**: ç»“æ„ä½“ä¸åŒ…å«ä»»ä½•å­—æ®µï¼›

```rust
struct Point {x: f32,  y: f32, }  // å…·åç»“æ„ä½“
struct Color(i32, i32, i32);  // å…ƒç»„ç»“æ„ä½“
struct Integer(u32);          // å…ƒç»„ç»“æ„ä½“åªæœ‰ä¸€ä¸ªå­—æ®µæ—¶ï¼Œç§°ä¸ºNewTypeæ¨¡å¼
struct Nil;                   // å•å…ƒç»“æ„ä½“ï¼Œæ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ä½“ã€‚å•å…ƒç»“æ„ä½“å®ä¾‹å°±æ˜¯å…¶æœ¬èº«ã€‚

// ç»“æ„ä½“å®ä¾‹åŒ–
let point: Point = Point { x: 0.3, y: 0.4 };
println!("point coordinates: ({},{})", point.x, point.y); // è®¿é—® point çš„å­—æ®µ
// letè§£ç»‘struct
let Point {x: my_x, y: my_y} = point;

// struct tuple
struct Pair(i32, f32);  //struct tuple
let pair = Pair(1, 0.1);
println!("pair contains {:?} and {:?}", pair.0, pair.1);
let Pair(integer, decimal) = pair;
println!("pair contains {:?} and {:?}", integer, decimal);
```

### æšä¸¾(Enum)

- `enum`ç”¨äºè¡¨ç¤ºå¤šç§å¯èƒ½æ•°å€¼ä¸­çš„ä¸€ç§ï¼›
- `enum`çš„å¤šä¸ªå€¼å…±ç”¨ä¸€ä¸ªå­˜å‚¨ç©ºé—´ï¼›

```rust
// ä¸å¸¦å‚æ•°æšä¸¾
enum Number {
    Zero,
    One,
}

// å¸¦å‚æ•°æšä¸¾
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}
```

### è”åˆä½“(Union)

- `union`å’Œ enums ç±»ä¼¼ï¼Œä½†æ²¡æœ‰æ ‡ç­¾ï¼›
- `union`çš„æ‰€æœ‰å­—æ®µå…±äº«åŒä¸€æ®µå­˜å‚¨;
- `union`çš„å°ºå¯¸ç”±å…¶å°ºå¯¸æœ€å¤§çš„å­—æ®µçš„å°ºå¯¸æ‰€å†³å®š;
- `union`å­—æ®µçš„è¯»å–å¿…é¡»æ”¾åœ¨éå®‰å…¨(`unsafe`)å—é‡Œ;
- `union`æ²¡æœ‰â€œæ´»è·ƒå­—æ®µ(active field)â€ã€‚æ¯æ¬¡è®¿é—®è”åˆä½“åªæ˜¯ç”¨æ‰€æŒ‡å®šçš„å­—æ®µçš„ç±»å‹è§£é‡Šæ­¤è”åˆä½“çš„å­˜å‚¨;

```rust
#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}

let u = MyUnion { f1: 1 }; //unionå®šä¹‰
unsafe { u.f1 = 5 };    //unionå†™å…¥æ˜¯ä¸å®‰å…¨çš„
let value = unsafe { u.f1 }; //uionè¯»å–æ˜¯ä¸å®‰å…¨çš„
// unionæ¨¡å¼åŒ¹é…
unsafe {
    match u {
        MyUnion { f1: 10 } => { println!("ten"); }
        MyUnion { f2 } => { println!("{}", f2); }
    }
}
```

## é›†åˆç±»å‹

é›†åˆç±»å‹ç”±å¤šä¸ªç›¸åŒç±»å‹çš„å€¼ç»„æˆï¼ŒåŒ…æ‹¬ï¼š

- **æ•°ç»„(array)**:
- **å‘é‡(vector)**ï¼š

### æ•°ç»„(Array)

åœ¨ä¸€å—è¿ç»­ç©ºé—´å†…å­˜ä¸­ï¼Œå­˜å‚¨äº†ä¸€ç³»åˆ—çš„åŒæ ·ç±»å‹çš„æ•°æ®

- æ•°ç»„çš„ç±»å‹ä¸º `[T; N]`ï¼Œ`T`è¡¨ç¤ºå…ƒç´ ç±»å‹ï¼Œ`N`ä¸ºå…ƒç´ ä¸ªæ•°;
- åªæœ‰å½“ T, N éƒ½ç›¸åŒæ—¶ï¼Œæ•°ç»„çš„ç±»å‹æ‰ç›¸åŒï¼›
- Rust æ•°ç»„å¤§å°å›ºå®šï¼Œä¸€æ—¦å£°æ˜ï¼Œå…¶é•¿åº¦ä¸ä¼šå¢å¤§æˆ–ç¼©å°ï¼›
- æ•°ç»„ä½äº `æ ˆ`ä¸Šï¼›
- array ç´¢å¼•è®¿é—®é”™è¯¯ä¼šäº§ç”Ÿ panicï¼›
- `array`åªèƒ½å‚¨å­˜ä¸€ç§ç±»å‹çš„æ•°æ®ï¼Œæ— æ³•å­˜å‚¨ä¸åŒç±»å‹çš„æ•°æ®ï¼›

```rust
// æ•°ç»„å®šä¹‰
let a: [i32; 5] = [1, 2, 3, 4, 5];
let array: [i32; 4] = [42, 10, 5, 2];
// let a = [1,"string"];   //é”™è¯¯ï¼Œæ•°ç»„å…ƒç´ ç±»å‹åº”è¯¥ç›¸åŒ
let color = ["Red", "Yellow", "Blue"];
let second = a[1];   // æ•°ç»„å…ƒç´ ç´¢å¼•è®¿é—®
let l = a.len()      // æ•°ç»„é•¿åº¦
```

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/03/30-12-57-31-2022-03-30-12-57-10-image.png)

### å‘é‡(Vector)

- `Vec`æ˜¯åŠ¨æ€æ•°ç»„ï¼Œä¼šè‡ªåŠ¨å¢é•¿ï¼Œä¸ä¼šè‡ªåŠ¨æ”¶ç¼©ï¼›
- Vector åŒ…å«ä¸¤éƒ¨åˆ†ï¼š

  - æ ˆä¸Šçš„ vector ç»“æ„ä½“ï¼š

    - æŒ‡å‘å †ä¸Šè¿ç»­ç©ºé—´çš„é¦–æŒ‡é’ˆï¼›
    - æ€»å…ƒç´ ä¸ªæ•°ï¼›
    - å·²ä½¿ç”¨å…ƒç´ ä¸ªæ•°ï¼›

  - å †ä¸Šçš„è¿ç»­åˆ†é…ç©ºé—´ï¼›

- `Vec<T>`ä¸­çš„æ³›å‹ `T` å¿…é¡»æ˜¯ `Sized`çš„ï¼›
- vector æŠŠæ‰€æœ‰çš„å…ƒç´ æ”¾åœ¨ä¸€ä¸ªåˆ†é…åœ¨å †ï¼ˆheapï¼‰ä¸Šçš„ array ä¸Šã€‚å½“ä¸€ä¸ªæ–°å…ƒç´ è¢« push è¿›æ¥æ—¶ï¼Œvector æ£€æŸ¥ array æ˜¯å¦æœ‰è¶³å¤Ÿçš„å‰©ä½™ç©ºé—´ã€‚å¦‚æœç©ºé—´ä¸è¶³ï¼Œvector å°±åˆ†é…ä¸€ä¸ªæ›´å¤§çš„ arrayï¼Œå°†æ‰€æœ‰çš„å…ƒç´ éƒ½æ‹·è´åˆ°è¿™ä¸ªæ–°çš„ array ä¸­ï¼Œç„¶åé‡Šæ”¾æ—§çš„ array

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/03/30-12-55-30-2022-03-30-12-55-23-image.png)

```rust
// vectoråˆå§‹åŒ–
let v1: Vec<i32> = Vec::new();        //Vec::new()
let v2 = vec![1,2,3];                 //[1,2,3]
let v21 = vec![false; 4];                 //[3,3, 3, 3]
let v3: Vec<_> = (1..5).collect();    //[1,2,3,4]
let v4 = Vec::with_capacity(5);       //é¢„ç•™ç©ºé—´åˆå§‹åŒ–

// vectorå…ƒç´ è®¿é—®
let third: &i32 = &v[2];                //[]è¿ç®—ç¬¦
let third: Option<&i32> = v.get(2);     //get()æ–¹æ³•

// éå†
for i in &v { .. } // è·å¾—å¼•ç”¨
for i in &mut v { .. } // è·å¾—å¯å˜å¼•ç”¨
for i in v { .. } // è·å¾—æ‰€æœ‰æƒï¼Œæ³¨æ„æ­¤æ—¶Vecçš„å±ä¸»å°†ä¼šè¢«è½¬ç§»ï¼ï¼
// è¿­ä»£å™¨
for x in xs.iter() {
        println!("> {}", x);
}
// å†…ç½®æ–¹æ³•
let mut v = vec![11,22];
v.len();                         //vé•¿åº¦(å…ƒç´ æ•°é‡)
v.is_empty();                    //vecæ˜¯å¦ä¸ºç©º
v.get(1);                        //get
v.iter();                        //iterator
v.push(33);                      //åœ¨å°¾éƒ¨æ’å…¥å…ƒç´ 33
v.resize(10, 0);                 //
v.insert(0, 111);                //åœ¨ç´¢å¼•0å¤„æ’å…¥111
v.remove(1);                     //åˆ é™¤iå…ƒç´ å¹¶è¿”å›è¢«åˆ é™¤çš„å…ƒç´ ï¼Œç´¢å¼•è¶Šç•Œå°†panicæŠ¥é”™é€€å‡º
v.pop();                         //åˆ é™¤å¹¶è¿”å›vecå°¾éƒ¨çš„å…ƒç´ ï¼Œvecä¸ºç©ºåˆ™è¿”å›None
v.append(vec![3, 4]);            //å°†å¦ä¸€ä¸ªvecä¸­çš„æ‰€æœ‰å…ƒç´ è¿½åŠ ç§»å…¥vecä¸­ï¼Œç§»åŠ¨åå¦ä¸€ä¸ªvecå˜ä¸ºç©ºvec
v.truncate(2);                    //å°†vecæˆªæ–­2ï¼Œå¤šä½™çš„å…ƒç´ è¢«åˆ é™¤
v.retain(|x| *x > 20);            //ä¿ç•™æ»¡è¶³æ¡ä»¶çš„
v.drain(1..=3);                   //åˆ é™¤æŒ‡å®šèŒƒå›´çš„å…ƒç´ ï¼ŒåŒæ—¶è¿”å›è¯¥èŒƒå›´æ‰€æœ‰å…ƒç´ çš„è¿­ä»£å™¨
v.split_off(2);                   //ä»index 2å¤„åˆ†è£‚ä¸ºä¸¤ä¸ªvec
v.clear();                        //æ¸…ç©ºvec
```

### åˆ‡ç‰‡(Slice)

- åˆ‡ç‰‡(slice)æ˜¯å¯¹æ•°ç»„(array)æˆ– vector çš„ä¸€ä¸ªä¸´æ—¶è§†å›¾;
- slice æ˜¯åŠ¨æ€å¤§å°ç±»å‹ï¼Œæ— æ³•ç›´æ¥è¢«ä½¿ç”¨ï¼Œåªèƒ½é€šè¿‡å¼•ç”¨å½¢å¼æ¥è®¿é—®ï¼›
- slice å½¢å¼ï¼š`[T]`ï¼›
- Slice ç»§æ‰¿äº† Array çš„ lengthã€item ç­‰å¾ˆå¤šçš„æ–¹æ³•ï¼›
- slice åŒ…å« 2 ä¸ªå­—æ®µï¼š

  - æŒ‡å‘ slice èµ·å§‹å…ƒç´ çš„å¤´æŒ‡é’ˆï¼›
  - slice ä¸­å…ƒç´ çš„ä¸ªæ•°ï¼›

```rust
let v = [1, 2, 3, 4];  //å®šä¹‰ä¸€ä¸ªæ•°ç»„ï¼›
let s1 = &v[..];       //è·å–æ•°ç»„çš„åˆ‡ç‰‡å¼•ç”¨ï¼›
let s = &v[1..3];      //è·å–æ•°ç»„åˆ‡ç‰‡[2,3];
```

### èŒƒå›´(Range)

- Range æ˜¯ Rust å†…ç½®çš„ç”¨äºè¡¨ç¤ºä¸€ä¸ªèŒƒå›´çš„æ•°æ®ç±»å‹ï¼›
- Range æ•°æ®ç±»å‹ä½äº `std::ops::RangeXXX`å†…ï¼›
- æ¯ä¸ªèŒƒå›´éƒ½æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¯ç”¨ for å¾ªç¯æ‰“å°èŒƒå›´å†…çš„å…ƒç´ ï¼›

Rust æ”¯æŒèŒƒå›´æ“ä½œç¬¦ï¼Œæœ‰ä»¥ä¸‹å‡ ç§è¡¨ç¤ºèŒƒå›´çš„æ“ä½œç¬¦ï¼š

| èŒƒå›´è¡¨è¾¾å¼  | ç±»å‹                       | è¡¨ç¤ºçš„èŒƒå›´      |
| ----------- | -------------------------- | --------------- |
| start..end  | std::ops::Range            | start â‰¤ x < end |
| start..     | std::ops::RangeFrom        | start â‰¤ x       |
| ..end       | std::ops::RangeTo          | x < end         |
| ..          | std::ops::RangeFull        | -               |
| start..=end | std::ops::RangeInclusive   | start â‰¤ x â‰¤ end |
| ..=end      | std::ops::RangeToInclusive | x â‰¤ end         |

```rust
// rangeç»“æ„ä½“å®šä¹‰
pub struct Range<Idx> {
    pub start: Idx,
    pub end: Idx,
}

// rangeçš„ä½¿ç”¨
use std::ops::{Range, RangeInclusive};

assert_eq!((1..5), Range{ start: 1, end: 5 });
// (1..=5)æ˜¯ç»“æ„ä½“std::ops::RangeInclusiveçš„ä¸€ä¸ªå®ä¾‹
assert_eq!((1..=5), RangeInclusive::new(1, 5));
// è‡ªå¸¦çš„ sum æ–¹æ³•ç”¨äºæ±‚å’Œ
assert_eq!(3+4+5, (3..6).sum());
assert_eq!(3+4+5+6, (3..=6).sum());
(3..6)

// æ¯ä¸ªèŒƒå›´éƒ½æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¯ç”¨for å¾ªç¯æ‰“å°èŒƒå›´å†…çš„å…ƒç´ 
for i in (1..5) {
    println!("{}", i);
}
for i in (1..=5) {
    println!("{}", i);
}
// é€†åº
for i in (1..=5).rev() {
    println!("{}", i);
}

// èŒƒå›´æ“ä½œ
let arr = [11, 22, 33, 44, 55];
let s1 = &arr[0..3];    // [11,22,33]
let s2 = &arr[1..=3];   // [22, 33, 44]
let s3 = &arr[..];      // [11, 22, 33, 44, 55]
```

## å¸¸ç”¨æ•°æ®ç±»å‹

### å­—ç¬¦ä¸²

Rust ä¸­çš„å­—ç¬¦ä¸²åŒ…æ‹¬ä¸¤ç§ï¼š`str`å’Œ `String`ã€‚

#### str(å­—ç¬¦ä¸²å­—é¢é‡)

- `str`ç”±æ ¸å¿ƒè¯­è¨€æä¾› `core::str`ï¼›
- å¸¸ä»¥å¼•ç”¨çš„å½¢å¼å‡ºç°â€”â€”`&str`ï¼›
- é™æ€ä¸å¯å˜ï¼›
- æ”¯æŒè½¬ä¹‰ï¼›
- æ”¯æŒåˆ‡ç‰‡æ“ä½œï¼›
- `&str`æœ‰ä¸¤ç§äº§ç”Ÿæ–¹å¼ï¼š

  - å­—ç¬¦ä¸²å­—é¢é‡ï¼š`&str`å†…å­˜ä½äºç¨‹åºçš„é¢„åˆ†é…æ–‡æœ¬åŒºï¼Œè¯¥åŒºåŸŸä¸ºåªè¯»åŒºåŸŸï¼›
  - å­—ç¬¦ä¸²å¼•ç”¨ï¼šä¸ºä¸€ä¸ª `String`çš„åˆ‡ç‰‡å¼•ç”¨ï¼ŒåŸ `String`å­—ç¬¦ä½äºå †ä¸Šï¼›

```rust
//å®šä¹‰
let x = "Hello";                // å­—ç¬¦ä¸²å­—é¢é‡
let x: &'static str = "Hello";  //å®Œæ•´å½¢å¼
//è½¬ä¹‰
let z = "foo
         bar";
let w = "foo\n      bar";
assert_eq!(z, w);
```

#### String(å­—ç¬¦ä¸²)

- `String` ç”±æ ‡å‡†åº“æä¾›çš„ `std::String`ï¼›
- ä½äºå †(heap)ä¸Šåˆ†é…å†…å­˜ï¼›
- å¯å¢é•¿çš„ã€å¯å˜çš„ã€æœ‰æ‰€æœ‰æƒï¼›
- `String` å’Œ `&str` éƒ½æ˜¯ UTF-8 ç¼–ç çš„ï¼›
- `String` -> `&str`éå¸¸è½»æ¾ï¼Œå‡ ä¹æ²¡æœ‰å¼€é”€ï¼›
- `&str` -> `String`æ˜¯éœ€è¦åœ¨å †ä¸Šè¯·æ±‚å†…å­˜çš„ï¼›
- `String`ä¸æ”¯æŒé€šè¿‡ä¸‹æ ‡è®¿é—®ï¼Œå¯è½¬æ¢ä¸º `&str`è¿›è¡Œï¼›

* ä¸æ˜¯ char æ•°ç»„, è€Œæ˜¯ UTF-8**å˜é•¿**åºåˆ—ï¼›
* ASCII å­—ç¬¦å ä¸€ä¸ªå­—èŠ‚ byte, å…¶ä½™å­—ç¬¦å å¤šä¸ªä¸å®šé•¿å­—èŠ‚.
* `len()`æ–¹æ³•è¿”å›çš„æ˜¯å­—èŠ‚(byte)é•¿åº¦, è€Œéå­—ç¬¦(char)é•¿åº¦
* `chars().count()`è¿”å›å­—ç¬¦(char)é•¿åº¦
* ä¸€ä¸ªæ ˆä¸Šçš„ String å˜é‡åœ¨å†…å­˜ä¸­è¡¨ç¤ºå¦‚ä¸‹:

```rust
//æ–°å»ºString
let s1 = String::new();                 //new: åˆ›å»ºç©ºå­—ç¬¦ä¸²
//&str -> String
let s2 = "string".to_string()            //to_string: åˆ›å»ºéç©ºå­—ç¬¦ä¸²
let s3 = String::from("string2")         //from: åˆ›å»ºéç©ºå­—ç¬¦ä¸²
let mut s4 = String::from("foo");
let s5 = String::from("bar");
//raw string
let raw_str = r"Escapes don't work here: \x3F \u{211D}";
assert_eq!(raw_str, "Escapes don't work here: ? â„");
let quotes = r#"And then I said: "There is no escape!""#;
println!("{}", quotes);
// å¦‚æœå¸Œæœ›åœ¨å­—ç¬¦ä¸²ä¸­ä½¿ç”¨ # å·ï¼Œå¯ä»¥å¦‚ä¸‹ä½¿ç”¨ï¼š
let  delimiter = r###"A string with "# in it. And even "##!"###;
println!("{}", delimiter);
// String -> &str
let str1: &str = s2.as_str();        //
let str2 = &*s2; //String å®ç°impl Deref<Target=str> for String
let str2 = &s2;  //string -> &str
//æ›´æ–°å­—ç¬¦ä¸²
s4.push_str("bar");                   //push_str: æ·»åŠ å­—ç¬¦ä¸²
s4.push_str(&s2)                      // è¿™é‡Œæ˜¯&s2 è€Œä¸æ˜¯s2
s4.push('l')                          //push: æ·»åŠ å­—ç¬¦
//è¿æ¥å­—ç¬¦ä¸²
// let s3 = s1 + "wold";
let s3 = s1 + &s2;   //s1 è¢«ç§»åŠ¨äº†ï¼Œä¸èƒ½ç»§ç»­ä½¿ç”¨
//æ ¼å¼åŒ–å­—ç¬¦ä¸²
let s = format!("{}-{}-{}", s1, s2, s3);  //format!å®ä¸ä¼šè·å–å‚æ•°çš„æ‰€æœ‰æƒ

// Vec<char> -> String
let s4 = String::from_iter(vec!['a', 'b', 'c'].iter()); //s4 = "abc"

// å­—ç¬¦ä¸²slice
let mut s1 = String::from("hello");   //&str -> String
let s2 = "wold";
println!("{}", &s1[..1], &s2[1..2]); // ä¸è¦å¿˜äº† & ç¬¦å·

// string -> &[u8]
let u8_bytes = s1.as_bytes();   // &[104, 101, 108, 108, 111],
let chars = s2.chars();     //Chars

s1.chars().nth(2)  // ç¬¬2ä¸ªå­—ç¬¦
// éå†å­—ç¬¦
for c in "abcd".chars() {
    println!("{}", c); // a,b,c,d
}
// éå†byte
for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {
    println!("{}", b); // 224 164 168 224 ...
}
// æ’å…¥
s1.insert(5, ',');   //æ’å…¥å­—ç¬¦
s1.insert_str(6, " I like");  //æ’å…¥å­—ç¬¦ä¸²å­—é¢é‡
// æ›¿æ¢
s1.replace("rust", "RUST");       //æ›¿æ¢æ‰€æœ‰å­ä¸²ï¼Œè¿”å›æ›¿æ¢åçš„æ–°å­—ç¬¦ä¸²
s1.replacen("rust", "RUST", 1);   //æ›¿æ¢1ä¸ªå­ä¸²ï¼Œè¿”å›æ›¿æ¢åçš„æ–°å­—ç¬¦ä¸²
s1.replace_range(7..8, "R");
// åˆ é™¤
s1.pop();         //åˆ é™¤s1å°¾éƒ¨å­—ç¬¦ï¼›
s1.remove(0);     //åˆ é™¤s1ç¬¬0ä¸ªå­—èŠ‚çš„å­—ç¬¦, å¦‚æœå‚æ•°ä¸åœ¨å­—ç¬¦çš„å­—èŠ‚è¾¹ç•Œï¼Œåˆ™å‘ç”Ÿé”™è¯¯ï¼›
// æˆªæ–­
s1.truncate(3);   //æˆªæ–­s1ä»ç¬¬3ä¸ªå­—èŠ‚å¼€å§‹åˆ°æœ€åçš„æ‰€æœ‰å­—ç¬¦ï¼›
s1.clear();       //æ¸…ç©ºå­—ç¬¦ä¸²æ‰€æœ‰å­—ç¬¦ï¼›
// è¿æ¥
let s2 = s1 + "abc";  //è¿æ¥å­—ç¬¦ä¸²å­—é¢é‡ï¼›
s1 += "cdf";   //s1ä¸ºmut

//å­—ç¬¦ä¸²åˆ‡ç‰‡
let s = String::from("Hello word");
let hello = &s[0..5];       // hello: &str
let word = &s[6..11];       // word: &str

//
use utf8_slice;
let s = "The ğŸš€ goes to the ğŸŒ‘!";
let rocket = utf8_slice::slice(s, 4, 5);  // ç»“æœæ˜¯ "ğŸš€"
```

### å“ˆå¸Œè¡¨(HashMap)

- æ‰€æœ‰å®ç°äº† `Eq`å’Œ `Hash`çš„ç±»å‹éƒ½å¯ä»¥ä½œä¸º HashMap çš„ keyï¼›
- é€šè¿‡ `#[derive(PartialEq, Eq,hash)]`å¯ä»¥å¿«é€Ÿçš„å®ç° `Eq`å’Œ `Hash`ã€‚

```rust
//å¼•å…¥hashmapåŒ…
use std::collections::HashMap

//new
let mut scores = HashMap::new();        //new
let solar_distance = HashMap::from([    //from
    ("Mercury", 0.4),
    ("Venus", 0.7),
    ("Earth", 1.0),
    ("Mars", 1.5),
]);

scores.insert(String::form("Blue"), 10);    //insert
scores.insert(String::from("Yellow"), 50);

let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];
let scores: HashMap<_,_> = teams.iter().zip(initial_scores.iter()).collect();

let score = scores.get(String::form("Blue")); //get

//éå†
for (key, value) in &scores {
  println!("{}: {}", key, value);
}

// entry
// or_insert æ–¹æ³•ä¼šè¿”å›è¿™ä¸ªé”®çš„å€¼çš„ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼ˆ&mut Vï¼‰
scores.entry(String::from("Yellow")).or_insert(50); //å¦‚æœå­˜åœ¨å°±å¿½ç•¥ï¼Œå¦‚æœä¸å­˜åœ¨å°±æ’å…¥
scores2.entry(String::from("Yellow")).or_default().push(50);  //string->vec<i32> æ’å…¥
```

- Rust ä¸­çš„ HashSet å®ç°éå¸¸ç®€å•å°±æ˜¯ `HashMap<T,()>`ï¼›

```rust
use std::collections::HashSet;
// Type inference lets us omit an explicit type signature (which
// would be `HashSet<String>` in this example).
let mut books = HashSet::new();

// Add some books.
books.insert("A Dance With Dragons".to_string());
books.insert("To Kill a Mockingbird".to_string());
books.insert("The Odyssey".to_string());
books.insert("The Great Gatsby".to_string());

// Check for a specific one.
if !books.contains("The Winds of Winter") {
    println!("We have {} books, but The Winds of Winter ain't one.",
             books.len());
}

// Remove a book.
books.remove("The Odyssey");

// Iterate over everything.
for book in &books {
    println!("{book}");
}
```

### æœ‰åºæ˜ å°„(BTreeMap)

- æœ‰åºæ˜ å°„ä¸ hashmap åŒºåˆ«åœ¨äºå…¶ key æœ‰åº;
- é€šè¿‡è¿­ä»£å™¨å¯æŒ‰ key é¡ºåºè®¿é—® BtreeMap ä¸­çš„æ‰€æœ‰å…ƒç´ ;

### æœ‰åºé›†åˆ(BTreeSet)

- BTreeSet ä¸ºæœ‰åºé›†åˆ, å’Œ hashset åŒºåˆ«åœ¨äºé›†åˆä¸­çš„å…ƒç´ ä¸ºæœ‰åºé›†;
-

```rust
use std::collections::BTreeSet;

// ç±»å‹æ¨æ–­å…è®¸æˆ‘ä»¬çœç•¥æ˜¾å¼ç±»å‹ç­¾åï¼ˆå®ƒ
// åœ¨è¿™ä¸ªä¾‹å­ä¸­å°†æ˜¯ `BTreeSet<&str>`ï¼‰ã€‚
let mut books = BTreeSet::new();

// æ·»åŠ ä¸€äº›ä¹¦ç±ã€‚
books.insert("A Dance With Dragons");
books.insert("To Kill a Mockingbird");
books.insert("The Odyssey");
books.insert("The Great Gatsby");

// æ£€æŸ¥ä¸€ä¸ªç‰¹å®šçš„ã€‚
if !books.contains("The Winds of Winter") {
    println!("We have {} books, but The Winds of Winter ain't one.",
             books.len());
}
books.remove("The Odyssey");  // åˆ é™¤ä¸€æœ¬ä¹¦ã€‚

// éå†æ‰€æœ‰å†…å®¹ã€‚
for book in &books {
    println!("{book}");
}
```

### åŒç«¯é˜Ÿåˆ—(VecDeque)

- åŸºäºå¯æ‰©å¼ çš„ç¯å½¢ç¼“å†²åŒç«¯é˜Ÿåˆ—ï¼›

### äºŒå‰å †/ä¼˜å…ˆé˜Ÿåˆ—(BinaryHeap)

- BinaryHeap æ˜¯ rust ä¸­çš„;
- BinaryHeap é»˜è®¤ä¸ºå¤§ç«¯å †, å³æœ€å¤§å€¼åœ¨å †é¡¶, é€šè¿‡ä½¿ç”¨ `Reverse`å¾—åˆ°å°ç«¯å †;
-

```rust
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::new();
let heap2 = BinaryHeap::from([1, 5, 2]);  //

assert_eq!(heap.peek(), None);
heap.push(93);
heap.push(80);
heap.push(48);
assert_eq!(heap.peek(), Some(&93));

use std::cmp::Reverse;

let mut heap = BinaryHeap::new();

// åœ¨ `Reverse` ä¸­åŒ…è£…å€¼
heap.push(Reverse(1));
heap.push(Reverse(5));
heap.push(Reverse(2));

// å¦‚æœæˆ‘ä»¬ç°åœ¨å¼¹å‡ºè¿™äº›åˆ†æ•°ï¼Œå®ƒä»¬åº”è¯¥ä»¥ç›¸åçš„é¡ºåºè¿”å›ã€‚
assert_eq!(heap.pop(), Some(Reverse(1)));
assert_eq!(heap.pop(), Some(Reverse(2)));
assert_eq!(heap.pop(), Some(Reverse(5)));
assert_eq!(heap.pop(), None);

```

## å‚è€ƒ

1. https://www.codemore.top/p/ce5ae822-e775-351d-830c-994110faf023/
2. https://unpluggedcoder.me/2019/08/15/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BOwnership/
3. [Rust ä¹‹è·¯ï¼ˆ2ï¼‰â€”â€”æ•°æ®ç±»å‹ ä¸Šç¯‡ - sumyuan - åšå®¢å›­](https://www.cnblogs.com/sumyuan/p/13787094.html)
4. https://doc.rust-lang.org/std/collections/struct.VecDeque.html
5. https://rustwiki.org/zh-CN/edition-guide/rust-2018/data-types/union-for-an-unsafe-form-of-enum.html
6. https://rustwiki.org/zh-CN/std/collections/binary_heap/struct.BinaryHeap.html
