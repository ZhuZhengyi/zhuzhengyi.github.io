# ASM汇编语言基础

## 简介

汇编语言是

## CPU架构

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2023/03/01-20-21-18-2023-03-01-20-21-04-image.png)

## 寄存器

8086寄存器

* 8个8位通用寄存器：AL,AH,BL,BH,CL,CH,DL,DH

* 8个16位通用寄存器：AX,BX,CX,DX,SI,DI,BP,SP

* 8个32位通用寄存器：EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2023/03/01-16-37-36-2023-03-01-16-37-22-image.png)

> 1）指针寄存器（SP,ESP,BP,EBP）  
> SP,ESP为堆栈指针寄存器，存放当前堆栈段栈顶的偏移地址，  
> 是根据指令自动移动的，要想随机读取  
> 
> 堆栈段中的数据，必须通过BP或EBP基址指针寄存器来读取。  
> 2）控制寄存器（IP,EIP,FLAGS,EFLAGS）  
> IP,EIP为指令指针寄存器，用于存放当前正在执行的指令的  
> 下一条指令的偏移地址，该寄存器所指的为代码段的偏移地址。  
> FLAGS为标识寄存器，表示程序运行时的状态和一些特殊控制

3）段寄存器

代码和数据是分开存放，代码存放在代码段，数据存放在数据段

## Intel 和 AT&T 汇编语言区别

```asm
OP-code dst src //Intel语法
Op-code src dst //AT&T语法
```

| Intel Code               | AT&T Code                      |
| ------------------------ | ------------------------------ |
| mov eax,1                | movl $1,%eax                   |
| mov ebx,0ffh             | movl $0xff,%ebx                |
| int 80h                  | int $0x80                      |
| mov ebx, eax             | movl %eax, %ebx                |
| mov eax,[ecx]            | movl (%ecx),%eax               |
| mov eax,[ebx+3]          | movl 3(%ebx),%eax              |
| mov eax,[ebx+20h]        | movl 0x20(%ebx),%eax           |
| add eax,[ebx+ecx*2h]     | addl (%ebx,%ecx,0x2),%eax      |
| lea eax,[ebx+ecx]        | leal (%ebx,%ecx),%eax          |
| sub eax,[ebx+ecx*4h-20h] | subl -0x20(%ebx,%ecx,0x4),%eax |

## 常用汇编指令

### 通用数据传送指令

```
MOV     传送字或字节.  
MOVSX   先符号扩展,再传送.  
MOVZX   先零扩展,再传送.  
PUSH    把字压入堆栈.  
POP     把字弹出堆栈.  
PUSHA   把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.  
POPA    把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.  
PUSHAD  把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.  
POPAD   把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.  
BSWAP   交换32位寄存器里字节的顺序  
XCHG    交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数)  
CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX)  
XADD    先交换再累加.(结果在第一个操作数里)  
XLAT    字节查表转换.----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.([BX+AL]->AL)  
```

### 输入输出端口传送指令

```
IN      I/O端口输入. ( 语法: IN   累加器,    {端口号│DX} )  
OUT     I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )输入输出端口由立即方式指定时,    其范围是 0-255; 由寄存器 DX 指定时,其范围是    0-65535.  
```

### 目的地址传送指令

```
LEA     装入有效地址.例: LEA DX,string ;把偏移地址存到DX.  
LDS     传送目标指针,把指针内容装入DS.例: LDS SI,string   ;把段地址:偏移地址存到DS:SI.  
LES     传送目标指针,把指针内容装入ES.例: LES DI,string   ;把段地址:偏移地址存到ES:DI.  
LFS     传送目标指针,把指针内容装入FS.例: LFS DI,string   ;把段地址:偏移地址存到FS:DI.  
LGS     传送目标指针,把指针内容装入GS.例: LGS DI,string   ;把段地址:偏移地址存到GS:DI.  
LSS     传送目标指针,把指针内容装入SS.例: LSS DI,string   ;把段地址:偏移地址存到SS:DI.  
```

### 标志传送指令

```
LAHF    标志寄存器传送,把标志装入AH.  
SAHF    标志寄存器传送,把AH内容装入标志寄存器.  
PUSHF   标志入栈.  
POPF    标志出栈.  
PUSHD   32位标志入栈.  
POPD    32位标志出栈.  
```

## EFLAGS寄存器

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200726180558668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlbGxfbWVfNDA0,size_16,color_FFFFFF,t_70)  

* CF：进位位，如果运算结果的最高位产生一个进位或错位，则CF置1，否则CF清零。

* PF：奇偶位。如果运算结果低8位中“1”的个数为偶数时，则PF置1。否则PF清0。

* AF：辅助进位位。反应运算结果低四位产生进位或错位的情况。

* ZF：零值位。如果运算结果为零则ZF置1。否则清零。

**SF：符号位。**

如果运算结果为负，即一个数的最高位为1，则SF置1，否则SF清零。

**OF：溢出位。**  
如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。

## JCC

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200726181619798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlbGxfbWVfNDA0,size_16,color_FFFFFF,t_70)

## 堆栈图

### C语言程序的堆栈图

```c
#include<stdio.h>
int function(int x ,int y,int z) 
{
    return x+y-z;
}

int main()
{
    function(2,3,4);  //仅仅调用此函数而已
}
```

堆栈图如下（过程）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200726183129316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlbGxfbWVfNDA0,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200726183221566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlbGxfbWVfNDA0,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200726183326281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlbGxfbWVfNDA0,size_16,color_FFFFFF,t_70)

```
不同的编译器生成的堆栈图可能不同，要视情况而定
```

## 汇编中的函数

### 汇编中的函数

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200726184925811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlbGxfbWVfNDA0,size_16,color_FFFFFF,t_70)

### 函数的入口

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200726185044361.png)

### 函数的出口

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020072618511318.png)

## 参考

1. [GCC内联汇编基础 - 简书](https://www.jianshu.com/p/1782e14a0766)

2. http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html

3. https://zhuanlan.zhihu.com/p/27339191

4. https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-02-arch.html
