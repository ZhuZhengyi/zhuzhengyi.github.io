<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.88.1"><meta name=theme-color content="#eee"><meta name=color-scheme content="light dark"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=referrer content="no-referrer"><title>内存分配器设计 | Justice's Site</title><link rel=stylesheet href=/css/meme.min.9817bc2927846b0050dc426a67aa17fa82ec82b87efb1fbf54d04e1c5d660ff1.css><script src=/js/meme.min.a47e8b4e30b64bdbf742f15475cc3b6a642c07cbb9b9557e194a898081a8a42d.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Justice"><meta name=description content="这篇文章介绍了如何从头开始实现堆分配器。它提出并讨论了不同的分配器设计，包括Bump分配，基于链表的分配和固定大小的块分配。 对于这三种设计中的每一种，我们将创建一个可用于我们的内核的基本实现。"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Justice's Site"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Justice's Site"><meta name=msapplication-starturl content="../../../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2020-01-22T18:31:30+00:00","dateModified":"2025-01-26T10:18:55+00:00","url":"https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/","headline":"内存分配器设计","description":"这篇文章介绍了如何从头开始实现堆分配器。它提出并讨论了不同的分配器设计，包括Bump分配，基于链表的分配和固定大小的块分配。 对于这三种设计中的每一种，我们将创建一个可用于我们的内核的基本实现。","inLanguage":"zh-cn","articleSection":"post","wordCount":18470,"image":["https://os.phil-opp.com/allocator-designs/bump-allocation.svg","https://os.phil-opp.com/allocator-designs/allocation-fragmentation.svg","https://os.phil-opp.com/allocator-designs/linked-list-allocation.svg","https://os.phil-opp.com/allocator-designs/linked-list-allocator-push.svg","https://os.phil-opp.com/allocator-designs/linked-list-allocator-remove-region.svg","https://os.phil-opp.com/allocator-designs/linked-list-allocator-fragmentation-on-dealloc.svg","https://os.phil-opp.com/allocator-designs/linked-list-allocator-merge-on-dealloc.svg","https://os.phil-opp.com/allocator-designs/fixed-size-block-example.svg"],"author":{"@type":"Person","description":"Viva La Vida","email":"justice_103@126.com","image":"https://justice.bj.cn/icons/apple-touch-icon.png","url":"https://io-oi.me/","name":"Justice"},"license":"[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)","publisher":{"@type":"Organization","name":"Justice's Site","logo":{"@type":"ImageObject","url":"https://justice.bj.cn/icons/apple-touch-icon.png"},"url":"https://justice.bj.cn"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://justice.bj.cn"}}</script><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@reuixiy"><meta name=twitter:creator content="@reuixiy"><meta property="og:title" content="内存分配器设计"><meta property="og:description" content="这篇文章介绍了如何从头开始实现堆分配器。它提出并讨论了不同的分配器设计，包括Bump分配，基于链表的分配和固定大小的块分配。 对于这三种设计中的每一种，我们将创建一个可用于我们的内核的基本实现。"><meta property="og:url" content="https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/"><meta property="og:site_name" content="Justice's Site"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://os.phil-opp.com/allocator-designs/bump-allocation.svg"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-01-22T18:31:30+00:00"><meta property="article:modified_time" content="2025-01-26T10:18:55+00:00"><meta property="article:section" content="post"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Justice's Site</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=/><span class=menu-item-name>主页</span></a></li><li class=menu-item><a href=/post/><span class=menu-item-name>点滴</span></a></li><li class=menu-item><a href=/tags/><span class=menu-item-name>标签</span></a></li><li class=menu-item><a href=/categories/><span class=menu-item-name>分类</span></a></li><li class=menu-item><a href=/about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a href=http://passer-by.com/pacman/><span class=menu-item-name>更多</span></a></li><li class=menu-item><a id=theme-switcher href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-light"><path d="M193.2 104.5 242 7a18 18 0 0128 0l48.8 97.5L422.2 70A18 18 0 01442 89.8l-34.5 103.4L505 242a18 18 0 010 28l-97.5 48.8L442 422.2A18 18 0 01422.2 442l-103.4-34.5L270 505a18 18 0 01-28 0l-48.8-97.5L89.8 442A18 18 0 0170 422.2l34.5-103.4-97.5-48.8a18 18 0 010-28l97.5-48.8L70 89.8A18 18 0 0189.8 70zM256 128a128 128 0 10.01.0M256 160a96 96 0 10.01.0"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-dark"><path d="M27 412A256 256 0 10181 5a11.5 11.5.0 00-5 20A201.5 201.5.0 0142 399a11.5 11.5.0 00-15 13"/></svg></a></li><a id=search-btn href=# class="menu-item search-item" data-target=search-modal><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="16" width="16" class="search-icon" data-type="search"><path fill="currentcolor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg></a><li class=menu-item><a href=/about/><span class=menu-item-name>关于</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=justify data-type=post data-toc-num=true><h1 class="post-title p-name">内存分配器设计</h1><div class=post-meta><time datetime=2020-01-22T18:31:30+00:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2020.1.22</time>
<time datetime=2025-01-26T10:18:55+00:00 class="post-meta-item modified dt-updated"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M4e2 64h-48V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H160V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H48C21.49 64 0 85.49.0 112v352c0 26.51 21.49 48 48 48h352c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 4e2H54a6 6 0 01-6-6V160h352v298a6 6 0 01-6 6zm-52.849-200.65L198.842 404.519c-4.705 4.667-12.303 4.637-16.971-.068l-75.091-75.699c-4.667-4.705-4.637-12.303.068-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l44.104 44.461 111.072-110.181c4.705-4.667 12.303-4.637 16.971.068l22.536 22.718c4.667 4.705 4.636 12.303-.069 16.97z"/></svg>&nbsp;2025.1.26</time>
<span class="post-meta-item category"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M464 128H272l-54.63-54.63c-6-6-14.14-9.37-22.63-9.37H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V176c0-26.51-21.49-48-48-48zm0 272H48V112h140.12l54.63 54.63c6 6 14.14 9.37 22.63 9.37H464v224z"/></svg>&nbsp;<a href=/post/ class="category-link p-category">滴水穿石</a></span>
<span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3.0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9.0l60.1 60.1c18.8 18.7 18.8 49.1.0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3.0-17l-111-111c-4.8-4.7-12.4-4.7-17.1.0zM124.1 339.9c-5.5-5.5-5.5-14.3.0-19.8l154-154c5.5-5.5 14.3-5.5 19.8.0s5.5 14.3.0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8.0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;18470</span>
<span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5.0-2e2-89.5-2e2-2e2S145.5 56 256 56s2e2 89.5 2e2 2e2-89.5 2e2-2e2 2e2zm61.8-104.4-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6.0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;37&nbsp;分钟</span>
<span class="post-meta-item busuanzi-page-pv" id=busuanzi_container_page_pv><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="icon post-meta-icon"><path d="M288 144a110.94 110.94.0 00-31.24 5 55.4 55.4.0 017.24 27 56 56 0 01-56 56 55.4 55.4.0 01-27-7.24A111.71 111.71.0 10288 144zm284.52 97.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35.0 000 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35.0 000-29.19zM288 4e2c-98.65.0-189.09-55-237.93-144C98.91 167 189.34 112 288 112s189.09 55 237.93 144C477.1 345 386.66 4e2 288 4e2z"/></svg>&nbsp;<span id=busuanzi_value_page_pv></span></span></div><nav class=contents><h2 id=contents class=contents-title>目录</h2><ol class=toc><li><a id=contents:介绍 href=#介绍>介绍</a><ol><li><a id=contents:设计目标 href=#设计目标>设计目标</a></li></ol></li><li><a id=contents:bump分配器 href=#bump分配器>Bump分配器</a><ol><li><a id=contents:基本想法 href=#基本想法>基本想法</a></li><li><a id=contents:实现 href=#实现>实现</a></li><li><a id=contents:实现globalalloc href=#实现globalalloc>实现<code>GlobalAlloc</code></a><ol><li><a id=contents:首次尝试实现 href=#首次尝试实现>首次尝试实现</a></li><li><a id=contents:globalalloc和可变性 href=#globalalloc和可变性><code>GlobalAlloc</code>和可变性</a></li><li><a id=contents:locked包装类型 href=#locked包装类型><code>Locked</code>包装类型</a></li><li><a id=contents:lockedbumpallocator href=#lockedbumpallocator><code>Locked&lt;BumpAllocator></code></a></li></ol></li><li><a id=contents:使用 href=#使用>使用</a></li><li><a id=contents:讨论 href=#讨论>讨论</a><ol><li><a id=contents:bump分配器的缺点 href=#bump分配器的缺点>Bump分配器的缺点</a></li><li><a id=contents:重用释放的内存 href=#重用释放的内存>重用释放的内存？</a></li></ol></li></ol></li><li><a id=contents:链表分配器 href=#链表分配器>链表分配器</a><ol><li><a id=contents:实现-1 href=#实现-1>实现</a><ol><li><a id=contents:分配器类型 href=#分配器类型>分配器类型</a></li><li><a id=contents:add_free_region方法 href=#add_free_region方法><code>add_free_region</code>方法</a></li><li><a id=contents:find_region方法 href=#find_region方法><code>find_region</code>方法</a><ol><li><a id=contents:alloc_from_region函数 href=#alloc_from_region函数><code>alloc_from_region</code>函数</a></li></ol></li><li><a id=contents:实现globalalloc-1 href=#实现globalalloc-1>实现<code>GlobalAlloc</code></a></li><li><a id=contents:布局调整 href=#布局调整>布局调整</a></li></ol></li><li><a id=contents:使用-1 href=#使用-1>使用</a></li><li><a id=contents:讨论-1 href=#讨论-1>讨论</a><ol><li><a id=contents:合并释放的块 href=#合并释放的块>合并释放的块</a></li><li><a id=contents:性能 href=#性能>性能</a></li></ol></li></ol></li><li><a id=contents:固定大小的块分配器 href=#固定大小的块分配器>固定大小的块分配器</a><ol><li><a id=contents:介绍-1 href=#介绍-1>介绍</a><ol><li><a id=contents:块大小和浪费的内存 href=#块大小和浪费的内存>块大小和浪费的内存</a></li><li><a id=contents:释放 href=#释放>释放</a></li><li><a id=contents:后备分配器 href=#后备分配器>后备分配器</a></li><li><a id=contents:创建新块 href=#创建新块>创建新块</a></li></ol></li><li><a id=contents:实现-2 href=#实现-2>实现</a><ol><li><a id=contents:列表节点 href=#列表节点>列表节点</a></li><li><a id=contents:块大小 href=#块大小>块大小</a></li><li><a id=contents:分配器类型-1 href=#分配器类型-1>分配器类型</a></li><li><a id=contents:计算链表索引 href=#计算链表索引>计算链表索引</a></li><li><a id=contents:实现globalalloc-2 href=#实现globalalloc-2>实现<code>GlobalAlloc</code></a><ol><li><a id=contents:alloc href=#alloc><code>alloc</code></a></li></ol></li><li><a id=contents:dealloc href=#dealloc><code>dealloc</code></a></li></ol></li><li><a id=contents:使用-2 href=#使用-2>使用</a></li><li><a id=contents:讨论-2 href=#讨论-2>讨论</a></li><li><a id=contents:变化 href=#变化>变化</a><ol><li><a id=contents:slab分配器 href=#slab分配器>slab分配器</a></li><li><a id=contents:伙伴分配器 href=#伙伴分配器>伙伴分配器</a></li></ol></li></ol></li><li><a id=contents:总结 href=#总结>总结</a></li><li><a id=contents:接下来是什么 href=#接下来是什么>接下来是什么？</a></li></ol></nav><div class="post-body e-content"><h2 id=介绍><a href=#介绍 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:介绍 class=headings>介绍</a></h2><p>在<a href=https://os.phil-opp.com/heap-allocation target=_blank rel=noopener>上一篇文章</a>中我们向内核添加了对堆内存分配的基本支持。 为此，我们在页表中<a href=https://os.phil-opp.com/heap-allocation#creating-a-kernel-heap target=_blank rel=noopener>创建了一个新的内存区域</a> ，并<a href=https://os.phil-opp.com/heap-allocation#using-an-allocator-crate target=_blank rel=noopener>使用<code>linked_list_allocator</code> crate</a>管理该部分内存。 现在我们有了一个可以工作的堆，但大部分工作都是这个crate做的，而我们没有了解它是如何工作的。</p><p>在本文中，我们将展示如何从头开始创建自己的堆分配器，而不是依赖现有的分配器crate。 我们将讨论不同的分配器设计，包括简单的<em>Bump分配器</em>和基本的<em>固定大小的块分配器</em> ，并使用此过程中得到的知识来实现（相比<code>linked_list_allocator</code> crate）性能更好的分配器。</p><h3 id=设计目标><a href=#设计目标 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:设计目标 class=headings>设计目标</a></h3><p>分配器的职责是管理可用的堆内存。 它需要在<code>alloc</code>调用中返回未使用的内存，并跟踪由<code>dealloc</code>释放的内存，以便可以再次重用它。 最重要的是，它绝不能重复分配已经在其他地方使用的内存，因为这会导致不确定的行为。</p><p>除了正确性之外，还有许多次要设计目标。 例如，分配器应有效地利用可用内存并使<a href=https://en.wikipedia.org/wiki/Fragmentation_(computing) target=_blank rel=noopener><em>碎片</em></a>减少。此外，它对于并发应用程序应能很好地工作，并可扩展到任意数量的处理器。 为了获得最佳性能，它甚至可以针对CPU缓存优化内存布局，以提高<a href=http://docs.cray.com/books/S-2315-50/html-S-2315-50/qmeblljm.html target=_blank rel=noopener>缓存亲和性</a>并避免<a href=http://mechanical-sympathy.blogspot.de/2011/07/false-sharing.html target=_blank rel=noopener>False Sharing</a> 。</p><p>这些要求会使好的分配器非常复杂。 例如， <a href=http://jemalloc.net/ target=_blank rel=noopener>jemalloc</a>具有超过30,000行代码。 通常我们不希望内核代码中的分配器如此复杂，因为其中的单个错误会就会导致严重的安全漏洞。 幸运的是，与用户空间代码相比，内核代码的分配模式通常要简单得多，因此相对简单的分配器设计通常就足够了。</p><p>在下文中，我们介绍了三种可能的内核分配器设计，并说明了它们的优缺点。</p><h2 id=bump分配器><a href=#bump分配器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:bump分配器 class=headings>Bump分配器</a></h2><p>最简单的分配器设计是<em>Bump分配器</em> 。 它线性分配内存，并且仅记录分配的字节数和分配次数。 它仅在非常特定的用例中有用，因为它有一个严格的限制：它只能一次释放所有内存。</p><h3 id=基本想法><a href=#基本想法 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:基本想法 class=headings>基本想法</a></h3><p>Bump分配器背后的思想是通过增加（ <em>“Bump”</em> ） <code>next</code>变量来线性分配内存，该变量指向未使用的内存的开头。 一开始， <code>next</code>等于堆的起始地址。 每次分配时， <code>next</code>都会增加，因此它始终指向已用和未用内存之间的边界：</p><p><img src=https://os.phil-opp.com/allocator-designs/bump-allocation.svg alt="在三个时间点的堆内存区域：1：在堆的开始处存在一个分配；下一个指针指向其结尾 2：在第一个分配之后立即添加了第二个分配；下一个指针指向第二个分配的末尾3：在第二个分配之后立即添加了第三个分配；`下一个指针指向第三分配的末尾"></p><p><code>next</code>指针单向移动，因此永远不会两次分配相同的存储区域。 当<code>next</code>到达堆末尾时，无法再分配更多的内存，从而导致下一次分配出现内存不足错误。</p><p>Bump分配器通常带有一个分配计数器，分配计数器在每个<code>alloc</code>调用中增加1，在每个<code>dealloc</code>调用中减少1。 当分配计数器达到零时，表示堆上分配的所有内存都已释放。 在这种情况下，可以将<code>next</code>指针重置为堆的起始地址，以便完整的堆内存可再次用于分配。</p><h3 id=实现><a href=#实现 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:实现 class=headings>实现</a></h3><p>我们通过声明一个新的<code>allocator::bump</code>子模块开始我们的实现：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>mod</span> <span class=nn>bump</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>子模块的内容位于新的<code>src/allocator/bump.rs</code>文件中，如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/bump.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>BumpAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>heap_start</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>heap_end</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>next</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>allocations</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>BumpAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Creates a new empty bump allocator.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>BumpAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>heap_start</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>heap_end</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>next</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>allocations</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Initializes the bump allocator with the given heap bounds.
</span><span class=sd></span><span class=w>    </span><span class=sd>///
</span><span class=sd></span><span class=w>    </span><span class=sd>/// This method is unsafe because the caller must ensure that the given
</span><span class=sd></span><span class=w>    </span><span class=sd>/// memory range is unused. Also, this method must be called only once.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>init</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>heap_start</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>heap_size</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>heap_start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>heap_start</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>heap_end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>heap_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>heap_size</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>heap_start</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p><code>heap_start</code>和<code>heap_end</code>字段跟踪堆内存区域的下限和上限。 调用者需要确保这些地址有效，否则分配器将返回无效的内存。 因此， <code>init</code>函数是<code>unsafe</code>的。</p><p><code>next</code>字段的目的是始终指向堆的第一个未使用字节，即下一个分配的起始地址。 在<code>init</code>函数中将其设置为<code>heap_start</code> ，因为在开始时没有使用任何堆内存。 在每次分配时，此字段都会增加分配大小（ <em>“ bumped”</em> ），以确保我们不会两次返回相同的内存区域。</p><p><code>allocations</code>字段是记录分配数的简单计数器，目的是在释放最后一个分配后重置分配器。 初始化为0。</p><p>我们选择创建一个单独的<code>init</code>函数，而不是直接在<code>new</code>中直接执行初始化，以使接口与<code>linked_list_allocator</code> crate提供的分配器相同。 这样，无需更改其他代码即可切换分配器。</p><h3 id=实现globalalloc><a href=#实现globalalloc class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:实现globalalloc class=headings>实现<code>GlobalAlloc</code></a></h3><p>如<a href=https://os.phil-opp.com/heap-allocation#the-allocator-interface target=_blank rel=noopener>前</a>一篇<a href=https://os.phil-opp.com/heap-allocation#the-allocator-interface target=_blank rel=noopener>文章所述</a> ，所有堆分配器都需要实现<a href=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html target=_blank rel=noopener><code>GlobalAlloc trait</code></a>，其定义如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc_zeroed</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>realloc</span><span class=p>(</span><span class=w>
</span><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>new_size</span>: <span class=kt>usize</span>
    <span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>仅需要<code>alloc</code>和<code>dealloc</code>方法，其他两个方法具有默认实现，可以省略。</p><h4 id=首次尝试实现><a href=#首次尝试实现 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:首次尝试实现 class=headings>首次尝试实现</a></h4><p>让我们尝试为<code>BumpAllocator</code>实现<code>alloc</code>方法：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/bump.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>alloc</span>::<span class=p>{</span><span class=n>GlobalAlloc</span><span class=p>,</span><span class=w> </span><span class=n>Layout</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>BumpAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// TODO alignment and bounds check
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>next</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>layout</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>allocations</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>alloc_start</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>_ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>_layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>todo</span><span class=o>!</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>首先，我们使用<code>next</code>字段作为分配的起始地址。 然后，我们更新<code>next</code>字段以指向分配的结束地址，这是堆上的下一个未使用的地址。 在以<code>*mut u8</code>指针返回分配的开始地址之前，我们将<code>allocations</code>计数器增加1。</p><p>请注意，我们不执行任何边界检查或对齐调整，因此此实现尚不安全。 这并不要紧，因为无论如何它都无法编译并出现以下错误：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=n>error</span><span class=p>[</span><span class=n>E0594</span><span class=p>]:</span><span class=w> </span><span class=n>cannot</span><span class=w> </span><span class=n>assign</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=o>`</span><span class=n>self</span><span class=p>.</span><span class=n>next</span><span class=o>`</span><span class=w> </span><span class=n>which</span><span class=w> </span><span class=k>is</span><span class=w> </span><span class=n>behind</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>`&amp;`</span><span class=w> </span><span class=n>reference</span><span class=w>
</span><span class=w>  </span><span class=o>--&gt;</span><span class=w> </span><span class=n>src</span><span class=o>/</span><span class=n>allocator</span><span class=o>/</span><span class=n>bump</span><span class=p>.</span><span class=n>rs</span><span class=p>:</span><span class=mi>29</span><span class=p>:</span><span class=mi>9</span><span class=w>
</span><span class=w>   </span><span class=o>|</span><span class=w>
</span><span class=w></span><span class=mi>26</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=n>unsafe</span><span class=w> </span><span class=n>fn</span><span class=w> </span><span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=n>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span><span class=p>:</span><span class=w> </span><span class=n>Layout</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=o>*</span><span class=n>mut</span><span class=w> </span><span class=n>u8</span><span class=w> </span><span class=err>{</span><span class=w>
</span><span class=w>   </span><span class=o>|</span><span class=w>                     </span><span class=o>---</span><span class=c1>-- help: consider changing this to be a mutable reference: `&amp;mut self`
</span><span class=c1></span><span class=p>...</span><span class=w>
</span><span class=w></span><span class=mi>29</span><span class=w> </span><span class=o>|</span><span class=w>         </span><span class=n>self</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>layout</span><span class=p>.</span><span class=nf>size</span><span class=p>();</span><span class=w>
</span><span class=w>   </span><span class=o>|</span><span class=w>         </span><span class=o>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class=w> </span><span class=o>`</span><span class=n>self</span><span class=o>`</span><span class=w> </span><span class=k>is</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>`&amp;`</span><span class=w> </span><span class=n>reference</span><span class=p>,</span><span class=w> </span><span class=n>so</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=n>it</span><span class=w> </span><span class=n>refers</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>cannot</span><span class=w> </span><span class=n>be</span><span class=w> </span><span class=n>written</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>（ <code>self.allocations += 1</code>行也发生相同的错误。为简洁起见，在此省略。）</p><p>发生该错误是因为<code>GlobalAlloc</code> trait的<a href=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.alloc target=_blank rel=noopener><code>alloc</code></a>和<a href=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc target=_blank rel=noopener><code>dealloc</code></a>方法仅在不可变的<code>&self</code>引用上运行，因此无法更新<code>next</code>和<code>allocations</code>字段。 这是有问题的，因为在每个分配上<code>next</code>进行更新是Bump分配器的基本原理。</p><p>注意，在方法声明中将<code>&self</code>更改为<code>&mut self</code>的编译器建议在这里不起作用。 原因是方法签名是由<code>GlobalAlloc</code> trait定义的，不能在实现端进行更改。 （我在Rust 的repo开了一个关于此类不合法的编译期建议的<a href=https://github.com/rust-lang/rust/issues/68049 target=_blank rel=noopener>issue</a>。）</p><h4 id=globalalloc和可变性><a href=#globalalloc和可变性 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:globalalloc和可变性 class=headings><code>GlobalAlloc</code>和可变性</a></h4><p>在我们研究此可变性问题的可能解决方案之前，让我们尝试理解为什么使用<code>&self</code>参数定义<code>GlobalAlloc</code> trait方法的：正如我们在上一篇文章中看到<a href=https://os.phil-opp.com/heap-allocation#the-global-allocator-attribute target=_blank rel=noopener>的那样</a> ，全局堆分配器是通过将<code>#[global_allocator]</code>属性添加到实现<code>GlobalAlloc</code>特性的<code>static</code> 。静态变量在Rust中是不可变的，因此无法调用在静态分配器上采用<code>&mut self</code>的方法。 因此， <code>GlobalAlloc</code>所有方法仅采用不可变的<code>&self</code>引用。</p><p>幸运的是，有一种方法可以从<code>&self</code>引用中获取<code>&mut self</code>引用：通过将分配器包装在<a href=https://docs.rs/spin/0.5.0/spin/struct.Mutex.html target=_blank rel=noopener><code>spin::Mutex</code></a>自旋锁中，我们可以使用同步<a href=https://doc.rust-lang.org/book/ch15-05-interior-mutability.html target=_blank rel=noopener>内部可变性</a> 。 这种类型提供了执行<a href=https://en.wikipedia.org/wiki/Mutual_exclusion target=_blank rel=noopener>互斥</a>的<code>lock</code>方法，因此可以安全地将<code>&self</code>引用转换为<code>&mut self</code>引用。 我们已经在内核中多次使用了包装器类型，例如<a href=https://os.phil-opp.com/vga-text-mode#spinlocks target=_blank rel=noopener>VGA文本缓冲区</a> 。</p><h4 id=locked包装类型><a href=#locked包装类型 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:locked包装类型 class=headings><code>Locked</code>包装类型</a></h4><p>借助<code>spin::Mutex</code>包装器类型，我们可以为Bump分配器实现<code>GlobalAlloc</code>特性。 诀窍是不是直接为<code>BumpAllocator</code>实现特征，而是为包装的<code>spin::Mutex</code>类型实现特征：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>unsafe</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>spin</span>::<span class=n>Mutex</span><span class=o>&lt;</span><span class=n>BumpAllocator</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=err>…</span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>不幸的是，这仍然不起作用，因为Rust编译器不允许实现其他crate中定义trait：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
  --&gt; src/allocator/bump.rs:28:1
   |
28 | unsafe impl GlobalAlloc for spin::Mutex&lt;BumpAllocator&gt; {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^--------------------------
   | |                           |
   | |                           `spin::mutex::Mutex` is not defined in the current crate
   | impl doesn&#39;t use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead
</code></pre></td></tr></table></div></div></div><p>为了解决这个问题，我们需要围绕<code>spin::Mutex</code>创建我们自己的包装器类型：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=sd>/// A wrapper around spin::Mutex to permit trait implementations.
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Locked</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>inner</span>: <span class=nc>spin</span>::<span class=n>Mutex</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=w> </span><span class=n>Locked</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>inner</span>: <span class=nc>A</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Locked</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>inner</span>: <span class=nc>spin</span>::<span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=n>inner</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>spin</span>::<span class=n>MutexGuard</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>inner</span><span class=p>.</span><span class=n>lock</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该类型是围绕<code>spin::Mutex&lt;A></code>的通用包装。 它对包装的类型<code>A</code>没有任何限制，因此可以用于包装所有类型，而不仅仅是分配器。 它提供了一个简单的<code>new</code>构造函数，该函数将给定值包装了起来。 为了方便起见，它还提供了一个<code>lock</code> 函数，该函数调用被包装的<code>Mutex</code>上的<code>lock</code> 。 由于<code>Locked</code>类型足够通用，因此也可用于其他分配器实现，因此我们将其放在父<code>allocator</code>模块中。</p><h4 id=lockedbumpallocator><a href=#lockedbumpallocator class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:lockedbumpallocator class=headings><code>Locked&lt;BumpAllocator></code></a></h4><p><code>Locked</code>类型是在我们自己的crate中定义的（与<code>spin::Mutex</code>相反），因此我们可以使用它为我们的Bump分配器实现<code>GlobalAlloc</code> 。 完整的实现如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/bump.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=p>{</span><span class=n>align_up</span><span class=p>,</span><span class=w> </span><span class=n>Locked</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>alloc</span>::<span class=p>{</span><span class=n>GlobalAlloc</span><span class=p>,</span><span class=w> </span><span class=n>Layout</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=n>ptr</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Locked</span><span class=o>&lt;</span><span class=n>BumpAllocator</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bump</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w> </span><span class=c1>// get a mutable reference
</span><span class=c1></span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>align_up</span><span class=p>(</span><span class=n>bump</span><span class=p>.</span><span class=n>next</span><span class=p>,</span><span class=w> </span><span class=n>layout</span><span class=p>.</span><span class=n>align</span><span class=p>());</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>alloc_end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>layout</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>alloc_end</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>bump</span><span class=p>.</span><span class=n>heap_end</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>ptr</span>::<span class=n>null_mut</span><span class=p>()</span><span class=w> </span><span class=c1>// out of memory
</span><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>bump</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>alloc_end</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=n>bump</span><span class=p>.</span><span class=n>allocations</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=n>alloc_start</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>_ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>_layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bump</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w> </span><span class=c1>// get a mutable reference
</span><span class=c1></span><span class=w>
</span><span class=w>        </span><span class=n>bump</span><span class=p>.</span><span class=n>allocations</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>bump</span><span class=p>.</span><span class=n>allocations</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>bump</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bump</span><span class=p>.</span><span class=n>heap_start</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p><code>alloc</code>和<code>dealloc</code>第一步都是通过<code>inner</code>字段调用<a href=https://docs.rs/spin/0.5.0/spin/struct.Mutex.html#method.lock target=_blank rel=noopener><code>Mutex::lock</code></a>方法，以获取对包装后的分配器类型的可变引用。 该实例将保持锁定状态，直到方法结束，以便在多线程上下文中不会发生数据竞争（我们将很快添加线程支持）。</p><p>与以前的原型相比， <code>alloc</code>实现现在遵守对齐要求并执行边界检查以确保分配保留在堆内存区域内。 第一步是将<code>next</code>地址四舍五入为<code>Layout</code>参数指定的对齐方式。 <code>align_up</code>显示<code>align_up</code>函数的代码。 像以前一样，我们然后将请求的分配大小添加到<code>alloc_start</code>以获得分配的结束地址。 如果它大于堆的结束地址，我们将返回一个空指针，以指示内存不足的情况。否则，我们将更新<code>next</code>地址，并像以前一样将<code>allocations</code>计数器增加1。 最后，我们返回转换为<code>*mut u8</code>指针的<code>alloc_start</code>地址。</p><p><code>dealloc</code>函数将忽略给定的指针和<code>Layout</code>参数。 相反，它只是减少了<code>allocations</code>计数器。如果计数器再次达到<code>0</code> ，则意味着所有分配都被再次释放。 在这种情况下，它将<code>next</code>地址重置为<code>heap_start</code>地址，以使完整的堆内存再次可用。</p><p><code>align_up</code>函数足够通用，可以将其放入父<code>allocator</code>模块中。 看起来像这样：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>align_up</span><span class=p>(</span><span class=n>addr</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>align</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>remainder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>addr</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>align</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>remainder</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>addr</span><span class=w> </span><span class=c1>// addr already aligned
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>addr</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>remainder</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>align</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该函数首先计算<code>align</code>除<code>addr</code>除法的<a href=https://en.wikipedia.org/wiki/Euclidean_division target=_blank rel=noopener>余数</a> 。 如果余数为<code>0</code> ，则地址已与给定的对齐方式对齐。 否则，我们通过减去余数（这样新的余数为0）然后加上<code>align</code>（以便地址不会变得小于原始地址）来对齐地址。</p><h3 id=使用><a href=#使用 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用 class=headings>使用</a></h3><p>要使用Bump分配器而不是<code>linked_list_allocator</code> crate，我们需要更新<code>allocator.rs</code>的<code>ALLOCATOR</code>静态值：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>bump</span>::<span class=n>BumpAllocator</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[global_allocator]</span><span class=w>
</span><span class=w></span><span class=k>static</span><span class=w> </span><span class=n>ALLOCATOR</span>: <span class=nc>Locked</span><span class=o>&lt;</span><span class=n>BumpAllocator</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Locked</span>::<span class=n>new</span><span class=p>(</span><span class=n>BumpAllocator</span>::<span class=n>new</span><span class=p>());</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>在这里，重要的是，我们将<code>BumpAllocator::new</code>和<code>Locked::new</code> 定义为<a href=https://doc.rust-lang.org/reference/items/functions.html#const-functions target=_blank rel=noopener><code>const</code>函数</a> 。 如果它们是普通函数，则将发生编译错误，因为<code>static</code>的初始化表达式必须在编译时求值。</p><p>我们不需要在<code>init_heap</code>函数中更改<code>ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE)</code>调用，因为凹凸分配器提供的接口与<code>linked_list_allocator</code>提供的分配器相同。</p><p>现在我们的内核使用我们的凹凸分配器！ 一切都应该仍然有效，包括我们在上<a href=https://os.phil-opp.com/heap-allocation#adding-a-test target=_blank rel=noopener><code>heap_allocation</code></a>文章中创建的<a href=https://os.phil-opp.com/heap-allocation#adding-a-test target=_blank rel=noopener><code>heap_allocation</code>测试</a> ：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>&gt; cargo xtest --test heap_allocation
[…]
Running 3 tests
simple_allocation... [ok]
large_vec... [ok]
many_boxes... [ok]
</code></pre></td></tr></table></div></div></div><h3 id=讨论><a href=#讨论 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:讨论 class=headings>讨论</a></h3><p>Bump分配的最大优点是它非常快。 与需要主动寻找合适的内存块并在<code>alloc</code>和<code>dealloc</code>时执行各种记录任务的其他分配器设计（请参见下文）相比， 可以将Bump分配器优化为仅使用数条汇编指令。 这使得凹凸分配器对于优化分配性能很有用，例如在创建<a href=https://hacks.mozilla.org/2019/03/fast-bump-allocated-virtual-doms-with-rust-and-wasm target=_blank rel=noopener>虚拟DOM库时</a> 。</p><p>虽然很少使用Bump分配器作为全局分配器，但是凹凸分配的原理通常以竞技场分配的形式应用，<a href=https://mgravell.github.io/Pipelines.Sockets.Unofficial/docs/arenas.html target=_blank rel=noopener>竞技场分配</a>基本上是将多次分配集中在一起以提高性能。 Rust的竞技场分配器的一个示例是<a href=https://docs.rs/toolshed/0.8.1/toolshed/index.html target=_blank rel=noopener><code>toolshed</code></a> 。</p><h4 id=bump分配器的缺点><a href=#bump分配器的缺点 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:bump分配器的缺点 class=headings>Bump分配器的缺点</a></h4><p>Bump分配器的主要局限性在于，只有释放所有分配后，它才能重新使用释放的内存。 这意味着单个长期分配足以防止内存重用。 当我们添加<code>many_boxes</code>测试的变体时，我们可以看到这一点：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in tests/heap_allocation.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[test_case]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>many_boxes_long_lived</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>serial_print</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;many_boxes_long_lived... &#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>long_lived</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w> </span><span class=c1>// new
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>HEAP_SIZE</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>long_lived</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w> </span><span class=c1>// new
</span><span class=c1></span><span class=w>    </span><span class=n>serial_println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;[ok]&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>像<code>many_boxes</code>测试一样，如果分配器不重新使用释放的内存，此测试会创建大量分配以引发内存不足故障。 此外，测试会创建一个<code>long_lived</code>分配，该分配对于整个循环执行有效。</p><p>当我们尝试运行新测试时，我们发现它确实失败了：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>&gt; cargo xtest --test heap_allocation
Running 4 tests
simple_allocation... [ok]
large_vec... [ok]
many_boxes... [ok]
many_boxes_long_lived... [failed]

Error: panicked at &#39;allocation error: Layout { size_: 8, align_: 8 }&#39;, src/lib.rs:86:5
</code></pre></td></tr></table></div></div></div><p>让我们尝试详细了解为什么会发生此故障：首先，在堆的开头分配了<code>long_lived</code>，从而将<code>allocations</code>计数器增加1。对于循环的每次迭代，都会临时分配一次内存并在下一次迭代开始之前释放它。 这意味着<code>allocations</code>计数器在迭代开始时临时增加到2，在迭代结束时减少到1。 现在的问题是，凹凸分配器仅在释放<em>所有</em>分配后才可以重用内存，即<code>allocations</code>计数器降为0。由于在循环结束之前不会发生这种情况，因此每次循环迭代都会分配一个新的内存区域，多次迭代后导致了内存不足错误。</p><h4 id=重用释放的内存><a href=#重用释放的内存 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:重用释放的内存 class=headings>重用释放的内存？</a></h4><p>问题是：我们可以通过某种方式扩展凹凸分配器以消除此限制吗？</p><p>正如我们在上一篇文章中了解到的那样，分配可以生存任意长的时间，并且可以按任意顺序释放。 这意味着我们需要跟踪数量可能无限的非连续未使用内存区域，如以下示例所示：</p><p><img src=https://os.phil-opp.com/allocator-designs/allocation-fragmentation.svg alt=img></p><p>该图显示了一段时间内的堆。 一开始，整个堆还没有被使用， <code>next</code>地址等于<code>heap_start</code> （第1行）。 然后发生第一个分配（第2行）。 在第3行中，分配了第二个存储块，并释放了第一次分配的内润。 在第4行中进行了更多分配。其中一半寿命很短，在第5行中已被释放，在该行中还进行了另一次新分配。</p><p>第5行显示了一个基本问题：我们共有五个未使用的内存区域，它们的大小各不相同，但是<code>next</code>指针只能指向最后一个区域的开始。 尽管对于本示例，我们可以将其他未使用的存储区域的起始地址和大小存储在大小为4的数组中，但这并不是一般的解决方案，因为我们可以轻松地创建一个包含8、16或1000个未使用的存储区域的示例。</p><p>通常，当我们有数量不定的项目时，我们可以使用在堆上分配的集合类型。 但此时这是不可能的，因为堆分配器不能依赖于自身（这将导致无限递归或死锁）。 因此，我们需要找到其他解决方案。</p><h2 id=链表分配器><a href=#链表分配器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:链表分配器 class=headings>链表分配器</a></h2><p>在实现分配器时，跟踪任意数量的空闲内存区域的常见技巧是将这些区域本身用作后备存储。 这利用了以下事实：区域仍被映射到虚拟地址并由物理帧支持，但是不再需要存储信息。 通过在已被释放的区域中存储有关的信息，我们可以跟踪无限制数量的已被释放的区域，而无需额外的内存。</p><p>最常见的实现方法是在释放的内存中构造一个链表，每个节点都是一个释放的内存区域：</p><p><img src=https://os.phil-opp.com/allocator-designs/linked-list-allocation.svg alt=img></p><p>每个列表节点包含两个字段：内存区域的大小和指向下一个未使用的内存区域的指针。 使用这种方法，我们只需要一个指向第一个未使用区域（称为<code>head</code> ）的指针即可跟踪所有未使用区域，而与它们的数量无关。 产生的数据结构通常称为<a href=https://en.wikipedia.org/wiki/Free_list target=_blank rel=noopener><em>空闲列表</em></a> 。</p><p>正如您可能从名称中猜到的那样，这是<code>linked_list_allocator</code> crate使用的技术。</p><h3 id=实现-1><a href=#实现-1 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:实现-1 class=headings>实现</a></h3><p>在下面，我们将创建自己的简单<code>LinkedListAllocator</code>类型，该类型使用上述方法来跟踪已被释放的内存区域。 文章的其他部分不需要这一部分知识，因此您可以根据需要跳过这部分实现细节。</p><h4 id=分配器类型><a href=#分配器类型 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:分配器类型 class=headings>分配器类型</a></h4><p>我们首先在一个新的<code>allocator::linked_list</code>子模块中创建一个私有<code>ListNode</code>结构：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>mod</span> <span class=nn>linked_list</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>ListNode</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>size</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>next</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>就像图中一样，列表节点具有<code>size</code>字段和指向下一个节点的可选指针，由<code>Option&lt;&'static mut ListNode></code>类型表示。 <code>&'static mut</code>类型在语义上描述了一个有所有权的，在指针后面的对象。 基本上，这是一个没有析构函数的<a href=https://doc.rust-lang.org/alloc/boxed/index.html target=_blank rel=noopener><code>Box</code></a> ，它在所在作用域的末尾释放对象。</p><p>我们为<code>ListNode</code>实现以下方法：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>ListNode</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>const</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>size</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>ListNode</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>size</span><span class=p>,</span><span class=w> </span><span class=n>next</span>: <span class=nb>None</span> <span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>start_addr</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>end_addr</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start_addr</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>size</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该类型具有一个名为<code>new</code>的简单构造函数，以及用于计算所表示区域的开始和结束地址的方法。我们将<code>new</code>函数设为<a href=https://doc.rust-lang.org/reference/items/functions.html#const-functions target=_blank rel=noopener>const函数</a> ，稍后在构造静态链表分配器时将需要使用该函数。 请注意，在const函数中使用可变引用（包括将<code>next</code>字段设置为<code>None</code> ）仍然不稳定。 为了使其能够编译，我们需要在<code>lib.rs</code>的开头添加 <strong><code>#![feature(const_mut_refs)]</code></strong> 。</p><p>使用<code>ListNode</code>结构作为构建块，我们现在可以创建<code>LinkedListAllocator</code>结构：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>LinkedListAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>head</span>: <span class=nc>ListNode</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>LinkedListAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Creates an empty LinkedListAllocator.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>head</span>: <span class=nc>ListNode</span>::<span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Initialize the allocator with the given heap bounds.
</span><span class=sd></span><span class=w>    </span><span class=sd>///
</span><span class=sd></span><span class=w>    </span><span class=sd>/// This function is unsafe because the caller must guarantee that the given
</span><span class=sd></span><span class=w>    </span><span class=sd>/// heap bounds are valid and that the heap is unused. This method must be
</span><span class=sd></span><span class=w>    </span><span class=sd>/// called only once.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>init</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>heap_start</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>heap_size</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>add_free_region</span><span class=p>(</span><span class=n>heap_start</span><span class=p>,</span><span class=w> </span><span class=n>heap_size</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Adds the given memory region to the front of the list.
</span><span class=sd></span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>add_free_region</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>addr</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>size</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>todo</span><span class=o>!</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该结构包含一个指向第一个堆区域的<code>head</code>节点。 我们只对<code>next</code>指针的值感兴趣，因此我们在<code>ListNone::new</code>函数中将<code>size</code>设置为0。 我们让<code>head</code>为<code>ListNode</code>类型而非<code>&'static mut ListNode</code>类型，这样做的优点是， <code>alloc</code>方法的实现将更加简单。</p><p>像Bump分配器一样， <code>new</code>函数不会使用堆边界来初始化分配器。 除了保持API兼容性之外，原因还在于初始化函数需要将节点写入堆内存，这只能在运行时发生。 但是， <code>new</code>函数必须是可以在编译时求值的<a href=https://doc.rust-lang.org/reference/items/functions.html#const-functions target=_blank rel=noopener><code>const</code>函数</a> ，因为它将用于初始化<code>ALLOCATOR</code>静态函数。 出于这个原因，我们再次单独提供了一个非const的<code>init</code>方法。</p><p><code>init</code>方法使用<code>add_free_region</code>方法，稍后将显示其实现。 现在，我们使用<a href=https://doc.rust-lang.org/core/macro.todo.html target=_blank rel=noopener><code>todo!</code></a> 宏，以提供一个总是panic的占位符实现。</p><h4 id=add_free_region方法><a href=#add_free_region方法 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:add_free_region方法 class=headings><code>add_free_region</code>方法</a></h4><p><code>add_free_region</code>方法提供对链表的基本<em>push</em>操作。 当前，我们仅从<code>init</code>调用此方法，但它也将成为我们<code>dealloc</code>实现中的中心方法。 请记住，当再次释放分配的内存区域时，将调用<code>dealloc</code>方法。 为了跟踪此释放的内存区域，我们希望将其push到链表。</p><p><code>add_free_region</code>方法的实现如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=n>align_up</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=n>mem</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>LinkedListAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Adds the given memory region to the front of the list.
</span><span class=sd></span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>add_free_region</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>addr</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>size</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// ensure that the freed region is capable of holding ListNode
</span><span class=c1></span><span class=w>        </span><span class=n>assert</span><span class=o>!</span><span class=p>(</span><span class=n>align_up</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span><span class=w> </span><span class=n>mem</span>::<span class=n>align_of</span>::<span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>())</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>addr</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert</span><span class=o>!</span><span class=p>(</span><span class=n>size</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>mem</span>::<span class=n>size_of</span>::<span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>());</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// create a new list node and append it at the start of the list
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ListNode</span>::<span class=n>new</span><span class=p>(</span><span class=n>size</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>node</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>head</span><span class=p>.</span><span class=n>next</span><span class=p>.</span><span class=n>take</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>node_ptr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>addr</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=n>ListNode</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>node_ptr</span><span class=p>.</span><span class=n>write</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>head</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>*</span><span class=n>node_ptr</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该方法以地址和大小表示的内存区域作为参数，并将其添加到列表的前面。 首先，它确保给定区域具有存储<code>ListNode</code>所需的大小和对齐方式。 然后，它通过以下步骤创建节点并将其插入到列表中：</p><p><img src=https://os.phil-opp.com/allocator-designs/linked-list-allocator-push.svg alt=img></p><p>步骤0显示了在<code>add_free_region</code>之前堆的状态。 在步骤1中，使用图中标记为已<code>freed</code>的内存区域调用该方法。 初步检查后，该方法在其堆栈上创建一个具有被释放区域大小的新<code>node</code> 。 然后，它使用<a href=https://doc.rust-lang.org/core/option/enum.Option.html#method.take target=_blank rel=noopener><code>Option::take</code></a>方法将节点的<code>next</code>指针设置为当前的<code>head</code>指针，从而将<code>head</code>指针重置为<code>None</code> 。</p><p>在步骤2中，该方法通过<a href=https://doc.rust-lang.org/std/primitive.pointer.html#method.write target=_blank rel=noopener><code>write</code></a>方法将新创建的<code>node</code>写入到被释放的内存区域的开头。 然后将<code>head</code>指针指向新节点。 最终的指针结构看起来有些混乱，因为被释放区域总是插入在列表的开头，但是如果我们跟随指针，我们会看到每个空闲区域仍然可以从<code>head</code>指针到达。</p><h4 id=find_region方法><a href=#find_region方法 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:find_region方法 class=headings><code>find_region</code>方法</a></h4><p>对链表的第二项基本操作是查找条目并将其从列表中删除。 这是实现<code>alloc</code>方法所需的中心操作。 我们通过以下方式将操作实现为<code>find_region</code>方法：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>LinkedListAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Looks for a free region with the given size and alignment and removes
</span><span class=sd></span><span class=w>    </span><span class=sd>/// it from the list.
</span><span class=sd></span><span class=w>    </span><span class=sd>///
</span><span class=sd></span><span class=w>    </span><span class=sd>/// Returns a tuple of the list node and the start address of the allocation.
</span><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>find_region</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>size</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>align</span>: <span class=kt>usize</span><span class=p>)</span><span class=w>
</span><span class=w>        </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>ListNode</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=o>&gt;</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// reference to current list node, updated for each iteration
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>current</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>head</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=c1>// look for a large enough memory region in linked list
</span><span class=c1></span><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=k>ref</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>region</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>current</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>alloc_start</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Self</span>::<span class=n>alloc_from_region</span><span class=p>(</span><span class=o>&amp;</span><span class=n>region</span><span class=p>,</span><span class=w> </span><span class=n>size</span><span class=p>,</span><span class=w> </span><span class=n>align</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=c1>// region suitable for allocation -&gt; remove node from list
</span><span class=c1></span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>region</span><span class=p>.</span><span class=n>next</span><span class=p>.</span><span class=n>take</span><span class=p>();</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>ret</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>((</span><span class=n>current</span><span class=p>.</span><span class=n>next</span><span class=p>.</span><span class=n>take</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>alloc_start</span><span class=p>));</span><span class=w>
</span><span class=w>                </span><span class=n>current</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=n>ret</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=c1>// region not suitable -&gt; continue with next region
</span><span class=c1></span><span class=w>                </span><span class=n>current</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>current</span><span class=p>.</span><span class=n>next</span><span class=p>.</span><span class=n>as_mut</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// no suitable region found
</span><span class=c1></span><span class=w>        </span><span class=nb>None</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该方法使用一个<code>current</code>变量和一个<a href=https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops target=_blank rel=noopener><code>while let</code>循环</a>来遍历列表元素。 首先，将<code>current</code>设置到（虚拟） <code>head</code>节点。 然后在每次迭代中，将其更新到当前节点的<code>next</code>字段（在<code>else</code>块中）。 如果该区域适合于具有给定大小和对齐方式的分配，则将该区域从列表中删除，并与<code>alloc_start</code>地址一起返回。</p><p>当<code>current.next</code>指针变为<code>None</code> ，循环退出。 这意味着我们遍历了整个列表，但是没有找到适合分配的区域。 在这种情况下，我们返回<code>None</code> 。 检查区域是否合适是通过<code>alloc_from_region</code>函数来进行的，稍后将展示其实现。</p><p>让我们更详细地研究如何从列表中删除合适的区域：</p><p><img src=https://os.phil-opp.com/allocator-designs/linked-list-allocator-remove-region.svg alt=img></p><p>步骤0显示了任何指针调整之前的情况。 图中标记出了<code>region</code>和<code>current</code>区域以及<code>region.next</code>和<code>current.next</code>指针。 在步骤1中，可以使用<a href=https://doc.rust-lang.org/core/option/enum.Option.html#method.take target=_blank rel=noopener><code>Option::take</code></a>方法将<code>region.next</code>和<code>current.next</code>指针都重置为<code>None</code> 。 原始指针存储在名为<code>next</code>和<code>ret</code>局部变量中。</p><p>在步骤2中，将<code>current.next</code>指针设置为本地的<code>next</code>指针，它是原来的<code>region.next</code>指针。结果是<code>current</code>直接指向region之后的<code>region</code> ，因此<code>region</code>不再是链表的元素。 然后，该函数将指针返回到存储在本地<code>ret</code>变量中的区域。</p><h5 id=alloc_from_region函数><a href=#alloc_from_region函数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:alloc_from_region函数 class=headings><code>alloc_from_region</code>函数</a></h5><p><code>alloc_from_region</code>函数返回区域是否适合于具有给定大小和对齐方式的分配。 定义如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>LinkedListAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Try to use the given region for an allocation with given size and
</span><span class=sd></span><span class=w>    </span><span class=sd>/// alignment.
</span><span class=sd></span><span class=w>    </span><span class=sd>///
</span><span class=sd></span><span class=w>    </span><span class=sd>/// Returns the allocation start address on success.
</span><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>alloc_from_region</span><span class=p>(</span><span class=n>region</span>: <span class=kp>&amp;</span><span class=nc>ListNode</span><span class=p>,</span><span class=w> </span><span class=n>size</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>align</span>: <span class=kt>usize</span><span class=p>)</span><span class=w>
</span><span class=w>        </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=p>()</span><span class=o>&gt;</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>align_up</span><span class=p>(</span><span class=n>region</span><span class=p>.</span><span class=n>start_addr</span><span class=p>(),</span><span class=w> </span><span class=n>align</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>alloc_end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>size</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>alloc_end</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>region</span><span class=p>.</span><span class=n>end_addr</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=c1>// region too small
</span><span class=c1></span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(());</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>excess_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>region</span><span class=p>.</span><span class=n>end_addr</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>alloc_end</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>excess_size</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>excess_size</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>mem</span>::<span class=n>size_of</span>::<span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=c1>// rest of region too small to hold a ListNode (required because the
</span><span class=c1></span><span class=w>            </span><span class=c1>// allocation splits the region in a used and a free part)
</span><span class=c1></span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(());</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// region suitable for allocation
</span><span class=c1></span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>alloc_start</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>首先，该函数使用我们之前定义的<code>align_up</code>函数来计算潜在分配的开始和结束地址。 如果要求的结束地址在该区域的结束地址之后，则该分配不适合该区域，并且我们返回错误。</p><p>此后，该函数执行了一个作用不太显然的检查。 进行此检查是必要的，因为在大多数情况下，分配并不能完全适合某个合适的区域，因此分配后，该区域的一部分仍然可用。 该区域的这一部分必须在分配后存储自己的<code>ListNode</code> ，因此它必须足够大才能存储。该检查准确地验证了这一点：分配是否完全适合（<code>excess_size == 0</code>）或多余的大小足以存储a <code>ListNode</code>。</p><h4 id=实现globalalloc-1><a href=#实现globalalloc-1 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:实现globalalloc-1 class=headings>实现<code>GlobalAlloc</code></a></h4><p>通过<code>add_free_region</code>和<code>find_region</code>方法提供的基本操作，我们现在可以最终实现<code>GlobalAlloc</code> trait。与Bump分配器一样，我们不直接针对<code>LinkedListAllocator</code>，而是仅针对包装过的<code>Locked&lt;LinkedListAllocator></code>来实现trait。该<a href=https://os.phil-opp.com/allocator-designs#a-locked-wrapper-type target=_blank rel=noopener><code>Locked</code>包装</a>通过自旋锁向分配器实例添加了内部可变性，这使得我们可以修改它，即使<code>alloc</code>和<code>dealloc</code>方法的参数是不可变的<code>&self</code>引用。</p><p>实现看起来像这样：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=n>Locked</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>alloc</span>::<span class=p>{</span><span class=n>GlobalAlloc</span><span class=p>,</span><span class=w> </span><span class=n>Layout</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=n>ptr</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Locked</span><span class=o>&lt;</span><span class=n>LinkedListAllocator</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// perform layout adjustments
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=p>,</span><span class=w> </span><span class=n>align</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LinkedListAllocator</span>::<span class=n>size_align</span><span class=p>(</span><span class=n>layout</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>inner</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>((</span><span class=n>region</span><span class=p>,</span><span class=w> </span><span class=n>alloc_start</span><span class=p>))</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>allocator</span><span class=p>.</span><span class=n>find_region</span><span class=p>(</span><span class=n>size</span><span class=p>,</span><span class=w> </span><span class=n>align</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>alloc_end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>alloc_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>size</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>excess_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>region</span><span class=p>.</span><span class=n>end_addr</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>alloc_end</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>excess_size</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>allocator</span><span class=p>.</span><span class=n>add_free_region</span><span class=p>(</span><span class=n>alloc_end</span><span class=p>,</span><span class=w> </span><span class=n>excess_size</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>alloc_start</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>ptr</span>::<span class=n>null_mut</span><span class=p>()</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// perform layout adjustments
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LinkedListAllocator</span>::<span class=n>size_align</span><span class=p>(</span><span class=n>layout</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>inner</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>add_free_region</span><span class=p>(</span><span class=n>ptr</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>size</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>让我们从该<code>dealloc</code>方法开始，因为它更简单：首先，它执行一些布局调整，我们将在稍后进行解释，并通过调用<a href=https://os.phil-opp.com/allocator-designs#a-locked-wrapper-type target=_blank rel=noopener>Locked wrapper</a>的<a href=https://docs.rs/spin/0.5.0/spin/struct.Mutex.html#method.lock target=_blank rel=noopener><code>Mutex::lock</code></a>函数来获取<code>&mut LinkedListAllocator</code>。然后，它调用<code>add_free_region</code>函数以将释放区域添加到空闲列表中。</p><p>该<code>alloc</code>方法有点复杂。它以相同的布局调整开始，并且还调用该<a href=https://docs.rs/spin/0.5.0/spin/struct.Mutex.html#method.lock target=_blank rel=noopener><code>Mutex::lock</code></a>函数以接收可变的分配器引用。然后，它使用<code>find_region</code>方法找到适合分配的存储区域，并将其从列表中删除。如果此操作失败并返回<code>None</code>，则返回<code>null_mut</code>，告知用户没有合适的存储区域。</p><p>在成功的情况下，该<code>find_region</code>方法返回合适区域（不再在列表中）的元组和分配的起始地址。使用<code>alloc_start</code>、分配大小和区域的结束地址，它再次计算分配的结束地址和多余的大小。如果多余的大小不为null，则调用<code>add_free_region</code>将内存区域的多余的大小添加回空闲列表。最后，它返回转换为<code>*mut u8</code>指针的<code>alloc_start</code>。</p><h4 id=布局调整><a href=#布局调整 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:布局调整 class=headings>布局调整</a></h4><p>那么我们在<code>alloc</code>和<code>dealloc</code>的一开始做的这些布局的调整，都是什么？它们确保每个分配的块都能够存储一个<code>ListNode</code>。这一点很重要，因为在某个时候我们要释放这一块内存并向其中写一个<code>ListNode</code>。如果块小于一个<code>ListNode</code>的大小或没有正确的对齐方式，则会发生未定义的行为。</p><p>布局调整由一个<code>size_align</code>函数执行，该函数定义如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/linked_list.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>LinkedListAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Adjust the given layout so that the resulting allocated memory
</span><span class=sd></span><span class=w>    </span><span class=sd>/// region is also capable of storing a `ListNode`.
</span><span class=sd></span><span class=w>    </span><span class=sd>///
</span><span class=sd></span><span class=w>    </span><span class=sd>/// Returns the adjusted size and alignment as a (size, align) tuple.
</span><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>size_align</span><span class=p>(</span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>layout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>layout</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>align_to</span><span class=p>(</span><span class=n>mem</span>::<span class=n>align_of</span>::<span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>())</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;adjusting alignment failed&#34;</span><span class=p>)</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>pad_to_align</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>layout</span><span class=p>.</span><span class=n>size</span><span class=p>().</span><span class=n>max</span><span class=p>(</span><span class=n>mem</span>::<span class=n>size_of</span>::<span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>());</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>size</span><span class=p>,</span><span class=w> </span><span class=n>layout</span><span class=p>.</span><span class=n>align</span><span class=p>())</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>首先，如果需要，函数对<a href=https://doc.rust-lang.org/alloc/alloc/struct.Layout.html target=_blank rel=noopener><code>Layout</code></a>参数应用<code>align_to</code>方法来将内存对齐到能够容纳一个 <code>ListNode</code> 。然后，它使用该<a href=https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.pad_to_align target=_blank rel=noopener><code>pad_to_align</code></a>方法将大小四舍五入为对齐方式的倍数，以确保下一个存储块的起始地址也将具有正确的对齐方式以存储<code>ListNode</code>。在第二步中，它使用<a href=https://doc.rust-lang.org/std/cmp/trait.Ord.html#method.max target=_blank rel=noopener><code>max</code></a>方法来强制最小分配大小为<code>mem::size_of::&lt;ListNode></code>。这样，<code>dealloc</code>函数可以安全地将<code>ListNode</code>写入已释放的内存块。</p><p>无论是<code>align_to</code>和<code>pad_to_align</code>方法都使用了不稳定的特性。要启用该功能，我们需要将添加**<code>#![feature(alloc_layout_extra)]</code>**到<code>lib.rs</code>的开头。</p><h3 id=使用-1><a href=#使用-1 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用-1 class=headings>使用</a></h3><p>现在，我们可以更新 <code>allocator</code>模块中的<code>ALLOCATOR</code>静态变量以使用我们的新<code>LinkedListAllocator</code>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>linked_list</span>::<span class=n>LinkedListAllocator</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[global_allocator]</span><span class=w>
</span><span class=w></span><span class=k>static</span><span class=w> </span><span class=n>ALLOCATOR</span>: <span class=nc>Locked</span><span class=o>&lt;</span><span class=n>LinkedListAllocator</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w>
</span><span class=w>    </span><span class=n>Locked</span>::<span class=n>new</span><span class=p>(</span><span class=n>LinkedListAllocator</span>::<span class=n>new</span><span class=p>());</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>由于<code>init</code>函数对于Bump和链表分配器的行为相同，因此我们不需要修改<code>init_heap</code>中的<code>init</code>调用。</p><p>现在，当我们再次运行<code>heap_allocation</code>测试时，我们看到所有测试现在都通过了，包括Bump分配器没有通过的<code>many_boxes_long_lived</code>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>&gt; cargo xtest --test heap_allocation
simple_allocation... [ok]
large_vec... [ok]
many_boxes... [ok]
many_boxes_long_lived... [ok]
</code></pre></td></tr></table></div></div></div><p>这表明我们的链表分配器能够将释放的内存重新用于后续分配。</p><h3 id=讨论-1><a href=#讨论-1 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:讨论-1 class=headings>讨论</a></h3><p>与Bump分配器相比，链表分配器更适合用作通用分配器，主要是因为它能够直接重用释放的内存。但是，它也有一些缺点。其中一些是由我们的实现引起的，但是链表分配器这种设计本身也存在一些缺点。</p><h4 id=合并释放的块><a href=#合并释放的块 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:合并释放的块 class=headings>合并释放的块</a></h4><p>我们实现的主要问题是，它只会将堆拆分为较小的块，而不会将它们重新合并在一起。考虑以下示例：</p><p><img src=https://os.phil-opp.com/allocator-designs/linked-list-allocator-fragmentation-on-dealloc.svg alt=img></p><p>在第一行中，在堆上进行了三次分配。它们中的两个在第2行中再次被释放，而第三个在第3行中被释放。现在整个堆都不再被使用，但仍被分成四个单独的块。此时，可能无法再进行大分配，因为四个块都不足够大。随着时间的流逝，该过程将继续进行，并将堆分成越来越小的块。这样下去总有一天，堆中会充满此类碎片，以至于正常大小的分配都将失败。</p><p>要解决此问题，我们需要将相邻的释放块重新合并在一起。对于上面的示例，这意味着：</p><p><img src=https://os.phil-opp.com/allocator-designs/linked-list-allocator-merge-on-dealloc.svg alt=img></p><p>像以前一样，三个分配中的两个在第<code>2</code>行中被释放。现在，我们不执行保留碎片的堆的操作，而是直接执行另外一个步骤，<code>2a</code>行将两个最右边的块合并在一起。在<code>3</code>第3 行中，释放了第三个分配（如之前一样），从而导致完全未使用的堆由三个不同的块组成。然后，在附加的合并步骤中（<code>3a</code>行）我们将三个相邻的块合并在一起。</p><p><code>linked_list_allocator</code> crate以下列方式这一合并策略：它始终保持列表按照起始地址排序，而不是直接在链表的开头插入被<code>deallocate</code>释放的内存块。这样，<code>deallocate</code>调用时可以通过检查列表中两个相邻块的地址和大小来进行合并。当然，这种方式的释放操作比较慢，但是可以防止我们在上面看到的堆碎片。</p><h4 id=性能><a href=#性能 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:性能 class=headings>性能</a></h4><p>正如我们在上面学到的，Bump分配器非常快，可以优化为仅需几个汇编指令操作。链表分配器的性能要差得多。其问题是分配请求可能需要遍历完整的链表，直到找到合适的块为止。</p><p>由于列表长度取决于未使用的存储块的数量，因此对于不同的程序，其性能可能会发生极大的变化。仅创建几个分配的程序将有相对较快的分配性能。但是，对于一个会进行很多次分配，导致堆变得碎片化的程序，分配性能将非常糟糕，因为链表将非常长，并且其中大多数包含的块都非常小。</p><p>值得注意的是，这类性能问题不是由我们的实现引起的问题，而是链表方法的根本问题。由于分配性能对于内核级代码非常重要，因此我们在下面探讨了第三种分配器设计，该设计以降低内存利用率代价来提高性能。</p><h2 id=固定大小的块分配器><a href=#固定大小的块分配器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:固定大小的块分配器 class=headings>固定大小的块分配器</a></h2><p>下面，我们介绍一种分配器设计，该设计使用固定大小的内存块来满足分配请求。这样，分配器通常返回的块大于分配所需的块，这会由于<a href=https://en.wikipedia.org/wiki/Fragmentation_(computing)#Internal_fragmentation target=_blank rel=noopener>内部碎片</a>而导致内存浪费。另一方面，它大大减少了找到合适块所需的时间（与链表分配器相比），从而有更好的分配性能。</p><h3 id=介绍-1><a href=#介绍-1 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:介绍-1 class=headings>介绍</a></h3><p><em>固定大小的块分配器</em>背后的思想是：并不恰好分配大小等于所需的内存，而是固定一些块大小并将每个分配舍入到能装下它的最小块大小。例如，对于16、64和512字节的块大小，分配4个字节将返回一个16字节的块，分配一个48字节将返回一个64字节的块，而分配128个字节将返回一个512字节的块。 。</p><p>像链表分配器一样，我们通过在未使用的内存中创建链表来跟踪未使用的内存。但是，我们不使用具有不同块大小的单个列表，而是为每个大小类创建一个单独的列表。然后，每个链表仅存储单个大小的块。例如，对于块大小为16、64和512的内存，将有三个单独的链表：</p><p><img src=https://os.phil-opp.com/allocator-designs/fixed-size-block-example.svg alt=img></p><p>我们有三个头指针<code>head_16</code>，<code>head_64</code>以及<code>head_512</code>而不是一个单一的<code>head</code>指针，每个都指到到对应的大小的第一个未使用块。单个列表中的所有节点都具有相同的大小。例如，由<code>head_16</code>指针开始的列表仅包含16字节的块。这意味着我们不再需要在每个列表节点中存储大小，因为它已经由头指针的名称指定了。</p><p>由于列表中的每个元素都具有相同的大小，因此每个列表元素都同样适用于分配请求。这意味着我们可以使用以下步骤非常有效地执行分配：</p><ul><li>将请求的分配大小四舍五入到下一个块大小。例如，当请求分配12个字节时，在上面的示例中，我们将选择16的块大小。</li><li>检索列表的头部指针，例如从一个头指针数组中检索。对于块大小16，我们需要使用<code>head_16</code>。</li><li>从列表中删除第一个块并返回它。</li></ul><p>最值得注意的是，我们总是可以返回链表的第一个元素，而不再需要遍历整个链表。因此，分配比使用链表分配器快得多。</p><h4 id=块大小和浪费的内存><a href=#块大小和浪费的内存 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:块大小和浪费的内存 class=headings>块大小和浪费的内存</a></h4><p>根据块大小，我们通过舍入会损失很多内存。例如，当返回一个512字节的块以进行128字节的分配时，分配的内存中有四分之三未被使用。通过定义合理的块大小，可以在某种程度上限制浪费的内存量。例如，当使用2的幂（4、8、16、32、64、128、…）作为块大小时，在最坏的情况下，我们可以将内存浪费限制为分配大小的一半，平均情况下为分配的四分之一。</p><p>通常也会基于程序中的常用的分配大小来优化块大小。例如，我们可以额外增加块大小24，以提高经常执行24字节分配的程序的内存使用率。这样，通常可以减少浪费的内存量，而不会损失性能优势。</p><h4 id=释放><a href=#释放 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:释放 class=headings>释放</a></h4><p>像分配一样，释放也非常高效。它涉及以下步骤：</p><ul><li>将释放的内存大小四舍五入到下一个块大小。这是必需的，因为编译器仅将请求的分配大小传递给<code>dealloc</code>，而不传递<code>alloc</code>所返回的块的大小。通过在<code>alloc</code>和<code>dealloc</code>中使用相同的大小调整函数我们可以确保始终释放正确的内存量。</li><li>检索列表的头部指针，例如从一个头指针数组中检索。</li><li>通过更新头指针，将释放的块添加到列表的开头。</li></ul><p>最值得注意的是，也无需遍历列表即可进行释放。这意味着<code>dealloc</code>无论列表长度如何，所需的时间都保持不变。</p><h4 id=后备分配器><a href=#后备分配器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:后备分配器 class=headings>后备分配器</a></h4><p>鉴于大容量分配（> 2KB）通常是很少见的，尤其是在操作系统内核中，因此有可能需要退回到其他分配器进行这些分配。例如，为了减少内存浪费，我们可以退回到链表分配器中进行大于2048字节的分配。由于预期该大小的分配非常少，因此这个链表将保持较小状态，因此分配和释放仍会相当快。</p><h4 id=创建新块><a href=#创建新块 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:创建新块 class=headings>创建新块</a></h4><p>上面，我们始终假定列表中始终有足够的特定大小的块来满足所有分配请求。但是，在某个时候，块大小的链接列表将为空。此时，有两种方法可以创建特定大小的未使用的新块来满足分配请求：</p><ul><li>从后备分配器分配一个新块（如果有）。</li><li>从其他列表中拆分较大的块。如果块大小为2的幂，则此方法最有效。例如，一个32字节的块可以分为两个16字节的块。</li></ul><p>对于我们的实现，为了简单考虑，因此我们将从后备分配器分配新块。</p><h3 id=实现-2><a href=#实现-2 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:实现-2 class=headings>实现</a></h3><p>现在我们知道了固定大小的块分配器是如何工作的，我们可以开始实现它了。我们将不依赖于上一节中创建的链表分配器的实现，因此即使您跳过了链表分配器的实现，也可以看这一部分。</p><h4 id=列表节点><a href=#列表节点 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:列表节点 class=headings>列表节点</a></h4><p>我们通过在新<code>allocator::fixed_size_block</code>模块中创建<code>ListNode</code>类型来开始实现：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>mod</span> <span class=nn>fixed_size_block</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>ListNode</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>next</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>这种类型类似于我们的<a href=https://os.phil-opp.com/allocator-designs#the-allocator-type target=_blank rel=noopener>链表分配器</a>中的<code>ListNode</code>类型，不同之处在于我们没有第二个<code>size</code>字段。不需要该字段是因为每个列表中的每个块都具有相同的大小。</p><h4 id=块大小><a href=#块大小 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:块大小 class=headings>块大小</a></h4><p>接下来，我们定义一个常量<code>BLOCK_SIZES</code>切片，并使用用于实现的块大小：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=sd>/// The block sizes to use.
</span><span class=sd>///
</span><span class=sd>/// The sizes must each be power of 2 because they are also used as
</span><span class=sd>/// the block alignment (alignments must be always powers of 2).
</span><span class=sd></span><span class=k>const</span><span class=w> </span><span class=n>BLOCK_SIZES</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>usize</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=mi>8</span><span class=p>,</span><span class=w> </span><span class=mi>16</span><span class=p>,</span><span class=w> </span><span class=mi>32</span><span class=p>,</span><span class=w> </span><span class=mi>64</span><span class=p>,</span><span class=w> </span><span class=mi>128</span><span class=p>,</span><span class=w> </span><span class=mi>256</span><span class=p>,</span><span class=w> </span><span class=mi>512</span><span class=p>,</span><span class=w> </span><span class=mi>1024</span><span class=p>,</span><span class=w> </span><span class=mi>2048</span><span class=p>];</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>我们使用从8到2048的2的幂作为块大小。我们不定义任何小于8的块大小，因为每个块在释放时必须能够存储指向下一个块的64位指针。对于大于2048字节的分配，我们将退回到链表分配器。</p><p>为了简化实现，我们定义块的大小也是其在内存中所需的对齐方式。因此，一个16字节的块始终在16字节的边界上对齐，而512字节的块始终在512字节的边界上对齐。由于对齐始终需要为2的幂，因此排除了任何其他块大小。如果将来需要的块大小不是2的幂，我们仍然可以为此调整实现（例如，通过定义第二个<code>BLOCK_ALIGNMENTS</code>数组）。</p><h4 id=分配器类型-1><a href=#分配器类型-1 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:分配器类型-1 class=headings>分配器类型</a></h4><p>使用<code>ListNode</code>类型和<code>BLOCK_SIZES</code>切片，我们现在可以定义分配器类型：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>FixedSizeBlockAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>list_heads</span>: <span class=p>[</span><span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>;</span><span class=w> </span><span class=n>BLOCK_SIZES</span><span class=p>.</span><span class=n>len</span><span class=p>()],</span><span class=w>
</span><span class=w>    </span><span class=n>fallback_allocator</span>: <span class=nc>linked_list_allocator</span>::<span class=n>Heap</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该<code>list_heads</code>字段是一个<code>head</code>指针数组，每个块大小一个。这是通过<code>len()</code>将<code>BLOCK_SIZES</code>slice的用作数组长度来实现的。作为大于最大块大小的分配的后备分配器，我们使用由<code>linked_list_allocator</code>提供的分配器。我们也可以使用我们自己实现的<code>LinkedListAllocator</code>，但是它的缺点是它不<a href=https://os.phil-opp.com/allocator-designs#merging-freed-blocks target=_blank rel=noopener>合并被释放的块</a>。</p><p>对于<code>FixedSizeBlockAllocator</code>，我们提供了与其他分配器类型相同的<code>new</code>和<code>init</code>函数：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>FixedSizeBlockAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Creates an empty FixedSizeBlockAllocator.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>FixedSizeBlockAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>list_heads</span>: <span class=p>[</span><span class=nb>None</span><span class=p>;</span><span class=w> </span><span class=n>BLOCK_SIZES</span><span class=p>.</span><span class=n>len</span><span class=p>()],</span><span class=w>
</span><span class=w>            </span><span class=n>fallback_allocator</span>: <span class=nc>linked_list_allocator</span>::<span class=n>Heap</span>::<span class=n>empty</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Initialize the allocator with the given heap bounds.
</span><span class=sd></span><span class=w>    </span><span class=sd>///
</span><span class=sd></span><span class=w>    </span><span class=sd>/// This function is unsafe because the caller must guarantee that the given
</span><span class=sd></span><span class=w>    </span><span class=sd>/// heap bounds are valid and that the heap is unused. This method must be
</span><span class=sd></span><span class=w>    </span><span class=sd>/// called only once.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>init</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>heap_start</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>heap_size</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>fallback_allocator</span><span class=p>.</span><span class=n>init</span><span class=p>(</span><span class=n>heap_start</span><span class=p>,</span><span class=w> </span><span class=n>heap_size</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p><code>new</code>函数只是使用空节点初始化<code>list_heads</code>数组，并创建一个空链表分配器作为<code>fallback_allocator</code>。 由于初始化非<code>Copy</code>类型的数组仍然是不稳定特性，因此我们需要在lib.rs的开头添加<code>#![feature(const_in_array_repeat_expressions)]</code>。 在这种情况下，<code>None</code>不是<code>Copy</code>的原因是<code>ListNode</code>没有实现<code>Copy</code>。 因此，<code>Option</code>包装及其<code>None</code>变体也不是<code>Copy</code>。</p><p>不安全的init函数仅调用<code>fallback_allocator</code>的init函数，而无需对<code>list_heads</code>数组进行任何其他初始化。 相反，我们将在<code>alloc</code>和<code>dealloc</code>调用时lazy地初始化列表。</p><p>为了方便起见，我们还创建了一个私有<code>fallback_alloc</code>方法，该方法使用<code>fallback_allocator</code>分配空间：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>alloc</span>::<span class=n>Layout</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=n>ptr</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>FixedSizeBlockAllocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Allocates using the fallback allocator.
</span><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>fallback_alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>fallback_allocator</span><span class=p>.</span><span class=n>allocate_first_fit</span><span class=p>(</span><span class=n>layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>ptr</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>ptr</span>::<span class=n>null_mut</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>由于<code>linked_list_allocator</code>crate的<a href=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.Heap.html target=_blank rel=noopener><code>Heap</code></a>类型无法实现<a href=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html target=_blank rel=noopener><code>GlobalAlloc</code></a>（因为如果没有锁，这是不可能的）。而是提供了<a href=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.Heap.html#method.allocate_first_fit target=_blank rel=noopener><code>allocate_first_fit</code></a>这样一个接口稍有不同的方法。它返回<code>Result&lt;NonNull&lt;u8>, AllocErr></code>，而不是返回 <code>*mut u8</code>并使用空指针来表示错误。该<a href=https://doc.rust-lang.org/nightly/core/ptr/struct.NonNull.html target=_blank rel=noopener><code>NonNull</code></a>类型是保证非空的原始指针的抽象。<a href=https://doc.rust-lang.org/nightly/core/alloc/struct.AllocErr.html target=_blank rel=noopener><code>AllocErr</code></a>是用于标记分配错误的类型。通过将<code>Ok</code>case 映射到<a href=https://doc.rust-lang.org/nightly/core/ptr/struct.NonNull.html#method.as_ptr target=_blank rel=noopener><code>NonNull::as_ptr</code></a>方法并将<code>Err</code>case 映射到空指针，我们可以轻松地将其转换回<code>*mut u8</code>类型。</p><h4 id=计算链表索引><a href=#计算链表索引 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:计算链表索引 class=headings>计算链表索引</a></h4><p>在实现<code>GlobalAlloc</code>特征之前，我们定义一个<code>list_index</code>辅助函数，该函数对一个<a href=https://doc.rust-lang.org/alloc/alloc/struct.Layout.html target=_blank rel=noopener><code>Layout</code></a>返回给定的最小可能块大小：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=sd>/// Choose an appropriate block size for the given layout.
</span><span class=sd>///
</span><span class=sd>/// Returns an index into the `BLOCK_SIZES` array.
</span><span class=sd></span><span class=k>fn</span> <span class=nf>list_index</span><span class=p>(</span><span class=n>layout</span>: <span class=kp>&amp;</span><span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>required_block_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>layout</span><span class=p>.</span><span class=n>size</span><span class=p>().</span><span class=n>max</span><span class=p>(</span><span class=n>layout</span><span class=p>.</span><span class=n>align</span><span class=p>());</span><span class=w>
</span><span class=w>    </span><span class=n>BLOCK_SIZES</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>position</span><span class=p>(</span><span class=o>|&amp;</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>required_block_size</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>被分配的块必须至少具有给定<code>Layout</code>所需的大小和对齐方式。由于我们让块的大小等于其对齐到的大小，因此这意味着<code>required_block_size</code>是<code>size()</code>和<code>align()</code>属性的<a href=https://doc.rust-lang.org/core/cmp/trait.Ord.html#method.max target=_blank rel=noopener>最大值</a>。要查找<code>BLOCK_SIZES</code>切片中首个比所要求的更大的块，我们首先使用<code>iter()</code>方法来获得迭代器，然后使用<code>position</code>方法来找到第一个大小大于等于要求的块的索引。</p><p>请注意，我们不返回块大小本身，而是返回<code>BLOCK_SIZES</code>切片的索引。原因是我们要使用返回的索引作为<code>list_heads</code>数组的索引。</p><h4 id=实现globalalloc-2><a href=#实现globalalloc-2 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:实现globalalloc-2 class=headings>实现<code>GlobalAlloc</code></a></h4><p>最后一步是实现<code>GlobalAlloc</code> trait：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=n>Locked</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>alloc</span>::<span class=n>GlobalAlloc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Locked</span><span class=o>&lt;</span><span class=n>FixedSizeBlockAllocator</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>todo</span><span class=o>!</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>todo</span><span class=o>!</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>像其他分配器一样，我们不直接为<code>GlobalAlloc</code>分配器类型实现trait，而是使用<a href=https://os.phil-opp.com/allocator-designs#a-locked-wrapper-type target=_blank rel=noopener><code>Locked</code>包装器</a>添加同步的内部可变性。由于<code>alloc</code>和的<code>dealloc</code>的实现相对较大，因此我们在下面逐一介绍它们。</p><h5 id=alloc><a href=#alloc class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:alloc class=headings><code>alloc</code></a></h5><p>该<code>alloc</code>方法的实现如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in `impl` block in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>list_index</span><span class=p>(</span><span class=o>&amp;</span><span class=n>layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>index</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>match</span><span class=w> </span><span class=n>allocator</span><span class=p>.</span><span class=n>list_heads</span><span class=p>[</span><span class=n>index</span><span class=p>].</span><span class=n>take</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=nb>Some</span><span class=p>(</span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=n>allocator</span><span class=p>.</span><span class=n>list_heads</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=n>next</span><span class=p>.</span><span class=n>take</span><span class=p>();</span><span class=w>
</span><span class=w>                    </span><span class=n>node</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=n>ListNode</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>                </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=c1>// no block exists in list =&gt; allocate new block
</span><span class=c1></span><span class=w>                    </span><span class=kd>let</span><span class=w> </span><span class=n>block_size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BLOCK_SIZES</span><span class=p>[</span><span class=n>index</span><span class=p>];</span><span class=w>
</span><span class=w>                    </span><span class=c1>// only works if all block sizes are a power of 2
</span><span class=c1></span><span class=w>                    </span><span class=kd>let</span><span class=w> </span><span class=n>block_align</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>block_size</span><span class=p>;</span><span class=w>
</span><span class=w>                    </span><span class=kd>let</span><span class=w> </span><span class=n>layout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Layout</span>::<span class=n>from_size_align</span><span class=p>(</span><span class=n>block_size</span><span class=p>,</span><span class=w> </span><span class=n>block_align</span><span class=p>)</span><span class=w>
</span><span class=w>                        </span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>                    </span><span class=n>allocator</span><span class=p>.</span><span class=n>fallback_alloc</span><span class=p>(</span><span class=n>layout</span><span class=p>)</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>allocator</span><span class=p>.</span><span class=n>fallback_alloc</span><span class=p>(</span><span class=n>layout</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>让我们一步步看：</p><p>首先，我们使用该<code>Locked::lock</code>方法来获取对包装后的分配器实例的可变引用。接下来，我们调用<code>list_index</code>刚刚定义的函数，以计算给定布局的适当块大小，并将相应的索引获取到<code>list_heads</code>数组中。如果此索引为<code>None</code>，则不适合该分配的块大小，因此我们使用<code>fallback_allocator</code>using <code>fallback_alloc</code>函数。</p><p>如果列表索引为<code>Some</code>，则尝试<code>list_heads[index]</code>使用该<a href=https://doc.rust-lang.org/core/option/enum.Option.html#method.take target=_blank rel=noopener><code>Option::take</code></a>方法删除相应列表中的第一个节点。如果列表不为空，则进入语句的<code>Some(node)</code>分支，在<code>match</code>该处将列表的顶部指针指向弹出的后继对象<code>node</code>（<a href=https://doc.rust-lang.org/core/option/enum.Option.html#method.take target=_blank rel=noopener><code>take</code></a>再次使用）。最后，我们将弹出的<code>node</code>指针作为返回<code>*mut u8</code>。</p><p>如果列表头为<code>None</code>，则表示块列表为空。这意味着我们需要<a href=https://os.phil-opp.com/allocator-designs#creating-new-blocks target=_blank rel=noopener>如上所述</a>构建一个新块。为此，我们首先从<code>BLOCK_SIZES</code>切片中获取当前块的大小，并将其用作新块的大小和对齐方式。然后，我们<code>Layout</code>从中创建一个新对象，并调用该<code>fallback_alloc</code>方法来执行分配。调整布局和对齐方式的原因是，该块将在取消分配时添加到块列表中。</p><h4 id=dealloc><a href=#dealloc class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:dealloc class=headings><code>dealloc</code></a></h4><p><code>dealloc</code>方法的实现如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator/fixed_size_block.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=p>{</span><span class=n>mem</span><span class=p>,</span><span class=w> </span><span class=n>ptr</span>::<span class=n>NonNull</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// inside the `unsafe impl GlobalAlloc` block
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>list_index</span><span class=p>(</span><span class=o>&amp;</span><span class=n>layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>index</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>new_node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ListNode</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>next</span>: <span class=nc>allocator</span><span class=p>.</span><span class=n>list_heads</span><span class=p>[</span><span class=n>index</span><span class=p>].</span><span class=n>take</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=p>};</span><span class=w>
</span><span class=w>            </span><span class=c1>// verify that block has size and alignment required for storing node
</span><span class=c1></span><span class=w>            </span><span class=n>assert</span><span class=o>!</span><span class=p>(</span><span class=n>mem</span>::<span class=n>size_of</span>::<span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>BLOCK_SIZES</span><span class=p>[</span><span class=n>index</span><span class=p>]);</span><span class=w>
</span><span class=w>            </span><span class=n>assert</span><span class=o>!</span><span class=p>(</span><span class=n>mem</span>::<span class=n>align_of</span>::<span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>BLOCK_SIZES</span><span class=p>[</span><span class=n>index</span><span class=p>]);</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>new_node_ptr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ptr</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=n>ListNode</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=n>new_node_ptr</span><span class=p>.</span><span class=n>write</span><span class=p>(</span><span class=n>new_node</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=n>allocator</span><span class=p>.</span><span class=n>list_heads</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>*</span><span class=n>new_node_ptr</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>ptr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>NonNull</span>::<span class=n>new</span><span class=p>(</span><span class=n>ptr</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=n>allocator</span><span class=p>.</span><span class=n>fallback_allocator</span><span class=p>.</span><span class=n>deallocate</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span><span class=w> </span><span class=n>layout</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>像<code>alloc</code>中一样，我们首先使用<code>lock</code>方法获取可变的分配器引用，然后使用<code>list_index</code>函数获取与给定<code>Layout</code>对应的块列表。如果index为<code>None</code>，则不存在合适的块大小<code>BLOCK_SIZES</code>，这表明该分配是由后备分配器创建的。因此，我们使用后备分配器的<a href=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.Heap.html#method.deallocate target=_blank rel=noopener><code>deallocate</code></a>释放内存。该方法期望使用 <a href=https://doc.rust-lang.org/nightly/core/ptr/struct.NonNull.html target=_blank rel=noopener><code>NonNull</code></a>而不是 <code>*mut u8</code>，因此我们需要先转换指针。 （<code>unwrap</code>仅在指针为null时调用失败，这在编译器调用<code>dealloc</code>时永远不会发生。）</p><p>如果<code>list_index</code>返回了块索引，则需要将释放的内存块添加到列表中。为此，我们首先创建一个<code>ListNode</code>指向当前列表头的新内容（通过再次使用<a href=https://doc.rust-lang.org/core/option/enum.Option.html#method.take target=_blank rel=noopener><code>Option::take</code></a>）。在将新节点写入释放的内存块之前，我们首先要断言由指定的当前块大小<code>index</code>具有存储<code>ListNode</code>大小和对齐方式所需的空间。然后，我们通过将给定的<code>*mut u8</code>指针转换为<code>*mut ListNode</code>指针，然后<a href=https://doc.rust-lang.org/std/primitive.pointer.html#method.write target=_blank rel=noopener><code>write</code></a>在其上调用unsafe 方法来执行写操作。最后一步是将列表的起始指针设置为新创建的结点。为此，我们将原始指针<code>new_node_ptr</code>转换为可变引用。</p><p>有几件事值得注意：</p><ul><li>我们不区分从块列表分配的块和从后备分配器分配的块。这意味着在<code>alloc</code>中创建的新块将添加到上的块列表中<code>dealloc</code>，从而增加了该大小的块数。</li><li>该<code>alloc</code>方法是在我们的实现中唯一创建新块的地方。这意味着我们最初从空块列表开始，仅在执行针对该块大小的分配时才懒惰地填充列表。</li><li>即使我们执行了某些<code>unsafe</code>操作，也不需要在<code>alloc</code>和<code>dealloc</code>中添加<code>unsafe</code>块。原因是Rust目前将<code>unsafe</code>函数的全部视为一个大<code>unsafe</code>块。由于使用显式块具有明显的优点，即哪些操作不安全，哪些操作不安全，因此<a href=https://github.com/rust-lang/rfcs/pull/2585 target=_blank rel=noopener>有一个RFC</a>建议更改此行为。</li></ul><h3 id=使用-2><a href=#使用-2 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用-2 class=headings>使用</a></h3><p>要使用新的 <code>FixedSizeBlockAllocator</code>，我们需要更新<code>allocator</code>模块中的<code>ALLOCATOR</code>静态变量：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>fixed_size_block</span>::<span class=n>FixedSizeBlockAllocator</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[global_allocator]</span><span class=w>
</span><span class=w></span><span class=k>static</span><span class=w> </span><span class=n>ALLOCATOR</span>: <span class=nc>Locked</span><span class=o>&lt;</span><span class=n>FixedSizeBlockAllocator</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Locked</span>::<span class=n>new</span><span class=p>(</span><span class=w>
</span><span class=w>    </span><span class=n>FixedSizeBlockAllocator</span>::<span class=n>new</span><span class=p>());</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>由于<code>init</code>函数对于我们实现的所有分配器的行为均相同，因此无需修改<code>init_heap</code>中的<code>init</code>调用。</p><p>现在，当我们再次运行<code>heap_allocation</code>测试时，所有测试仍应通过：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>&gt; cargo xtest --test heap_allocation
simple_allocation... [ok]
large_vec... [ok]
many_boxes... [ok]
many_boxes_long_lived... [ok]
</code></pre></td></tr></table></div></div></div><p>我们的新分配器似乎可以正常工作！</p><h3 id=讨论-2><a href=#讨论-2 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:讨论-2 class=headings>讨论</a></h3><p>尽管固定大小的块方法比链表方法具有更好的性能，但是当使用2的幂作为块大小时，它最差情况下会浪费多达一半的内存。这种权衡是否值得，在很大程度上取决于应用程序类型。对于性能至关重要的操作系统内核，固定大小块方法似乎是更好的选择。</p><p>在实现方面，我们可以在当前的实现中进行很多改进：</p><ul><li>与其仅使用后备分配器Lazy地分配块，还不如预先填充列表以提高初始分配的性能。</li><li>为了简化实现，我们只允许块大小为2的幂，以便我们也可以将它们用作块对齐。通过以不同的方式存储（或计算）对齐方式，我们还可以允许任意其他块大小。这样，我们可以增加更多的块大小，例如常见的分配大小，以最大程度地减少浪费的内存。</li><li>目前，我们仅创建新的块，但不再释放它们。这会导致碎片，最终可能导致大块内存的分配请求失败。为每种块大小列表强制设置最大长度可能是一个好的选择。当达到最大长度时，后续的释放使用后备分配器进行，而不是将其添加到列表中。</li><li>我们可以使用一个特殊的分配器来分配大于4KiB的内存，而不是使用链表分配器。这个想法利用了在4KiB页面上运行的<a href=https://os.phil-opp.com/paging-introduction target=_blank rel=noopener>分页</a>可以将连续的虚拟内存块映射到非连续的物理帧。这样，未分配内存的碎片对于大分配而言不再是问题。</li><li>使用这样的页面分配器，可能有必要添加最大4KiB的块大小并完全删除链表分配器。这样做的主要优点是减少了碎片并提高了性能可预测性，即更好的最坏情况性能。</li></ul><p>请务必注意，上面概述的实现上的改进仅是建议。操作系统内核中使用的分配器通常会针对内核的特定工作负载进行高度优化，这只有通过广泛的性能分析才能实现。</p><h3 id=变化><a href=#变化 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:变化 class=headings>变化</a></h3><p>固定大小的块分配器设计也有很多变体。<em>slab分配器</em>和<em>伙伴分配器</em>是两个流行的示例，它们也用在诸如Linux之类的流行内核中。下面，我们对这两种设计进行简短介绍。</p><h4 id=slab分配器><a href=#slab分配器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:slab分配器 class=headings>slab分配器</a></h4><p><a href=https://en.wikipedia.org/wiki/Slab_allocation target=_blank rel=noopener><em>slab</em>分配器</a>的思想是使用与内核中选定类型直接对应的块大小。这样，那些类型的分配恰好适合块大小，并且不会浪费内存。有时，甚至有可能在未使用的块中预先初始化好类型实例，以进一步提高性能。</p><p>slab分配通常与其他分配器结合使用。例如，它可以与固定大小的块分配器一起使用，以进一步拆分分配的块，以减少内存浪费。它还经常用于在一次分配大块内存，然后在这块内存上实现<a href=https://en.wikipedia.org/wiki/Object_pool_pattern target=_blank rel=noopener>对象池模式</a>。</p><h4 id=伙伴分配器><a href=#伙伴分配器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:伙伴分配器 class=headings>伙伴分配器</a></h4><p><a href=https://en.wikipedia.org/wiki/Buddy_memory_allocation target=_blank rel=noopener>伙伴分配器</a>设计不是使用链表来管理释放的块，而是使用<a href=https://en.wikipedia.org/wiki/Binary_tree target=_blank rel=noopener>二叉树</a>数据结构以及2的幂次方块大小。当需要一定大小的新块时，它将一个较大的块分成两半，从而在树中创建两个子节点。每当再次释放一个块时，就会分析树中的相邻块。如果邻居也是空的，则将两个块重新连接在一起，成为一个大小两倍的块。</p><p>此合并过程的优点是减少了<a href=https://en.wikipedia.org/wiki/Fragmentation_(computing)#External_fragmentation target=_blank rel=noopener>外部碎片</a>，因此可以将较小的释放块重新用于较大的分配。它还不使用后备分配器，因此性能更可预测。最大的缺点是只能使用2的幂次的块大小，这可能会由于<a href=https://en.wikipedia.org/wiki/Fragmentation_(computing)#Internal_fragmentation target=_blank rel=noopener>内部碎片</a>而导致大量的内存浪费。因此，伙伴分配器通常与slab分配器结合使用，以将分配的块进一步拆分为多个较小的块。</p><h2 id=总结><a href=#总结 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:总结 class=headings>总结</a></h2><p>这篇文章概述了不同的分配器设计。我们学习了如何实现基本的<a href=https://os.phil-opp.com/allocator-designs#bump-allocator target=_blank rel=noopener>Bump分配器</a>，该<a href=https://os.phil-opp.com/allocator-designs#bump-allocator target=_blank rel=noopener>分配器</a>通过增加单个<code>next</code>指针来线性<a href=https://os.phil-opp.com/allocator-designs#bump-allocator target=_blank rel=noopener>分配</a>内存。虽然Bump分配非常快，但是只有释放所有分配后，它才能重新使用内存。因此，它很少用作全局分配器。</p><p>接下来，我们创建了一个<a href=https://os.phil-opp.com/allocator-designs#linked-list-allocator target=_blank rel=noopener>链表分配器</a>，该<a href=https://os.phil-opp.com/allocator-designs#linked-list-allocator target=_blank rel=noopener>分配器</a>使用空闲的内存块本身来创建链表，即所谓的<a href=https://en.wikipedia.org/wiki/Free_list target=_blank rel=noopener>链表</a>。该列表可以存储任意数量的大小不同的已释放块。尽管不会发生内存浪费，但是由于分配请求可能需要完整遍历列表，因此该方法的性能很差。我们的实现还遭受<a href=https://en.wikipedia.org/wiki/Fragmentation_(computing)#External_fragmentation target=_blank rel=noopener>外部碎片</a>的困扰，因为它不会将相邻的释放块重新合并在一起。</p><p>为了解决链表方法的性能问题，我们创建了一个<a href=https://os.phil-opp.com/allocator-designs#fixed-size-block-allocator target=_blank rel=noopener>固定大小块分配器</a>，该<a href=https://os.phil-opp.com/allocator-designs#fixed-size-block-allocator target=_blank rel=noopener>分配器</a>预定义了一组固定的块大小。对于每个块大小，都存在一个单独的<a href=https://en.wikipedia.org/wiki/Free_list target=_blank rel=noopener>空闲列表</a>，因此分配和取消分配只需要在<a href=https://en.wikipedia.org/wiki/Free_list target=_blank rel=noopener>列表的</a>开头插入/弹出，因此非常快。由于每个分配都向上舍入到下一个更大的块大小，因此由于<a href=https://en.wikipedia.org/wiki/Fragmentation_(computing)#Internal_fragmentation target=_blank rel=noopener>内部碎片</a>而浪费了一些内存。</p><p>还有更多具有不同权衡取舍的分配器设计。<a href=https://os.phil-opp.com/allocator-designs#slab-allocator target=_blank rel=noopener>slab分配</a>可以很好地优化常见固定大小结构的分配，但并非在所有情况下都适用。<a href=https://os.phil-opp.com/allocator-designs#buddy-allocator target=_blank rel=noopener>伙伴分配</a>使用二叉树将释放的块合并回去，但浪费了大量内存，因为它仅支持2次幂的块大小。同样重要的是要记住，每个内核实现都有独特的工作负载，因此没有适合所有情况的“最佳”分配器设计。</p><h2 id=接下来是什么><a href=#接下来是什么 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:接下来是什么 class=headings>接下来是什么？</a></h2><p>通过这篇文章，我们现在就结束了我们的内存管理部分。接下来，我们将开始探索<a href=https://en.wikipedia.org/wiki/Computer_multitasking& target=_blank rel=noopener><em>多任务处理</em></a>，从<a href=https://en.wikipedia.org/wiki/Thread_(computing) target=_blank rel=noopener><em>线程</em></a>开始。在随后的文章中，我们将探索多处理器、进程以及基于async/await的协作式多任务处理。</p></div><ul class=post-copyright><li class="copyright-item author"><span class=copyright-item-text>作者</span>：<a href=https://io-oi.me/ class="p-author h-card" target=_blank rel=noopener>Justice</a></li><li class="copyright-item link"><span class=copyright-item-text>链接</span>：<a href=/post/09.pub/writing-an-os-in-rust/11-allocator-designs/ target=_blank rel=noopener>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/</a></li><li class="copyright-item license"><span class=copyright-item-text>许可</span>：<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></li></ul></article><div class=updated-badge-container><span title="Updated @ 2025-01-26 10:18:55 UTC" style=cursor:help><svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" class="updated-badge"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="a"><rect width="130" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#a)"><path class="updated-badge-left" d="M0 0h55v20H0z"/><path class="updated-badge-right" d="M55 0h75v20H55z"/><path fill="url(#b)" d="M0 0h130v20H0z"/></g><g fill="#fff" text-anchor="middle" font-size="110"><text x="285" y="150" fill="#010101" fill-opacity=".3" textLength="450" transform="scale(.1)">updated</text><text x="285" y="140" textLength="450" transform="scale(.1)">updated</text><text x="915" y="150" fill="#010101" fill-opacity=".3" textLength="650" transform="scale(.1)">2025-01-26</text><text x="915" y="140" textLength="650" transform="scale(.1)">2025-01-26</text></g></svg></span></div><div class=post-share><div class=share-items><div class="share-item facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&hashtag=%23MemoryManagement" title=分享到「Facebook」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon facebook-icon"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg></a></div><div class="share-item mastodon"><a href="/fedishare.html#title=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&description=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%a6%82%e4%bd%95%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%88%86%e9%85%8d%e5%99%a8%e3%80%82%e5%ae%83%e6%8f%90%e5%87%ba%e5%b9%b6%e8%ae%a8%e8%ae%ba%e4%ba%86%e4%b8%8d%e5%90%8c%e7%9a%84%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1%ef%bc%8c%e5%8c%85%e6%8b%acBump%e5%88%86%e9%85%8d%ef%bc%8c%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%9d%97%e5%88%86%e9%85%8d%e3%80%82%20%e5%af%b9%e4%ba%8e%e8%bf%99%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e7%a7%8d%ef%bc%8c%e6%88%91%e4%bb%ac%e5%b0%86%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e3%80%82&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/" title=分享到「Mastodon」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon mastodon-icon"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg></a></div><div class="share-item fediverse"><a href="/fedishare.html#title=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&description=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%a6%82%e4%bd%95%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%88%86%e9%85%8d%e5%99%a8%e3%80%82%e5%ae%83%e6%8f%90%e5%87%ba%e5%b9%b6%e8%ae%a8%e8%ae%ba%e4%ba%86%e4%b8%8d%e5%90%8c%e7%9a%84%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1%ef%bc%8c%e5%8c%85%e6%8b%acBump%e5%88%86%e9%85%8d%ef%bc%8c%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%9d%97%e5%88%86%e9%85%8d%e3%80%82%20%e5%af%b9%e4%ba%8e%e8%bf%99%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e7%a7%8d%ef%bc%8c%e6%88%91%e4%bb%ac%e5%b0%86%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e3%80%82&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/" title=分享到「Fediverse」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="64 163 873 873" class="icon fediverse-icon"><defs><linearGradient id="fediverse-gradient"><stop offset="0" stop-color="#ff0101"/><stop offset="10%" stop-color="#9501ff"/><stop offset="50%" stop-color="#ffca01"/><stop offset="75%" stop-color="#01a3ff"/><stop offset="100%" stop-color="#65ff01"/></linearGradient></defs><path d="M539 176q-32 0-55 22t-25 55 20.5 58 56 27 58.5-20.5 27-56-20.5-59T544 176h-5zm-87 95-232 118q20 20 25 48l231-118q-19-20-24-48zm167 27q-13 25-38 38l183 184q13-25 39-38zM477 320 342 585l40 40 143-280q-28-5-48-25zm104 16q-22 11-46 10l-8-1 21 132 56 9zM155 370q-32 0-55 22.5t-25 55 20.5 58 56.5 27 59-21 26.5-56-21-58.5-55.5-27h-6zm90 68q1 9 1 18-1 19-10 35l132 21 26-50zm225 36-26 51 311 49q-1-8-1-17 1-19 10-36zm372 6q-32 1-55 23t-24.5 55 21 58 56 27 58.5-20.5 27-56.5-20.5-59-56.5-27h-6zM236 493q-13 25-39 38l210 210 51-25zm-40 38q-21 11-44 10l-9-1 40 256q21-10 45-9l8 1zm364 22 48 311q21-10 44-9l10 1-46-294zm195 23-118 60 8 56 135-68q-20-20-25-48zm26 49-119 231q28 5 48 25l119-231q-28-5-48-25zM306 654l-68 134q28 5 48 25l60-119zm262 17-281 143q19 20 24 48l265-135zM513 771l-51 25 106 107q13-25 39-38zM222 795q-32 0-55.5 22.5t-25 55 21 57.5 56 27 58.5-20.5 27-56-20.5-58.5-56.5-27h-5zm89 68q2 9 1 18-1 19-9 35l256 41q-1-9-1-18 1-18 10-35zm335 0q-32 0-55 22.5t-24.5 55 20.5 58 56 27 59-21 27-56-20.5-58.5-56.5-27h-6z"/></svg></a></div><div class="share-item twitter"><a href="https://twitter.com/share?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&text=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&hashtags=MemoryManagement,&via=reuixiy" title=分享到「Twitter」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon twitter-icon"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></a></div><div class="share-item linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&title=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&summary=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%a6%82%e4%bd%95%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%88%86%e9%85%8d%e5%99%a8%e3%80%82%e5%ae%83%e6%8f%90%e5%87%ba%e5%b9%b6%e8%ae%a8%e8%ae%ba%e4%ba%86%e4%b8%8d%e5%90%8c%e7%9a%84%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1%ef%bc%8c%e5%8c%85%e6%8b%acBump%e5%88%86%e9%85%8d%ef%bc%8c%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%9d%97%e5%88%86%e9%85%8d%e3%80%82%20%e5%af%b9%e4%ba%8e%e8%bf%99%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e7%a7%8d%ef%bc%8c%e6%88%91%e4%bb%ac%e5%b0%86%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e3%80%82&source=Justice%27s%20Site" title=分享到「LinkedIn」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon linkedin-icon"><path d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></a></div><div class="share-item telegram"><a href="https://t.me/share/url?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&text=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1" title=分享到「Telegram」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon telegram-icon"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"/></svg></a></div><div class="share-item weibo"><a href="https://service.weibo.com/share/share.php?&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&title=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&pic=https://os.phil-opp.com/allocator-designs/bump-allocation.svg&searchPic=false" title=分享到「新浪微博」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon weibo-icon"><path d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7.0 395.3.0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"/></svg></a></div><div class="share-item douban"><a href="https://www.douban.com/share/service?href=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&name=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&text=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%a6%82%e4%bd%95%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%88%86%e9%85%8d%e5%99%a8%e3%80%82%e5%ae%83%e6%8f%90%e5%87%ba%e5%b9%b6%e8%ae%a8%e8%ae%ba%e4%ba%86%e4%b8%8d%e5%90%8c%e7%9a%84%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1%ef%bc%8c%e5%8c%85%e6%8b%acBump%e5%88%86%e9%85%8d%ef%bc%8c%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%9d%97%e5%88%86%e9%85%8d%e3%80%82%20%e5%af%b9%e4%ba%8e%e8%bf%99%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e7%a7%8d%ef%bc%8c%e6%88%91%e4%bb%ac%e5%b0%86%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e3%80%82" title=分享到「豆瓣」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon douban-icon"><path d="M.643.92v2.412h22.714V.92H.643zm1.974 4.926v9.42h18.764v-9.42H2.617zm2.72 2.408H18.69v4.605H5.338V8.254zm1.657 7.412-2.512.938c1.037 1.461 1.87 2.825 2.512 4.091H0v2.385h24v-2.385h-6.678c.818-1.176 1.589-2.543 2.303-4.091l-2.73-.938a29.952 29.952.0 01-2.479 5.03h-4.75c-.786-1.962-1.677-3.641-2.672-5.03z"/></svg></a></div><div class="share-item qq"><a href="https://connect.qq.com/widget/shareqq/index.html?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&title=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&summary=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%a6%82%e4%bd%95%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%88%86%e9%85%8d%e5%99%a8%e3%80%82%e5%ae%83%e6%8f%90%e5%87%ba%e5%b9%b6%e8%ae%a8%e8%ae%ba%e4%ba%86%e4%b8%8d%e5%90%8c%e7%9a%84%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1%ef%bc%8c%e5%8c%85%e6%8b%acBump%e5%88%86%e9%85%8d%ef%bc%8c%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%9d%97%e5%88%86%e9%85%8d%e3%80%82%20%e5%af%b9%e4%ba%8e%e8%bf%99%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e7%a7%8d%ef%bc%8c%e6%88%91%e4%bb%ac%e5%b0%86%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e3%80%82&pics=https://os.phil-opp.com/allocator-designs/bump-allocation.svg&site=Justice%27s%20Site" title=分享到「QQ」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon qq-icon"><path d="M433.754 420.445c-11.526 1.393-44.86-52.741-44.86-52.741.0 31.345-16.136 72.247-51.051 101.786 16.842 5.192 54.843 19.167 45.803 34.421-7.316 12.343-125.51 7.881-159.632 4.037-34.122 3.844-152.316 8.306-159.632-4.037-9.045-15.25 28.918-29.214 45.783-34.415-34.92-29.539-51.059-70.445-51.059-101.792.0.0-33.334 54.134-44.859 52.741-5.37-.65-12.424-29.644 9.347-99.704 10.261-33.024 21.995-60.478 40.144-105.779C60.683 98.063 108.982.006 224 0c113.737.006 163.156 96.133 160.264 214.963 18.118 45.223 29.912 72.85 40.144 105.778 21.768 70.06 14.716 99.053 9.346 99.704z"/></svg></a></div><div class="share-item qzone"><a href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&title=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&summary=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%a6%82%e4%bd%95%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%88%86%e9%85%8d%e5%99%a8%e3%80%82%e5%ae%83%e6%8f%90%e5%87%ba%e5%b9%b6%e8%ae%a8%e8%ae%ba%e4%ba%86%e4%b8%8d%e5%90%8c%e7%9a%84%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1%ef%bc%8c%e5%8c%85%e6%8b%acBump%e5%88%86%e9%85%8d%ef%bc%8c%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%9d%97%e5%88%86%e9%85%8d%e3%80%82%20%e5%af%b9%e4%ba%8e%e8%bf%99%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e7%a7%8d%ef%bc%8c%e6%88%91%e4%bb%ac%e5%b0%86%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e3%80%82&pics=https://os.phil-opp.com/allocator-designs/bump-allocation.svg&site=Justice%27s%20Site" title="分享到「QQ 空间」" target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon qzone-icon"><path d="M23.985 9.202c-.032-.099-.127-.223-.334-.258-.207-.036-7.351-1.406-7.351-1.406s-.105-.022-.198-.07c-.092-.047-.127-.167-.127-.167S12.447.956 12.349.77C12.25.583 12.104.532 12 .532s-.251.051-.349.238c-.098.186-3.626 6.531-3.626 6.531s-.035.12-.128.167c-.092.047-.197.07-.197.07S.556 8.908.348 8.943c-.208.036-.302.16-.333.258a.477.477.0 00.125.449l5.362 5.49s.072.08.119.172c.016.104.005.21.005.21s-1.189 7.242-1.22 7.45.075.369.159.43c.083.062.233.106.421.013.189-.093 6.812-3.261 6.812-3.261s.098-.044.201-.061.201.061.201.061 6.623 3.168 6.812 3.261c.188.094.338.049.421-.013a.463.463.0 00.159-.43c-.021-.14-.93-5.677-.93-5.677.876-.54 1.425-1.039 1.849-1.747-2.594.969-6.006 1.717-9.415 1.866-.915.041-2.41.097-3.473-.015-.678-.071-1.17-.144-1.243-.438-.053-.215.054-.46.545-.831a2640.5 2640.5.0 012.861-2.155c1.285-.968 3.559-2.47 3.559-2.731.0-.285-2.144-.781-4.037-.781-1.945.0-2.275.132-2.811.168-.488.034-.769.005-.804-.138-.06-.248.183-.389.588-.568.709-.314 1.86-.594 1.984-.626.194-.052 3.082-.805 5.618-.535 1.318.14 3.244.668 3.244 1.276.0.342-1.721 1.494-3.225 2.597-1.149.843-2.217 1.561-2.217 1.688.0.342 3.533 1.241 6.689 1.01l.003-.022c.048-.092.119-.172.119-.172l5.362-5.49a.477.477.0 00.127-.449z"/></svg></a></div><div class="share-item pocket"><a href="https://getpocket.com/edit.php?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/" title=分享到「Pocket」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon pocket-icon"><path d="M407.6 64h-367C18.5 64 0 82.5.0 104.6v135.2C0 364.5 99.7 464 224.2 464c124 0 223.8-99.5 223.8-224.2V104.6c0-22.4-17.7-40.6-40.4-40.6zm-162 268.5c-12.4 11.8-31.4 11.1-42.4.0C89.5 223.6 88.3 227.4 88.3 209.3c0-16.9 13.8-30.7 30.7-30.7 17 0 16.1 3.8 105.2 89.3 90.6-86.9 88.6-89.3 105.5-89.3 16.9.0 30.7 13.8 30.7 30.7.0 17.8-2.9 15.7-114.8 123.2z"/></svg></a></div><div class="share-item hackernews"><a href="https://news.ycombinator.com/submitlink?u=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/&t=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1" title="分享到Hacker News" target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon hackernews-icon"><path d="M0 32v448h448V32H0zm21.2 197.2H21c.1-.1.2-.3.3-.4.0.1.0.3-.1.4zm218 53.9V384h-31.4V281.3L128 128h37.3c52.5 98.3 49.2 101.2 59.3 125.6 12.3-27 5.8-24.4 60.6-125.6H320l-80.8 155.1z"/></svg></a></div><div class="share-item qrcode"><div class=qrcode-container title=通过「二维码」><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon qrcode-icon"><path d="M0 224h192V32H0v192zM64 96h64v64H64V96zm192-64v192h192V32H256zm128 128h-64V96h64v64zM0 480h192V288H0v192zm64-128h64v64H64v-64zm352-64h32v128h-96v-32h-32v96h-64V288h96v32h64v-32zm0 160h32v32h-32v-32zm-64 0h32v32h-32v-32z"/></svg><div id=qrcode-img></div></div><script src=https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js></script>
<script>const typeNumber=0,errorCorrectionLevel='L',qr=qrcode(typeNumber,errorCorrectionLevel);qr.addData('https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/'),qr.make(),document.getElementById('qrcode-img').innerHTML=qr.createImgTag()</script></div><div class="share-item email"><a href="mailto:?subject=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1&body=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%a6%82%e4%bd%95%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e5%ae%9e%e7%8e%b0%e5%a0%86%e5%88%86%e9%85%8d%e5%99%a8%e3%80%82%e5%ae%83%e6%8f%90%e5%87%ba%e5%b9%b6%e8%ae%a8%e8%ae%ba%e4%ba%86%e4%b8%8d%e5%90%8c%e7%9a%84%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1%ef%bc%8c%e5%8c%85%e6%8b%acBump%e5%88%86%e9%85%8d%ef%bc%8c%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%ba%e5%ae%9a%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%9d%97%e5%88%86%e9%85%8d%e3%80%82%20%e5%af%b9%e4%ba%8e%e8%bf%99%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e7%a7%8d%ef%bc%8c%e6%88%91%e4%bb%ac%e5%b0%86%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e3%80%82%0Ahttps://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/" title=通过「电子邮件」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon email-icon"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V4e2c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5.0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg></a></div></div></div><div class=related-posts><h2 class=related-title>相关文章：<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon related-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6.0-12-5.4-12-12v-92h-92c-6.6.0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6.0 12 5.4 12 12v92h92c6.6.0 12 5.4 12 12v56z"/></svg></h2><ul class=related-list><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/10-heap-allocation/ class=related-link>分配堆内存</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/09-paging-implementation/ class=related-link>实现分页</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/08-introduction-to-paging/ class=related-link>介绍分页</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/03-vga-text-mode/ class=related-link>使用Rust编写操作系统（三）：VGA字符模式</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/04-testing/ class=related-link>使用Rust编写操作系统（四）：内核测试</a></li></ul></div><div class=post-tags><a href=/tags/memory-management/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Memory Management</a></div><ul class=post-nav><li class=post-nav-prev><a href=/post/50.ml/ai_cookbook/math_basic/1_algebra/ rel=prev>&lt; 线性代数</a></li><li class=post-nav-next><a href=/post/09.pub/writing-an-os-in-rust/12-async-await/ rel=next>Async/Await ></a></li></ul><div id=utterances></div></div></main><script>let indexURL="https://justice.bj.cn/index.json",includeSectionsInSearch=["post"],search_no_results="0 results for",search_initial_message=""</script><div class="search-modal dark" aria-hidden=true style=--color-primary:#7f0ec6><div data-target=close-search-modal class=search-modal-overlay></div><div class=search-wrapper data-image=true data-description=true data-tags=true data-categories=true><div class=search-wrapper-header><label for=search-modal-input style=margin-top:-1px><span class=sr-only>search icon</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-icon" data-type="search"><path fill="currentcolor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-reset" data-type="reset"><path fill="currentcolor" d="M256 512A256 256 0 10256 0a256 256 0 100 512zM175 175c9.4-9.4 24.6-9.4 33.9.0l47 47 47-47c9.4-9.4 24.6-9.4 33.9.0s9.4 24.6.0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6.0 33.9s-24.6 9.4-33.9.0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9.0s-9.4-24.6.0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6.0-33.9z"/></svg></label>
<input id=search-modal-input type=text data-search-input autocomplete=off aria-label=Search placeholder></div><div class=search-wrapper-body><div class=search-result data-search-result></div><span class=search-result-empty></span></div><div class=search-wrapper-footer><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16"><path d="M3.204 11h9.592L8 5.519 3.204 11zm-.753-.659 4.796-5.48a1 1 0 011.506.0l4.796 5.48c.566.647.106 1.659-.753 1.659H3.204a1 1 0 01-.753-1.659z"/></svg></kbd><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" style="margin-top:1px" viewBox="0 0 16 16"><path d="M3.204 5h9.592L8 10.481 3.204 5zm-.753.659 4.796 5.48a1 1 0 001.506.0l4.796-5.48c.566-.647.106-1.659-.753-1.659H3.204a1 1 0 00-.753 1.659z"/></svg></kbd>to navigate</span>
<span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentcolor" style="display:inline-block" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.5 1.5a.5.5.0 01.5.5v4.8a2.5 2.5.0 01-2.5 2.5H2.707l3.347 3.346a.5.5.0 01-.708.708l-4.2-4.2a.5.5.0 010-.708l4-4a.5.5.0 11.708.708L2.707 8.3H12.5A1.5 1.5.0 0014 6.8V2a.5.5.0 01.5-.5z"/></svg></kbd>to select</span>
<span class=search-result-info></span>
<span data-target=close-search-modal><kbd>ESC</kbd> to close</span></div></div></div><template id=search-result-item-template><div class=search-result-item>#{ isset image }<div class=search-result-item-image>#{image}</div>#{ end }<div class=search-result-item-body><a href=#{slug} class=search-result-item-title>#{title}</a>
#{ isset description }<p class=search-result-item-description>#{description}</p>#{ end }<p class=search-result-item-content>#{content}</p><div class=search-result-item-taxonomies>#{ isset categories }<div><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16" style="margin-top:-2px"><path d="M11 0H3A2 2 0 001 2v12a2 2 0 002 2h8a2 2 0 002-2 2 2 0 002-2V4a2 2 0 00-2-2 2 2 0 00-2-2zm2 3a1 1 0 011 1v8a1 1 0 01-1 1V3zM2 2a1 1 0 011-1h8a1 1 0 011 1v12a1 1 0 01-1 1H3a1 1 0 01-1-1V2z"/></svg>#{categories}</div>#{ end }
#{ isset tags }<div><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16"><path d="M3 2v4.586l7 7L14.586 9l-7-7H3zM2 2a1 1 0 011-1h4.586a1 1 0 01.707.293l7 7a1 1 0 010 1.414l-4.586 4.586a1 1 0 01-1.414.0l-7-7A1 1 0 012 6.586V2z"/><path d="M5.5 5a.5.5.0 110-1 .5.5.0 010 1zm0 1a1.5 1.5.0 100-3 1.5 1.5.0 000 3zM1 7.086a1 1 0 00.293.707L8.75 15.25l-.043.043a1 1 0 01-1.414.0l-7-7A1 1 0 010 7.586V3a1 1 0 011-1v5.086z"/></svg>#{tags}</div>#{ end }</div></div></div></template><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2013–2025&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Justice</div><div class=powered-by>Powered by <a href=https://github.com/gohugoio/hugo target=_blank rel=noopener>Hugo</a> | Theme is <a href=https://github.com/reuixiy/hugo-theme-meme target=_blank rel=noopener>MemE</a></div><div class=site-copyright><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></div><div class=busuanzi-site-uv-and-pv><span id=busuanzi_container_site_uv>本站访客数&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon busuanzi-site-uv"><path d="M224 256c70.7.0 128-57.3 128-128S294.7.0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2.0 422.4V464c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"/></svg>&nbsp;<span id=busuanzi_value_site_uv></span></span>&nbsp;|&nbsp;<span id=busuanzi_container_site_pv>本站访问量&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="icon busuanzi-site-pv"><path d="M288 144a110.94 110.94.0 00-31.24 5 55.4 55.4.0 017.24 27 56 56 0 01-56 56 55.4 55.4.0 01-27-7.24A111.71 111.71.0 10288 144zm284.52 97.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35.0 000 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35.0 000-29.19zM288 4e2c-98.65.0-189.09-55-237.93-144C98.91 167 189.34 112 288 112s189.09 55 237.93 144C477.1 345 386.66 4e2 288 4e2z"/></svg>&nbsp;<span id=busuanzi_value_site_pv></span></span></div><ul class=socials><li class=socials-item><a href=/rss.xml target=_blank rel="external noopener" title=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M19.199 24C19.199 13.467 10.533 4.8.0 4.8V0c13.165.0 24 10.835 24 24h-4.801zM3.291 17.415c1.814.0 3.293 1.479 3.293 3.295.0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526.0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727.0 15.909 7.184 15.909 15.91z"/></svg></a></li><li class=socials-item><a href=mailto:reuixiy@gmail.com target=_blank rel="external noopener" title=Email><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon social-icon"><path d="M464 64H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 4e2V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V4e2H48z"/></svg></a></li><li class=socials-item><a href=https://github.com/reuixiy target=_blank rel="external noopener" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a></li><li class=socials-item><a href=https://twitter.com/reuixiy target=_blank rel="external noopener" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon social-icon"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></a></li><li class=socials-item><a href=https://t.me/yixiuer target=_blank rel="external noopener" title=Telegram><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon social-icon"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"/></svg></a></li></ul></div></footer></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css><script>if(typeof renderMathInElement=='undefined'){const a=b=>{const a=document.createElement('script');a.defer=!0,a.crossOrigin='anonymous',Object.keys(b).forEach(c=>{a[c]=b[c]}),document.body.appendChild(a)};a({src:'https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js',onload:()=>{a({src:'https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/mhchem.min.js',onload:()=>{a({src:'https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js',onload:()=>{renderKaTex()}})}})}})}else renderKaTex();function renderKaTex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})}</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){const a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script>
<script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(a=>{a.parentElement.outerHTML=`<div class="mermaid">${a.innerText}</div>`});const mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script>function loadComments(){(function(){const b=document.getElementById("utterances");if(!b)return;const a=document.createElement('script');a.src='https://utteranc.es/client.js',a.async=!0,a.crossOrigin='anonymous',a.setAttribute('repo','ZhuZhengyi/gh_comment'),a.setAttribute('issue-term','pathname');const c=getCurrentTheme()==='dark';c?a.setAttribute('theme','photon-dark'):a.setAttribute('theme','github-light'),b.appendChild(a)})()}</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script>
<script>let imgNodes=document.querySelectorAll('div.post-body img');imgNodes=Array.from(imgNodes).filter(a=>a.parentNode.tagName!=="A"),mediumZoom(imgNodes,{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script>
<script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></body></html>