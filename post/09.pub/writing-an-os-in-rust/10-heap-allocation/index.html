<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.88.1"><meta name=theme-color content="#eee"><meta name=color-scheme content="light dark"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=referrer content="no-referrer"><title>分配堆内存 | Justice's Site</title><link rel=stylesheet href=/css/meme.min.9817bc2927846b0050dc426a67aa17fa82ec82b87efb1fbf54d04e1c5d660ff1.css><script src=/js/meme.min.a47e8b4e30b64bdbf742f15475cc3b6a642c07cbb9b9557e194a898081a8a42d.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Justice"><meta name=description content="这篇文章为我们的内核增加了对堆分配的支持。 首先，它介绍了动态内存，并展示了借用检查器如何防止常见的分配错误。 然后，它实现Rust的基本分配接口，创建一个堆内存区域，并设置一个分配器crate。 在这篇文章的结尾，内置分配crate的所有分配和收集类型将对我们的内核可用。"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Justice's Site"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Justice's Site"><meta name=msapplication-starturl content="../../../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2019-09-29T09:45:40+00:00","dateModified":"2024-08-25T13:04:05+00:00","url":"https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/","headline":"分配堆内存","description":"这篇文章为我们的内核增加了对堆分配的支持。 首先，它介绍了动态内存，并展示了借用检查器如何防止常见的分配错误。 然后，它实现Rust的基本分配接口，创建一个堆内存区域，并设置一个分配器crate。 在这篇文章的结尾，内置分配crate的所有分配和收集类型将对我们的内核可用。","inLanguage":"zh-cn","articleSection":"post","wordCount":10767,"image":["https://os.phil-opp.com/heap-allocation/call-stack.svg","https://os.phil-opp.com/heap-allocation/call-stack-static.svg","https://os.phil-opp.com/heap-allocation/call-stack-heap.svg","https://os.phil-opp.com/heap-allocation/call-stack-heap-freed.svg","https://os.phil-opp.com/heap-allocation/qemu-dummy-output.png","https://os.phil-opp.com/heap-allocation/qemu-alloc-showcase.png"],"author":{"@type":"Person","description":"Viva La Vida","email":"justice_103@126.com","image":"https://justice.bj.cn/icons/apple-touch-icon.png","url":"https://io-oi.me/","name":"Justice"},"license":"[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)","publisher":{"@type":"Organization","name":"Justice's Site","logo":{"@type":"ImageObject","url":"https://justice.bj.cn/icons/apple-touch-icon.png"},"url":"https://justice.bj.cn"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://justice.bj.cn"}}</script><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@reuixiy"><meta name=twitter:creator content="@reuixiy"><meta property="og:title" content="分配堆内存"><meta property="og:description" content="这篇文章为我们的内核增加了对堆分配的支持。 首先，它介绍了动态内存，并展示了借用检查器如何防止常见的分配错误。 然后，它实现Rust的基本分配接口，创建一个堆内存区域，并设置一个分配器crate。 在这篇文章的结尾，内置分配crate的所有分配和收集类型将对我们的内核可用。"><meta property="og:url" content="https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/"><meta property="og:site_name" content="Justice's Site"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://os.phil-opp.com/heap-allocation/call-stack.svg"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-09-29T09:45:40+00:00"><meta property="article:modified_time" content="2024-08-25T13:04:05+00:00"><meta property="article:section" content="post"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Justice's Site</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=/><span class=menu-item-name>主页</span></a></li><li class=menu-item><a href=/post/><span class=menu-item-name>点滴</span></a></li><li class=menu-item><a href=/tags/><span class=menu-item-name>标签</span></a></li><li class=menu-item><a href=/categories/><span class=menu-item-name>分类</span></a></li><li class=menu-item><a href=/about><span class=menu-item-name>关于</span></a></li><li class=menu-item><a href=http://passer-by.com/pacman/><span class=menu-item-name>更多</span></a></li><li class=menu-item><a id=theme-switcher href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-light"><path d="M193.2 104.5 242 7a18 18 0 0128 0l48.8 97.5L422.2 70A18 18 0 01442 89.8l-34.5 103.4L505 242a18 18 0 010 28l-97.5 48.8L442 422.2A18 18 0 01422.2 442l-103.4-34.5L270 505a18 18 0 01-28 0l-48.8-97.5L89.8 442A18 18 0 0170 422.2l34.5-103.4-97.5-48.8a18 18 0 010-28l97.5-48.8L70 89.8A18 18 0 0189.8 70zM256 128a128 128 0 10.01.0M256 160a96 96 0 10.01.0"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-dark"><path d="M27 412A256 256 0 10181 5a11.5 11.5.0 00-5 20A201.5 201.5.0 0142 399a11.5 11.5.0 00-15 13"/></svg></a></li><a id=search-btn href=# class="menu-item search-item" data-target=search-modal><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="16" width="16" class="search-icon" data-type="search"><path fill="currentcolor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg></a></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=justify data-type=post data-toc-num=true><h1 class="post-title p-name">分配堆内存</h1><div class=post-meta><time datetime=2019-09-29T09:45:40+00:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2019.9.29</time>
<time datetime=2024-08-25T13:04:05+00:00 class="post-meta-item modified dt-updated"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M4e2 64h-48V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H160V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H48C21.49 64 0 85.49.0 112v352c0 26.51 21.49 48 48 48h352c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 4e2H54a6 6 0 01-6-6V160h352v298a6 6 0 01-6 6zm-52.849-200.65L198.842 404.519c-4.705 4.667-12.303 4.637-16.971-.068l-75.091-75.699c-4.667-4.705-4.637-12.303.068-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l44.104 44.461 111.072-110.181c4.705-4.667 12.303-4.637 16.971.068l22.536 22.718c4.667 4.705 4.636 12.303-.069 16.97z"/></svg>&nbsp;2024.8.25</time>
<span class="post-meta-item category"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M464 128H272l-54.63-54.63c-6-6-14.14-9.37-22.63-9.37H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V176c0-26.51-21.49-48-48-48zm0 272H48V112h140.12l54.63 54.63c6 6 14.14 9.37 22.63 9.37H464v224z"/></svg>&nbsp;<a href=/post/ class="category-link p-category">滴水穿石</a></span>
<span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3.0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9.0l60.1 60.1c18.8 18.7 18.8 49.1.0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3.0-17l-111-111c-4.8-4.7-12.4-4.7-17.1.0zM124.1 339.9c-5.5-5.5-5.5-14.3.0-19.8l154-154c5.5-5.5 14.3-5.5 19.8.0s5.5 14.3.0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8.0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;10767</span>
<span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5.0-2e2-89.5-2e2-2e2S145.5 56 256 56s2e2 89.5 2e2 2e2-89.5 2e2-2e2 2e2zm61.8-104.4-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6.0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;22&nbsp;分钟</span>
<span class="post-meta-item busuanzi-page-pv" id=busuanzi_container_page_pv><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="icon post-meta-icon"><path d="M288 144a110.94 110.94.0 00-31.24 5 55.4 55.4.0 017.24 27 56 56 0 01-56 56 55.4 55.4.0 01-27-7.24A111.71 111.71.0 10288 144zm284.52 97.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35.0 000 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35.0 000-29.19zM288 4e2c-98.65.0-189.09-55-237.93-144C98.91 167 189.34 112 288 112s189.09 55 237.93 144C477.1 345 386.66 4e2 288 4e2z"/></svg>&nbsp;<span id=busuanzi_value_page_pv></span></span></div><nav class=contents><h2 id=contents class=contents-title>目录</h2><ol class=toc><li><a id=contents:局部和静态变量 href=#局部和静态变量>局部和静态变量</a><ol><li><a id=contents:局部变量 href=#局部变量>局部变量</a></li><li><a id=contents:静态变量 href=#静态变量>静态变量</a></li></ol></li><li><a id=contents:动态内存 href=#动态内存>动态内存</a><ol><li><a id=contents:常见错误 href=#常见错误>常见错误</a></li><li><a id=contents:rust中的动态内存分配 href=#rust中的动态内存分配>Rust中的动态内存分配</a></li><li><a id=contents:用例 href=#用例>用例</a></li></ol></li><li><a id=contents:分配器接口 href=#分配器接口>分配器接口</a><ol><li><a id=contents:globalalloctrait href=#globalalloctrait><code>GlobalAlloc</code>Trait</a><ol><li><a id=contents:unsafe href=#unsafe>Unsafe</a></li></ol></li><li><a id=contents:dummyallocator href=#dummyallocator><code>DummyAllocator</code></a></li><li><a id=contents:global_allocator属性 href=#global_allocator属性>#<code>[global_allocator]</code>属性</a></li><li><a id=contents:alloc_error_handler属性 href=#alloc_error_handler属性><code>#[alloc_error_handler]</code>属性</a></li></ol></li><li><a id=contents:创建内核堆 href=#创建内核堆>创建内核堆</a></li><li><a id=contents:使用分配器-crate href=#使用分配器-crate>使用分配器 crate</a></li><li><a id=contents:添加测试 href=#添加测试>添加测试</a></li><li><a id=contents:总结 href=#总结>总结</a></li><li><a id=contents:接下来 href=#接下来>接下来？</a></li></ol></nav><div class="post-body e-content"><h2 id=局部和静态变量><a href=#局部和静态变量 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:局部和静态变量 class=headings>局部和静态变量</a></h2><p>当前，我们在内核中使用两种类型的变量：局部变量和<code>static</code>变量。 局部变量存储在<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/Call_stack&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiDjrmAp1RMPlkX43yI6cMjfgQlEg" target=_blank rel=noopener>调用堆栈</a>中，并且仅在所在的函数返回之前才有效。 静态变量存储在固定的内存位置，并且在程序的整个生命周期中始终有效。</p><h3 id=局部变量><a href=#局部变量 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:局部变量 class=headings>局部变量</a></h3><p>局部变量存储在<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/Call_stack&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiDjrmAp1RMPlkX43yI6cMjfgQlEg" target=_blank rel=noopener>调用堆栈中</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/Call_stack&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiDjrmAp1RMPlkX43yI6cMjfgQlEg" target=_blank rel=noopener>调用堆栈</a>是支持<code>push</code>和<code>pop</code>操作的<a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type) target=_blank rel=noopener>堆栈数据结构</a> 。 在每个函数里，编译器会将被调用函数的参数，返回地址和局部变量压入栈中：</p><p><img src=https://os.phil-opp.com/heap-allocation/call-stack.svg alt="An outer() and an inner(i: usize) function. Both have some local variables. Outer calls inner(1). The call stack contains the following slots: the local variables of outer, then the argument i = 1, then the return address, then the local variables of inner."></p><p>上面的示例显示了<code>inner</code>函数被<code>outer</code>函数调用之后的调用堆栈。 我们看到调用堆栈首先包含了<code>outer</code>的局部变量。 在<code>inner</code>调用中，参数<code>1</code>和函数的返回地址被压入栈中。 然后将控制权转移到<code>inner</code> ，从而开始压入其局部变量。</p><p><code>inner</code>函数返回后，将弹出其调用堆栈的一部分，仅保留<code>outer</code>函数的局部变量：</p><p>我们看到<code>inner</code>的局部变量仅在函数返回之前有效。 当我们使用某个值太久时，例如当我们尝试返回对局部变量的引用时，Rust编译器会强制检查这些生命周期并引发错误：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>inner</span><span class=p>(</span><span class=n>i</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=kt>u32</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span><span class=w>    </span><span class=o>&amp;</span><span class=n>z</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>（<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D6186a0f3a54f468e1de8894996d12819&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhcWnAktOoWRK84k152ti4sf_VPhQ" target=_blank rel=noopener>在Playground中运行示例</a>）</p><p>虽然在此示例中返回引用毫无意义，但在某些情况下，我们希望变量的寿命比函数更长。 当我们尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/cpu-exceptions/&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgwRvWr9gSPjeJgzsv7l7wShMNucg#loading-the-idt" target=_blank rel=noopener>加载中断描述符表</a>并不得不使用<code>static</code>变量来延长生存期时，我们已经在内核中看到了这种情况。</p><h3 id=静态变量><a href=#静态变量 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:静态变量 class=headings>静态变量</a></h3><p>静态变量存储在与堆栈分开的固定内存位置。 链接器在编译时分配了此存储位置，并编码在了可执行文件中。 静态变量在程序的完整运行时中都有效，因此它们具有<code>'static</code>生命周期，并且始终可以从局部变量中进行引用：</p><p><img src=https://os.phil-opp.com/heap-allocation/call-stack-static.svg alt="The same outer/inner example with the difference that inner has a static Z: [u32; 3] = [1,2,3]; and returns a &Z[i] reference"></p><p>在上面的示例中，当<code>inner</code>函数返回时，它的部分调用堆栈被销毁。静态变量位于一个不会被销毁的单独的内存范围内，因此<code>&Z[1]</code>引用在返回后仍然有效。</p><p>除了<code>'static</code>生命周期之外，静态变量还具有有用的属性：它们的位置在编译时确定，因此不需要引用即可访问它。 我们为<code>println</code>宏利用了该属性：通过在内部使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/vga-text-mode/&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhjKVQ-rVdxu77flCvGVy5Fx-CA02w#a-global-interface" target=_blank rel=noopener>静态<code>Writer</code></a> ，不需要<code>&mut Writer</code>引用即可调用该宏，这在我们无法访问任何其他变量的<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/cpu-exceptions/&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgwRvWr9gSPjeJgzsv7l7wShMNucg#implementation" target=_blank rel=noopener>异常处理程序</a>中非常有用。</p><p>但是，静态变量的此属性带来一个关键的缺点：默认情况下，它们是只读的。 Rust之所以要这样做是因为，例如，如果两个线程同时修改一个静态变量，则会发生<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/nomicon/races.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhjYe_MLT6P-PIV2jWQnPjP6WbgrPQ" target=_blank rel=noopener>数据争用</a> 。 修改静态变量的唯一方法是将其封装为<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/spin/0.5.2/spin/struct.Mutex.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiPigEeaETYxRVwZpm59ZJfQBqK7w" target=_blank rel=noopener><code>Mutex</code></a>类型，以确保在任何时间点仅存在一个<code>&mut</code>引用。 我们已经为<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/vga-text-mode/&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhjKVQ-rVdxu77flCvGVy5Fx-CA02w#spinlocks" target=_blank rel=noopener>静态VGA缓冲区<code>Writer</code></a>使用了<code>Mutex</code> 。</p><h2 id=动态内存><a href=#动态内存 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:动态内存 class=headings>动态内存</a></h2><p>局部变量和静态变量已经非常强大，可以满足大部分场合的要求。 但是，我们看到它们都有局限性：</p><ul><li>局部变量仅在所在函数或块结束之前有效。 这是因为它们存在于调用堆栈中，并在所在的函数返回后销毁。</li><li>静态变量在程序运行时始终有效，因此无法在不再需要时回收和重用其内存。 而且，它们的所有权语义不明确，并且可以从所有函数中访问，因此，当我们要修改它们时，需要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/spin/0.5.2/spin/struct.Mutex.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiPigEeaETYxRVwZpm59ZJfQBqK7w" target=_blank rel=noopener><code>Mutex</code></a>进行保护。</li></ul><p>局部和静态变量的另一个限制是它们具有固定的大小。 因此，当添加更多元素时，它们将无法存储动态增长的集合。 （Rust中有一些关于建议使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://github.com/rust-lang/rust/issues/48055&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhs9Pf2O2O5WPZ-Xvlj1DibDpm-Rg" target=_blank rel=noopener>未确定</a>大小的<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://github.com/rust-lang/rust/issues/48055&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhs9Pf2O2O5WPZ-Xvlj1DibDpm-Rg" target=_blank rel=noopener>右值</a>的建议，该值允许动态大小的局部变量，但它们仅在某些特定情况下有效。）</p><p>为了避免这些缺点，编程语言通常支持第三个内存区域：**堆 **来存储变量。 堆通过两个称为<code>allocate</code>和<code>deallocate</code>函数在运行时支持<em>动态内存分配</em> 。 它以以下方式工作： <code>allocate</code>函数返回指定大小的可用内存块，可用于存储变量。 然后，该变量将一直存在，直到通过调用对该变量的引用的<code>deallocate</code>函数将其<code>deallocate</code>为止。</p><p>让我们来看一个例子：</p><p><img src=https://os.phil-opp.com/heap-allocation/call-stack-heap.svg alt="The inner function calls allocate(size_of([u32; 3])), writes z.write([1,2,3]);, and returns (z as *mut u32).offset(i). The outer function does deallocate(y, size_of(u32)) on the returned value y."></p><p>在这里， <code>inner</code>函数使用堆内存而不是静态变量来存储<code>z</code> 。 它首先分配所需大小的内存块，然后返回<code>*mut u8</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgxBivPXeHGd4Lv7ZRfhxcOwPp25w#dereferencing-a-raw-pointer" target=_blank rel=noopener>原始指针</a> 。 然后，它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/ptr/fn.write.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhGBOZaaa9afSHJ_T9_KNkhBtR70w" target=_blank rel=noopener><code>ptr::write</code></a>方法将数组<code>[1,2,3]</code>写入其中。 在最后一步中，它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/std/primitive.pointer.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhjoDpBUUAFPMkakB2aev8GBAmlz1A#method.offset" target=_blank rel=noopener><code>offset</code></a>函数计算指向第<code>i</code>个元素的指针，然后将其返回。 （请注意，为简洁起见，我们在此示例函数中省略了一些必需的强制转换和unsafe块。）</p><p>分配的内存将一直存在，直到通过调用<code>deallocate</code>显式释放它为止。 因此，即使在<code>inner</code>返回并且调用栈的一部分被销毁之后，返回的指针仍然有效。 与静态内存相比，使用堆内存的优势在于，可以在释放内存后重用内存，这是通过<code>deallocate</code>中的<code>deallocate</code>调用实现的。 调用之后，情况如下：</p><p><img src=https://os.phil-opp.com/heap-allocation/call-stack-heap-freed.svg alt="The call stack contains the local variables of outer, the heap contains z[0] and z[2], but no longer z[1]."></p><p>我们看到<code>z[1]</code>的位置上又是空闲的了，可以重新用于下一个<code>allocate</code>调用。 但是，我们也看到<code>z[0]</code>和<code>z[2]</code>没有被释放，因为我们从未释放过它们。 这种错误称为<em>内存泄漏</em> ，通常是导致程序过度消耗内存的原因（试想一下，当我们在循环中重复调用<code>inner</code>时会发生什么）。 这看起来很糟糕，但是动态分配还可能会发生更多危险的错误类型。</p><h3 id=常见错误><a href=#常见错误 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:常见错误 class=headings>常见错误</a></h3><p>除了不幸的但不会使程序容易受到攻击的内存泄漏外，还有两种常见的错误类型，其后果更为严重：</p><ul><li>当我们在调用<code>deallocate</code>后意外地继续使用变量时，我们有一个所谓的<strong>use-after-free</strong>漏洞。这样的错误会导致未定义的行为，并且攻击者经常会利用它执行任意代码。</li><li>当我们不小心两次释放变量时，我们就有一个<strong>double-free</strong>漏洞。它可能在第一次<code>deallocate</code>调用之后释放在同一位置分配的另一个变量。 因此，它可能导致use-after-free漏洞。</li></ul><p>这些类型的漏洞是众所周知的，因此人们可能会期望大家现在已经学会了如何避免它们。 但是，他们并没有，仍然经常发现此类漏洞，例如Linux中最近发现的<a href=https://securityboulevard.com/2019/02/linux-use-after-free-vulnerability-found-in-linux-2-6-through-4-20-11/ target=_blank rel=noopener>use-after-free漏洞</a>允许任意代码执行。 这表明即使是最好的程序员也不一定总是能够正确处理复杂项目中的动态内存。</p><p>为了避免这些问题，许多语言（例如Java或Python）都使用称为<a href=https://en.wikipedia.org/wiki/Garbage_collection_(computer_science) target=_blank rel=noopener><em>垃圾回收</em></a>的技术自动管理动态内存。 这种方法让程序员永远不要手动调用<code>deallocate</code> 。 而是定期暂停程序并扫描未使用的堆变量，然后将它们自动释放。 因此，上述漏洞永远不会发生。 缺点是常规扫描的性能开销以及可能较长的暂停时间。</p><p>Rust针对此问题采用了不同的方法：它使用一种称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiXg-xhyAHe5PuaeLsNN8Nsck3u9g" target=_blank rel=noopener><em>所有权</em></a>的概念，该概念能够在编译时检查动态内存操作的正确性。 因此，不需要垃圾收集来避免提到的漏洞，这意味着没有性能开销。 这种方法的另一个优点是，程序员仍然可以像使用C或C ++一样对动态内存的使用进行细粒度的控制。</p><h3 id=rust中的动态内存分配><a href=#rust中的动态内存分配 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:rust中的动态内存分配 class=headings>Rust中的动态内存分配</a></h3><p>Rust标准库提供了抽象类型来隐式调用这些函数，而不是让程序员手动调用<code>allocate</code>和<code>deallocate</code> 。 最重要的类型是<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/std/boxed/index.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgydQDRRu9l94xRKsKXfpC58IaGQQ" target=_blank rel=noopener><strong>Box</strong></a> ，它是堆分配值的抽象。 它提供了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/boxed/struct.Box.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiALFCmMq4SQmt-_lR3sbOud4Zh8g#method.new" target=_blank rel=noopener><code>Box::new</code></a>构造函数，该函数接受一个值，使用该值的大小调用<code>allocate</code> ，然后将该值移动到堆上新分配的插槽中。 为了再次释放堆内存， <code>Box</code>类型实现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/book/ch15-03-drop.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiheLdRjZNyOmgfBOzki5tmpGGmEA" target=_blank rel=noopener><code>Drop</code>特性</a>以在超出范围时调用<code>deallocate</code> ：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>]);</span><span class=w>
</span><span class=w>    </span><span class=p>[</span><span class=err>…</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> </span><span class=c1>// z goes out of scope and `deallocate` is called
</span></code></pre></td></tr></table></div></div></div><p>此模式有一个奇怪的名称， <a href=https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization target=_blank rel=noopener><em>资源获得即初始化</em></a> （或简称<em>RAII</em> ）。 它起源于C++，用于实现类似的抽象类型<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.cppreference.com/w/cpp/memory/unique_ptr&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiqCXA9Qx4dEIWJLDL41o5wPIwCJg" target=_blank rel=noopener><code>std::unique_ptr</code></a> 。</p><p>单靠这种类型不足以防止所有的use-after-free漏洞，因为在<code>Box</code>超出范围并释放相应的堆内存空间之后，程序员仍然可以保留对内容的引用：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>]);</span><span class=w>
</span><span class=w>    </span><span class=o>&amp;</span><span class=n>z</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w> </span><span class=c1>// z goes out of scope and `deallocate` is called
</span><span class=c1></span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>这就是Rust所有权机制起作用的地方。它为每个引用分配了抽象<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhheK8nR0_Zz4xow84YA4SkVmwPdbg" target=_blank rel=noopener>生命周期</a> ，这是该引用有效的范围。 在上面的示例中， <code>x</code>引用是从<code>z</code>数组中获取的，因此在<code>z</code>超出范围后，它将变为无效。 在<a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=28180d8de7b62c6b4a681a7b1f745a48" target=_blank rel=noopener>Playgroud中运行上述示例时</a>，您会看到Rust编译器确实报告了错误：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>error<span class=o>[</span>E0597<span class=o>]</span>: <span class=sb>`</span>z<span class=o>[</span>_<span class=o>]</span><span class=sb>`</span> does not live long enough
 --&gt; src/main.rs:4:9
  <span class=p>|</span>
<span class=m>2</span> <span class=p>|</span>     <span class=nb>let</span> <span class=nv>x</span> <span class=o>=</span> <span class=o>{</span>
  <span class=p>|</span>         - borrow later stored here
<span class=m>3</span> <span class=p>|</span>         <span class=nb>let</span> <span class=nv>z</span> <span class=o>=</span> Box::new<span class=o>([</span>1,2,3<span class=o>])</span><span class=p>;</span>
<span class=m>4</span> <span class=p>|</span>         <span class=p>&amp;</span>z<span class=o>[</span>1<span class=o>]</span>
  <span class=p>|</span>         ^^^^^ borrowed value does not live long enough
<span class=m>5</span> <span class=p>|</span>     <span class=o>}</span><span class=p>;</span> // z goes out of scope and <span class=sb>`</span>deallocate<span class=sb>`</span> is called
  <span class=p>|</span>     - <span class=sb>`</span>z<span class=o>[</span>_<span class=o>]</span><span class=sb>`</span> dropped here <span class=k>while</span> still borrowed
</code></pre></td></tr></table></div></div></div><p>一开始，这个错误提示可能会有些混乱。 创建一个值的引用被称为<em>借用</em>，因为它类似于现实生活中的借用：您可以临时访问某个对象，但需要在某个时候将其返回，并且不得销毁它。 通过检查所有借用在对象被销毁之前是否已结束，Rust编译器可以保证不会发生use-after-free。</p><p>Rust的所有权系统更进了一步，它不仅可以防止使用后使用的错误，而且可以像Java或Python这样的垃圾收集语言提供完全的<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/Memory_safety&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiUSIOCdxW0QA2oZubgSMT-wZKM7Q" target=_blank rel=noopener><em>内存安全性</em></a> 。 另外，它保证<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/Thread_safety&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgl5oGZfFqc51TdoKgVrffZcKjSfg" target=_blank rel=noopener><em>线程安全</em></a> ，Rust代码在多线程环境下比那些语言更安全。 最重要的是，所有这些检查都在编译时进行，因此与C中的手动内存管理相似，它没有运行时开销。</p><h3 id=用例><a href=#用例 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:用例 class=headings>用例</a></h3><p>现在我们知道Rust中动态内存分配的基础知识，但是什么时候应该使用它呢？ 没有动态内存分配的内核已经走得很远了，那么为什么现在需要它呢？</p><p>首先，动态内存分配总是会带来一些性能开销，因为我们需要为每个分配在堆上找到一个空闲空间。 因此，通常最好使用局部变量，尤其是在性能敏感的内核代码中。 但是，在某些情况下，动态内存分配是最佳选择。</p><p>基本规则是，具有动态生存期或可变大小的变量需要动态内存。 动态生存期最重要的类型是<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/rc/index.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhOvikyjnB-QTtPny0gSuSLpF9Tkw" target=_blank rel=noopener><strong>Rc</strong></a> ，它对其包装值的引用进行计数，并在所有引用离开作用域后将其释放。另外一些具有可变大小的类型的示例包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/vec/index.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhHCKQLyRM5nVe02J_5GfW_hJSj_g" target=_blank rel=noopener><strong>Vec</strong></a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/string/index.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhxFOZSUCPDiU1gZFAW_5Q5bksW7A" target=_blank rel=noopener><strong>String</strong></a>等<a href=https://doc.rust-lang.org/alloc/collections/index.html target=_blank rel=noopener>集合类型</a> ，这些<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/collections/index.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhihRW6JMQDicWS77B_50faSnHwSug" target=_blank rel=noopener>类型</a>会在添加更多元素时动态增长。 这些类型的工作方式是在它们装满时重新分配一块更大的内存，将所有元素复制过来，然后取消掉旧的分配。</p><p>对于我们的内核，我们最需要的是集合类型，例如，在以后的帖子中实现多任务处理时用于存储活动任务的列表。</p><h2 id=分配器接口><a href=#分配器接口 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:分配器接口 class=headings>分配器接口</a></h2><p>实现堆分配器的第一步是添加对内置<code>alloc</code>crate的依赖。 与<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhiAG6dIvJgsOsusTaEqJeByp29mQA" target=_blank rel=noopener><code>core</code></a>crate一样，它是标准库的子集，另外还包含分配和集合类型。 为了添加对<code>alloc</code>的依赖，我们将以下内容添加到我们的<code>lib.rs</code>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>extern</span><span class=w> </span><span class=k>crate</span><span class=w> </span><span class=n>alloc</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>与其他依赖不同，我们不需要修改<code>Cargo.toml</code> 。 原因是<code>alloc</code>crate与Rust编译器一起作为标准库的一部分提供，因此我们只需要启用它即可。 这就是这个<code>extern crate</code>语句的作用。（历史上，所有依赖项都需要一个<code>extern crate</code>语句，该语句现在是可选的）。</p><p><code>#[no_std]</code>默认禁用了<code>alloc</code>crate，其原因是它还有其他要求。 现在尝试编译项目时，我们可以从错误中提示看到这些要求：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>error: no global memory allocator found but one is required<span class=p>;</span> link to std or add
       <span class=c1>#[global_allocator] to a static item that implements the GlobalAlloc trait.</span>

error: <span class=sb>`</span><span class=c1>#[alloc_error_handler]` function required, but not found</span>
</code></pre></td></tr></table></div></div></div><p>发生第一个错误是因为分配箱需要堆分配器，该堆分配器是提供<code>allocate</code>和<code>deallocate</code>功能的对象。 在Rust中，堆分配器由<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg" target=_blank rel=noopener><code>GlobalAlloc</code></a>特性描述，该特性在错误消息中提到。 要为crate设置堆分配器，必须将<code>#[global_allocator]</code>属性应用于实现<code>GlobalAlloc</code> trait的<code>static</code>变量。</p><p>发生第二个错误是因为<code>allocate</code>调用可能失败，通常是在没有更多可用内存时失败。 我们的程序必须能够对这种情况做出反应，这就是<code>#[alloc_error_handler]</code>函数的作用。</p><p>在以下各节中，我们将详细描述这些特征和属性。</p><h3 id=globalalloctrait><a href=#globalalloctrait class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:globalalloctrait class=headings><code>GlobalAlloc</code>Trait</a></h3><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg" target=_blank rel=noopener><code>GlobalAlloc</code></a> Trait 定义了堆分配器必须提供的功能。 该Trait很特殊，因为程序员几乎从不直接使用它。 相反，当使用<code>alloc</code>分配内存和使用集合类型时，编译器将自动向trait中的方法插入适当的调用。</p><p>由于我们将需要为我们的分配器类型实现trait，因此有必要仔细研究其声明：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc_zeroed</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>realloc</span><span class=p>(</span><span class=w>
</span><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>layout</span>: <span class=nc>Layout</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>new_size</span>: <span class=kt>usize</span>
    <span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>它定义了两个必需的方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhixPH85ItX6ssyPAbPLnxIX8ZIpXA" target=_blank rel=noopener><code>alloc</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg#tymethod.dealloc" target=_blank rel=noopener><code>dealloc</code></a> ，它们与我们在示例中使用的<code>allocate</code>和<code>deallocate</code>函数相对应：</p><ul><li><a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhixPH85ItX6ssyPAbPLnxIX8ZIpXA" target=_blank rel=noopener><code>alloc</code></a>方法将<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/struct.Layout.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgfbVGb4vhKLhix2Ocb5VA9y29OfA" target=_blank rel=noopener><code>Layout</code></a>实例作为参数，该实例描述分配的内存应具有的所需大小和对齐方式。 它返回<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgxBivPXeHGd4Lv7ZRfhxcOwPp25w#dereferencing-a-raw-pointer" target=_blank rel=noopener>原始指针</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhgxBivPXeHGd4Lv7ZRfhxcOwPp25w#dereferencing-a-raw-pointer" target=_blank rel=noopener>指向</a>分配的内存块的第一个字节。 <code>alloc</code>方法返回空指针而非显式的错误值以指示分配错误。 这有点令人不习惯，但是它的优点是包装现有的系统分配器很容易，因为它们使用相同的调用约定。</li><li>对应的有<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg#tymethod.dealloc" target=_blank rel=noopener><code>dealloc</code></a>方法，负责释放内存块。 它接收两个参数，一个是<code>alloc</code>返回的指针， <code>alloc</code>是用于分配的<code>Layout</code> 。</li></ul><p>该特征还使用默认实现定义了两个方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg#method.alloc_zeroed" target=_blank rel=noopener><code>alloc_zeroed</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg#method.realloc" target=_blank rel=noopener><code>realloc</code></a> ：</p><ul><li><a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg#method.alloc_zeroed" target=_blank rel=noopener><code>alloc_zeroed</code></a>方法等效于调用<code>alloc</code> ，然后将分配的内存块设置为零，这正是提供的默认实现所执行的。 如果可能的话，分配器实现可以使用更有效的自定义实现来覆盖默认实现。</li><li><a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhja9Cla59NwkTNZAMz6PcSj4jN6wg#method.realloc" target=_blank rel=noopener><code>realloc</code></a>方法允许增加或减少分配。 默认实现分配一个具有所需大小的新内存块，并复制先前分配的所有内容。 同样，分配器实现可能可以提供此方法的更有效实现，例如，如果可能的话，通过就地扩展/缩小分配。</li></ul><h4 id=unsafe><a href=#unsafe class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:unsafe class=headings>Unsafe</a></h4><p>要注意的一件事是trait本身和所有trait方法都被声明为<code>unsafe</code> ：</p><ul><li>将该特征声明为<code>unsafe</code>的原因是，程序员必须保证分配器类型的特征实现是正确的。 例如， <code>alloc</code>方法绝不能返回已在其他地方使用的内存块，因为这将导致未定义的行为。</li><li>同样，方法<code>unsafe</code>的原因是，调用方在调用方法时必须确保各种不变性，例如，传递给<code>alloc</code>的<code>Layout</code>指定一个非零大小。 在实践中，这实际上并不重要，因为方法通常是由编译器直接调用的，这可以确保满足要求。</li></ul><h3 id=dummyallocator><a href=#dummyallocator class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:dummyallocator class=headings><code>DummyAllocator</code></a></h3><p>既然我们知道应该提供什么分配器类型，我们就可以创建一个简单的虚拟分配器。 为此，我们创建一个新的<code>allocator</code>模块：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>mod</span> <span class=nn>allocator</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>我们的DummyAllocator会尽最大的努力来实现Trait，并在调用<code>alloc</code>时始终返回错误。 看起来像这样：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>alloc</span>::<span class=p>{</span><span class=n>GlobalAlloc</span><span class=p>,</span><span class=w> </span><span class=n>Layout</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=n>ptr</span>::<span class=n>null_mut</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Dummy</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>GlobalAlloc</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Dummy</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>_layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>null_mut</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=k>fn</span> <span class=nf>dealloc</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>_ptr</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>_layout</span>: <span class=nc>Layout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>panic</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;dealloc should be never called&#34;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该结构不需要任何字段，因此我们将其创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/nomicon/exotic-sizes.html&xid=25657,15700023,15700186,15700190,15700256,15700259,15700262,15700265,15700271&usg=ALkJrhhjDn4Dp1jvubRT6ctCKEw2rj_gYA#zero-sized-types-zsts" target=_blank rel=noopener>为零大小类型</a> 。 如上所述，我们总是从<code>alloc</code>返回空指针，它对应于分配错误。 由于分配器从不返回任何内存，因此永远不会发生对<code>dealloc</code>的调用。 因此，我们在<code>dealloc</code>方法被调用时panic。 <code>alloc_zeroed</code>和<code>realloc</code>方法具有默认实现，因此我们无需为其提供实现。</p><p>现在我们有了一个简单的分配器，但是我们仍然必须告诉Rust编译器它应该使用这个分配器。这时<code>#[global_allocator]</code>就有用了。</p><h3 id=global_allocator属性><a href=#global_allocator属性 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:global_allocator属性 class=headings>#<code>[global_allocator]</code>属性</a></h3><p><code>#[global_allocator]</code>属性告诉Rust编译器应该使用哪个分配器实例作为全局堆分配器。 该属性仅适用于实现<code>GlobalAlloc</code>特性的<code>static</code> 。 让我们将<code>Dummy</code>分配器的一个实例注册为全局分配器：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[global_allocator]</span><span class=w>
</span><span class=w></span><span class=k>static</span><span class=w> </span><span class=n>ALLOCATOR</span>: <span class=nc>allocator</span>::<span class=n>Dummy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>allocator</span>::<span class=n>Dummy</span><span class=p>;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>由于<code>Dummy</code>分配器是<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/nomicon/exotic-sizes.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgeU-TEc9SDEbOIraxGeQ8xYg4r3A#zero-sized-types-zsts" target=_blank rel=noopener>零大小的类型</a> ，因此我们不需要在初始化表达式中指定任何字段。 请注意， <code>#[global_allocator]</code>模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://github.com/rust-lang/rust/pull/51335&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhiRtm-6gsZO_3uOw-LJ9wMyI-a1kA" target=_blank rel=noopener>不能在子模块中使用</a> ，因此我们需要将其放入<code>lib.rs</code> 。</p><p>现在，当我们尝试编译它时，第一个错误应该消失了。 让我们修复剩余的第二个错误：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=n>error</span>: <span class=err>`</span><span class=cp>#[alloc_error_handler]</span><span class=err>`</span><span class=w> </span><span class=n>function</span><span class=w> </span><span class=n>required</span><span class=p>,</span><span class=w> </span><span class=n>but</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>found</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><h3 id=alloc_error_handler属性><a href=#alloc_error_handler属性 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:alloc_error_handler属性 class=headings><code>#[alloc_error_handler]</code>属性</a></h3><p>正如我们在讨论<code>GlobalAlloc</code>特性时所了解的那样， <code>alloc</code>函数可以通过返回空指针来指示分配错误。 问题是：Rust运行时应如何应对这种分配失败？ 这是<code>#[alloc_error_handler]</code>属性的来源。它指定发生分配错误时调用的函数，类似于在发生panic时调用panic处理程序的方式。</p><p>让我们添加这样的函数来修复编译错误：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#![feature(alloc_error_handler)]</span><span class=w> </span><span class=c1>// at the top of the file
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[alloc_error_handler]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>alloc_error_handler</span><span class=p>(</span><span class=n>layout</span>: <span class=nc>alloc</span>::<span class=n>alloc</span>::<span class=n>Layout</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>panic</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;allocation error: {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>layout</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p><code>alloc_error_handler</code>函数仍然不稳定，因此我们需要一个特性设置来启用它。 该函数接收一个参数：发生分配失败时传递给<code>alloc</code>的<code>Layout</code>实例。 我们对解决该错误无能为力，因此我们只是发送包含<code>Layout</code>实例的panic消息。</p><p>加上这个函数之后，编译错误应该已经被修复了。 现在我们可以使用<code>alloc</code>的分配和收集类型，例如，我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/boxed/struct.Box.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhiosxpeNyAEHn8OqRYErq2bnWWKRw" target=_blank rel=noopener><code>Box</code></a>在堆上分配一个值：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/main.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>extern</span><span class=w> </span><span class=k>crate</span><span class=w> </span><span class=n>alloc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>boxed</span>::<span class=nb>Box</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>kernel_main</span><span class=p>(</span><span class=n>boot_info</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=n>BootInfo</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// […] print &#34;Hello World!&#34;, call `init`, create `mapper` and `frame_allocator`
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>41</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// […] call `test_main` in test mode
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;It did not crash!&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>blog_os</span>::<span class=n>hlt_loop</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>请注意，我们也需要在<code>main.rs</code>指定<code>extern crate alloc</code>语句。 这是必需的，因为<code>main.rs</code>和<code>main.rs</code>部分被视为单独的crate。 但是，我们不需要创建另一个静态<code>#[global_allocator]</code>，因为全局分配器适用于项目中的所有crate。 实际上，在另一个crate中指定其他分配器将是错误的。</p><p>运行上面的代码时，我们看到我们的<code>alloc_error_handler</code>函数被调用：<img src=https://os.phil-opp.com/heap-allocation/qemu-dummy-output.png alt="QEMU printing " panicked at `allocation error: layout { size_: 4, align_: 4 }, src/lib.rs:89:5""></p><p>调用错误处理程序是因为<code>Box::new</code>函数隐式调用了全局分配器的<code>alloc</code>函数。 我们的虚拟分配器始终返回空指针，因此每次分配都会失败。 为了解决这个问题，我们需要创建一个实际上返回可用内存的分配器。</p><h2 id=创建内核堆><a href=#创建内核堆 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:创建内核堆 class=headings>创建内核堆</a></h2><p>在创建合适的分配器之前，我们首先需要创建一个堆内存区域，分配器可以从中分配内存。 为此，我们需要为堆区域定义一个虚拟内存范围，然后将该区域映射到物理帧。 有关虚拟内存和页表的概述，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/paging-introduction/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhkanSS8TkxwpQrLCkMYDffTLWobg" target=_blank rel=noopener><em>“分页简介”</em></a> 。</p><p>第一步是为堆定义虚拟内存区域。 我们可以选择所需的任何虚拟地址范围，只要它尚未用于其他内存区域即可。 让我们将其定义为从地址<code>0x_4444_4444_0000</code>开始的内存，以便稍后可以轻松识别堆指针：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>HEAP_START</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=mh>0x_4444_4444_0000</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>HEAP_SIZE</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>1024</span><span class=p>;</span><span class=w> </span><span class=c1>// 100 KiB
</span></code></pre></td></tr></table></div></div></div><p>我们现在将堆大小设置为100 KiB。 如果将来需要更多空间，我们可以简单地增加它。</p><p>如果我们现在尝试使用此堆区域，则会发生页面错误，因为虚拟内存区域尚未映射到物理内存。为了解决这个问题，我们创建了一个<code>init_heap</code>函数，该函数使用我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/paging-implementation/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhj_xC5St0tlJnPmBv9hvbAEPd6W5A" target=_blank rel=noopener><em>“分页实现”一文中</em></a>介绍的<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/paging-implementation/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhj_xC5St0tlJnPmBv9hvbAEPd6W5A#using-mappedpagetable" target=_blank rel=noopener><code>Mapper</code> API</a>映射堆页面：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>x86_64</span>::<span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>structures</span>::<span class=n>paging</span>::<span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>mapper</span>::<span class=n>MapToError</span><span class=p>,</span><span class=w> </span><span class=n>FrameAllocator</span><span class=p>,</span><span class=w> </span><span class=n>Mapper</span><span class=p>,</span><span class=w> </span><span class=n>Page</span><span class=p>,</span><span class=w> </span><span class=n>PageTableFlags</span><span class=p>,</span><span class=w> </span><span class=n>Size4KiB</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=p>},</span><span class=w>
</span><span class=w>    </span><span class=n>VirtAddr</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>init_heap</span><span class=p>(</span><span class=w>
</span><span class=w>    </span><span class=n>mapper</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>Mapper</span><span class=o>&lt;</span><span class=n>Size4KiB</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>frame_allocator</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>FrameAllocator</span><span class=o>&lt;</span><span class=n>Size4KiB</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>MapToError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>page_range</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>heap_start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>VirtAddr</span>::<span class=n>new</span><span class=p>(</span><span class=n>HEAP_START</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u64</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>heap_end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>heap_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>HEAP_SIZE</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=k>u64</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>heap_start_page</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Page</span>::<span class=n>containing_address</span><span class=p>(</span><span class=n>heap_start</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>heap_end_page</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Page</span>::<span class=n>containing_address</span><span class=p>(</span><span class=n>heap_end</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>Page</span>::<span class=n>range_inclusive</span><span class=p>(</span><span class=n>heap_start_page</span><span class=p>,</span><span class=w> </span><span class=n>heap_end_page</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>page</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>page_range</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>frame</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>frame_allocator</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>allocate_frame</span><span class=p>()</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>ok_or</span><span class=p>(</span><span class=n>MapToError</span>::<span class=n>FrameAllocationFailed</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>flags</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PageTableFlags</span>::<span class=n>PRESENT</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>PageTableFlags</span>::<span class=n>WRITABLE</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>mapper</span><span class=p>.</span><span class=n>map_to</span><span class=p>(</span><span class=n>page</span><span class=p>,</span><span class=w> </span><span class=n>frame</span><span class=p>,</span><span class=w> </span><span class=n>flags</span><span class=p>,</span><span class=w> </span><span class=n>frame_allocator</span><span class=p>)</span><span class=o>?</span><span class=p>.</span><span class=n>flush</span><span class=p>()</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该函数通过使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/page/enum.Size4KiB.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhg2M_G0Ol9na-mTvgYz9wcyhGSTxg" target=_blank rel=noopener><code>Size4KiB</code></a>作为模版参数来获取对<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/trait.Mapper.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgVFv5BTMRwDVcKqwVIbnPTvsmTPg" target=_blank rel=noopener><code>Mapper</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/trait.FrameAllocator.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjggS52v2i2ScjsxhDb74n9oOyHIA" target=_blank rel=noopener><code>FrameAllocator</code></a>实例的可变引用，它们均限于4KiB页。 该函数的返回值是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/result/enum.Result.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhce2hBUz9y9tfOupW--gctQJa0tQ" target=_blank rel=noopener><code>Result</code></a> ，其<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/result/enum.Result.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhce2hBUz9y9tfOupW--gctQJa0tQ" target=_blank rel=noopener><code>Result</code></a>成功时为单位类型<code>()</code>，而出错时为<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/enum.MapToError.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhicxFwlIHtXfyNzcvL79bpGKF_HjA" target=_blank rel=noopener><code>MapToError</code></a>，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/trait.Mapper.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgVFv5BTMRwDVcKqwVIbnPTvsmTPg#tymethod.map_to" target=_blank rel=noopener><code>Mapper::map_to</code></a>方法返回的错误类型。 在这里重用错误类型是有意义的，因为<code>map_to</code>方法是此函数中错误的主要来源。</p><p>实现可以分为两部分：</p><ul><li>**创建页面范围：：**要创建我们要映射的页面范围，我们将<code>HEAP_START</code>指针转换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/struct.VirtAddr.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhNOHf3zU7AgNVZhjYJkAVQ39Xufw" target=_blank rel=noopener><code>VirtAddr</code></a>类型。 然后，我们通过添加<code>HEAP_SIZE</code>从中计算出堆结束地址。 我们需要一个包含性的边界（堆最后一个字节的地址），因此我们减去1。接下来，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/page/struct.Page.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjSe7J0VwXNgWPo3i7TiwHf8vSwFw#method.containing_address" target=_blank rel=noopener><code>containing_address</code></a>函数将地址转换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/page/struct.Page.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjSe7J0VwXNgWPo3i7TiwHf8vSwFw" target=_blank rel=noopener><code>Page</code></a>类型。 最后，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/page/struct.Page.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjSe7J0VwXNgWPo3i7TiwHf8vSwFw#method.range_inclusive" target=_blank rel=noopener><code>Page::range_inclusive</code></a>函数从起始页面和结束页面创建页面范围。</li><li>**映射页面：**第二步是映射我们刚刚创建的页面范围的所有页面。 为此，我们使用<code>for</code>循环遍历该范围内的页面。 对于每个页面，我们执行以下操作：<ul><li>我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/trait.FrameAllocator.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjggS52v2i2ScjsxhDb74n9oOyHIA#tymethod.allocate_frame" target=_blank rel=noopener><code>FrameAllocator::allocate_frame</code></a>方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/trait.FrameAllocator.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjggS52v2i2ScjsxhDb74n9oOyHIA#tymethod.allocate_frame" target=_blank rel=noopener><code>FrameAllocator::allocate_frame</code></a>页面应映射到的物理帧。 当没有剩余的帧时，此方法将返回<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/option/enum.Option.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhaJ_Il3_-qAEhTV0CU_eroK_zIqA#variant.None" target=_blank rel=noopener><code>None</code></a> 。 我们通过使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/option/enum.Option.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhaJ_Il3_-qAEhTV0CU_eroK_zIqA#method.ok_or" target=_blank rel=noopener><code>Option::ok_or</code></a>方法将其映射到<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/enum.MapToError.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhicxFwlIHtXfyNzcvL79bpGKF_HjA#variant.FrameAllocationFailed" target=_blank rel=noopener><code>MapToError::FrameAllocationFailed</code></a>错误来处理这种情况，然后应用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhg1cg548fqAFT-Y_9h9-bsEfN4Qpw" target=_blank rel=noopener>问号运算符</a>以在出现错误的情况下尽早返回。</li><li>我们为页面设置了必需的<code>PRESENT</code>标志和<code>WRITABLE</code>标志。 使用这些标志，允许读取和写入访问，这对于堆内存是有意义的。</li><li>我们使用不安全的<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/trait.Mapper.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgVFv5BTMRwDVcKqwVIbnPTvsmTPg#tymethod.map_to" target=_blank rel=noopener><code>Mapper::map_to</code></a>方法在活动页面表中创建映射。 该方法可能会失败，因此我们再次使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhg1cg548fqAFT-Y_9h9-bsEfN4Qpw" target=_blank rel=noopener>问号运算符</a>将错误转发给调用方。 成功后，该方法将返回一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/struct.MapperFlush.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhu0tpL-XJy7I4bFlQNnOuMtOYO7g" target=_blank rel=noopener><code>MapperFlush</code></a>实例，我们可以使用该实例使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/struct.MapperFlush.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhu0tpL-XJy7I4bFlQNnOuMtOYO7g#method.flush" target=_blank rel=noopener><code>flush</code></a>方法来更新<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/paging-introduction/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhkanSS8TkxwpQrLCkMYDffTLWobg#the-translation-lookaside-buffer" target=_blank rel=noopener><em>转换后备缓冲区</em></a>。</li></ul></li></ul><p>最后一步是从我们的<code>kernel_main</code>调用此函数：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/main.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>kernel_main</span><span class=p>(</span><span class=n>boot_info</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=n>BootInfo</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>blog_os</span>::<span class=n>allocator</span><span class=p>;</span><span class=w> </span><span class=c1>// new import
</span><span class=c1></span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>blog_os</span>::<span class=n>memory</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>BootInfoFrameAllocator</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Hello World{}&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;!&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>blog_os</span>::<span class=n>init</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>mapper</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>memory</span>::<span class=n>init</span><span class=p>(</span><span class=n>boot_info</span><span class=p>.</span><span class=n>physical_memory_offset</span><span class=p>)</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>frame_allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>BootInfoFrameAllocator</span>::<span class=n>init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>boot_info</span><span class=p>.</span><span class=n>memory_map</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// new
</span><span class=c1></span><span class=w>    </span><span class=n>allocator</span>::<span class=n>init_heap</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>mapper</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>frame_allocator</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;heap initialization failed&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>41</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// […] call `test_main` in test mode
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;It did not crash!&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>blog_os</span>::<span class=n>hlt_loop</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>我们在这里出示了完整的代码，为了便于参考上下文。 仅有的新行是<code>blog_os::allocator</code>导入和对<code>allocator::init_heap</code>函数的调用。 万一<code>init_heap</code>函数返回错误，我们会使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/result/enum.Result.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhce2hBUz9y9tfOupW--gctQJa0tQ#method.expect" target=_blank rel=noopener><code>Result::expect</code></a>方法来引发panic，因为当前没有明智的方法来处理此错误。</p><p>现在，我们有一个准备使用的映射堆内存区域。 <code>Box::new</code>调用仍然使用我们旧的<code>Dummy</code>分配器，因此运行它时，您仍然会看到“内存不足”错误。 让我们通过使用适当的分配器来解决此问题。</p><h2 id=使用分配器-crate><a href=#使用分配器-crate class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用分配器-crate class=headings>使用分配器 crate</a></h2><p>由于实现分配器有些复杂，因此我们首先使用外部分配器crate。 在下一篇文章中，我们将学习如何实现自己的分配器。</p><p><code>no_std</code>应用程序的一个简单分配器箱是<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://github.com/phil-opp/linked-list-allocator/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjRQdwoIoMwukn1dxQxvPbEk9FaCw" target=_blank rel=noopener><code>linked_list_allocator</code></a>箱子。 它起这个名称是因为：它使用链接列表数据结构来跟踪释放的内存区域。 有关此方法的详细说明，请参见下一篇文章。</p><p>要使用板条箱，我们首先需要在<code>Cargo.toml</code>添加对它的依赖：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=err>#</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>Cargo</span><span class=p>.</span><span class=n>toml</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=n>dependencies</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=n>linked_list_allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;0.6.4&#34;</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>然后，我们可以用crate提供的分配器替换我们的dummy分配器：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>linked_list_allocator</span>::<span class=n>LockedHeap</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[global_allocator]</span><span class=w>
</span><span class=w></span><span class=k>static</span><span class=w> </span><span class=n>ALLOCATOR</span>: <span class=nc>LockedHeap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LockedHeap</span>::<span class=n>empty</span><span class=p>();</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>该结构被命名为<code>LockedHeap</code>因为，它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/spin/0.5.2/spin/struct.Mutex.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhiB-xAcS86h4-YyKqhs0T_npkoGBQ" target=_blank rel=noopener><code>spin::Mutex</code></a>进行同步。 这是必需的，因为多个线程可以同时访问<code>ALLOCATOR</code>静态对象。 一如往常，在使用<code>Mutex</code>时 ，我们需要注意不要意外导致死锁。 这意味着我们不应该在中断处理程序中执行任何分配，因为它们可以在任意时间运行，并且可能会中断正在进行的分配。</p><p>仅将<code>LockedHeap</code>设置为全局分配器是不够的。 原因是我们使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.LockedHeap.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjSImcHYQIFUsXh6pW843hrmoYKmQ#method.empty" target=_blank rel=noopener><code>empty</code></a>构造函数，该函数创建了一个没有任何后备内存的分配器。 就像我们的虚拟分配器一样，它总是在<code>alloc</code>上返回错误。为了解决这个问题，我们需要在创建堆之后初始化分配器：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/allocator.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>init_heap</span><span class=p>(</span><span class=w>
</span><span class=w>    </span><span class=n>mapper</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>Mapper</span><span class=o>&lt;</span><span class=n>Size4KiB</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>frame_allocator</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>FrameAllocator</span><span class=o>&lt;</span><span class=n>Size4KiB</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>MapToError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// […] map all heap pages to physical frames
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=c1>// new
</span><span class=c1></span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>super</span>::<span class=n>ALLOCATOR</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>init</span><span class=p>(</span><span class=n>HEAP_START</span><span class=p>,</span><span class=w> </span><span class=n>HEAP_SIZE</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.LockedHeap.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjSImcHYQIFUsXh6pW843hrmoYKmQ#method.lock" target=_blank rel=noopener><code>LockedHeap::lock</code></a>方法获取对包装后的<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.Heap.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgOQD-NmzuyehtvmIr_FZz2Unvq2A" target=_blank rel=noopener><code>Heap</code></a>实例的排他性引用，然后在该实例上以堆边界作为参数调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.Heap.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgOQD-NmzuyehtvmIr_FZz2Unvq2A#method.init" target=_blank rel=noopener><code>init</code></a>方法。 重要的是在映射堆页面<em>之后</em>初始化堆，因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://docs.rs/linked_list_allocator/0.6.4/linked_list_allocator/struct.Heap.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgOQD-NmzuyehtvmIr_FZz2Unvq2A#method.init" target=_blank rel=noopener><code>init</code></a>函数会尝试写入堆内存。</p><p>初始化堆之后，我们现在可以使用内置alloc crate中的的所有分配和集合类型，而不会出现错误：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in src/main.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=p>{</span><span class=n>boxed</span>::<span class=nb>Box</span><span class=p>,</span><span class=w> </span><span class=n>vec</span><span class=p>,</span><span class=w> </span><span class=n>vec</span>::<span class=nb>Vec</span><span class=p>,</span><span class=w> </span><span class=n>rc</span>::<span class=n>Rc</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>kernel_main</span><span class=p>(</span><span class=n>boot_info</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=n>BootInfo</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// […] initialize interrupts, mapper, frame_allocator, heap
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=c1>// allocate a number on the heap
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>heap_value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>41</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;heap_value at {:p}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>heap_value</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// create a dynamically sized vector
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=mi>500</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>vec</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;vec at {:p}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>vec</span><span class=p>.</span><span class=n>as_slice</span><span class=p>());</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// create a reference counted vector -&gt; will be freed when count reaches 0
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>reference_counted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>]);</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>cloned_reference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reference_counted</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;current reference count is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>strong_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cloned_reference</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=n>core</span>::<span class=n>mem</span>::<span class=n>drop</span><span class=p>(</span><span class=n>reference_counted</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;reference count is {} now&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>strong_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cloned_reference</span><span class=p>));</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// […] call `test_main` in test context
</span><span class=c1></span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;It did not crash!&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>blog_os</span>::<span class=n>hlt_loop</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>此代码示例演示<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/boxed/struct.Box.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhiosxpeNyAEHn8OqRYErq2bnWWKRw" target=_blank rel=noopener><code>Box</code></a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/vec/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhieY-F6KPuz5zi1aQC51lYwWTpocQ" target=_blank rel=noopener><code>Vec</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/rc/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhRszVAQpT964_IqTwW-N23ixY3Og" target=_blank rel=noopener><code>Rc</code></a>类型的某些用法。对于<code>Box</code>和<code>Vec</code>类型，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/fmt/trait.Pointer.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhi8JAgOHJJ7R4OMg1lddXKPPImIfg" target=_blank rel=noopener><code>{:p}</code>格式说明符</a>打印基础堆指针。为了进行展示<code>Rc</code>，我们创建了一个引用计数的堆值，并使用该<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/rc/struct.Rc.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgdb8ySpOxHWtrwxFWLY2BRF6R_0Q#method.strong_count" target=_blank rel=noopener><code>Rc::strong_count</code></a>函数在删除实例之前和之后（使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/core/mem/fn.drop.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhj1lgzbQAChTDPbzBUXrB1rjwXYkQ" target=_blank rel=noopener><code>core::mem::drop</code></a>）打印当前引用计数。</p><p>运行它时，我们看到以下内容：</p><p><img src=https://os.phil-opp.com/heap-allocation/qemu-alloc-showcase.png alt=QEMU在0x444444440000打印vec在0x4444444408000处的heap_value当前引用计数为2引用计数现在为1></p><p>如预期的那样，我们看到<code>Box</code> 和 <code>Vec</code>值存在于堆中，如以开头的指针所指示<code>0x_4444_4444</code>。引用计数值也表现出预期的效果，在<code>clone</code>调用之后，引用计数为2，在删除一个实例之后，引用计数再次为1。</p><p>向量从<code>0x800</code>开始的原因不是装箱的值是<code>0x800</code>字节大的，而是向量需要增加其容量时发生的<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/vec/struct.Vec.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhggQTZld9-J9QlCghMnx6mS6Iv6Yw#capacity-and-reallocation" target=_blank rel=noopener>重新分配</a>。例如，当向量的容量为32且我们尝试添加下一个元素时，向量将在幕后分配容量为64的新后备数组，并将所有元素复制到其后。然后释放旧分配。</p><p>当然<code>alloc</code>，我们现在可以在内核中使用所有更多的分配和收集类型，包括：</p><ul><li>线程安全引用计数的指针 <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/sync/struct.Arc.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhj0W9GHTbExBe7ogcC-At7IwnbvzA" target=_blank rel=noopener><code>Arc</code></a></li><li>有所有权的字符串类型<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/string/struct.String.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjCj3aWKrmBGjI8tSiHyAR6AM07kw" target=_blank rel=noopener><code>String</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/macro.format.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgROMRJHZB_3JXG5v6BfGOFfyxgeQ" target=_blank rel=noopener><code>format!</code></a>宏</li><li><a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/collections/linked_list/struct.LinkedList.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgxe05cnRkWpSbYK8E95OQ9Dr16uQ" target=_blank rel=noopener><code>LinkedList</code></a></li><li>可成长的环形缓冲区 <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/collections/vec_deque/struct.VecDeque.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhjMDKrGsPBTUoy8J-dzcNlJ9_icLA" target=_blank rel=noopener><code>VecDeque</code></a></li><li><a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/collections/binary_heap/struct.BinaryHeap.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhiLc9dwZt2-i1zsmCUyeP0MaFeI3Q" target=_blank rel=noopener><code>BinaryHeap</code></a>优先队列</li><li><a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhg_SwcL9IDCpGKpEg1N6gV9Voruxw" target=_blank rel=noopener><code>BTreeMap</code></a> 和 <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/collections/btree_set/struct.BTreeSet.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhix7vWfraqRdLrcIm8JC7VWF8p5ZA" target=_blank rel=noopener><code>BTreeSet</code></a></li></ul><p>当我们要实现线程列表，调度队列或支持async/await时，这些类型将变得非常有用。</p><h2 id=添加测试><a href=#添加测试 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:添加测试 class=headings>添加测试</a></h2><p>为了确保我们不会意外破坏新的分配代码，我们应该为其添加集成测试。我们首先创建一个<code>tests/heap_allocation.rs</code>具有以下内容的新文件：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in tests/heap_allocation.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#![no_std]</span><span class=w>
</span><span class=w></span><span class=cp>#![no_main]</span><span class=w>
</span><span class=w></span><span class=cp>#![feature(custom_test_frameworks)]</span><span class=w>
</span><span class=w></span><span class=cp>#![test_runner(blog_os::test_runner)]</span><span class=w>
</span><span class=w></span><span class=cp>#![reexport_test_harness_main = </span><span class=s>&#34;test_main&#34;</span><span class=cp>]</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>extern</span><span class=w> </span><span class=k>crate</span><span class=w> </span><span class=n>alloc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>bootloader</span>::<span class=p>{</span><span class=n>entry_point</span><span class=p>,</span><span class=w> </span><span class=n>BootInfo</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=n>panic</span>::<span class=n>PanicInfo</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=n>entry_point</span><span class=o>!</span><span class=p>(</span><span class=n>main</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>(</span><span class=n>boot_info</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=n>BootInfo</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>unimplemented</span><span class=o>!</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[panic_handler]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>panic</span><span class=p>(</span><span class=n>info</span>: <span class=kp>&amp;</span><span class=nc>PanicInfo</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>blog_os</span>::<span class=n>test_panic_handler</span><span class=p>(</span><span class=n>info</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>我们重用了<code>lib.rs</code>中的<code>test_runner</code>和<code>test_panic_handler</code>。由于我们要测试内存分配，因此通过<code>extern crate alloc</code>语句启用了这个crate。有关测试样板的更多信息，请查看“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://os.phil-opp.com/testing/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhie76olh4ei1lGqtBZIyplpwxv8qg" target=_blank rel=noopener><em>测试”</em></a>文章。</p><p>该<code>main</code>函数的实现如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in tests/heap_allocation.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>(</span><span class=n>boot_info</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=n>BootInfo</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>blog_os</span>::<span class=n>allocator</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>blog_os</span>::<span class=n>memory</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>BootInfoFrameAllocator</span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>x86_64</span>::<span class=n>VirtAddr</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>blog_os</span>::<span class=n>init</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>phys_mem_offset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>VirtAddr</span>::<span class=n>new</span><span class=p>(</span><span class=n>boot_info</span><span class=p>.</span><span class=n>physical_memory_offset</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>mapper</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>memory</span>::<span class=n>init</span><span class=p>(</span><span class=n>phys_mem_offset</span><span class=p>)</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>frame_allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>BootInfoFrameAllocator</span>::<span class=n>init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>boot_info</span><span class=p>.</span><span class=n>memory_map</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=n>allocator</span>::<span class=n>init_heap</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>mapper</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>frame_allocator</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;heap initialization failed&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>test_main</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>它与我们<code>main.rs</code>中的<code>kernel_main</code>函数非常相似，不同之处在于我们不调用<code>println</code>，不包含任何示例分配以及无条件地调用<code>test_main</code>。</p><p>现在我们准备添加一些测试用例。首先，我们添加一个测试，该测试使用进行简单分配<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://doc.rust-lang.org/alloc/boxed/struct.Box.html&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhiosxpeNyAEHn8OqRYErq2bnWWKRw" target=_blank rel=noopener><code>Box</code></a>并检查分配的值，以确保基本分配有效：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in tests/heap_allocation.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>blog_os</span>::<span class=p>{</span><span class=n>serial_print</span><span class=p>,</span><span class=w> </span><span class=n>serial_println</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>boxed</span>::<span class=nb>Box</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[test_case]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>simple_allocation</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>serial_print</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;simple_allocation... &#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>heap_value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>41</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>heap_value</span><span class=p>,</span><span class=w> </span><span class=mi>41</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>serial_println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;[ok]&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>最重要的是，此测试可验证没有发生分配错误。</p><p>接下来，我们迭代构建一个大向量，以测试大量分配和多次分配（由于重新分配）：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in tests/heap_allocation.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>alloc</span>::<span class=n>vec</span>::<span class=nb>Vec</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[test_case]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>large_vec</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>serial_print</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;large_vec... &#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1000</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>vec</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>sum</span>::<span class=o>&lt;</span><span class=kt>u64</span><span class=o>&gt;</span><span class=p>(),</span><span class=w> </span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>serial_println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;[ok]&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>我们通过与<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgV_rmHr53cE-UooOstgDtXajdMwA#Partial_sums" target=_blank rel=noopener>第n部分和</a>的公式进行比较来验证<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhgV_rmHr53cE-UooOstgDtXajdMwA#Partial_sums" target=_blank rel=noopener>和</a>。这使我们确信分配的值都是正确的。</p><p>作为第三项测试，我们依次创建一万个分配：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// in tests/heap_allocation.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[test_case]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>many_boxes</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>serial_print</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;many_boxes... &#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=mi>10_000</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=n>serial_println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;[ok]&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><p>此测试可确保分配器将释放的内存重新用于后续分配，因为否则分配器将耗尽内存。这似乎是对分配器的明显要求，但是有些分配器设计没有这样做。下一篇文章中将展示一个做不到这一点的不好的分配器设计。</p><p>让我们运行新的集成测试：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=o>&gt;</span><span class=w> </span><span class=n>cargo</span><span class=w> </span><span class=n>xtest</span><span class=w> </span><span class=o>--</span><span class=n>test</span><span class=w> </span><span class=n>heap_allocation</span><span class=w>
</span><span class=w></span><span class=p>[</span><span class=err>…</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=n>Running</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=n>tests</span><span class=w>
</span><span class=w></span><span class=n>simple_allocation</span><span class=p>...</span><span class=w> </span><span class=p>[</span><span class=n>ok</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=n>large_vec</span><span class=p>...</span><span class=w> </span><span class=p>[</span><span class=n>ok</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=n>many_boxes</span><span class=p>...</span><span class=w> </span><span class=p>[</span><span class=n>ok</span><span class=p>]</span><span class=w>
</span></code></pre></td></tr></table></div></div></div><h2 id=总结><a href=#总结 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:总结 class=headings>总结</a></h2><p>这篇文章介绍了动态内存，并解释了为什么以及在什么地方需要它。我们了解了Rust的借用检查器如何防止常见漏洞，并了解了Rust的内存分配API的工作方式。</p><p>在使用虚拟分配器创建了Rust分配器接口的最小实现之后，我们为内核创建了一个适当的堆内存区域。为此，我们定义的堆的虚拟地址范围，然后使用该映射范围内的物理帧的所有页面<code>Mapper</code>，并<code>FrameAllocator</code>从以前的帖子。</p><p>最后，我们添加了对<code>linked_list_allocator</code>板条箱的依赖，以向内核添加适当的分配器。有了这个分配器，我们能够使用<code>Box</code>，<code>Vec</code>并从其他分配和集合类型<code>alloc</code> crate。</p><h2 id=接下来><a href=#接下来 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:接下来 class=headings>接下来？</a></h2><p>尽管我们已经在本文中添加了堆分配支持，但我们将大部分工作交给了<code>linked_list_allocator</code> crate。下一篇文章将详细显示如何从头开始实现分配器。它将介绍多种可能的分配器设计，展示如何实现它们的简单版本，并说明其优缺点。</p></div><ul class=post-copyright><li class="copyright-item author"><span class=copyright-item-text>作者</span>：<a href=https://io-oi.me/ class="p-author h-card" target=_blank rel=noopener>Justice</a></li><li class="copyright-item link"><span class=copyright-item-text>链接</span>：<a href=/post/09.pub/writing-an-os-in-rust/10-heap-allocation/ target=_blank rel=noopener>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/</a></li><li class="copyright-item license"><span class=copyright-item-text>许可</span>：<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></li></ul></article><div class=updated-badge-container><span title="Updated @ 2024-08-25 13:04:05 UTC" style=cursor:help><svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" class="updated-badge"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="a"><rect width="130" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#a)"><path class="updated-badge-left" d="M0 0h55v20H0z"/><path class="updated-badge-right" d="M55 0h75v20H55z"/><path fill="url(#b)" d="M0 0h130v20H0z"/></g><g fill="#fff" text-anchor="middle" font-size="110"><text x="285" y="150" fill="#010101" fill-opacity=".3" textLength="450" transform="scale(.1)">updated</text><text x="285" y="140" textLength="450" transform="scale(.1)">updated</text><text x="915" y="150" fill="#010101" fill-opacity=".3" textLength="650" transform="scale(.1)">2024-08-25</text><text x="915" y="140" textLength="650" transform="scale(.1)">2024-08-25</text></g></svg></span></div><div class=post-share><div class=share-items><div class="share-item facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&hashtag=%23MemoryManagement" title=分享到「Facebook」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon facebook-icon"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg></a></div><div class="share-item mastodon"><a href="/fedishare.html#title=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&description=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e4%ba%86%e5%af%b9%e5%a0%86%e5%88%86%e9%85%8d%e7%9a%84%e6%94%af%e6%8c%81%e3%80%82%20%e9%a6%96%e5%85%88%ef%bc%8c%e5%ae%83%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%ef%bc%8c%e5%b9%b6%e5%b1%95%e7%a4%ba%e4%ba%86%e5%80%9f%e7%94%a8%e6%a3%80%e6%9f%a5%e5%99%a8%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e5%b8%b8%e8%a7%81%e7%9a%84%e5%88%86%e9%85%8d%e9%94%99%e8%af%af%e3%80%82%20%e7%84%b6%e5%90%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0Rust%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3%ef%bc%8c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a0%86%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%b9%b6%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%88%86%e9%85%8d%e5%99%a8crate%e3%80%82%20%e5%9c%a8%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e7%bb%93%e5%b0%be%ef%bc%8c%e5%86%85%e7%bd%ae%e5%88%86%e9%85%8dcrate%e7%9a%84%e6%89%80%e6%9c%89%e5%88%86%e9%85%8d%e5%92%8c%e6%94%b6%e9%9b%86%e7%b1%bb%e5%9e%8b%e5%b0%86%e5%af%b9%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%8f%af%e7%94%a8%e3%80%82&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/" title=分享到「Mastodon」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon mastodon-icon"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg></a></div><div class="share-item fediverse"><a href="/fedishare.html#title=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&description=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e4%ba%86%e5%af%b9%e5%a0%86%e5%88%86%e9%85%8d%e7%9a%84%e6%94%af%e6%8c%81%e3%80%82%20%e9%a6%96%e5%85%88%ef%bc%8c%e5%ae%83%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%ef%bc%8c%e5%b9%b6%e5%b1%95%e7%a4%ba%e4%ba%86%e5%80%9f%e7%94%a8%e6%a3%80%e6%9f%a5%e5%99%a8%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e5%b8%b8%e8%a7%81%e7%9a%84%e5%88%86%e9%85%8d%e9%94%99%e8%af%af%e3%80%82%20%e7%84%b6%e5%90%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0Rust%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3%ef%bc%8c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a0%86%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%b9%b6%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%88%86%e9%85%8d%e5%99%a8crate%e3%80%82%20%e5%9c%a8%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e7%bb%93%e5%b0%be%ef%bc%8c%e5%86%85%e7%bd%ae%e5%88%86%e9%85%8dcrate%e7%9a%84%e6%89%80%e6%9c%89%e5%88%86%e9%85%8d%e5%92%8c%e6%94%b6%e9%9b%86%e7%b1%bb%e5%9e%8b%e5%b0%86%e5%af%b9%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%8f%af%e7%94%a8%e3%80%82&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/" title=分享到「Fediverse」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="64 163 873 873" class="icon fediverse-icon"><defs><linearGradient id="fediverse-gradient"><stop offset="0" stop-color="#ff0101"/><stop offset="10%" stop-color="#9501ff"/><stop offset="50%" stop-color="#ffca01"/><stop offset="75%" stop-color="#01a3ff"/><stop offset="100%" stop-color="#65ff01"/></linearGradient></defs><path d="M539 176q-32 0-55 22t-25 55 20.5 58 56 27 58.5-20.5 27-56-20.5-59T544 176h-5zm-87 95-232 118q20 20 25 48l231-118q-19-20-24-48zm167 27q-13 25-38 38l183 184q13-25 39-38zM477 320 342 585l40 40 143-280q-28-5-48-25zm104 16q-22 11-46 10l-8-1 21 132 56 9zM155 370q-32 0-55 22.5t-25 55 20.5 58 56.5 27 59-21 26.5-56-21-58.5-55.5-27h-6zm90 68q1 9 1 18-1 19-10 35l132 21 26-50zm225 36-26 51 311 49q-1-8-1-17 1-19 10-36zm372 6q-32 1-55 23t-24.5 55 21 58 56 27 58.5-20.5 27-56.5-20.5-59-56.5-27h-6zM236 493q-13 25-39 38l210 210 51-25zm-40 38q-21 11-44 10l-9-1 40 256q21-10 45-9l8 1zm364 22 48 311q21-10 44-9l10 1-46-294zm195 23-118 60 8 56 135-68q-20-20-25-48zm26 49-119 231q28 5 48 25l119-231q-28-5-48-25zM306 654l-68 134q28 5 48 25l60-119zm262 17-281 143q19 20 24 48l265-135zM513 771l-51 25 106 107q13-25 39-38zM222 795q-32 0-55.5 22.5t-25 55 21 57.5 56 27 58.5-20.5 27-56-20.5-58.5-56.5-27h-5zm89 68q2 9 1 18-1 19-9 35l256 41q-1-9-1-18 1-18 10-35zm335 0q-32 0-55 22.5t-24.5 55 20.5 58 56 27 59-21 27-56-20.5-58.5-56.5-27h-6z"/></svg></a></div><div class="share-item twitter"><a href="https://twitter.com/share?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&text=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&hashtags=MemoryManagement,&via=reuixiy" title=分享到「Twitter」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon twitter-icon"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></a></div><div class="share-item linkedin"><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&title=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&summary=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e4%ba%86%e5%af%b9%e5%a0%86%e5%88%86%e9%85%8d%e7%9a%84%e6%94%af%e6%8c%81%e3%80%82%20%e9%a6%96%e5%85%88%ef%bc%8c%e5%ae%83%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%ef%bc%8c%e5%b9%b6%e5%b1%95%e7%a4%ba%e4%ba%86%e5%80%9f%e7%94%a8%e6%a3%80%e6%9f%a5%e5%99%a8%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e5%b8%b8%e8%a7%81%e7%9a%84%e5%88%86%e9%85%8d%e9%94%99%e8%af%af%e3%80%82%20%e7%84%b6%e5%90%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0Rust%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3%ef%bc%8c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a0%86%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%b9%b6%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%88%86%e9%85%8d%e5%99%a8crate%e3%80%82%20%e5%9c%a8%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e7%bb%93%e5%b0%be%ef%bc%8c%e5%86%85%e7%bd%ae%e5%88%86%e9%85%8dcrate%e7%9a%84%e6%89%80%e6%9c%89%e5%88%86%e9%85%8d%e5%92%8c%e6%94%b6%e9%9b%86%e7%b1%bb%e5%9e%8b%e5%b0%86%e5%af%b9%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%8f%af%e7%94%a8%e3%80%82&source=Justice%27s%20Site" title=分享到「LinkedIn」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon linkedin-icon"><path d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></a></div><div class="share-item telegram"><a href="https://t.me/share/url?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&text=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98" title=分享到「Telegram」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon telegram-icon"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"/></svg></a></div><div class="share-item weibo"><a href="https://service.weibo.com/share/share.php?&url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&title=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&pic=https://os.phil-opp.com/heap-allocation/call-stack.svg&searchPic=false" title=分享到「新浪微博」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon weibo-icon"><path d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7.0 395.3.0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"/></svg></a></div><div class="share-item douban"><a href="https://www.douban.com/share/service?href=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&name=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&text=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e4%ba%86%e5%af%b9%e5%a0%86%e5%88%86%e9%85%8d%e7%9a%84%e6%94%af%e6%8c%81%e3%80%82%20%e9%a6%96%e5%85%88%ef%bc%8c%e5%ae%83%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%ef%bc%8c%e5%b9%b6%e5%b1%95%e7%a4%ba%e4%ba%86%e5%80%9f%e7%94%a8%e6%a3%80%e6%9f%a5%e5%99%a8%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e5%b8%b8%e8%a7%81%e7%9a%84%e5%88%86%e9%85%8d%e9%94%99%e8%af%af%e3%80%82%20%e7%84%b6%e5%90%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0Rust%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3%ef%bc%8c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a0%86%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%b9%b6%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%88%86%e9%85%8d%e5%99%a8crate%e3%80%82%20%e5%9c%a8%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e7%bb%93%e5%b0%be%ef%bc%8c%e5%86%85%e7%bd%ae%e5%88%86%e9%85%8dcrate%e7%9a%84%e6%89%80%e6%9c%89%e5%88%86%e9%85%8d%e5%92%8c%e6%94%b6%e9%9b%86%e7%b1%bb%e5%9e%8b%e5%b0%86%e5%af%b9%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%8f%af%e7%94%a8%e3%80%82" title=分享到「豆瓣」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon douban-icon"><path d="M.643.92v2.412h22.714V.92H.643zm1.974 4.926v9.42h18.764v-9.42H2.617zm2.72 2.408H18.69v4.605H5.338V8.254zm1.657 7.412-2.512.938c1.037 1.461 1.87 2.825 2.512 4.091H0v2.385h24v-2.385h-6.678c.818-1.176 1.589-2.543 2.303-4.091l-2.73-.938a29.952 29.952.0 01-2.479 5.03h-4.75c-.786-1.962-1.677-3.641-2.672-5.03z"/></svg></a></div><div class="share-item qq"><a href="https://connect.qq.com/widget/shareqq/index.html?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&title=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&summary=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e4%ba%86%e5%af%b9%e5%a0%86%e5%88%86%e9%85%8d%e7%9a%84%e6%94%af%e6%8c%81%e3%80%82%20%e9%a6%96%e5%85%88%ef%bc%8c%e5%ae%83%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%ef%bc%8c%e5%b9%b6%e5%b1%95%e7%a4%ba%e4%ba%86%e5%80%9f%e7%94%a8%e6%a3%80%e6%9f%a5%e5%99%a8%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e5%b8%b8%e8%a7%81%e7%9a%84%e5%88%86%e9%85%8d%e9%94%99%e8%af%af%e3%80%82%20%e7%84%b6%e5%90%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0Rust%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3%ef%bc%8c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a0%86%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%b9%b6%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%88%86%e9%85%8d%e5%99%a8crate%e3%80%82%20%e5%9c%a8%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e7%bb%93%e5%b0%be%ef%bc%8c%e5%86%85%e7%bd%ae%e5%88%86%e9%85%8dcrate%e7%9a%84%e6%89%80%e6%9c%89%e5%88%86%e9%85%8d%e5%92%8c%e6%94%b6%e9%9b%86%e7%b1%bb%e5%9e%8b%e5%b0%86%e5%af%b9%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%8f%af%e7%94%a8%e3%80%82&pics=https://os.phil-opp.com/heap-allocation/call-stack.svg&site=Justice%27s%20Site" title=分享到「QQ」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon qq-icon"><path d="M433.754 420.445c-11.526 1.393-44.86-52.741-44.86-52.741.0 31.345-16.136 72.247-51.051 101.786 16.842 5.192 54.843 19.167 45.803 34.421-7.316 12.343-125.51 7.881-159.632 4.037-34.122 3.844-152.316 8.306-159.632-4.037-9.045-15.25 28.918-29.214 45.783-34.415-34.92-29.539-51.059-70.445-51.059-101.792.0.0-33.334 54.134-44.859 52.741-5.37-.65-12.424-29.644 9.347-99.704 10.261-33.024 21.995-60.478 40.144-105.779C60.683 98.063 108.982.006 224 0c113.737.006 163.156 96.133 160.264 214.963 18.118 45.223 29.912 72.85 40.144 105.778 21.768 70.06 14.716 99.053 9.346 99.704z"/></svg></a></div><div class="share-item qzone"><a href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&title=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&summary=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e4%ba%86%e5%af%b9%e5%a0%86%e5%88%86%e9%85%8d%e7%9a%84%e6%94%af%e6%8c%81%e3%80%82%20%e9%a6%96%e5%85%88%ef%bc%8c%e5%ae%83%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%ef%bc%8c%e5%b9%b6%e5%b1%95%e7%a4%ba%e4%ba%86%e5%80%9f%e7%94%a8%e6%a3%80%e6%9f%a5%e5%99%a8%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e5%b8%b8%e8%a7%81%e7%9a%84%e5%88%86%e9%85%8d%e9%94%99%e8%af%af%e3%80%82%20%e7%84%b6%e5%90%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0Rust%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3%ef%bc%8c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a0%86%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%b9%b6%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%88%86%e9%85%8d%e5%99%a8crate%e3%80%82%20%e5%9c%a8%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e7%bb%93%e5%b0%be%ef%bc%8c%e5%86%85%e7%bd%ae%e5%88%86%e9%85%8dcrate%e7%9a%84%e6%89%80%e6%9c%89%e5%88%86%e9%85%8d%e5%92%8c%e6%94%b6%e9%9b%86%e7%b1%bb%e5%9e%8b%e5%b0%86%e5%af%b9%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%8f%af%e7%94%a8%e3%80%82&pics=https://os.phil-opp.com/heap-allocation/call-stack.svg&site=Justice%27s%20Site" title="分享到「QQ 空间」" target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon qzone-icon"><path d="M23.985 9.202c-.032-.099-.127-.223-.334-.258-.207-.036-7.351-1.406-7.351-1.406s-.105-.022-.198-.07c-.092-.047-.127-.167-.127-.167S12.447.956 12.349.77C12.25.583 12.104.532 12 .532s-.251.051-.349.238c-.098.186-3.626 6.531-3.626 6.531s-.035.12-.128.167c-.092.047-.197.07-.197.07S.556 8.908.348 8.943c-.208.036-.302.16-.333.258a.477.477.0 00.125.449l5.362 5.49s.072.08.119.172c.016.104.005.21.005.21s-1.189 7.242-1.22 7.45.075.369.159.43c.083.062.233.106.421.013.189-.093 6.812-3.261 6.812-3.261s.098-.044.201-.061.201.061.201.061 6.623 3.168 6.812 3.261c.188.094.338.049.421-.013a.463.463.0 00.159-.43c-.021-.14-.93-5.677-.93-5.677.876-.54 1.425-1.039 1.849-1.747-2.594.969-6.006 1.717-9.415 1.866-.915.041-2.41.097-3.473-.015-.678-.071-1.17-.144-1.243-.438-.053-.215.054-.46.545-.831a2640.5 2640.5.0 012.861-2.155c1.285-.968 3.559-2.47 3.559-2.731.0-.285-2.144-.781-4.037-.781-1.945.0-2.275.132-2.811.168-.488.034-.769.005-.804-.138-.06-.248.183-.389.588-.568.709-.314 1.86-.594 1.984-.626.194-.052 3.082-.805 5.618-.535 1.318.14 3.244.668 3.244 1.276.0.342-1.721 1.494-3.225 2.597-1.149.843-2.217 1.561-2.217 1.688.0.342 3.533 1.241 6.689 1.01l.003-.022c.048-.092.119-.172.119-.172l5.362-5.49a.477.477.0 00.127-.449z"/></svg></a></div><div class="share-item pocket"><a href="https://getpocket.com/edit.php?url=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/" title=分享到「Pocket」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon pocket-icon"><path d="M407.6 64h-367C18.5 64 0 82.5.0 104.6v135.2C0 364.5 99.7 464 224.2 464c124 0 223.8-99.5 223.8-224.2V104.6c0-22.4-17.7-40.6-40.4-40.6zm-162 268.5c-12.4 11.8-31.4 11.1-42.4.0C89.5 223.6 88.3 227.4 88.3 209.3c0-16.9 13.8-30.7 30.7-30.7 17 0 16.1 3.8 105.2 89.3 90.6-86.9 88.6-89.3 105.5-89.3 16.9.0 30.7 13.8 30.7 30.7.0 17.8-2.9 15.7-114.8 123.2z"/></svg></a></div><div class="share-item hackernews"><a href="https://news.ycombinator.com/submitlink?u=https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/&t=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98" title="分享到Hacker News" target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon hackernews-icon"><path d="M0 32v448h448V32H0zm21.2 197.2H21c.1-.1.2-.3.3-.4.0.1.0.3-.1.4zm218 53.9V384h-31.4V281.3L128 128h37.3c52.5 98.3 49.2 101.2 59.3 125.6 12.3-27 5.8-24.4 60.6-125.6H320l-80.8 155.1z"/></svg></a></div><div class="share-item qrcode"><div class=qrcode-container title=通过「二维码」><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon qrcode-icon"><path d="M0 224h192V32H0v192zM64 96h64v64H64V96zm192-64v192h192V32H256zm128 128h-64V96h64v64zM0 480h192V288H0v192zm64-128h64v64H64v-64zm352-64h32v128h-96v-32h-32v96h-64V288h96v32h64v-32zm0 160h32v32h-32v-32zm-64 0h32v32h-32v-32z"/></svg><div id=qrcode-img></div></div><script src=https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js></script>
<script>const typeNumber=0,errorCorrectionLevel='L',qr=qrcode(typeNumber,errorCorrectionLevel);qr.addData('https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/'),qr.make(),document.getElementById('qrcode-img').innerHTML=qr.createImgTag()</script></div><div class="share-item email"><a href="mailto:?subject=%e5%88%86%e9%85%8d%e5%a0%86%e5%86%85%e5%ad%98&body=%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e4%ba%86%e5%af%b9%e5%a0%86%e5%88%86%e9%85%8d%e7%9a%84%e6%94%af%e6%8c%81%e3%80%82%20%e9%a6%96%e5%85%88%ef%bc%8c%e5%ae%83%e4%bb%8b%e7%bb%8d%e4%ba%86%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%ef%bc%8c%e5%b9%b6%e5%b1%95%e7%a4%ba%e4%ba%86%e5%80%9f%e7%94%a8%e6%a3%80%e6%9f%a5%e5%99%a8%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e5%b8%b8%e8%a7%81%e7%9a%84%e5%88%86%e9%85%8d%e9%94%99%e8%af%af%e3%80%82%20%e7%84%b6%e5%90%8e%ef%bc%8c%e5%ae%83%e5%ae%9e%e7%8e%b0Rust%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3%ef%bc%8c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a0%86%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%ef%bc%8c%e5%b9%b6%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%88%86%e9%85%8d%e5%99%a8crate%e3%80%82%20%e5%9c%a8%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e7%bb%93%e5%b0%be%ef%bc%8c%e5%86%85%e7%bd%ae%e5%88%86%e9%85%8dcrate%e7%9a%84%e6%89%80%e6%9c%89%e5%88%86%e9%85%8d%e5%92%8c%e6%94%b6%e9%9b%86%e7%b1%bb%e5%9e%8b%e5%b0%86%e5%af%b9%e6%88%91%e4%bb%ac%e7%9a%84%e5%86%85%e6%a0%b8%e5%8f%af%e7%94%a8%e3%80%82%0Ahttps://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/" title=通过「电子邮件」 target=_blank rel=noopener><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon email-icon"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V4e2c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5.0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg></a></div></div></div><div class=related-posts><h2 class=related-title>相关文章：<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon related-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6.0-12-5.4-12-12v-92h-92c-6.6.0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6.0 12 5.4 12 12v92h92c6.6.0 12 5.4 12 12v56z"/></svg></h2><ul class=related-list><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/09-paging-implementation/ class=related-link>实现分页</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/08-introduction-to-paging/ class=related-link>介绍分页</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/11-allocator-designs/ class=related-link>内存分配器设计</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/12-async-await/ class=related-link>Async/Await</a></li><li class=related-item><a href=/post/09.pub/writing-an-os-in-rust/02-minimal-rust-kernel/ class=related-link>使用Rust编写操作系统（二）：最小化内核</a></li></ul></div><div class=post-tags><a href=/tags/memory-management/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Memory Management</a></div><ul class=post-nav><li class=post-nav-prev><a href=/post/09.pub/writing-an-os-in-rust/12-async-await/ rel=prev>&lt; Async/Await</a></li><li class=post-nav-next><a href=/post/09.pub/writing-an-os-in-rust/09-paging-implementation/ rel=next>实现分页 ></a></li></ul><div id=utterances></div></div></main><script>let indexURL="https://justice.bj.cn/index.json",includeSectionsInSearch=["post"],search_no_results="0 results for",search_initial_message=""</script><div class="search-modal dark" aria-hidden=true style=--color-primary:#7f0ec6><div data-target=close-search-modal class=search-modal-overlay></div><div class=search-wrapper data-image=true data-description=true data-tags=true data-categories=true><div class=search-wrapper-header><label for=search-modal-input style=margin-top:-1px><span class=sr-only>search icon</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-icon" data-type="search"><path fill="currentcolor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-reset" data-type="reset"><path fill="currentcolor" d="M256 512A256 256 0 10256 0a256 256 0 100 512zM175 175c9.4-9.4 24.6-9.4 33.9.0l47 47 47-47c9.4-9.4 24.6-9.4 33.9.0s9.4 24.6.0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6.0 33.9s-24.6 9.4-33.9.0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9.0s-9.4-24.6.0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6.0-33.9z"/></svg></label>
<input id=search-modal-input type=text data-search-input autocomplete=off aria-label=Search placeholder></div><div class=search-wrapper-body><div class=search-result data-search-result></div><span class=search-result-empty></span></div><div class=search-wrapper-footer><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16"><path d="M3.204 11h9.592L8 5.519 3.204 11zm-.753-.659 4.796-5.48a1 1 0 011.506.0l4.796 5.48c.566.647.106 1.659-.753 1.659H3.204a1 1 0 01-.753-1.659z"/></svg></kbd><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" style="margin-top:1px" viewBox="0 0 16 16"><path d="M3.204 5h9.592L8 10.481 3.204 5zm-.753.659 4.796 5.48a1 1 0 001.506.0l4.796-5.48c.566-.647.106-1.659-.753-1.659H3.204a1 1 0 00-.753 1.659z"/></svg></kbd>to navigate</span>
<span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentcolor" style="display:inline-block" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.5 1.5a.5.5.0 01.5.5v4.8a2.5 2.5.0 01-2.5 2.5H2.707l3.347 3.346a.5.5.0 01-.708.708l-4.2-4.2a.5.5.0 010-.708l4-4a.5.5.0 11.708.708L2.707 8.3H12.5A1.5 1.5.0 0014 6.8V2a.5.5.0 01.5-.5z"/></svg></kbd>to select</span>
<span class=search-result-info></span>
<span data-target=close-search-modal><kbd>ESC</kbd> to close</span></div></div></div><template id=search-result-item-template><div class=search-result-item>#{ isset image }<div class=search-result-item-image>#{image}</div>#{ end }<div class=search-result-item-body><a href=#{slug} class=search-result-item-title>#{title}</a>
#{ isset description }<p class=search-result-item-description>#{description}</p>#{ end }<p class=search-result-item-content>#{content}</p><div class=search-result-item-taxonomies>#{ isset categories }<div><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16" style="margin-top:-2px"><path d="M11 0H3A2 2 0 001 2v12a2 2 0 002 2h8a2 2 0 002-2 2 2 0 002-2V4a2 2 0 00-2-2 2 2 0 00-2-2zm2 3a1 1 0 011 1v8a1 1 0 01-1 1V3zM2 2a1 1 0 011-1h8a1 1 0 011 1v12a1 1 0 01-1 1H3a1 1 0 01-1-1V2z"/></svg>#{categories}</div>#{ end }
#{ isset tags }<div><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16"><path d="M3 2v4.586l7 7L14.586 9l-7-7H3zM2 2a1 1 0 011-1h4.586a1 1 0 01.707.293l7 7a1 1 0 010 1.414l-4.586 4.586a1 1 0 01-1.414.0l-7-7A1 1 0 012 6.586V2z"/><path d="M5.5 5a.5.5.0 110-1 .5.5.0 010 1zm0 1a1.5 1.5.0 100-3 1.5 1.5.0 000 3zM1 7.086a1 1 0 00.293.707L8.75 15.25l-.043.043a1 1 0 01-1.414.0l-7-7A1 1 0 010 7.586V3a1 1 0 011-1v5.086z"/></svg>#{tags}</div>#{ end }</div></div></div></template><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2013–2024&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Justice</div><div class=powered-by>Powered by <a href=https://github.com/gohugoio/hugo target=_blank rel=noopener>Hugo</a> | Theme is <a href=https://github.com/reuixiy/hugo-theme-meme target=_blank rel=noopener>MemE</a></div><div class=site-copyright><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></div><div class=busuanzi-site-uv-and-pv><span id=busuanzi_container_site_uv>本站访客数&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon busuanzi-site-uv"><path d="M224 256c70.7.0 128-57.3 128-128S294.7.0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2.0 422.4V464c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"/></svg>&nbsp;<span id=busuanzi_value_site_uv></span></span>&nbsp;|&nbsp;<span id=busuanzi_container_site_pv>本站访问量&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="icon busuanzi-site-pv"><path d="M288 144a110.94 110.94.0 00-31.24 5 55.4 55.4.0 017.24 27 56 56 0 01-56 56 55.4 55.4.0 01-27-7.24A111.71 111.71.0 10288 144zm284.52 97.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35.0 000 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35.0 000-29.19zM288 4e2c-98.65.0-189.09-55-237.93-144C98.91 167 189.34 112 288 112s189.09 55 237.93 144C477.1 345 386.66 4e2 288 4e2z"/></svg>&nbsp;<span id=busuanzi_value_site_pv></span></span></div><ul class=socials><li class=socials-item><a href=/rss.xml target=_blank rel="external noopener" title=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M19.199 24C19.199 13.467 10.533 4.8.0 4.8V0c13.165.0 24 10.835 24 24h-4.801zM3.291 17.415c1.814.0 3.293 1.479 3.293 3.295.0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526.0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727.0 15.909 7.184 15.909 15.91z"/></svg></a></li><li class=socials-item><a href=mailto:reuixiy@gmail.com target=_blank rel="external noopener" title=Email><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon social-icon"><path d="M464 64H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 4e2V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V4e2H48z"/></svg></a></li><li class=socials-item><a href=https://github.com/reuixiy target=_blank rel="external noopener" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a></li><li class=socials-item><a href=https://twitter.com/reuixiy target=_blank rel="external noopener" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon social-icon"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></a></li><li class=socials-item><a href=https://t.me/yixiuer target=_blank rel="external noopener" title=Telegram><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon social-icon"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"/></svg></a></li></ul></div></footer></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css><script>if(typeof renderMathInElement=='undefined'){const a=b=>{const a=document.createElement('script');a.defer=!0,a.crossOrigin='anonymous',Object.keys(b).forEach(c=>{a[c]=b[c]}),document.body.appendChild(a)};a({src:'https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js',onload:()=>{a({src:'https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/mhchem.min.js',onload:()=>{a({src:'https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js',onload:()=>{renderKaTex()}})}})}})}else renderKaTex();function renderKaTex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})}</script><script>typeof MathJax=='undefined'?(window.MathJax={loader:{load:['[tex]/mhchem']},tex:{inlineMath:{'[+]':[['$','$']]},tags:'ams',packages:{'[+]':['mhchem']}}},function(){const a=document.createElement('script');a.src='https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js',a.defer=!0,document.head.appendChild(a)}()):(MathJax.texReset(),MathJax.typeset())</script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js></script>
<script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(a=>{a.parentElement.outerHTML=`<div class="mermaid">${a.innerText}</div>`});const mermaidConfig={startOnLoad:!0,flowchart:{useMaxWidth:!1,htmlLabels:!0},theme:'default'};mermaid.initialize(mermaidConfig)</script><script>function loadComments(){(function(){const b=document.getElementById("utterances");if(!b)return;const a=document.createElement('script');a.src='https://utteranc.es/client.js',a.async=!0,a.crossOrigin='anonymous',a.setAttribute('repo','ZhuZhengyi/gh_comment'),a.setAttribute('issue-term','pathname');const c=getCurrentTheme()==='dark';c?a.setAttribute('theme','photon-dark'):a.setAttribute('theme','github-light'),b.appendChild(a)})()}</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script>
<script>let imgNodes=document.querySelectorAll('div.post-body img');imgNodes=Array.from(imgNodes).filter(a=>a.parentNode.tagName!=="A"),mediumZoom(imgNodes,{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script>
<script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></body></html>