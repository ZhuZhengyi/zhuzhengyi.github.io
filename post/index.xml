<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>滴水穿石 on Justice的小站</title><link>https://justice.bj.cn/post/</link><description>Recent content in 滴水穿石 on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://justice.bj.cn/post/index.xml" rel="self" type="application/rss+xml"/><item><title>1008.前序遍历构造二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1008.symmetric-tree/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1008.symmetric-tree/</guid><description>1008.前序遍历构造二叉搜索树 给定一个整数数组，它表示BST(即 二叉搜索树 )的 先序遍历 ，构造树并返回其根。 保证 对于给定的测试用例，总是有可</description></item><item><title>101.对称二叉树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/101.symmetric-tree/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/101.symmetric-tree/</guid><description>101.对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg 输入：root = [1,2,2,null,3,null,3] 输出：f</description></item><item><title>1027.最长等差数列</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1027.longest-arithmetic-subsequence/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1027.longest-arithmetic-subsequence/</guid><description>1027.最长等差数列 给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。 回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], &amp;hellip;, nums[ik] ，且 0 &amp;lt;= i1 &amp;lt; i2 &amp;lt; &amp;hellip;</description></item><item><title>103.二叉树的锯齿形层序遍历</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/103.binary-tree-zigzag-level-order-traversal/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/103.binary-tree-zigzag-level-order-traversal/</guid><description>103.二叉树的锯齿形层序遍历 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层</description></item><item><title>1037.有效的回旋镖</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1037.valid-boomerang/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1037.valid-boomerang/</guid><description>1037.有效的回旋镖 给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。 回旋镖 定义为一组三个点，这些点 各不</description></item><item><title>1061.按字典序排列最小的等效字符串</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1061.lexicographically-smallest-equivalent-string/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1061.lexicographically-smallest-equivalent-string/</guid><description>1061.按字典序排列最小的等效字符串 给出长度相同的两个字符串s1 和 s2 ，还有一个字符串 baseStr 。 其中 s1[i] 和 s2[i] 是一组等价字符。 举个例子，如果 s1 = &amp;quot;abc&amp;quot; 且 s2</description></item><item><title>1123.最深叶节点的最近公共祖先</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1123.lowest-common-ancestor-of-deepest-leaves/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1123.lowest-common-ancestor-of-deepest-leaves/</guid><description>1123.最深叶节点的最近公共祖先 给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。 回想一下： 叶节点 是二叉树中没有子节点的节点 树</description></item><item><title>2305.公平分发饼干</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/2305.fair-distribution-of-cookies/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/2305.fair-distribution-of-cookies/</guid><description>2305.公平分发饼干 给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需</description></item><item><title>最深叶节点的最近公共祖先</title><link>https://justice.bj.cn/post/leetcode/doc/1123.%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/1123.%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>最深叶节点的最近公共祖先 Category Difficulty Likes Dislikes algorithms Medium (71.90%) 220 - Tags Unknown Companies Unknown 给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。 回想一下： 叶节点 是二叉树中没</description></item><item><title>1.两数之和</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1.two-sum/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1.two-sum/</guid><description>1.两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种</description></item><item><title>10.正则表达式匹配</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/10.regular-expression-matching/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/10.regular-expression-matching/</guid><description>10.正则表达式匹配 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一</description></item><item><title>100.相同的树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/100.same-tree/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/100.same-tree/</guid><description>100.相同的树 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是</description></item><item><title>1008.前序遍历构造二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1008.construct-binary-search-tree-from-preorder-traversal/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1008.construct-binary-search-tree-from-preorder-traversal/</guid><description>1008.前序遍历构造二叉搜索树 给定一个整数数组，它表示BST(即 二叉搜索树 )的 先序遍历 ，构造树并返回其根。 保证 对于给定的测试用例，总是有可</description></item><item><title>180.连续出现的数字</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/180.consecutive-numbers/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/180.consecutive-numbers/</guid><description>180.连续出现的数字 表：Logs +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+ | Column Name | Type | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+ | id | int | | num | varchar | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+ 在 SQL 中，id 是该表的主键。 id 是一个自增列。 找出所有至少连续出现三次的</description></item><item><title>2119.反转两次的数字</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/2119.a-number-after-a-double-reversal/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/2119.a-number-after-a-double-reversal/</guid><description>2119.反转两次的数字 反转 一个整数意味着倒置它的所有位。 例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。 给你一个整数 num ，反转 num 得到 reversed1 ，接着</description></item><item><title>2125.银行中的激光束数量</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/2125.number-of-laser-beams-in-a-bank/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/2125.number-of-laser-beams-in-a-bank/</guid><description>2125.银行中的激光束数量 银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n</description></item><item><title>2605.从两个数字数组里生成最小数字</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/2605.form-smallest-number-from-two-digit-arrays/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/2605.form-smallest-number-from-two-digit-arrays/</guid><description>2605.从两个数字数组里生成最小数字 给你两个只包含 1 到 9 之间数字的数组 nums1 和 nums2 ，每个数组中的元素 互不相同 ，请你返回 最小 的数字，两个数组都 至少</description></item><item><title>606.根据二叉树创建字符串</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/606.construct-string-from-binary-tree/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/606.construct-string-from-binary-tree/</guid><description>606.根据二叉树创建字符串 给你二叉树的根节点 root ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。 空</description></item><item><title>607.销售员</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/607.sales-person/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/607.sales-person/</guid><description>607.销售员 表: SalesPerson +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;+ | Column Name | Type | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;+ | sales_id | int | | name | varchar | | salary | int | | commission_rate | int | | hire_date | date | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;+ sales_id 是该表的主键列(具有唯一值的列)。 该表的每一行都显</description></item><item><title>最多可以摧毁的敌人城堡数目</title><link>https://justice.bj.cn/post/leetcode/doc/2511.%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/2511.%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/</guid><description>最多可以摧毁的敌人城堡数目 题目描述 给你一个长度为 n ，下标从 0 开始的整数数组 forts ，表示一些城堡。forts[i] 可以是 -1 ，0 或者 1 ，其中： -1 表示</description></item></channel></rss>