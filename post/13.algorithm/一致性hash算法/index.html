<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>一致性哈希算法 - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=referrer content="no-referrer">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="一致性哈希算法 一致性哈希算法在 1997 年由麻省理工学院的 Karger 等人在解决分布式 Cache 中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷">
<meta name=keywords content="tech,it,blog">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/13.algorithm/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.34a0cf3583dc0fd6b4e3fe24a36c076984feee75ebc2792cff33928ccdcfc628.css integrity="sha256-NKDPNYPcD9a04/4ko2wHaYT+7nXrwnks/zOSjM3Pxig=" media=screen crossorigin=anonymous>
<meta property="og:title" content="一致性哈希算法">
<meta property="og:description" content="一致性哈希算法 一致性哈希算法在 1997 年由麻省理工学院的 Karger 等人在解决分布式 Cache 中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/13.algorithm/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-04-30T17:04:39+08:00">
<meta property="article:modified_time" content="2022-04-30T17:04:39+08:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="一致性哈希算法">
<meta itemprop=description content="一致性哈希算法 一致性哈希算法在 1997 年由麻省理工学院的 Karger 等人在解决分布式 Cache 中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷"><meta itemprop=datePublished content="2022-04-30T17:04:39+08:00">
<meta itemprop=dateModified content="2022-04-30T17:04:39+08:00">
<meta itemprop=wordCount content="3789">
<meta itemprop=keywords content="algorithm,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="一致性哈希算法">
<meta name=twitter:description content="一致性哈希算法 一致性哈希算法在 1997 年由麻省理工学院的 Karger 等人在解决分布式 Cache 中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<script src=/js/fuse.min.js></script>
<script src=/js/fastsearch.js></script>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=search-btn class="menu-item-link menu-item-search" href=javascript:void(0);>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
<div id=fastSearch>
<input id=searchInput tabindex=0>
<ul id=searchResults>
</ul>
</div>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>一致性哈希算法</h1>
<div class=post-meta>
<time datetime=2022-04-30 class=post-time>
2022-04-30 17:04:39
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/algorithm/> algorithm </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#一致性-hash-性质>一致性 Hash 性质</a></li>
<li><a href=#原理>原理</a>
<ul>
<li><a href=#基本概念>基本概念</a></li>
</ul>
</li>
<li><a href=#java-代码实现>JAVA 代码实现</a></li>
<li><a href=#jump-一致性哈希算法>Jump 一致性哈希算法</a></li>
<li><a href=#kademlia-算法>Kademlia 算法</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=一致性哈希算法>一致性哈希算法</h1>
<p>一致性哈希算法在 1997 年由麻省理工学院的 Karger 等人在解决分布式 Cache 中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和 CARP 十分类似。一致性哈希修正了 CARP 使用的简单哈希算法带来的问题，使得 DHT 可以在 P2P 环境中真正得到应用。</p>
<p>但现在一致性 hash 算法在分布式系统中也得到了广泛应用，研究过 memcached 缓存数据库的人都知道，memcached 服务器端本身不提供分布式 cache 的一致性，而是由客户端来提供，具体在计算一致性 hash 时采用如下步骤：</p>
<ol>
<li>首先求出 memcached 服务器（节点）的哈希值，并将其配置到 0 ～ 232 的圆（continuum）上。</li>
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过 232 仍然找不到服务器，就会保存到第一台 memcached 服务器上。</li>
</ol>
<p><img src=https://user-gold-cdn.xitu.io/2018/4/26/162ffff01ae569b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt></p>
<p>从上图的状态中添加一台 memcached 服务器。余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但 Consistent Hashing 中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响，如下图所示：</p>
<p><img src=https://user-gold-cdn.xitu.io/2018/4/26/162ffff01cb23ca9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt></p>
<h2 id=一致性-hash-性质>一致性 Hash 性质</h2>
<p>考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其 hash 值（通常与系统中的节点数目有关），由于 hash 值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性 hash 就显得至关重要，良好的分布式 cahce 系统中的一致性 hash 算法应该满足以下几个方面：</p>
<ul>
<li><strong>平衡性(Balance)</strong></li>
</ul>
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
<ul>
<li><strong>单调性(Monotonicity)</strong></li>
</ul>
<p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。简单的哈希算法往往不能满足单调性的要求，如最简单的线性哈希：x = (ax + b) mod (P)，在上式中，P 表示全部缓冲的大小。不难看出，当缓冲大小发生变化时(从 P1 到 P2)，原来所有的哈希结果均会发生变化，从而不满足单调性的要求。哈希结果的变化意味着当缓冲空间发生变化时，所有的映射关系需要在系统内全部更新。而在 P2P 系统内，缓冲的变化等价于 Peer 加入或退出系统，这一情况在 P2P 系统中会频繁发生，因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。</p>
<ul>
<li><strong>分散性(Spread)</strong></li>
</ul>
<p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
<ul>
<li><strong>负载(Load)</strong></li>
</ul>
<p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<ul>
<li><strong>平滑性(Smoothness)</strong></li>
</ul>
<p>平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</p>
<h2 id=原理>原理</h2>
<h3 id=基本概念>基本概念</h3>
<p>一致性哈希算法（Consistent Hashing）最早在论文《<a href="http://dl.acm.org/citation.cfm?id=258660">Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web</a>》中被提出。简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2^32-1（即哈希值是一个 32 位无符号整形），整个哈希空间环如下：</p>
<p><img src=https://user-gold-cdn.xitu.io/2018/4/26/162ffff019d48ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt></p>
<p>整个空间按顺时针方向组织。0 和 232-1 在零点中方向重合。</p>
<p>下一步将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 ip 或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用 ip 地址哈希后在环空间的位置如下：</p>
<p><img src=https://user-gold-cdn.xitu.io/2018/4/26/162ffff019f1cecc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt></p>
<p>接下来使用如下算法定位数据访问到相应服务器：将数据 key 使用相同的函数 Hash 计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p>
<p>例如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p>![](data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="746" height="775"/>)</p>
<p>根据一致性哈希算法，数据 A 会被定为到 Node A 上，B 被定为到 Node B 上，C 被定为到 Node C 上，D 被定为到 Node D 上。</p>
<p>下面分析一致性哈希算法的容错性和可扩展性。现假设 Node C 不幸宕机，可以看到此时对象 A、B、D 不会受到影响，只有 C 对象被重定位到 Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p>
<p>下面考虑另外一种情况，如果在系统中增加一台服务器 Node X，如下图所示：</p>
<p><img src=https://user-gold-cdn.xitu.io/2018/4/26/162ffff01dab936a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt></p>
<p>此时对象 Object A、B、D 不受影响，只有对象 C 需要重定位到新的 Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<p>另外，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务器，其环分布如下，</p>
<p><img src=https://user-gold-cdn.xitu.io/2018/4/26/162ffff040ae43be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt></p>
<p>此时必然造成大量数据集中到 Node A 上，而只有极少量会定位到 Node B 上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器 ip 或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p>
<p><img src=https://user-gold-cdn.xitu.io/2018/4/26/162ffff03ecc7be4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt></p>
<p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到 Node A 上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为 32 甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
<h2 id=java-代码实现>JAVA 代码实现</h2>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kn>package</span> <span class=nn>org.java.base.hash</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.Collection</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.HashSet</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.Iterator</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.Set</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.SortedMap</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.SortedSet</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.TreeMap</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.TreeSet</span><span class=o>;</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>ConsistentHash</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
 <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>numberOfReplicas</span><span class=o>;</span><span class=c1>// 节点的复制因子,实际节点个数 * numberOfReplicas =
</span><span class=c1></span> <span class=c1>// 虚拟节点个数
</span><span class=c1></span> <span class=kd>private</span> <span class=kd>final</span> <span class=n>SortedMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>circle</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>T</span><span class=o>&gt;();</span><span class=c1>// 存储虚拟节点的hash值到真实节点的映射
</span><span class=c1></span>
 <span class=kd>public</span> <span class=nf>ConsistentHash</span><span class=o>(</span> <span class=kt>int</span> <span class=n>numberOfReplicas</span><span class=o>,</span>
 <span class=n>Collection</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>nodes</span><span class=o>)</span> <span class=o>{</span>
 <span class=k>this</span><span class=o>.</span><span class=na>numberOfReplicas</span> <span class=o>=</span> <span class=n>numberOfReplicas</span><span class=o>;</span>
 <span class=k>for</span> <span class=o>(</span><span class=n>T</span> <span class=n>node</span> <span class=o>:</span> <span class=n>nodes</span><span class=o>){</span>
 <span class=n>add</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
 <span class=o>}</span>
 <span class=o>}</span>

 <span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=n>T</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
 <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numberOfReplicas</span><span class=o>;</span> <span class=n>i</span><span class=o>++){</span>
 <span class=c1>// 对于一个实际机器节点 node, 对应 numberOfReplicas 个虚拟节点
</span><span class=c1></span> <span class=cm>/*
</span><span class=cm> * 不同的虚拟节点(i不同)有不同的hash值,但都对应同一个实际机器node
</span><span class=cm> * 虚拟node一般是均衡分布在环上的,数据存储在顺时针方向的虚拟node上
</span><span class=cm> */</span>
 <span class=n>String</span> <span class=n>nodestr</span> <span class=o>=</span><span class=n>node</span><span class=o>.</span><span class=na>toString</span><span class=o>()</span> <span class=o>+</span> <span class=n>i</span><span class=o>;</span>
 <span class=kt>int</span> <span class=n>hashcode</span> <span class=o>=</span><span class=n>nodestr</span><span class=o>.</span><span class=na>hashCode</span><span class=o>();</span>
 <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;hashcode:&#34;</span><span class=o>+</span><span class=n>hashcode</span><span class=o>);</span>
 <span class=n>circle</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>hashcode</span><span class=o>,</span> <span class=n>node</span><span class=o>);</span>

 <span class=o>}</span>
 <span class=o>}</span>

 <span class=kd>public</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>(</span><span class=n>T</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
 <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numberOfReplicas</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
 <span class=n>circle</span><span class=o>.</span><span class=na>remove</span><span class=o>((</span><span class=n>node</span><span class=o>.</span><span class=na>toString</span><span class=o>()</span> <span class=o>+</span> <span class=n>i</span><span class=o>).</span><span class=na>hashCode</span><span class=o>());</span>
 <span class=o>}</span>

 <span class=cm>/*
</span><span class=cm> * 获得一个最近的顺时针节点,根据给定的key 取Hash
</span><span class=cm> * 然后再取得顺时针方向上最近的一个虚拟节点对应的实际节点
</span><span class=cm> * 再从实际节点中取得 数据
</span><span class=cm> */</span>
 <span class=kd>public</span> <span class=n>T</span> <span class=nf>get</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
 <span class=k>if</span> <span class=o>(</span><span class=n>circle</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
 <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
 <span class=kt>int</span> <span class=n>hash</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>hashCode</span><span class=o>();</span><span class=c1>// node 用String来表示,获得node在哈希环中的hashCode
</span><span class=c1></span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;hashcode-----&gt;:&#34;</span><span class=o>+</span><span class=n>hash</span><span class=o>);</span>
 <span class=k>if</span> <span class=o>(!</span><span class=n>circle</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>hash</span><span class=o>))</span> <span class=o>{</span><span class=c1>//数据映射在两台虚拟机器所在环之间,就需要按顺时针方向寻找机器
</span><span class=c1></span> <span class=n>SortedMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>tailMap</span> <span class=o>=</span> <span class=n>circle</span><span class=o>.</span><span class=na>tailMap</span><span class=o>(</span><span class=n>hash</span><span class=o>);</span>
 <span class=n>hash</span> <span class=o>=</span> <span class=n>tailMap</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()</span> <span class=o>?</span> <span class=n>circle</span><span class=o>.</span><span class=na>firstKey</span><span class=o>()</span> <span class=o>:</span> <span class=n>tailMap</span><span class=o>.</span><span class=na>firstKey</span><span class=o>();</span>
 <span class=o>}</span>
 <span class=k>return</span> <span class=n>circle</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>hash</span><span class=o>);</span>
 <span class=o>}</span>

 <span class=kd>public</span> <span class=kt>long</span> <span class=nf>getSize</span><span class=o>()</span> <span class=o>{</span>
 <span class=k>return</span> <span class=n>circle</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
 <span class=o>}</span>

 <span class=cm>/*
</span><span class=cm> * 查看表示整个哈希环中各个虚拟节点位置
</span><span class=cm> */</span>
 <span class=kd>public</span> <span class=kt>void</span> <span class=nf>testBalance</span><span class=o>(){</span>
 <span class=n>Set</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>sets</span> <span class=o>=</span> <span class=n>circle</span><span class=o>.</span><span class=na>keySet</span><span class=o>();</span><span class=c1>//获得TreeMap中所有的Key
</span><span class=c1></span> <span class=n>SortedSet</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>sortedSets</span><span class=o>=</span> <span class=k>new</span> <span class=n>TreeSet</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;(</span><span class=n>sets</span><span class=o>);</span><span class=c1>//将获得的Key集合排序
</span><span class=c1></span> <span class=k>for</span><span class=o>(</span><span class=n>Integer</span> <span class=n>hashCode</span> <span class=o>:</span> <span class=n>sortedSets</span><span class=o>){</span>
 <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>hashCode</span><span class=o>);</span>
 <span class=o>}</span>

 <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;----each location &#39;s distance are follows: ----&#34;</span><span class=o>);</span>
 <span class=cm>/*
</span><span class=cm> * 查看相邻两个hashCode的差值
</span><span class=cm> */</span>
 <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>it</span> <span class=o>=</span> <span class=n>sortedSets</span><span class=o>.</span><span class=na>iterator</span><span class=o>();</span>
 <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>it2</span> <span class=o>=</span> <span class=n>sortedSets</span><span class=o>.</span><span class=na>iterator</span><span class=o>();</span>
 <span class=k>if</span><span class=o>(</span><span class=n>it2</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span>
 <span class=n>it2</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
 <span class=kt>long</span> <span class=n>keyPre</span><span class=o>,</span> <span class=n>keyAfter</span><span class=o>;</span>
 <span class=k>while</span><span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=na>hasNext</span><span class=o>()</span> <span class=o>&amp;&amp;</span> <span class=n>it2</span><span class=o>.</span><span class=na>hasNext</span><span class=o>()){</span>
 <span class=n>keyPre</span> <span class=o>=</span> <span class=n>it</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
 <span class=n>keyAfter</span> <span class=o>=</span> <span class=n>it2</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
 <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>keyAfter</span> <span class=o>-</span> <span class=n>keyPre</span><span class=o>);</span>
 <span class=o>}</span>
 <span class=o>}</span>

 <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
 <span class=n>Set</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>nodes</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashSet</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;();</span>
 <span class=n>nodes</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;A&#34;</span><span class=o>);</span>
 <span class=n>nodes</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;B&#34;</span><span class=o>);</span>
 <span class=n>nodes</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;C&#34;</span><span class=o>);</span>

 <span class=n>ConsistentHash</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>consistentHash</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ConsistentHash</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;(</span><span class=n>2</span><span class=o>,</span> <span class=n>nodes</span><span class=o>);</span>
 <span class=n>consistentHash</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;D&#34;</span><span class=o>);</span>

 <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;hash circle size: &#34;</span> <span class=o>+</span> <span class=n>consistentHash</span><span class=o>.</span><span class=na>getSize</span><span class=o>());</span>
 <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;location of each node are follows: &#34;</span><span class=o>);</span>
 <span class=n>consistentHash</span><span class=o>.</span><span class=na>testBalance</span><span class=o>();</span>

 <span class=n>String</span> <span class=n>node</span> <span class=o>=</span><span class=n>consistentHash</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=s>&#34;apple&#34;</span><span class=o>);</span>
 <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;node-----------&gt;:&#34;</span><span class=o>+</span><span class=n>node</span><span class=o>);</span>
 <span class=o>}</span>

<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=jump-一致性哈希算法>Jump 一致性哈希算法</h2>
<p>jump consistent hash 是一种一致性哈希算法, 此算法<strong>零内存消耗</strong>，<strong>均匀分配</strong>，<strong>快速</strong>，并且<strong>只有 5 行代码</strong>。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>int32_t</span> <span class=nf>JumpConsistentHash</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int32_t</span> <span class=n>num_buckets</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int64_t</span> <span class=n>b</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>num_buckets</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>b</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
        <span class=n>key</span> <span class=o>=</span> <span class=n>key</span> <span class=o>*</span> <span class=mi>2862933555777941757ULL</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
        <span class=n>j</span> <span class=o>=</span> <span class=p>(</span><span class=n>b</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=kt>double</span><span class=p>(</span><span class=mi>1LL</span> <span class=o>&lt;&lt;</span> <span class=mi>31</span><span class=p>)</span> <span class=o>/</span> <span class=kt>double</span><span class=p>((</span><span class=n>key</span> <span class=o>&gt;&gt;</span> <span class=mi>33</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=kademlia-算法>Kademlia 算法</h2>
<p>Kademlia 算法在 2002 年由 Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点。Kademlia 后来被 eMule、BitTorrent 等 P2P 软件采用作为底层算法。</p>
<ul>
<li>对于任意一个有[ 2(n−1) ,2𝑛)个节点的网络，最多只需要 n 步搜索即可找到目标节点；</li>
<li>K-bucket 的更新机制一定程度上保持了网络的活性和安全性。</li>
</ul>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2022-04-30 17:04:39
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/alipay_reward_qrcode.png>
<span>支付宝打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/bitcoin_reward_qrcode.png>
<span>比特币打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/algorithm/>algorithm</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/13.algorithm/kmp%E7%AE%97%E6%B3%95/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">KMP算法</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/13.algorithm/design_pattern/>
<span class="next-text nav-default">设计模式及准则</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2024
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
</body>
</html>