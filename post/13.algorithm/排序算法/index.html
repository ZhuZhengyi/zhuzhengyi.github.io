<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>排序算法 - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=referrer content="no-referrer">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="排序算法 概述 排序是将无序的序列变成有序的序列的计算过程，是计算机程序设计中最基础算法之一。 分类 排序算法一般分为两大类： 比较类排序：通过比较操">
<meta name=keywords content="tech,it,blog">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/13.algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.34a0cf3583dc0fd6b4e3fe24a36c076984feee75ebc2792cff33928ccdcfc628.css integrity="sha256-NKDPNYPcD9a04/4ko2wHaYT+7nXrwnks/zOSjM3Pxig=" media=screen crossorigin=anonymous>
<meta property="og:title" content="排序算法">
<meta property="og:description" content="排序算法 概述 排序是将无序的序列变成有序的序列的计算过程，是计算机程序设计中最基础算法之一。 分类 排序算法一般分为两大类： 比较类排序：通过比较操">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/13.algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2024-03-07T11:58:54+08:00">
<meta property="article:modified_time" content="2024-03-07T11:58:54+08:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="排序算法">
<meta itemprop=description content="排序算法 概述 排序是将无序的序列变成有序的序列的计算过程，是计算机程序设计中最基础算法之一。 分类 排序算法一般分为两大类： 比较类排序：通过比较操"><meta itemprop=datePublished content="2024-03-07T11:58:54+08:00">
<meta itemprop=dateModified content="2024-03-07T11:58:54+08:00">
<meta itemprop=wordCount content="4815">
<meta itemprop=keywords content="algorithm,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="排序算法">
<meta name=twitter:description content="排序算法 概述 排序是将无序的序列变成有序的序列的计算过程，是计算机程序设计中最基础算法之一。 分类 排序算法一般分为两大类： 比较类排序：通过比较操"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<div id=fastSearch>
<input id=searchInput tabindex=0>
<ul id=searchResults>
</ul>
</div>
<script src=/js/fuse.min.js></script>
<script src=/js/fastsearch.js></script>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=search-btn style=display:inline-block href=javascript:void(0);>
<span class=icon-search>捜</span>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>排序算法</h1>
<div class=post-meta>
<time datetime=2024-03-07 class=post-time>
2024-03-07 11:58:54
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/algorithm/> algorithm </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#概述>概述</a>
<ul>
<li><a href=#分类>分类</a></li>
<li><a href=#相关概念>相关概念</a></li>
</ul>
</li>
<li><a href=#比较排序>比较排序</a>
<ul>
<li><a href=#冒泡排序bubble-sort>冒泡排序（Bubble Sort）</a></li>
<li><a href=#鸡尾酒排序>鸡尾酒排序</a></li>
<li><a href=#选择排序selection-sort>选择排序（Selection Sort）</a></li>
<li><a href=#插入排序insertion-sort>插入排序（Insertion Sort）</a></li>
</ul>
</li>
<li><a href=#高级比较排序算法>高级比较排序算法</a>
<ul>
<li><a href=#希尔排序shell-sort>希尔排序（Shell Sort）</a></li>
<li><a href=#归并排序merge-sort>归并排序（Merge Sort）</a></li>
<li><a href=#快速排序quick-sort>快速排序（Quick Sort）</a></li>
<li><a href=#堆排序heap-sort>堆排序（Heap Sort）</a></li>
</ul>
</li>
<li><a href=#非比较排序>非比较排序</a>
<ul>
<li><a href=#计数排序counting-sort>计数排序（Counting Sort）</a></li>
<li><a href=#桶排序bucket-sort>桶排序（Bucket Sort）</a></li>
<li><a href=#基数排序radix-sort>基数排序（Radix Sort）</a></li>
</ul>
</li>
<li><a href=#参考>参考</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=排序算法>排序算法</h1>
<h2 id=概述>概述</h2>
<p>排序是将无序的序列变成有序的序列的计算过程，是计算机程序设计中最基础算法之一。</p>
<h3 id=分类>分类</h3>
<p>排序算法一般分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较操作来实现，其时间复杂度不能突破$O(nlogn)$，故也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较操作实现，可突破基于比较排序的时间下界，可以线性时间运行，代价往往需要额外的空间；</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>排序方法</th>
<th>时间复杂度(Avg/Max/Min)</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>比较</td>
<td>冒泡排序</td>
<td>$O(n^2)$/$O(n^2)$/$O(n)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td>插入排序</td>
<td>$O(n^2)$/$O(n^2)$/$O(n)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td>选择排序</td>
<td>$O(n^2)$/$O(n^2)$/$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td></td>
<td>希尔排序</td>
<td>$O(n^{1.3})$/$O(n^2)$/$O(n)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td></td>
<td>归并排序</td>
<td>$O(nlog{{n}})$/$O(nlog{{n}})$/$O(nlog{{n}})$</td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td>堆排序</td>
<td>$O(n{log}n)$/$O(nlog{{n}})$/$O(nlog{{n}})$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td></td>
<td>快速排序</td>
<td>$O(n{log}n)$/$O(n^2)$/$O(nlog{{n}})$</td>
<td>$O(nlog_2n)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>非比较</td>
<td>基数排序</td>
<td>$O(n<em>k)$/$O(n</em>k)$/$O(n*k)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td>计数排序</td>
<td>$O(n+k)$/$O(n+k)$/$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td>桶排序</td>
<td>$O(n+k)$/$O(n^2)$/$O(n)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h3 id=相关概念>相关概念</h3>
<ul>
<li><strong>稳定性</strong>：如果 key1 原本在 key2 前面，而 key1==key2，排序之后 key1 仍然在 key2 的前面，则为稳定排序；</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数量级。反映当 n 变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度</strong>： 是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</li>
</ul>
<h2 id=比较排序>比较排序</h2>
<h3 id=冒泡排序bubble-sort>冒泡排序（Bubble Sort）</h3>
<ul>
<li>
<p>冒泡排序是一种比较排序算法。</p>
</li>
<li>
<p>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
</li>
<li>
<p>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
</li>
<li>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</li>
</ul>
<h4 id=实现>实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 冒泡排序
</span><span class=sd></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>bubble_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span>
<span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>        </span><span class=c1>// 外层控制遍历的次数
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>sorted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>      </span><span class=c1>// 提前判断是否有序
</span><span class=c1></span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=o>-</span><span class=n>i</span><span class=w> </span><span class=p>{</span><span class=w>  </span><span class=c1>// 内存控制每次遍历比较的次数
</span><span class=c1></span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>j</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span><span class=w>                </span><span class=n>sorted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>sorted</span><span class=w> </span><span class=p>{</span><span class=w>  </span><span class=c1>//如果一次遍历中, 所有前面的元素都&lt;后面元素, 则表明遍历的序列有序
</span><span class=c1></span><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>   
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h3 id=鸡尾酒排序>鸡尾酒排序</h3>
<ul>
<li>
<p>鸡尾酒排序是一种双向冒泡排序；</p>
</li>
<li>
<p>从两个方向（低到高、高到低）同时冒泡排序，效率更高；</p>
</li>
</ul>
<h4 id=算法描述>算法描述</h4>
<h4 id=实现-1>实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 鸡尾酒排序
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>cocktail_shaker_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span>
<span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>L</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>L</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>sorted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>i</span><span class=p>..(</span><span class=n>L</span><span class=o>-</span><span class=mi>1</span><span class=o>-</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>if</span><span class=w>  </span><span class=n>nums</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span><span class=w>                </span><span class=n>sorted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=k>if</span><span class=w>  </span><span class=n>nums</span><span class=p>[</span><span class=n>L</span><span class=o>-</span><span class=mi>1</span><span class=o>-</span><span class=n>k</span><span class=p>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>L</span><span class=o>-</span><span class=mi>1</span><span class=o>-</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>L</span><span class=o>-</span><span class=mi>1</span><span class=o>-</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>L</span><span class=o>-</span><span class=mi>1</span><span class=o>-</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span><span class=w>                </span><span class=n>sorted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>sorted</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>i</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h3 id=选择排序selection-sort>选择排序（Selection Sort）</h3>
<ul>
<li>
<p>选择排序(Selection-sort)是一种比较排序算法；</p>
</li>
<li>
<p>它通过将数组分为前后2个部分：</p>
<ul>
<li>
<p>前面已排序部分(初始大小为0)；</p>
</li>
<li>
<p>后面未排序部分(初始大小为<code>nums.len()</code>)；</p>
</li>
</ul>
</li>
<li>
<p>然后依次从未排序部分中<strong>选择</strong>(Select)剩下的最小元素，将其放到前面已排序部分的末尾；</p>
</li>
<li>
<p>如此重复, 直到所有后面部分元素都被加入到前面, 则排序完成；</p>
</li>
</ul>
<h4 id=算法描述-1>算法描述</h4>
<p>n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>
<p>初始状态：无序区为 R[1..n]，有序区为空；</p>
</li>
<li>
<p>第 i 趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为 R[1..i-1]和 R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i]和 R[i+1..n)分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；</p>
</li>
<li>
<p>n-1 趟结束，数组有序化了。</p>
</li>
</ol>
<h4 id=实现-2>实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 选择排序
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>select_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span>
<span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>                 
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>mi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>                 </span><span class=c1>// 未排序部分最小元素初始下标
</span><span class=c1></span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>      </span><span class=c1>// 遍历未排序部分, 寻找最小元素下标
</span><span class=c1></span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>mi</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>     </span><span class=c1>//
</span><span class=c1></span><span class=w>                </span><span class=n>mi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>mi</span><span class=p>);</span><span class=w>                </span><span class=c1>// 将最小元素和未排序部分最前面元素交换,
</span><span class=c1></span><span class=w>                                         </span><span class=c1>// 即紧接已排序部分之后
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h4 id=算法分析>算法分析</h4>
<ul>
<li>
<p>选择排序是最稳定的排序算法之一，无论什么数据进去都是$O(^2)$的时间复杂度，</p>
</li>
<li>
<p>当数据规模小时有优势；</p>
</li>
<li>
<p>不占用额外的内存空间；</p>
</li>
</ul>
<h3 id=插入排序insertion-sort>插入排序（Insertion Sort）</h3>
<ul>
<li>
<p>插入排序算法是一种比较排序算法；</p>
</li>
<li>
<p>其基本过程和选择排序类似，都将原序列看成前后两个部分：</p>
<ul>
<li>
<p>前面：已排序部分(初始长度为1)；</p>
</li>
<li>
<p>后面：未排序部分(初始长度为<code>nums.len()-1</code>)；</p>
</li>
</ul>
</li>
<li>
<p>不同之处在于遍历操作时，将后面未排序部分的最前面元素<strong>插入</strong>(Insert)到前面部分的合适位置；</p>
</li>
<li>
<p>每次插入时，插入点后面还有已排序的元素，则需要将其这些都后移一位；</p>
</li>
</ul>
<h4 id=算法描述-2>算法描述</h4>
<ol>
<li>
<p>将待排序数组分为前后两个部分:</p>
<ul>
<li>
<p>前面: <code>已排序部分</code>;</p>
</li>
<li>
<p>后面: <code>未排序部分</code>;</p>
</li>
</ul>
</li>
<li>
<p>开始<code>已排序部分</code>长度为1, <code>未排序部分</code>长度为<code>nums.len()-1</code>;</p>
</li>
<li>
<p>将<code>未排序部分</code>的头元素<strong>插入</strong>到前面<code>已排序部分</code>的正确位置(按大小顺序).
插入时，要将<code>已排序部分</code>插入点后面的元素依次往后移1位;</p>
</li>
<li>
<p>重复步骤3, 当所有<code>未排序部分</code>都插入到<code>已排序部分</code>后, 排序完成;</p>
</li>
</ol>
<h4 id=实现-3>实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 插入排序
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>insert_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span> <span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Clone</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=w>               </span><span class=c1>// `未排序部分`头元素
</span><span class=c1></span><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 从后往前将`已排序部分`中大于未排序部分头元素的元素
</span><span class=c1></span><span class=w>            </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span><span class=w>       </span><span class=c1>// 后移动一位
</span><span class=c1></span><span class=w>            </span><span class=n>j</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w>                   </span><span class=c1>// 将头元素插入到正确位置
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h4 id=算法分析-1>算法分析</h4>
<ul>
<li>
<p>插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序）；</p>
</li>
<li>
<p>在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</li>
</ul>
<h2 id=高级比较排序算法>高级比较排序算法</h2>
<h3 id=希尔排序shell-sort>希尔排序（Shell Sort）</h3>
<ul>
<li>
<p>ShellSort是第一个突破$O(n^2)$的排序算法，1959年由Shell发明；</p>
</li>
<li>
<p>是简单插入排序的改进版，与插入排序的不同之处在于，它会优先比较距离较远的元素；</p>
</li>
<li>
<p>希尔排序又叫<strong>缩小增量排序</strong>；</p>
</li>
</ul>
<h4 id=算法描述-3>算法描述</h4>
<p>先将整个待排序的序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>
<p>选择一个增量序列 t1，t2，…，tk，其中 ti>tj，tk=1；</p>
</li>
<li>
<p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。</p>
</li>
<li>
<p>仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<h4 id=实现-4>实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 希尔排序 
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>shell_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span> <span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// 带间隔的插入排序
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>_insert_sort_with_gap</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>PartialOrd</span> <span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>start</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>gap</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=n>start</span><span class=o>+</span><span class=n>gap</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()).</span><span class=n>step_by</span><span class=p>(</span><span class=n>gap</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=w>               </span><span class=c1>// `未排序部分`头元素
</span><span class=c1></span><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>gap</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=n>gap</span><span class=p>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 从后往前将`已排序部分`中大于未排序部分头元素的元素
</span><span class=c1></span><span class=w>                </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=n>gap</span><span class=p>];</span><span class=w>       </span><span class=c1>// 后移动gap位
</span><span class=c1></span><span class=w>                </span><span class=n>j</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>gap</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w>                   </span><span class=c1>// 将头元素插入到正确位置
</span><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>gap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=n>gap</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>start</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>gap</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>_insert_sort_with_gap</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>gap</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>gap</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h4 id=算法分析-2>算法分析</h4>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第 4 版）》的合著者 Robert Sedgewick 提出的。</p>
<h3 id=归并排序merge-sort>归并排序（Merge Sort）</h3>
<ul>
<li>
<p>归并排序是建立在归并操作(<code>merge()</code>)上的一种有效的排序算法；</p>
</li>
<li>
<p>是分治法（Divide and Conquer）的一个典型的应用。</p>
</li>
<li>
<p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
</li>
<li>
<p>若将两个有序表合并成一个有序表，称为 2-路归并。</p>
</li>
</ul>
<h4 id=算法描述-4>算法描述</h4>
<ol>
<li>
<p>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</p>
</li>
<li>
<p>对这两个子序列分别采用归并排序；</p>
</li>
<li>
<p>将两个排序好的子序列合并成一个最终的排序序列。</p>
</li>
</ol>
<h4 id=实现-5>实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 归并排序
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>merge_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w> 
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span> <span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Clone</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// 将数组左右两个有序的部分合并, 使整体有序
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>_merge</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>start</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>mid</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>end</span>: <span class=kt>usize</span><span class=p>)</span><span class=w>
</span><span class=w>         </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span> <span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Clone</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>nums1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>start</span><span class=p>..</span><span class=n>mid</span><span class=p>].</span><span class=n>iter</span><span class=p>().</span><span class=n>cloned</span><span class=p>().</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;&gt;</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>nums2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>..</span><span class=n>end</span><span class=p>].</span><span class=n>iter</span><span class=p>().</span><span class=n>cloned</span><span class=p>().</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;&gt;</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>l</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums1</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums2</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>nums2</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>(</span><span class=n>l</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums1</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>nums1</span><span class=p>[</span><span class=n>l</span><span class=p>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums2</span><span class=p>[</span><span class=n>r</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>nums</span><span class=p>[</span><span class=n>start</span><span class=o>+</span><span class=n>l</span><span class=o>+</span><span class=n>r</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums1</span><span class=p>[</span><span class=n>l</span><span class=p>];</span><span class=w>
</span><span class=w>                </span><span class=n>l</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>nums</span><span class=p>[</span><span class=n>start</span><span class=o>+</span><span class=n>l</span><span class=o>+</span><span class=n>r</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums2</span><span class=p>[</span><span class=n>r</span><span class=p>];</span><span class=w>
</span><span class=w>                </span><span class=n>r</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// 递归归并排序
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>_merge_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>start</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>end</span>: <span class=kt>usize</span><span class=p>)</span><span class=w>
</span><span class=w>         </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span> <span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Clone</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>end</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>end</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>_merge_sort</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>_merge_sort</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>,</span><span class=w> </span><span class=n>end</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>_merge</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>,</span><span class=w> </span><span class=n>end</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>_merge_sort</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>())</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h4 id=算法分析-3>算法分析</h4>
<ul>
<li>
<p>归并排序是一种稳定的排序方法。</p>
</li>
<li>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn）的时间复杂度。</p>
</li>
<li>
<p>代价是需要额外的内存空间；</p>
</li>
</ul>
<h3 id=快速排序quick-sort>快速排序（Quick Sort）</h3>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id=算法描述-5>算法描述</h4>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>
<p>从数列中挑出一个元素，称为 “基准”（pivot）；</p>
</li>
<li>
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li>
<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<h4 id=代码实现>代码实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>quick_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span>
<span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// 将nums划分为前后两个部分, 使前一部分都小于后一部分, 返回划分点
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>partition</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>PartialOrd</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>])</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>              </span><span class=c1>// 划分点
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>     </span><span class=c1>// 基准元素下标
</span><span class=c1></span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>p</span><span class=w> </span><span class=p>{</span><span class=w>             </span><span class=c1>// 依次遍历所有非基准元素
</span><span class=c1></span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>p</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 如果当前元素&lt;基准元素
</span><span class=c1></span><span class=w>                </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>);</span><span class=w>    </span><span class=c1>// 将其和划分点元素交换
</span><span class=c1></span><span class=w>                </span><span class=n>m</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>             </span><span class=c1>// 往后移动划分点
</span><span class=c1></span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>m</span><span class=p>,</span><span class=w> </span><span class=n>p</span><span class=p>);</span><span class=w>            </span><span class=c1>// 最后, 将基准元素和划分点元素交换
</span><span class=c1></span><span class=w>        </span><span class=n>m</span><span class=w>                           </span><span class=c1>// 返回划分点
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// 递归快排
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>_quick_sort</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>PartialOrd</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>nums</span><span class=p>);</span><span class=w>        </span><span class=c1>// 将nums划分为前后两部分
</span><span class=c1></span><span class=w>        </span><span class=n>_quick_sort</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>nums</span><span class=p>[..</span><span class=n>m</span><span class=p>]);</span><span class=w>    </span><span class=c1>// 
</span><span class=c1></span><span class=w>        </span><span class=n>_quick_sort</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>m</span><span class=o>+</span><span class=mi>1</span><span class=p>..]);</span><span class=w>  </span><span class=c1>//
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>_quick_sort</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>nums</span><span class=p>[..]);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h3 id=堆排序heap-sort>堆排序（Heap Sort）</h3>
<ul>
<li>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p>
</li>
<li>
<p>堆(heap)的性质:</p>
<ul>
<li>
<p><strong>堆</strong>是一个<strong>完全二叉树</strong>；</p>
</li>
<li>
<p>每个非叶子结点值均大于(大顶堆)/小于(小顶堆)其左右子节点值；</p>
</li>
<li>
<p><strong>根节点</strong>为所有节点中的最大值(大顶堆)/最小值(小顶堆)；</p>
</li>
</ul>
</li>
</ul>
<h4 id=算法描述-6>算法描述</h4>
<ol>
<li>
<p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li>
<p>将堆顶元素 R[1]与最后一个元素 R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足 R[1,2…n-1]&lt;=R[n]；</p>
</li>
</ol>
<h4 id=实现-6>实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 堆排序
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>heap_sort</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>PartialOrd</span>
<span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// 以nums[top]为顶调整为堆
</span><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>heapify</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>PartialOrd</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>],</span><span class=w> </span><span class=n>top</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>top</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>l</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>l</span><span class=p>]</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>m</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>l</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>r</span><span class=p>]</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>nums</span><span class=p>[</span><span class=n>m</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>m</span><span class=p>,</span><span class=w> </span><span class=n>top</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=n>heapify</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// 从最后一个非叶子节点开始, 往上依次调整所有以该节点为根的子树，使之成为大顶堆
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=o>/</span><span class=mi>2</span><span class=p>).</span><span class=n>rev</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>heapify</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>nums</span><span class=p>[..],</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// 依次取出堆顶元素, 和尾部元素交换
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>..</span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()).</span><span class=n>rev</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>nums</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>heapify</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>nums</span><span class=p>[..</span><span class=n>i</span><span class=p>],</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h2 id=非比较排序>非比较排序</h2>
<h3 id=计数排序counting-sort>计数排序（Counting Sort）</h3>
<ul>
<li>
<p>计数排序是一种非比较的排序算法；</p>
</li>
<li>
<p>核心在于将输入的数据值转化为键存储在额外开辟的数组空间中；</p>
</li>
<li>
<p>一种线性时间复杂度的排序；</p>
</li>
<li>
<p>计数排序要求输入的数据必须是有确定范围的整数；</p>
</li>
</ul>
<h4 id=代码实现-1>代码实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// 计数排序
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>count_sort</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>mi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>nums</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>min</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>ma</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>nums</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>max</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=p>(</span><span class=n>ma</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mi</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>];</span><span class=w>
</span><span class=w>    </span><span class=c1>// 统计每个数字出现的次数
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>clone</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>count</span><span class=p>[(</span><span class=n>n</span><span class=o>-</span><span class=n>mi</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>]</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// 统计每个数字出现的次数累加值
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=p>..</span><span class=n>count</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>count</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>count</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// 按累加值重新排序
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>clone</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>nums</span><span class=p>[</span><span class=n>count</span><span class=p>[(</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mi</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>]</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>count</span><span class=p>[(</span><span class=n>n</span><span class=o>-</span><span class=n>mi</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>]</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h4 id=算法分析-4>算法分析</h4>
<ul>
<li>
<p>计数排序是一个稳定的排序算法；</p>
</li>
<li>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时；</p>
</li>
<li>
<p>计数排序是一个很有效的排序算法；</p>
</li>
</ul>
<h3 id=桶排序bucket-sort>桶排序（Bucket Sort）</h3>
<ul>
<li>
<p>桶排序是计数排序的升级版。</p>
</li>
<li>
<p>它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</li>
<li>
<p>桶排序 (Bucket sort)的工作的原理：</p>
<ul>
<li>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</li>
</ul>
</li>
</ul>
<h4 id=代码实现-2>代码实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=sd>/// # 桶排序
</span><span class=sd>/// ## 基本思想
</span><span class=sd>/// - 计数排序的变种
</span><span class=sd>/// 1. 桶是一个二级数组;
</span><span class=sd>/// 2. 通过一个映射函数, 先将待排序序列中的各个元素映射到不同的桶中;
</span><span class=sd>/// 3. 然后再分别对桶中的元素进行排序;
</span><span class=sd>/// 4. 最后依次将各个桶中的元素合并, 得到完整有序的序列;
</span><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>bucket_sort</span><span class=p>(</span><span class=n>nums</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>mi</span><span class=p>,</span><span class=w> </span><span class=n>ma</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>nums</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>min</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=o>*</span><span class=n>nums</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>max</span><span class=p>().</span><span class=n>unwrap</span><span class=p>());</span><span class=w>  
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>mi</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>ma</span><span class=w> </span><span class=p>{</span><span class=w>  
</span><span class=w>        </span><span class=c1>// 所有元素大小相等, 则不用排序
</span><span class=c1></span><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// 分配桶空间
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>buckets</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=nb>Vec</span>::<span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span>::<span class=n>new</span><span class=p>();</span><span class=w> </span><span class=n>l</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span><span class=w>
</span><span class=w>    </span><span class=c1>// 分桶, 将nums各个元素分到相应的桶中
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>n</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>((</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mi</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=p>((</span><span class=n>ma</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mi</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>buckets</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>push</span><span class=p>(</span><span class=n>n</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// 将各桶中元素排序, 然后按顺序放回原数组
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>buckets</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>sort</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=n>i</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h4 id=算法分析-5>算法分析</h4>
<ul>
<li>
<p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。</p>
</li>
<li>
<p>桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</li>
</ul>
<h3 id=基数排序radix-sort>基数排序（Radix Sort）</h3>
<ul>
<li>
<p>基数排序是按照低位先排序，然后收集；</p>
</li>
<li>
<p>再按照高位排序，然后再收集；依次类推，直到最高位。</p>
</li>
<li>
<p>有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。</p>
</li>
<li>
<p>最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
</li>
</ul>
<h4 id=算法描述-7>算法描述</h4>
<ol>
<li>
<p>取得数组中的最大数，并取得位数；</p>
</li>
<li>
<p>arr 为原始数组，从最低位开始取每个位组成 radix 数组；</p>
</li>
<li>
<p>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</p>
</li>
</ol>
<h4 id=代码实现-3>代码实现</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><h4 id=算法分析-6>算法分析</h4>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n)的时间复杂度。假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为 O(n+k)，其中 k 为桶的数量。一般来说 n&#187;k，因此额外空间需要大概 n 个左右。</p>
<h2 id=参考>参考</h2>
<ol>
<li><a href=https://www.runoob.com/w3cnote/ten-sorting-algorithm.html>1.0 十大经典排序算法 | 菜鸟教程</a></li>
<li><a href=https://learnku.com/articles/70095>https://learnku.com/articles/70095</a></li>
<li><a href=https://juejin.cn/post/6844904053353218062#heading-8>Rust实现八种排序算法 - 掘金</a></li>
<li></li>
</ol>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2024-03-07 11:58:54
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/alipay_reward_qrcode.png>
<span>支付宝打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/bitcoin_reward_qrcode.png>
<span>比特币打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/algorithm/>algorithm</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/12.data_struct/%E5%B9%B6%E6%9F%A5%E9%9B%86/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">并查集</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/12.data_struct/02.%E6%95%B0%E7%BB%84/>
<span class="next-text nav-default">数组</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2024
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
</body>
</html>