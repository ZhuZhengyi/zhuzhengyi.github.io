---

---

# KMP算法

## 简介

* KMP算法是一种改进的[字符串匹配](https://link.jianshu.com?t=https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D)算法，由D.E.Knuth，J.H.Morris和V.R.Pratt共同发明；

* KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的；

## 核心思想

kmp算法的核心：即是计算字符串f每一个位置之前的字符串的前缀和后缀公共部分的最大长度（不包括字符串本身，否则最大长度始终是字符串本身）。获得f每一个位置的最大公共长度之后，就可以利用该最大公共长度快速和字符串O比较。当每次比较到两个字符串的字符不同时，我们就可以根据最大公共长度将字符串f向前移动(已匹配长度-最大公共长度)位，接着继续比较下一个位置。

## 代码

```c
void get_next(String T,int next[]){
  int j = 0;    
  int i = 1;
  next[0] = 0;
  while(i<StrLength(T)){
    if(T[i] == T[j]){
      next[i] = j + 1;
      ++j;
      ++i;
    }
    else{
      if(j!=0){
        j = next[j-1];
      }
      else{
        next[i] = 0;
        ++i;
      }
    }
  }
}

int KMP(String S,String T){
  int length_S = StrLength(S);
  int length_T = StrLength(T);
  int next[length_T];
  get_next(T,next);
  int i = 0;
  int j = 0;
  while(j<length_T && i<length_S){
    if(T[j] == S[i]){
      ++i;
      ++j;
    }
    else{
      if(j!=0)
        j = next[j-1];
      else
        ++i;
    }
  }
  if(j==length_T) return i - length_T +1;
  return 0;
}
```

## 参考

1. [字符串匹配的KMP算法 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

2. 
