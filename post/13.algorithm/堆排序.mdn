---
mathjax: true
---

# 堆排序

## 简介

堆排序是借助于堆这个数据结构来实现排序的一种算法。

### 堆(heap)的性质

1. **堆**是一个**完全二叉树**；

2. 堆的每个非叶子结点值均大于(大顶堆)/小于(小顶堆)其左右子节点值；

3. 堆的**根节点**为所有节点中的最大值(大顶堆)/最小值(小顶堆)；

![](https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/05/22-20-35-03-2021-05-22-20-34-57-image.png)

## 堆排序

- 堆排序利用堆节点的性质 2，每次从堆中排出堆顶元素，从而最终得到有序的序列；

- 由于堆是一个完全二叉树，所以可以用数组来组织；

- 基于完全二叉树性质，数组中根节点索引($i_o$)和其左右子节点($i_l,i_r$)满足如下关系：

$$
i_l = 2 * i_o + 1 \\
i_r = 2 * i_o + 2
$$

![](https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp)

## 复杂性分析

### 时间复杂度

- Avg: $O(nlogn)$

- Max: $O(n^2)$

- Min: $O(n)$

### 空间复杂度

## 实现

```python
def heap_sort(nums):
    def _heap_adjust(nums, start, length, big=True):
        '''
        堆调整, 将nums数组从start开始,长度为length的数组调整为堆
        '''
        root = start
        left = 2 * start + 1
        right = 2 * (start + 1)
        if left < length and nums[left] > nums[root]:
            root = left
        if right < length and nums[right] > nums[root]:
            root = right
        if root != start:
            nums[start], nums[root] = nums[root], nums[start]
            _heap_adjust(nums, root, length, big)

    #初始化堆
    for i in range(int((len(nums)-1)/2), -1, -1):
        _heap_adjust(nums, i, len(nums))

    # 循环取出堆顶元素, 放到数组尾部, 并调整堆
    for i in range(len(nums)-1, 0, -1):
        nums[0], nums[i] = nums[i], nums[0]
        _heap_adjust(nums, 0, i)
```

## 参考

1.
