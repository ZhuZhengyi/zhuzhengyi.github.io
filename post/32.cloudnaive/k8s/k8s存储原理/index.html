<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>K8S存储原理 - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="K8S存储原理 Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 kubectl explain pod.spec.volumes 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存">
<meta name=keywords content="Hugo,theme,jane">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/32.cloudnaive/k8s/k8s%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.2f6e4d7e6e51da09470910b5f0d41a7d2c517dbe97416dd268a18bb7334c4ff8.css integrity="sha256-L25Nfm5R2glHCRC18NQafSxRfb6XQW3SaKGLtzNMT/g=" media=screen crossorigin=anonymous>
<meta property="og:title" content="K8S存储原理">
<meta property="og:description" content="K8S存储原理 Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 kubectl explain pod.spec.volumes 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/32.cloudnaive/k8s/k8s%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-10-10T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-10T00:00:00+00:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="K8S存储原理">
<meta itemprop=description content="K8S存储原理 Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 kubectl explain pod.spec.volumes 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存"><meta itemprop=datePublished content="2021-10-10T00:00:00+00:00">
<meta itemprop=dateModified content="2021-10-10T00:00:00+00:00">
<meta itemprop=wordCount content="6827">
<meta itemprop=keywords content="cloudnaive,k8s,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="K8S存储原理">
<meta name=twitter:description content="K8S存储原理 Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 kubectl explain pod.spec.volumes 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=mobile-menu-item>
<a id=openSearchMobile class="mobile-menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<div class=modal-dialog>
<div class=modal-content>
<div id=closeSearch title=Close class=close>X</div>
<div class=modal-header>
<div class=modal-title>Search</div>
</div>
<div class=modal-body>
<script>(function(){var c='002186711602136249422:q1gkomof_em',a=document.createElement('script'),b;a.type='text/javascript',a.async=!0,a.src=(document.location.protocol=='https:'?'https:':'http:')+'//cse.google.com/cse.js?cx='+c,b=document.getElementsByTagName('script')[0],b.parentNode.insertBefore(a,b)})()</script>
<gcse:search></gcse:search>
</div>
</div>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=openSearch class="menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>K8S存储原理</h1>
<div class=post-meta>
<time datetime=2021-10-10 class=post-time>
2021-10-10
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/cloudnaive/> cloudnaive </a>
<a href=https://justice.bj.cn/categories/k8s/> k8s </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#存储架构>存储架构</a></li>
<li><a href=#flexvolumehttpswwwqikqiakcomk8strainstoragecsiflexvolume-permanent-link>FlexVolume<a href=https://www.qikqiak.com/k8strain/storage/csi/#flexvolume title="Permanent link">¶</a></a></li>
<li><a href=#csihttpswwwqikqiakcomk8strainstoragecsicsi-permanent-link>CSI<a href=https://www.qikqiak.com/k8strain/storage/csi/#csi title="Permanent link">¶</a></a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=k8s存储原理>K8S存储原理</h1>
<p>Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 <code>kubectl explain pod.spec.volumes</code> 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，</p>
<p>在 Kubernetes 中就对应 <code>In-Tree</code> 和 <code>Out-Of-Tree</code> 两种方式:</p>
<ul>
<li>
<p><code>In-Tree</code> 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，</p>
</li>
<li>
<p><code>Out-Of-Tree</code> 是独立于 Kubernetes 的，目前主要有 <code>CSI</code> 和 <code>FlexVolume</code> 两种机制，开发者可以根据自己的存储类型实现不同的存储插件接入到 Kubernetes 中去，其中 <code>CSI</code> 是现在也是以后主流的方式。</p>
</li>
</ul>
<h2 id=存储架构>存储架构</h2>
<p>前面我们了解到了 PV、PVC、StorgeClass 的使用，但是他们是如何和我们的 Pod 关联起来使用的呢？这就需要从 Volume 的处理流程和原理说起了。</p>
<p>如下所示，我们创建了一个 nfs 类型的 PV 资源对象：（volume.yaml）</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PersistentVolume</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w> </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nfs-pv</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w> </span><span class=nt>storageClassName</span><span class=p>:</span><span class=w> </span><span class=l>manual</span><span class=w>
</span><span class=w> </span><span class=nt>capacity</span><span class=p>:</span><span class=w> 
</span><span class=w> </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>1Gi</span><span class=w>
</span><span class=w> </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span><span class=w>
</span><span class=w></span>- <span class=l>ReadWriteOnce</span><span class=w>
</span><span class=w>  </span><span class=nt>persistentVolumeReclaimPolicy</span><span class=p>:</span><span class=w> </span><span class=l>Retain</span><span class=w>
</span><span class=w>  </span><span class=nt>nfs</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/data/k8s </span><span class=w> </span><span class=c># 指定nfs的挂载点</span><span class=w>
</span><span class=w>  </span><span class=nt>server</span><span class=p>:</span><span class=w> </span><span class=m>10.151.30.11</span><span class=w>  </span><span class=c># 指定nfs服务地址</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=nn>---</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PersistentVolumeClaim</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w> </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nfs-pvc</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w> </span><span class=nt>storageClassName</span><span class=p>:</span><span class=w> </span><span class=l>manual</span><span class=w>
</span><span class=w> </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span><span class=w>
</span><span class=w></span>- <span class=l>ReadWriteOnce</span><span class=w>
</span><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>1Gi</span><span class=w>
</span><span class=w></span>- <span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>我们知道用户真正使用的是 PVC，而要使用 PVC 的前提就是必须要先和某个符合条件的 PV 进行一一绑定，比如存储容器、访问模式，以及 PV 和 PVC 的 storageClassName 字段必须一样，这样才能够进行绑定，当 PVC 和 PV 绑定成功后就可以直接使用这个 PVC 对象了：(pod.yaml)</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w> </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-volumes</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w> </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span><span class=w>
</span><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nfs</span><span class=w>
</span><span class=w>  </span><span class=nt>persistentVolumeClaim</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>claimName</span><span class=p>:</span><span class=w> </span><span class=l>nfs-pvc</span><span class=w>
</span><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web</span><span class=w>
</span><span class=w>  </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web</span><span class=w>
</span><span class=w>  </span><span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span><span class=w>  </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nfs</span><span class=w>
</span><span class=w>  </span><span class=nt>subPath</span><span class=p>:</span><span class=w> </span><span class=l>test-volumes</span><span class=w>
</span><span class=w>  </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/usr/share/nginx/html&#34;</span><span class=l>`</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>直接创建上面的资源对象即可：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ kubectl apply -f volume.yaml
$ kubectl apply -f pod.yaml`
</code></pre></td></tr></table>
</div>
</div><p>我们只是在 volumes 中指定了我们上面创建的 PVC 对象，当这个 Pod 被创建之后， kubelet 就会把这个 PVC 对应的这个 NFS 类型的 Volume（PV）挂载到这个 Pod 容器中的目录中去。前面我们也提到了这样的话对于普通用户来说完全就不用关心后面的具体存储在 NFS 还是 Ceph 或者其他了，只需要直接使用 PVC 就可以了，因为真正的存储是需要很多相关的专业知识的，这样就完全职责分离解耦了。</p>
<p>普通用户直接使用 PVC 没有问题，但是也会出现一个问题，那就是当普通用户创建一个 PVC 对象的时候，这个时候系统里面并没有合适的 PV 来和它进行绑定，因为 PV 大多数情况下是管理员给我们创建的，这个时候启动 Pod 肯定就会失败了，如果现在管理员如果去创建一个对应的 PV 的话，PVC 和 PV 当然就可以绑定了，然后 Pod 也会自动的启动成功，这是因为在 Kubernetes 中有一个专门处理持久化存储的控制器 Volume Controller，这个控制器下面有很多个控制循环，其中一个就是用于 PV 和 PVC 绑定的 PersistentVolumeController。</p>
<p>PersistentVolumeController 会不断地循环去查看每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与未绑定的 PVC 进行绑定，这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态。而所谓将一个 PV 与 PVC 进行<code>“绑定”</code>，其实就是将这个 PV 对象的名字，填在了 PVC 对象的 <code>spec.volumeName</code> 字段上。</p>
<p>PV 和 PVC 绑定上了，那么又是如何将容器里面的数据进行持久化的呢，前面我们学习过 Docker 的 Volume 挂载，其实就是<strong>将一个宿主机上的目录和一个容器里的目录绑定挂载在了一起</strong>，具有持久化功能当然就是指的宿主机上面的这个目录了，当容器被删除或者在其他节点上重建出来以后，这个目录里面的内容依然存在，所以一般情况下实现持久化是需要一个远程存储的，比如 NFS、Ceph 或者云厂商提供的磁盘等等。所以接下来需要做的就是持久化宿主机目录这个过程。</p>
<p>当 Pod 被调度到一个节点上后，节点上的 kubelet 组件就会为这个 Pod 创建它的 Volume 目录，默认情况下 kubelet 为 Volume 创建的目录在 kubelet 工作目录下面：</p>
<p><code>/var/lib/kubelet/pods/&lt;Pod的ID>/volumes/kubernetes.io~&lt;Volume类型>/&lt;Volume名字></code></p>
<p>比如上面我们创建的 Pod 对应的 Volume 目录完整路径为：</p>
<p><code>/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv</code></p>
<p>提示</p>
<p>要获取 Pod 的唯一标识 uid，可通过命令 <code>kubectl get pod pod名 -o jsonpath={.metadata.uid}</code> 获取。</p>
<p>然后就需要根据我们的 Volume 类型来决定需要做什么操作了，比如上节课我们用的 Ceph RBD，那么 kubelet 就需要先将 Ceph 提供的 RBD 挂载到 Pod 所在的宿主机上面，这个阶段在 Kubernetes 中被称为 Attach 阶段。Attach 阶段完成后，为了能够使用这个块设备，kubelet 还要进行第二个操作，即：格式化这个块设备，然后将它挂载到宿主机指定的挂载点上。这个挂载点，也就是上面我们提到的 Volume 的宿主机的目录。将块设备格式化并挂载到 Volume 宿主机目录的操作，在 Kubernetes 中被称为 Mount 阶段。上节课我们使用 Ceph RBD 持久化的 Wordpress 的 MySQL 数据，我们可以查看对应的 Volume 信息：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ kubectl get pods -o wide -l app=wordpress
NAME                              READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES
wordpress-5b886cf59b-dv2zt        1/1     Running   0          20d   10.244.1.158   ydzs-node1   &lt;none&gt;           &lt;none&gt;
wordpress-mysql-b9ddd6d4c-pjhbt   1/1     Running   0          20d   10.244.4.70    ydzs-node4   &lt;none&gt;           &lt;none&gt;
</code></pre></td></tr></table>
</div>
</div><p>我们可以看到 MySQL 运行在 node4 节点上，然后可以在该节点上查看 Volume 信息，Pod 对应的 uid 可以通过如下命令获取：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ kubectl get pod wordpress-mysql-b9ddd6d4c-pjhbt -o jsonpath={.metadata.uid}
3f84af87-9f58-4c69-9e38-5ef234498133
$ ls /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/
mount  vol_data.json
</code></pre></td></tr></table>
</div>
</div><p>然后通过如下命令可以查看 Volume 的持久化信息：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ findmnt /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount
TARGET                                                                                            SOURCE    FSTYPE OPTIONS
/var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount    /dev/rbd0 ext4   rw,relatime,`
</code></pre></td></tr></table>
</div>
</div><p>可以看到这里的 Volume 是挂载到 <code>/dev/rbd0</code> 这个设备上面的，通过 <code>df</code> 命令也是可以看到的：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ df -h |grep dev
devtmpfs        3.9G     0  3.9G   0% /dev
tmpfs           3.9G     0  3.9G   0% /dev/shm
/dev/vda3        18G  4.7G   13G  27% /
/dev/vda1       497M  158M  340M  32% /boot
/dev/vdb1       197G   24G  164G  13% /data
/dev/rbd0        20G  160M   20G   1% /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount`
</code></pre></td></tr></table>
</div>
</div><p>这里我们就经过了 <code>Attach</code> 和 <code>Mount</code> 两个阶段完成了 Volume 的持久化。但是对于上面我们使用的 NFS 就更加简单了， 因为 NFS 存储并没有一个设备需要挂载到宿主机上面，所以这个时候 kubelet 就会直接进入第二个 <code>Mount</code> 阶段，相当于直接在宿主机上面执行如下的命令：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ mount -t nfs 10.151.30.11:/data/k8s /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv`
</code></pre></td></tr></table>
</div>
</div><p>同样可以在测试的 Pod 所在节点查看 Volume 的挂载信息：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ findmnt /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv
TARGET                                                                               SOURCE                 FSTYPE OPTIONS
/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv
                                                                                     10.151.30.11:/data/k8s nfs4   rw,relatime,`
</code></pre></td></tr></table>
</div>
</div><p>我们可以看到这个 Volume 被挂载到了 NFS（10.151.30.11:/data/k8s）下面，以后我们在这个目录里写入的所有文件，都会被保存在远程 NFS 服务器上。</p>
<p>这样在经过了上面的两个阶段过后，我们就得到了一个持久化的宿主机上面的 Volume 目录了，接下来 kubelet 只需要把这个 Volume 目录挂载到容器中对应的目录即可，这样就可以为 Pod 里的容器挂载这个持久化的 Volume 了，这一步其实也就相当于执行了如下所示的命令：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ docker run -v /var/lib/kubelet/pods/&lt;Pod的ID&gt;/volumes/kubernetes.io~&lt;Volume类型&gt;/&lt;Volume名字&gt;:/&lt;容器内的目标目录&gt; 我的镜像 ...`
</code></pre></td></tr></table>
</div>
</div><p>整个存储的架构可以用下图来说明： <img src=https://www.qikqiak.com/k8strain/assets/img/storage/k8s-storage-structrue.png alt=存储架构></p>
<ul>
<li>PV Controller：负责 PV/PVC 的绑定，并根据需求进行数据卷的 Provision/Delete 操作</li>
<li>AD Controller：负责存储设备的 Attach/Detach 操作，将设备挂载到目标节点</li>
<li>Volume Manager：管理卷的 Mount/Unmount 操作、卷设备的格式化等操作</li>
<li>Volume Plugin：扩展各种存储类型的卷管理能力，实现第三方存储的各种操作能力和 Kubernetes 存储系统结合</li>
</ul>
<p>我们上面使用的 NFS 就属于 In-Tree 这种方式，而上节课使用的 Ceph RBD 就是 Out-Of-Tree 的方式，而且是使用的是 CSI 插件。下面我们再来了解下 <code>FlexVolume</code> 和 <code>CSI</code> 两种插件方式。</p>
<h2 id=flexvolumehttpswwwqikqiakcomk8strainstoragecsiflexvolume-permanent-link>FlexVolume<a href=https://www.qikqiak.com/k8strain/storage/csi/#flexvolume title="Permanent link">¶</a></h2>
<p>FlexVolume 提供了一种扩展 Kubernetes 存储插件的方式，用户可以自定义自己的存储插件。要使用 FlexVolume 需要在每个节点上安装存储插件二进制文件，该二进制需要实现 FlexVolume 的相关接口，默认存储插件的存放路径为<code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/&lt;vendor~driver>/&lt;driver></code>，<code>VolumePlugins</code> 组件会不断 watch 这个目录来实现插件的添加、删除等功能。</p>
<p>其中 <code>vendor~driver</code> 的名字需要和 Pod 中<code>flexVolume.driver</code> 的字段名字匹配，例如：</p>
<p><code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/foo~cifs/cifs</code></p>
<p>对应的 Pod 中的 <code>flexVolume.driver</code> 属性为：<code>foo/cifs</code>。</p>
<p>在我们实现自定义存储插件的时候，需要实现 FlexVolume 的部分接口，因为要看实际需求，并不一定所有接口都需要实现。比如对于类似于 NFS 这样的存储就没必要实现 <code>attach/detach</code> 这些接口了，因为不需要，只需要实现 <code>init/mount/umount</code> 3个接口即可。</p>
<ul>
<li>init: <code>&lt;driver executable> init</code> - kubelet/kube-controller-manager 初始化存储插件时调用，插件需要返回是否需要要 attach 和 detach 操作</li>
<li>attach: <code>&lt;driver executable> attach &lt;json options> &lt;node name></code> - 将存储卷挂载到 Node 节点上</li>
<li>detach: <code>&lt;driver executable> detach &lt;mount device> &lt;node name></code> - 将存储卷从 Node 上卸载</li>
<li>waitforattach: <code>&lt;driver executable> waitforattach &lt;mount device> &lt;json options></code> - 等待 attach 操作成功（超时时间为 10 分钟）</li>
<li>isattached: <code>&lt;driver executable> isattached &lt;json options> &lt;node name></code> - 检查存储卷是否已经挂载</li>
<li>mountdevice: <code>&lt;driver executable> mountdevice &lt;mount dir> &lt;mount device> &lt;json options></code> - 将设备挂载到指定目录中以便后续 bind mount 使用</li>
<li>unmountdevice: <code>&lt;driver executable> unmountdevice &lt;mount device></code> - 将设备取消挂载</li>
<li>mount: <code>&lt;driver executable> mount &lt;mount dir> &lt;json options></code> - 将存储卷挂载到指定目录中</li>
<li>unmount: <code>&lt;driver executable> unmount &lt;mount dir></code> - 将存储卷取消挂载</li>
</ul>
<p>实现上面的这些接口需要返回如下所示的 JSON 格式的数据：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=p>{</span>
    <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;Success/Failure/Not supported&gt;&#34;</span><span class=p>,</span>
    <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;Reason for success/failure&gt;&#34;</span><span class=p>,</span>
    <span class=nt>&#34;device&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;Path to the device attached. This field is valid only for attach &amp; waitforattach call-outs&gt;&#34;</span>
    <span class=s2>&#34;volumeName&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;Cluster wide unique name of the volume. Valid only for getvolumename call-out&gt;&#34;</span>
    <span class=s2>&#34;attached&#34;</span><span class=p>:</span> <span class=err>&lt;True/False</span> <span class=err>(Return</span> <span class=kc>true</span> <span class=err>if</span> <span class=err>volume</span> <span class=err>is</span> <span class=err>attached</span> <span class=err>on</span> <span class=err>the</span> <span class=err>node.</span> <span class=err>Valid</span> <span class=err>only</span> <span class=err>for</span> <span class=err>isattached</span> <span class=err>call-out)&gt;</span>
    <span class=s2>&#34;capabilities&#34;</span><span class=p>:</span> <span class=err>&lt;Only</span> <span class=err>included</span> <span class=err>as</span> <span class=err>part</span> <span class=err>of</span> <span class=err>the</span> <span class=err>Init</span> <span class=err>response&gt;</span>
    <span class=p>{</span>
        <span class=nt>&#34;attach&#34;</span><span class=p>:</span> <span class=err>&lt;True/False</span> <span class=err>(Return</span> <span class=kc>true</span> <span class=err>if</span> <span class=err>the</span> <span class=err>driver</span> <span class=err>implements</span> <span class=err>attach</span> <span class=err>and</span> <span class=err>detach)&gt;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>比如我们来实现一个 NFS 的 FlexVolume 插件，最简单的方式就是写一个脚本，然后实现 init、mount、unmount 3个命令即可，然后按照上面的 JSON 格式返回数据，最后把这个脚本放在节点的 FlexVolume 插件目录下面即可。</p>
<p>下面就是官方给出的一个 NFS 的 FlexVolume 插件示例，可以从 <a href=https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs>examples/nfs at master · kubernetes/examples · GitHub</a> 获取脚本：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=cp>#!/bin/bash
</span><span class=cp></span><span class=c1>## 注意:</span>
<span class=c1># - 在使用插件之前需要先安装 jq。</span>

usage<span class=o>()</span> <span class=o>{</span>
    err <span class=s2>&#34;Invalid usage. Usage: &#34;</span>
    err <span class=s2>&#34;\t</span><span class=nv>$0</span><span class=s2> init&#34;</span>
    err <span class=s2>&#34;\t</span><span class=nv>$0</span><span class=s2> mount &lt;mount dir&gt; &lt;json params&gt;&#34;</span>
    err <span class=s2>&#34;\t</span><span class=nv>$0</span><span class=s2> unmount &lt;mount dir&gt;&#34;</span>
    <span class=nb>exit</span> <span class=m>1</span>
<span class=o>}</span>

err<span class=o>()</span> <span class=o>{</span>
    <span class=nb>echo</span> -ne <span class=nv>$*</span> 1&gt;<span class=p>&amp;</span><span class=m>2</span>
<span class=o>}</span>

log<span class=o>()</span> <span class=o>{</span>
    <span class=nb>echo</span> -ne <span class=nv>$*</span> &gt;<span class=p>&amp;</span><span class=m>1</span>
<span class=o>}</span>

ismounted<span class=o>()</span> <span class=o>{</span>
    <span class=nv>MOUNT</span><span class=o>=</span><span class=sb>`</span>findmnt -n <span class=si>${</span><span class=nv>MNTPATH</span><span class=si>}</span> 2&gt;/dev/null <span class=p>|</span> cut -d<span class=s1>&#39; &#39;</span> -f1<span class=sb>`</span>
    <span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>MOUNT</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>==</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>MNTPATH</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
        <span class=nb>echo</span> <span class=s2>&#34;1&#34;</span>
    <span class=k>else</span>
        <span class=nb>echo</span> <span class=s2>&#34;0&#34;</span>
    <span class=k>fi</span>
<span class=o>}</span>

domount<span class=o>()</span> <span class=o>{</span>
    <span class=nv>MNTPATH</span><span class=o>=</span><span class=nv>$1</span>

    <span class=nv>NFS_SERVER</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=nv>$2</span> <span class=p>|</span> jq -r <span class=s1>&#39;.server&#39;</span><span class=k>)</span>
    <span class=nv>SHARE</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=nv>$2</span> <span class=p>|</span> jq -r <span class=s1>&#39;.share&#39;</span><span class=k>)</span>

    <span class=k>if</span> <span class=o>[</span> <span class=k>$(</span>ismounted<span class=k>)</span> -eq <span class=m>1</span> <span class=o>]</span> <span class=p>;</span> <span class=k>then</span>
        log <span class=s1>&#39;{&#34;status&#34;: &#34;Success&#34;}&#39;</span>
        <span class=nb>exit</span> <span class=m>0</span>
    <span class=k>fi</span>

    mkdir -p <span class=si>${</span><span class=nv>MNTPATH</span><span class=si>}</span> <span class=p>&amp;</span>&gt; /dev/null

    mount -t nfs <span class=si>${</span><span class=nv>NFS_SERVER</span><span class=si>}</span>:/<span class=si>${</span><span class=nv>SHARE</span><span class=si>}</span> <span class=si>${</span><span class=nv>MNTPATH</span><span class=si>}</span> <span class=p>&amp;</span>&gt; /dev/null
    <span class=k>if</span> <span class=o>[</span> <span class=nv>$?</span> -ne <span class=m>0</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
        err <span class=s2>&#34;{ \&#34;status\&#34;: \&#34;Failure\&#34;, \&#34;message\&#34;: \&#34;Failed to mount </span><span class=si>${</span><span class=nv>NFS_SERVER</span><span class=si>}</span><span class=s2>:</span><span class=si>${</span><span class=nv>SHARE</span><span class=si>}</span><span class=s2> at </span><span class=si>${</span><span class=nv>MNTPATH</span><span class=si>}</span><span class=s2>\&#34;}&#34;</span>
        <span class=nb>exit</span> <span class=m>1</span>
    <span class=k>fi</span>
    log <span class=s1>&#39;{&#34;status&#34;: &#34;Success&#34;}&#39;</span>
    <span class=nb>exit</span> <span class=m>0</span>

<span class=o>}</span>

unmount<span class=o>()</span> <span class=o>{</span>
    <span class=nv>MNTPATH</span><span class=o>=</span><span class=nv>$1</span>
    <span class=k>if</span> <span class=o>[</span> <span class=k>$(</span>ismounted<span class=k>)</span> -eq <span class=m>0</span> <span class=o>]</span> <span class=p>;</span> <span class=k>then</span>
        log <span class=s1>&#39;{&#34;status&#34;: &#34;Success&#34;}&#39;</span>
        <span class=nb>exit</span> <span class=m>0</span>
    <span class=k>fi</span>

    umount <span class=si>${</span><span class=nv>MNTPATH</span><span class=si>}</span> <span class=p>&amp;</span>&gt; /dev/null
    <span class=k>if</span> <span class=o>[</span> <span class=nv>$?</span> -ne <span class=m>0</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
        err <span class=s2>&#34;{ \&#34;status\&#34;: \&#34;Failed\&#34;, \&#34;message\&#34;: \&#34;Failed to unmount volume at </span><span class=si>${</span><span class=nv>MNTPATH</span><span class=si>}</span><span class=s2>\&#34;}&#34;</span>
        <span class=nb>exit</span> <span class=m>1</span>
    <span class=k>fi</span>

    log <span class=s1>&#39;{&#34;status&#34;: &#34;Success&#34;}&#39;</span>
    <span class=nb>exit</span> <span class=m>0</span>

<span class=o>}</span>

<span class=nv>op</span><span class=o>=</span><span class=nv>$1</span>

<span class=k>if</span> ! <span class=nb>command</span> -v jq &gt;/dev/null 2&gt;<span class=p>&amp;</span>1<span class=p>;</span> <span class=k>then</span>
    err <span class=s2>&#34;{ \&#34;status\&#34;: \&#34;Failure\&#34;, \&#34;message\&#34;: \&#34;&#39;jq&#39; binary not found. Please install jq package before using this driver\&#34;}&#34;</span>
    <span class=nb>exit</span> <span class=m>1</span>
<span class=k>fi</span>

<span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$op</span><span class=s2>&#34;</span> <span class=o>=</span> <span class=s2>&#34;init&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
    log <span class=s1>&#39;{&#34;status&#34;: &#34;Success&#34;, &#34;capabilities&#34;: {&#34;attach&#34;: false}}&#39;</span>
    <span class=nb>exit</span> <span class=m>0</span>
<span class=k>fi</span>

<span class=k>if</span> <span class=o>[</span> <span class=nv>$#</span> -lt <span class=m>2</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
    usage
<span class=k>fi</span>

<span class=nb>shift</span>

<span class=k>case</span> <span class=s2>&#34;</span><span class=nv>$op</span><span class=s2>&#34;</span> in
    mount<span class=o>)</span>
        domount <span class=nv>$*</span>
        <span class=p>;;</span>
    unmount<span class=o>)</span>
        unmount <span class=nv>$*</span>
        <span class=p>;;</span>
    *<span class=o>)</span>
        log <span class=s1>&#39;{&#34;status&#34;: &#34;Not supported&#34;}&#39;</span>
        <span class=nb>exit</span> <span class=m>0</span>
<span class=k>esac</span>

<span class=nb>exit</span> <span class=m>1</span>
</code></pre></td></tr></table>
</div>
</div><p>将上面脚本命名成 nfs，放置到 node1 节点对应的插件下面： <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs</code>，并设置权限为 700：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ chmod 700 /usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs

# 安装 jq 工具

$ yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
$ yum install jq -y
</code></pre></td></tr></table>
</div>
</div><p>这个时候我们部署一个应用到 node1 节点上，并用 <code>flexVolume</code> 来持久化容器中的数据（当然也可以通过定义 flexvolume 类型的 PV、PVC 来使用），如下所示：(test-flexvolume.yaml)</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>apiVersion: v1
kind: Pod
metadata:
 name: test-flexvolume
spec:
 nodeSelector:
    kubernetes.io/hostname: ydzs-node1
 volumes:

- name: test
  flexVolume:
  driver: &#34;ydzs/nfs&#34;  # 定义插件类型，根据这个参数在对应的目录下面找到插件的可执行文件
  fsType: &#34;nfs&#34;  # 定义存储卷文件系统类型
  options:  # 定义所有与存储相关的一些具体参数
  server: &#34;10.151.30.11&#34;
  share: &#34;data/k8s&#34;
  containers:
- name: web
  image: nginx
  ports:
- containerPort: 80
  volumeMounts:
- name: test
  subPath: testflexvolume
  mountPath: /usr/share/nginx/html
</code></pre></td></tr></table>
</div>
</div><p>其中 <code>flexVolume.driver</code> 就是插件目录 <code>ydzs~nfs</code> 对应的 <code>ydzs/nfs</code> 名称，<code>flexVolume.options</code> 中根据上面的 nfs 脚本可以得知里面配置的是 NFS 的 Server 地址和挂载目录路径，直接创建上面的资源对象：</p>
<p><code>$ kubectl apply -f test-flexvolume.yaml $ kubectl get pods NAME READY STATUS RESTARTS AGE test-flexvolume 1/1 Running 0 13h ...... $ kubectl exec -it test-flexvolume mount |grep test 10.151.30.11:/data/k8s/testflexvolume on /usr/share/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11) $ mount |grep test 10.151.30.11:/data/k8s on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volumes/ydzs~nfs/test type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11) 10.151.30.11:/data/k8s/testflexvolume on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volume-subpaths/test/web/0 type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)</code></p>
<p>同样我们可以查看到 Pod 的本地持久化目录是被 mount 到了 NFS 上面，证明上面我们的 FlexVolume 插件是正常的。</p>
<p>调用</p>
<p>当我们要去真正的 mount NFS 的时候，就是通过 kubelet 调用 VolumePlugin，然后直接执行命令<code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs mount &lt;mount dir> &lt;json param></code> 来完成的，就相当于平时我们在宿主机上面手动挂载 NFS 的方式一样的，所以存储插件 nfs 是一个可执行的二进制文件或者 shell 脚本都是可以的。</p>
<h2 id=csihttpswwwqikqiakcomk8strainstoragecsicsi-permanent-link>CSI<a href=https://www.qikqiak.com/k8strain/storage/csi/#csi title="Permanent link">¶</a></h2>
<p>既然已经有了 FlexVolume 插件了，为什么还需要 CSI 插件呢？上面我们使用 FlexVolume 插件的时候可以看出 FlexVolume 插件实际上相当于就是一个普通的 shell 命令，类似于平时我们在 Linux 下面执行的 <code>ls</code> 命令一样，只是返回的信息是 JSON 格式的数据，并不是我们通常认为的一个常驻内存的进程，而 CSI 是一个更加完善、编码更加方便友好的一种存储插件扩展方式。</p>
<p>CSI 是由来自 Kubernetes、Mesos、 Cloud Foundry 等社区成员联合制定的一个行业标准接口规范，旨在将任意存储系统暴露给容器化应用程序。CSI 规范定义了存储提供商实现 CSI 兼容插件的最小操作集合和部署建议，CSI 规范的主要焦点是声明插件必须实现的接口。</p>
<p>在 Kubernetes 上整合 CSI 插件的整体架构如下图所示： <img src=https://www.qikqiak.com/k8strain/assets/img/storage/k8s-csi-structrue.png alt="kubernetes csi structrue"></p>
<p>Kubernetes CSI 存储体系主要由两部分组成：</p>
<ul>
<li>
<p>Kubernetes 外部组件：包含 Driver registrar、External provisioner、External attacher 三部分，这三个组件是从 Kubernetes 原本的 in-tree 存储体系中剥离出来的存储管理功能，实际上是 Kubernetes 中的一种外部 controller ，它们 watch kubernetes 的 API 资源对象，根据 watch 到的状态来调用下面提到的第二部分的 CSI 插件来实现存储的管理和操作。这部分是 Kubernetes 团队维护的，插件开发者完全不必关心其实现细节。</p>
<ul>
<li>Driver registra：用于将插件注册到 kubelet 的 sidecar 容器，并将驱动程序自定义的 NodeId 添加到节点的 Annotations 上，通过与 CSI 上面的 Identity 服务进行通信调用 CSI 的 GetNodeId 方法来完成该操作。</li>
<li>External provisioner：用于 watch Kubernetes 的 PVC 对象并调用 CSI 的 CreateVolume 和 DeleteVolume 操作。</li>
<li>External attacher：用于 Attach/Detach 阶段，通过 watch Kubernetes 的 VolumeAttachment 对象并调用 CSI 的 ControllerPublish 和 ControllerUnpublish 操作来完成对应的 Volume 的 Attach/Detach。而 Volume 的 Mount/Unmount 阶段并不属于外部组件，当真正需要执行 Mount 操作的时候，kubelet 会去直接调用下面的 CSI Node 服务来完成 Volume 的 Mount/UnMount 操作。</li>
</ul>
</li>
<li>
<p>CSI 存储插件: 这部分正是开发者需要实现的 CSI 插件部分，都是通过 gRPC 实现的服务，一般会用一个二进制文件对外提供服务，主要包含三部分：CSI Identity、CSI Controller、CSI Node。</p>
<ul>
<li>
<p>CSI Identity — 主要用于负责对外暴露这个插件本身的信息，确保插件的健康状态。</p>
<p>`service Identity {</p>
<pre><code>// 返回插件的名称和版本
rpc GetPluginInfo(GetPluginInfoRequest)
    returns (GetPluginInfoResponse) {}
// 返回这个插件的包含的功能，比如非块存储类型的 CSI 插件不需要实现 Attach 功能，GetPluginCapabilities 就可以在返回中标注这个 CSI 插件不包含 Attach 功能
rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)
    returns (GetPluginCapabilitiesResponse) {}
// 插件插件是否正在运行
rpc Probe (ProbeRequest)
    returns (ProbeResponse) {}
</code></pre>
<p>}`</p>
</li>
<li>
<p>CSI Controller - 主要实现 Volume 管理流程当中的 Provision 和 Attach 阶段，Provision 阶段是指创建和删除 Volume 的流程，而 Attach 阶段是指把存储卷附着在某个节点或脱离某个节点的流程，另外只有块存储类型的 CSI 插件才需要 Attach 功能。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>service Controller {

    // 创建存储卷，包括云端存储介质以及PV对象
    rpc CreateVolume (CreateVolumeRequest)
        returns (CreateVolumeResponse) {}

    //  删除存储卷
    rpc DeleteVolume (DeleteVolumeRequest)
        returns (DeleteVolumeResponse) {}

    // 挂载存储卷，将存储介质挂载到目标节点
    rpc ControllerPublishVolume (ControllerPublishVolumeRequest)
        returns (ControllerPublishVolumeResponse) {}

    // 卸载存储卷
    rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)
        returns (ControllerUnpublishVolumeResponse) {}

    // 例如：是否可以同时用于多个节点的读/写
    rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)
        returns (ValidateVolumeCapabilitiesResponse) {}

    // 返回所有可用的 volumes
    rpc ListVolumes (ListVolumesRequest)
        returns (ListVolumesResponse) {}

    // 可用存储池的总容量
    rpc GetCapacity (GetCapacityRequest)
        returns (GetCapacityResponse) {}

    // 例如. 插件可能未实现 GetCapacity、Snapshotting
    rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)
        returns (ControllerGetCapabilitiesResponse) {}

    // 创建快照
    rpc CreateSnapshot (CreateSnapshotRequest)
        returns (CreateSnapshotResponse) {}

    // 删除指定的快照
    rpc DeleteSnapshot (DeleteSnapshotRequest)
        returns (DeleteSnapshotResponse) {}

    // 获取所有的快照
    rpc ListSnapshots (ListSnapshotsRequest)
        returns (ListSnapshotsResponse) {}

}
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>CSI Node — 负责控制 Kubernetes 节点上的 Volume 操作。其中 Volume 的挂载被分成了 NodeStageVolume 和 NodePublishVolume 两个阶段。NodeStageVolume 接口主要是针对块存储类型的 CSI 插件而提供的，块设备在 &ldquo;Attach&rdquo; 阶段被附着在 Node 上后，需要挂载至 Pod 对应目录上，但因为块设备在 linux 上只能 mount 一次，而在 kubernetes volume 的使用场景中，一个 volume 可能被挂载进同一个 Node 上的多个 Pod 实例中，所以这里提供了 NodeStageVolume 这个接口，使用这个接口把块设备格式化后先挂载至 Node 上的一个临时全局目录，然后再调用 NodePublishVolume 使用 linux 中的 <code>bind mount</code> 技术把这个全局目录挂载进 Pod 中对应的目录上。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=kd>service</span> <span class=n>Node</span> <span class=p>{</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// 在节点上初始化存储卷（格式化），并执行挂载到Global目录
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodeStageVolume</span> <span class=p>(</span><span class=n>NodeStageVolumeRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodeStageVolumeResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// umount 存储卷在节点上的 Global 目录
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodeUnstageVolume</span> <span class=p>(</span><span class=n>NodeUnstageVolumeRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodeUnstageVolumeResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// 在节点上将存储卷的 Global 目录挂载到 Pod 的实际挂载目录
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodePublishVolume</span> <span class=p>(</span><span class=n>NodePublishVolumeRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodePublishVolumeResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// unmount 存储卷在节点上的 Pod 挂载目录
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodeUnpublishVolume</span> <span class=p>(</span><span class=n>NodeUnpublishVolumeRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodeUnpublishVolumeResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// 获取节点上Volume挂载文件系统统计信息（总空间、可用空间等）
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodeGetVolumeStats</span> <span class=p>(</span><span class=n>NodeGetVolumeStatsRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodeGetVolumeStatsResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// 获取节点的唯一 ID
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodeGetId</span> <span class=p>(</span><span class=n>NodeGetIdRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodeGetIdResponse</span><span class=p>)</span> <span class=p>{</span><span class=err>
</span><span class=err></span>        <span class=k>option</span> <span class=n>deprecated</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span><span class=err>
</span><span class=err></span>    <span class=p>}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// 返回节点插件的能力
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodeGetCapabilities</span> <span class=p>(</span><span class=n>NodeGetCapabilitiesRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodeGetCapabilitiesResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// 获取节点的一些信息
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>NodeGetInfo</span> <span class=p>(</span><span class=n>NodeGetInfoRequest</span><span class=p>)</span><span class=err>
</span><span class=err></span>        <span class=k>returns</span> <span class=p>(</span><span class=n>NodeGetInfoResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=p>}</span><span class=err>
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p>只需要实现上面的接口就可以实现一个 CSI 插件了。虽然 Kubernetes 并未规定 CSI 插件的打包安装，但是提供了以下建议来简化我们在 Kubernetes 上容器化 CSI Volume 驱动程序的部署方案，具体的方案介绍可以查看 CSI 规范介绍文档 <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>https://github.com/kubernetes/community</a></p>
<p><img src=https://www.qikqiak.com/k8strain/assets/img/storage/container-storage-interface_diagram1.png alt="container storage interface deploy"></p>
<p>按照上图的推荐方案，CSI Controller 部分以 StatefulSet 或者 Deployment 方式部署，CSI Node 部分以 DaemonSet 方式部署。因为这两部分实现在同一个 CSI 插件程序中，因此只需要把这个 CSI 插件与 External Components 以容器方式部署在同一个 Pod中，把这个 CSI 插件与 Driver registrar 以容器方式部署在 DaemonSet 的 Pod 中，即可完成 CSI 的部署。</p>
<p>前面我们使用的 Rook 部署的 Ceph 集群就是实现了 CSI 插件的:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>$ kubectl get pods -n rook-ceph |grep plugin
csi-cephfsplugin-2s9d5                                 3/3     Running     0          21d
csi-cephfsplugin-fgp4v                                 3/3     Running     0          17d
csi-cephfsplugin-fv5nx                                 3/3     Running     0          21d
csi-cephfsplugin-mn8q4                                 3/3     Running     0          17d
csi-cephfsplugin-nf6h8                                 3/3     Running     0          21d
csi-cephfsplugin-provisioner-56c8b7ddf4-68h6d          4/4     Running     0          21d
csi-cephfsplugin-provisioner-56c8b7ddf4-rq4t6          4/4     Running     0          21d
csi-cephfsplugin-xwnl4                                 3/3     Running     0          21d
csi-rbdplugin-7r88w                                    3/3     Running     0          21d
csi-rbdplugin-95g5j                                    3/3     Running     0          21d
csi-rbdplugin-bnzpr                                    3/3     Running     0          21d
csi-rbdplugin-dvftb                                    3/3     Running     0          21d
csi-rbdplugin-jzmj2                                    3/3     Running     0          17d
csi-rbdplugin-provisioner-6ff4dd4b94-bvtss             5/5     Running     0          21d
csi-rbdplugin-provisioner-6ff4dd4b94-lfn68             5/5     Running     0          21d
csi-rbdplugin-trxb4                                    3/3     Running     0          17d`
</code></pre></td></tr></table>
</div>
</div><p>这里其实是实现了 RBD 和 CephFS 两种 CSI，用 DaemonSet 在每个节点上运行了一个包含 <code>Driver registra</code> 容器的 Pod，当然和节点相关的操作比如 Mount/Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 <code>csi-rbdplugin-provisioner-xxx</code> Pod 中执行的。</p>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2021-10-10
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/cloudnaive/>cloudnaive</a>
<a href=https://justice.bj.cn/tags/k8s/>k8s</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/32.cloudnaive/k8s/kubernetes-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">K8S存储体系架构</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/30.architech/hbase/kerberos/>
<span class="next-text nav-default">Kerberos</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2022
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script>$("#openSearch, #openSearchMobile").click(function(){$(".modal-dialog").addClass("visible")}),$("#closeSearch").click(function(){$(".modal-dialog").removeClass("visible")}),$(document).click(function(a){$(a.target).closest(".modal-content, #openSearch, #openSearchMobile").length||$("body").find(".modal-dialog").removeClass("visible")})</script>
<script src=/js/l2d/L2Dwidget.min.js></script>
<script src=/js/l2d/L2Dwidget.0.min.js></script>
<script src=/js/l2d/L2Dwidget.init.js></script>
</body>
</html>