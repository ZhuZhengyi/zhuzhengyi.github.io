<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>k8s Volume实现原理 - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=referrer content="no-referrer">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="k8s Volume实现原理 在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消">
<meta name=keywords content="tech,it,blog">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/32.cloudnative/k8s/k8s-volume/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.34a0cf3583dc0fd6b4e3fe24a36c076984feee75ebc2792cff33928ccdcfc628.css integrity="sha256-NKDPNYPcD9a04/4ko2wHaYT+7nXrwnks/zOSjM3Pxig=" media=screen crossorigin=anonymous>
<meta property="og:title" content="k8s Volume实现原理">
<meta property="og:description" content="k8s Volume实现原理 在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/32.cloudnative/k8s/k8s-volume/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-04-30T09:23:49+08:00">
<meta property="article:modified_time" content="2022-04-30T09:23:49+08:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="k8s Volume实现原理">
<meta itemprop=description content="k8s Volume实现原理 在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消"><meta itemprop=datePublished content="2022-04-30T09:23:49+08:00">
<meta itemprop=dateModified content="2022-04-30T09:23:49+08:00">
<meta itemprop=wordCount content="8255">
<meta itemprop=keywords content="cloudnative,k8s,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="k8s Volume实现原理">
<meta name=twitter:description content="k8s Volume实现原理 在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<div id=fastSearch>
<input id=searchInput tabindex=0>
<ul id=searchResults>
</ul>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=search-click class="menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>k8s Volume实现原理</h1>
<div class=post-meta>
<time datetime=2022-04-30 class=post-time>
2022-04-30 09:23:49
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/cloudnative/> cloudnative </a>
<a href=https://justice.bj.cn/categories/k8s/> k8s </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#概述>概述</a>
<ul>
<li><a href=#卷>卷</a></li>
<li><a href=#持久卷>持久卷</a></li>
</ul>
</li>
<li><a href=#管理>管理</a>
<ul>
<li><a href=#kubelet>kubelet</a></li>
<li><a href=#卷管理器>卷管理器</a></li>
<li><a href=#附着分离控制器>附着分离控制器</a></li>
<li><a href=#持久卷控制器>持久卷控制器</a></li>
</ul>
</li>
<li><a href=#插件>插件</a>
<ul>
<li><a href=#emptydir>EmptyDir</a></li>
<li><a href=#configmap-和-secret>ConfigMap 和 Secret</a></li>
<li><a href=#gcepersistentdisk>GCEPersistentDisk</a></li>
</ul>
</li>
<li><a href=#总结>总结</a></li>
<li><a href=#相关文章>相关文章</a></li>
<li><a href=#referenece>Referenece</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=k8s-volume实现原理>k8s Volume实现原理</h1>
<p>在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消息队列等等。</p>
<p>然而 Kuberentes 中的每一个容器随时都可能因为某些原因而被删除和重启，容器中的文件也会随着它的删除而丢失，所以我们需要对集群中的某些文件和数据进行『持久化』；除此之外，由于同一个 Pod 中的多个 Container 可能也会有共享文件的需求，比如通过共享文件目录的方式为 nginx 生成需要代理的静态文件，所以我们需要一种方式来解决这两个问题。</p>
<p>作为 Kubernetes 集群中除了 Pod 和 Service 之外最常见的基本对象，Volume 不仅能够解决 Container 中文件的临时性问题，也能够让同一个 Pod 中的多个 Container 共享文件。</p>
<blockquote>
<p>这篇文章并不会介绍 Kubernetes 中 Volume 的使用方法和 API，而是会着重介绍 Volume 的工作原理，包含其创建过程、多种 Volume 实现的异同以及如何与云服务提供商进行适配。</p>
</blockquote>
<h2 id=概述>概述</h2>
<p>Kubernetes 中的 Volume 种类非常多，它不仅要支持临时的、易失的磁盘文件，还需要解决持久存储的问题；第一个问题往往都比较容易解决，后者作为持久存储在很多时候都需要与云服务商提供的存储方案打交道，如果是 Kubernetes 中已经支持的存储类型倒是还好，遇到不支持的类型还是比较麻烦的。</p>
<p><img src=https://img.draveness.me/2019-01-14-kubernetes-storage.png alt=kubernetes-storage></p>
<p>除了卷和持久卷之外，Kubernetes 还有另外一种更加复杂的概念 - 动态存储供应，它能够允许存储卷按需进行创建，不再需要集群的管理员手动调用云服务商提供的接口或者界面创建新的存储卷。</p>
<p>集群中的每一个卷在被 Pod 使用时都会经历四个操作，也就是附着（Attach）、挂载（Mount）、卸载（Unmount）和分离（Detach）。</p>
<p>如果 Pod 中使用的是 EmptyDir、HostPath 这种类型的卷，那么这些卷并不会经历附着和分离的操作，它们只会被挂载和卸载到某一个的 Pod 中，不过如果使用的云服务商提供的存储服务，这些持久卷只有附着到某一个节点之后才可以被挂在到相应的目录下，不过在其他节点使用这些卷时，该存储资源也需要先与当前的节点分离。</p>
<p>如果 pod</p>
<h3 id=卷>卷</h3>
<p>在这一节中提到的卷（Volume）其实是一个比较特定的概念，它并不是一个持久化存储，可能会随着 Pod 的删除而删除，常见的卷就包括 EmptyDir、HostPath、ConfigMap 和 Secret，这些卷与所属的 Pod 具有相同的生命周期，它们可以通过如下的方式挂载到 Pod 下面的某一个目录中：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-pod</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-container</span><span class=w>
</span><span class=w>      </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>k8s.gcr.io/busybox</span><span class=w>
</span><span class=w>      </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-volume</span><span class=w>
</span><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/cache</span><span class=w>
</span><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-volume</span><span class=w>
</span><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/hostpath</span><span class=w>
</span><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>config-volume</span><span class=w>
</span><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/data/configmap</span><span class=w>
</span><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>special-volume</span><span class=w>
</span><span class=w>          </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/data/secret</span><span class=w>
</span><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-volume</span><span class=w>
</span><span class=w>      </span><span class=nt>emptyDir</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hostpath-volume</span><span class=w>
</span><span class=w>      </span><span class=nt>hostPath</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/data/hostpath</span><span class=w>
</span><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Directory</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>config-volume</span><span class=w>
</span><span class=w>      </span><span class=nt>configMap</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>special-config</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>secret-volume</span><span class=w>
</span><span class=w>      </span><span class=nt>secret</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>secretName</span><span class=p>:</span><span class=w> </span><span class=l>secret-config</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，当我们将 ConfigMap 或者 Secret 『包装』成卷并挂载到某个目录时，我们其实创建了一些新的 Volume，这些 Volume 并不是 Kubernetes 中的对象，它们只存在于当前 Pod 中，随着 Pod 的删除而删除，但是需要注意的是这些『临时卷』的删除并不会导致相关  <code>ConfigMap</code>  或者  <code>Secret</code>  对象的删除。</p>
<p>从上面我们其实可以看出 Volume 没有办法脱离 Pod 而生存，它与 Pod 拥有完全相同的生命周期，而且它们也不是 Kubernetes 对象，所以 Volume 的主要作用还是用于跨节点或者容器对数据进行同步和共享。</p>
<h3 id=持久卷>持久卷</h3>
<p>临时的卷没有办法解决数据持久存储的问题，想要让数据能够持久化，首先就需要将 Pod 和卷的声明周期分离，这也就是引入持久卷  <code>PersistentVolume(PV)</code>  的原因。我们可以将  <code>PersistentVolume</code>  理解为集群中资源的一种，它与集群中的节点 Node 有些相似，PV 为 Kubernete 集群提供了一个如何提供并且使用存储的抽象，与它一起被引入的另一个对象就是  <code>PersistentVolumeClaim(PVC)</code>，这两个对象之间的关系与节点和 Pod 之间的关系差不多：</p>
<p><img src=https://img.draveness.me/2019-01-14-kubernetes-pv-and-pvc.png alt=kubernetes-pv-and-pvc></p>
<p><code>PersistentVolume</code>  是集群中的一种被管理员分配的存储资源，而  <code>PersistentVolumeClaim</code>  表示用户对存储资源的申请，它与 Pod 非常相似，PVC 消耗了持久卷资源，而 Pod 消耗了节点上的 CPU 和内存等物理资源。</p>
<p>因为 PVC 允许用户消耗抽象的存储资源，所以用户需要不同类型、属性和性能的 PV 就是一个比较常见的需求了，在这时我们可以通过  <code>StorageClass</code>  来提供不同种类的 PV 资源，上层用户就可以直接使用系统管理员提供好的存储类型。</p>
<h4 id=访问模式>访问模式</h4>
<p>Kubernetes 中的 PV 提供三种不同的访问模式，分别是  <code>ReadWriteOnce</code>、<code>ReadOnlyMany</code>  和  <code>ReadWriteMany</code>，这三种模式的含义和用法我们可以通过它们的名字推测出来：</p>
<ul>
<li><code>ReadWriteOnce</code>  表示当前卷可以被一个节点使用读写模式挂载；</li>
<li><code>ReadOnlyMany</code>  表示当前卷可以被多个节点使用只读模式挂载；</li>
<li><code>ReadWriteMany</code>  表示当前卷可以被多个节点使用读写模式挂载；</li>
</ul>
<p>不同的卷插件对于访问模式其实有着不同的支持，AWS 上的  <code>AWSElasticBlockStore</code>  和 GCP 上的  <code>GCEPersistentDisk</code>  就只支持  <code>ReadWriteOnce</code>  方式的挂载，不能同时挂载到多个节点上，但是  <code>CephFS</code>  就同时支持这三种访问模式。</p>
<h4 id=回收策略>回收策略</h4>
<p>当某个服务使用完某一个卷之后，它们会从 apiserver 中删除 PVC 对象，这时 Kubernetes 就需要对卷进行回收（Reclaim），持久卷也同样包含三种不同的回收策略，这三种回收策略会指导 Kubernetes 选择不同的方式对使用过的卷进行处理。</p>
<p><img src=https://img.draveness.me/2019-01-14-kubernetes-pv-reclaiming-strategy.png alt=kubernetes-pv-reclaiming-strategy></p>
<p>第一种回收策略就是保留（Retain）PV 中的数据，如果希望 PV 能够被重新使用，系统管理员需要删除被使用的  <code>PersistentVolume</code>  对象并手动清除存储和相关存储上的数据。</p>
<p>另一种常见的回收策略就是删除（Delete），当 PVC 被使用者删除之后，如果当前卷支持删除的回收策略，那么 PV 和相关的存储会被自动删除，如果当前 PV 上的数据确实不再需要，那么将回收策略设置成 Delete 能够节省手动处理的时间并快速释放无用的资源。</p>
<h4 id=存储供应>存储供应</h4>
<p>Kubernetes 集群中包含了很多的 PV 资源，而 PV 资源有两种供应的方式，一种是静态的，另一种是动态的，静态存储供应要求集群的管理员预先创建一定数量的 PV，然后使用者通过 PVC 的方式对 PV 资源的使用进行声明和申请；但是当系统管理员创建的 PV 对象不能满足使用者的需求时，就会进入动态存储供应的逻辑，供应的方式是基于集群中的  <code>StorageClass</code>  对象，当然这种动态供应的方式也可以通过配置进行关闭。</p>
<h2 id=管理>管理</h2>
<p>Volume 的创建和管理在 Kubernetes 中主要由卷管理器  <code>VolumeManager</code>  和  <code>AttachDetachController</code>  和  <code>PVController</code>  三个组件负责。其中卷管理器会负责卷的创建和管理的大部分工作，而  <code>AttachDetachController</code>  主要负责对集群中的卷进行 Attach 和 Detach，<code>PVController</code>  负责处理持久卷的变更，</p>
<p>文章接下来的内容会详细介绍这几部分之间的关系、工作原理以及它们是如何协作的。</p>
<h3 id=kubelet>kubelet</h3>
<p>作者在  <a href=https://draveness.me/kubernetes-pod>详解 Kubernetes Pod 的实现原理</a>  一文中曾简单介绍过 kubelet 和 Pod 的关系，</p>
<p>前者会负责后者的创建和管理，kubelet 中与 Pod 相关的信息都是从 apiserver 中获取的：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>graph LR
    apiserver-.-&gt;u
    u((updates))-.-&gt;kubelet
    kubelet-.-&gt;podWorkers
    podWorkers-.-&gt;worker1
    podWorkers-.-&gt;worker2
    style u fill:#fffede,stroke:#ebebb7
</code></pre></td></tr></table>
</div>
</div><p>两者的通信会使用一个  <code>kubetypes.PodUpdate</code>  类型的 Channel，kubelet 从 apiserver 中获取 Pod 时也会通过字段过滤器  <code>fields.OneTermEqualSelector(api.PodHostField, string(nodeName))</code>  仅选择被调度到 kubelet 所在节点上的 Pod：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>NewSourceApiserver</span><span class=p>(</span><span class=nx>c</span> <span class=nx>clientset</span><span class=p>.</span><span class=nx>Interface</span><span class=p>,</span> <span class=nx>nodeName</span> <span class=nx>types</span><span class=p>.</span><span class=nx>NodeName</span><span class=p>,</span> <span class=nx>updates</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
    <span class=nx>lw</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nf>NewListWatchFromClient</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nf>CoreV1</span><span class=p>().</span><span class=nf>RESTClient</span><span class=p>(),</span> <span class=s>&#34;pods&#34;</span><span class=p>,</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>NamespaceAll</span><span class=p>,</span> <span class=nx>fields</span><span class=p>.</span><span class=nf>OneTermEqualSelector</span><span class=p>(</span><span class=nx>api</span><span class=p>.</span><span class=nx>PodHostField</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>nodeName</span><span class=p>)))</span>
    <span class=nf>newSourceApiserverFromLW</span><span class=p>(</span><span class=nx>lw</span><span class=p>,</span> <span class=nx>updates</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>所有对 Pod 的变更最终都会通知给具体的 PodWorker，这些 Worker 协程会调用 kubelet <code>syncPod</code>  函数完成对 Pod 的同步：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant PW as PodWorker
    participant K as Kubelet
    participant VL as VolumeManager
    participant DSOWP as DesiredStateOfWorldPopulator
    participant ASOW as ActualStateOfWorld
    PW-&gt;&gt;+K: syncPod
    K-&gt;&gt;+VL: WaitForAttachAndMount
    VL-xDSOWP: ReprocessPod
    loop verifyVolumesMounted
        VL-&gt;&gt;+ASOW: getUnmountedVolumes
        ASOW--&gt;&gt;-VL: Volumes
    end
    VL--&gt;&gt;-K: Attached/Timeout
    K--&gt;&gt;-PW: return
</code></pre></td></tr></table>
</div>
</div><p>在一个 100 多行的  <code>syncPod</code>  方法中，kubelet 会调用  <code>WaitForAttachAndMount</code>  方法，等待某一个 Pod 中的全部卷已经被成功地挂载：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>kl</span> <span class=o>*</span><span class=nx>Kubelet</span><span class=p>)</span> <span class=nf>syncPod</span><span class=p>(</span><span class=nx>o</span> <span class=nx>syncPodOptions</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>pod</span> <span class=o>:=</span> <span class=nx>o</span><span class=p>.</span><span class=nx>pod</span>

    <span class=c1>// ...
</span><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>kl</span><span class=p>.</span><span class=nf>podIsTerminated</span><span class=p>(</span><span class=nx>pod</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>kl</span><span class=p>.</span><span class=nx>volumeManager</span><span class=p>.</span><span class=nf>WaitForAttachAndMount</span><span class=p>(</span><span class=nx>pod</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// ...
</span><span class=c1></span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法会将当前的 Pod 加入需要重新处理卷挂载的队列并在循环中持续调用  <code>verifyVolumesMounted</code>  方法来比较期望挂载的卷和实际挂载卷的区别，这个循环会等待两者变得完全相同或者超时后才会返回，当前方法的返回一般也意味着 Pod 中的全部卷已经挂载成功了。</p>
<h3 id=卷管理器>卷管理器</h3>
<p>当前节点卷的管理就都是由  <code>VolumeManager</code>  来负责了，在 Kubernetes 集群中的每一个节点（Node）上的 kubelet 启动时都会运行一个  <code>VolumeManager</code> Goroutine，它会负责在当前节点上的 Pod 和 Volume 发生变动时对 Volume 进行挂载和卸载等操作。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>graph TD
    subgraph Node
        VolumeManager-.-&gt;Kubelet
        DesiredStateOfWorldPopulator-.-&gt;VolumeManager
        Reconciler-.-&gt;VolumeManager
    end
</code></pre></td></tr></table>
</div>
</div><p>这个组件会在运行时启动两个 Goroutine 来管理节点中的卷，其中一个是  <code>DesiredStateOfWorldPopulator</code>，另一个是  <code>Reconciler</code>：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>graph LR
    VM(VolumeManager)-. run .-&gt;R(Reconciler)
    VM-. run .-&gt;DSWP(DesiredStateOfWorldPopulator)
    DSWP-. update .-&gt;DSW[DesiredStateOfWorld]
    ASW[ActualStateOfWorld]-. get .-&gt;DSWP
    DSW-. get .-&gt;R
    R-. update .-&gt;ASW
    DSWP-. getpods .-&gt;PodManager
    style ASW fill:#fffede,stroke:#ebebb7
    style DSW fill:#fffede,stroke:#ebebb7
</code></pre></td></tr></table>
</div>
</div><p>如上图所示，这里的  <code>DesiredStateOfWorldPopulator</code>  和  <code>Reconciler</code>  两个 Goroutine 会通过图中两个的  <code>XXXStateOfWorld</code>  状态进行通信，<code>DesiredStateOfWorldPopulator</code>  主要负责从 Kubernetes 节点中获取新的 Pod 对象并更新  <code>DesiredStateOfWorld</code>  结构；而后者会根据实际状态和当前状态的区别对当前节点的状态进行迁移，也就是通过  <code>DesiredStateOfWorld</code>  中状态的变更更新  <code>ActualStateOfWorld</code>  中的内容。</p>
<p>卷管理器中的两个 Goroutine，一个根据工程师的需求更新节点的期望状态  <code>DesiredStateOfWorld</code>，另一个 Goroutine 保证节点向期望状态『迁移』，也就是说  <code>DesiredStateOfWorldPopulator</code>  是卷管理器中的生产者，而  <code>Reconciler</code>  是消费者，接下来我们会分别介绍这两个 Goroutine 的工作和实现。</p>
<h4 id=desiredstateofworldpopulator>DesiredStateOfWorldPopulator</h4>
<p>作为卷管理器中的消费者，<code>DesiredStateOfWorldPopulator</code>  会根据工程师的请求不断修改当前节点的期望状态，我们可以通过以下的时序图来了解它到底做了哪些工作：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant DSOWP as DesiredStateOfWorldPopulator
    participant ASOW as ActualStateOfWorld
    participant DSOW as DesiredStateOfWorld
    participant PM as PodManager
    participant VPM as VolumePluginManager
    loop populatorLoop
        DSOWP-&gt;&gt;+DSOWP: findAndAddNewPods
        DSOWP-&gt;&gt;+ASOW: GetMountedVolumes
        ASOW--&gt;&gt;-DSOWP: mountedVolume
        DSOWP-&gt;&gt;+PM: GetPods
        PM--&gt;&gt;-DSOWP: pods
        loop Every Pod
            DSOWP-&gt;&gt;+DSOW: AddPodToVolume
            DSOW-&gt;&gt;+VPM: FindPluginBySpec
            VPM--&gt;&gt;-DSOW: volumePlugin
            DSOW--&gt;&gt;-DSOWP: volumeName
        end
        deactivate DSOWP

        DSOWP-&gt;&gt;+DSOWP: findAndRemoveDeletedPods
        DSOWP-&gt;&gt;+DSOW: GetVolumesToMount
        DSOW--&gt;&gt;-DSOWP: volumeToMount
        loop Every Volume
            DSOWP-&gt;&gt;+PM: GetPodByUID
            PM--&gt;&gt;-DSOWP: pods
            DSOWP-&gt;&gt;DSOW: DeletePodFromVolume
        end
        deactivate DSOWP
    end
</code></pre></td></tr></table>
</div>
</div><p>整个  <code>DesiredStateOfWorldPopulator</code>  运行在一个大的循环  <code>populatorLoop</code>  中，当前循环会通过两个方法  <code>findAndAddNewPods</code>  和  <code>findAndRemoveDeletedPods</code>  分别获取节点中被添加的新 Pod 或者已经被删除的老 Pod，获取到 Pod 之后会根据当前的状态修改期望状态：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dswp</span> <span class=o>*</span><span class=nx>desiredStateOfWorldPopulator</span><span class=p>)</span> <span class=nf>findAndAddNewPods</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>mountedVolumesForPod</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>volumetypes</span><span class=p>.</span><span class=nx>UniquePodName</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>cache</span><span class=p>.</span><span class=nx>MountedVolume</span><span class=p>)</span>

    <span class=nx>processedVolumesForFSResize</span> <span class=o>:=</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>()</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>pod</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>dswp</span><span class=p>.</span><span class=nx>podManager</span><span class=p>.</span><span class=nf>GetPods</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>dswp</span><span class=p>.</span><span class=nf>isPodTerminated</span><span class=p>(</span><span class=nx>pod</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>continue</span>
        <span class=p>}</span>
        <span class=nx>dswp</span><span class=p>.</span><span class=nf>processPodVolumes</span><span class=p>(</span><span class=nx>pod</span><span class=p>,</span> <span class=nx>mountedVolumesForPod</span><span class=p>,</span> <span class=nx>processedVolumesForFSResize</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>就像时序图和代码中所描述的，<code>DesiredStateOfWorldPopulator</code>  会从  <code>PodManager</code>  中获取当前节点中的 Pod，随后调用  <code>processPodVolumes</code>  方法为将所有的 Pod 对象加入  <code>DesiredStateOfWorld</code>  结构中：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dswp</span> <span class=o>*</span><span class=nx>desiredStateOfWorldPopulator</span><span class=p>)</span> <span class=nf>processPodVolumes</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>mountedVolumesForPod</span> <span class=kd>map</span><span class=p>[</span><span class=nx>volumetypes</span><span class=p>.</span><span class=nx>UniquePodName</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>cache</span><span class=p>.</span><span class=nx>MountedVolume</span><span class=p>,</span> <span class=nx>processedVolumesForFSResize</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>uniquePodName</span> <span class=o>:=</span> <span class=nx>util</span><span class=p>.</span><span class=nf>GetUniquePodName</span><span class=p>(</span><span class=nx>pod</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>dswp</span><span class=p>.</span><span class=nf>podPreviouslyProcessed</span><span class=p>(</span><span class=nx>uniquePodName</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>mountsMap</span><span class=p>,</span> <span class=nx>devicesMap</span> <span class=o>:=</span> <span class=nx>dswp</span><span class=p>.</span><span class=nf>makeVolumeMap</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Containers</span><span class=p>)</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>podVolume</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pod</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Volumes</span> <span class=p>{</span>
        <span class=nx>pvc</span><span class=p>,</span> <span class=nx>volumeSpec</span><span class=p>,</span> <span class=nx>volumeGidValue</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>dswp</span><span class=p>.</span><span class=nf>createVolumeSpec</span><span class=p>(</span><span class=nx>podVolume</span><span class=p>,</span> <span class=nx>pod</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>pod</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>mountsMap</span><span class=p>,</span> <span class=nx>devicesMap</span><span class=p>)</span>
        <span class=nx>dswp</span><span class=p>.</span><span class=nx>desiredStateOfWorld</span><span class=p>.</span><span class=nf>AddPodToVolume</span><span class=p>(</span><span class=nx>uniquePodName</span><span class=p>,</span> <span class=nx>pod</span><span class=p>,</span> <span class=nx>volumeSpec</span><span class=p>,</span> <span class=nx>podVolume</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>volumeGidValue</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>dswp</span><span class=p>.</span><span class=nf>markPodProcessed</span><span class=p>(</span><span class=nx>uniquePodName</span><span class=p>)</span>
    <span class=nx>dswp</span><span class=p>.</span><span class=nx>actualStateOfWorld</span><span class=p>.</span><span class=nf>MarkRemountRequired</span><span class=p>(</span><span class=nx>uniquePodName</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>findAndAddNewPods</code>  方法做的主要就是将节点中加入的新 Pod 添加到  <code>DesiredStateOfWorld</code>  中，而另一个方法  <code>findAndRemoveDeletedPods</code>  其实也做着类似的事情，它会将已经被删除的节点从  <code>DesiredStateOfWorld</code>  中剔除，总而言之  <code>DesiredStateOfWorldPopulator</code>  就是将当前节点的期望状态同步到  <code>DesiredStateOfWorld</code>  中，等待消费者的处理。</p>
<h4 id=reconciler>Reconciler</h4>
<p><code>VolumeManager</code>  持有的另一个 Goroutine <code>Reconciler</code>  会负责对当前节点上的 Volume 进行管理，它在正常运行时会启动  <code>reconcile</code>  循环，在这个方法中会分三次对当前状态和期望状态不匹配的卷进行卸载、挂载等操作：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant R as Reconciler
    participant ASOW as ActualStateOfWorld
    participant DSOW as DesiredStateOfWorld
    participant OE as OperationExecutor
    loop reconcile
        R-&gt;&gt;+ASOW: GetMountedVolumes
        activate R
        ASOW--&gt;&gt;-R: MountedVolumes
        R-&gt;&gt;DSOW: PodExistsInVolume
        R-&gt;&gt;OE: UnmountVolume
        deactivate R

        R-&gt;&gt;+DSOW: GetVolumesToMount
        activate R
        DSOW--&gt;&gt;-R: volumeToMount
        R-&gt;&gt;ASOW: PodExistsInVolume
        R-&gt;&gt;OE: AttachVolume/MountVolume
        deactivate R

        R-&gt;&gt;+ASOW: GetUnmountedVolumes
        activate R
        R-&gt;&gt;DSOW: VolumeExists
        R-&gt;&gt;OE: UnmountDevice/DetachVolume
        deactivate R
    end
</code></pre></td></tr></table>
</div>
</div><p>在当前的循环中首先会保证应该被卸载但是仍然在节点中存在的卷被卸载，然后将应该挂载的卷挂载到合适的位置，最后将设备与节点分离或者卸载，所有挂载和卸载的操作都是通过  <code>OperationExecutor</code>  完成的，这个结构体负责调用相应的插件执行操作，我们会在文章的后面展开进行介绍。</p>
<h3 id=附着分离控制器>附着分离控制器</h3>
<p>除了  <code>VolumeManager</code>  之外，另一个负责管理 Kubernetes 卷的组件就是  <code>AttachDetachController</code>  了，引入这个组件的目的主要是：</p>
<ol>
<li>让卷的挂载和卸载能够与节点的可用性脱离；
<ul>
<li>一旦节点或者 kubelet 宕机，附着（Attach）在当前节点上的卷应该能够被分离（Detach），分离之后的卷就能够再次附着到其他节点上；</li>
</ul>
</li>
<li>保证云服务商秘钥的安全；
<ul>
<li>如果每一个 kubelet 都需要触发卷的附着和分离逻辑，那么每一个节点都应该有操作卷的权限，但是这些权限应该只由主节点掌握，这样能够降低秘钥泄露的风险；</li>
</ul>
</li>
<li>提高卷附着和分离部分代码的稳定性；</li>
</ol>
<blockquote>
<p>这些内容都是在 Kubernetes 官方项目的 GitHub issue <a href=https://github.com/kubernetes/kubernetes/issues/20262>Detailed Design for Volume Attach/Detach Controller #20262</a>  中讨论的，想要了解  <code>AttachDetachController</code>  出现的原因可以阅读相关的内容。</p>
</blockquote>
<p>每一个  <code>AttachDetachController</code>  其实也包含  <code>Reconciler</code>  和  <code>DesiredStateOfWorldPopulator</code>  两个组件，这两个组件虽然与  <code>VolumeManager</code>  中的两个组件重名，实现的功能也非常类似，与  <code>VolumeManager</code>  具有几乎相同的数据流向，但是这两个 Goroutine 是跑在 Kubernetes 主节点中的，所以实现上可能一些差异：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>graph LR
    ADC(AttachDetachController)-. run .-&gt;R(Reconciler)
    ADC-. run .-&gt;DSWP(DesiredStateOfWorldPopulator)
    DSWP-. update .-&gt;DSW[DesiredStateOfWorld]
    ASW[ActualStateOfWorld]-. get .-&gt;DSWP
    DSW-. get .-&gt;R
    R-. update .-&gt;ASW
    DSWP-. getpods .-&gt;PodManager
    style ASW fill:#fffede,stroke:#ebebb7
    style DSW fill:#fffede,stroke:#ebebb7
</code></pre></td></tr></table>
</div>
</div><p>首先，无论是  <code>Reconciler</code>  还是  <code>DesiredStateOfWorldPopulator</code>，它们同步的就不再只是某个节点上 Pod 的信息了，它们需要对整个集群中的 Pod 对象负责，相关数据也不再是通过 apiserver 拉取了，而是使用  <code>podInformer</code>  在 Pod 对象发生变更时调用相应的方法。</p>
<h4 id=desiredstateofworldpopulator-1>DesiredStateOfWorldPopulator</h4>
<p>作为  <code>AttachDetachController</code>  启动的 Goroutine，<code>DesiredStateOfWorldPopulator</code>  的主要作用是从当前集群的状态中获取 Pod 对象并修改  <code>DesiredStateOfWorld</code>  结构，与  <code>VolumeManager</code>  中的同名 Goroutine 起到相同的作用，作为整个链路的生产者，它们只是在实现上由于处理 Pod 范围的不同有一些区别：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant DSOWP as DesiredStateOfWorldPopulator
    participant ASOW as ActualStateOfWorld
    participant DSOW as DesiredStateOfWorld
    participant PL as PodLister
    participant VPM as VolumePluginManager
    loop populatorLoopFunc
        DSOWP-&gt;&gt;+DSOWP: findAndRemoveDeletedPods
        DSOWP-&gt;&gt;+DSOW: GetPodToAdd
        DSOW--&gt;&gt;-DSOWP: podsToAdd
        loop Every Pod

            DSOWP-&gt;&gt;+PL: GetPod
            alt PodNotFound
                PL--&gt;&gt;-DSOWP: return
                DSOWP-&gt;&gt;DSOW: DeletePod
            else
            end
        end
        deactivate DSOWP

        DSOWP-&gt;&gt;+DSOWP: findAndAddActivePods
        DSOWP-&gt;&gt;+PL: List
        PL--&gt;&gt;-DSOWP: pods
        loop Every Pod
            DSOWP-&gt;&gt;+VPM: FindAttachablePluginBySpec
            VPM--&gt;&gt;-DSOW: attachableVolumePlugin
            DSOWP-&gt;&gt;+DSOW: AddPod/DeletePod
            DSOW--&gt;&gt;-DSOWP: volumeName
        end
        deactivate DSOWP
   end
</code></pre></td></tr></table>
</div>
</div><p><code>AttachDetachController</code>  中的  <code>DesiredStateOfWorldPopulator</code>  协程就主要会先处理 Pod 的删除逻辑，添加 Pod 的逻辑都是根据  <code>listPodsRetryDuration</code>  的设置周期性被触发的，所以从这里我们就能看到  <code>AttachDetachController</code>  其实主要还是处理被删除 Pod 中 Volume 的分离工作，当节点或者 kubelet 宕机时能够将节点中的卷进行分离，保证 Pod 在其他节点重启时不会出现问题。</p>
<h4 id=reconciler-1>Reconciler</h4>
<p>另一个用于调节当前状态与期望状态的 Goroutine 在执行它内部的循环时，也会优先处理分离卷的逻辑，后处理附着卷的工作，整个时序图与  <code>VolumeManager</code>  中的  <code>Reconciler</code>  非常相似：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant R as Reconciler
    participant ASOW as ActualStateOfWorld
    participant DSOW as DesiredStateOfWorld
    participant OE as OperationExecutor
    loop reconcile
        R-&gt;&gt;+ASOW: GetAttachedVolumes
        activate R
        ASOW--&gt;&gt;-R: attachedVolumes
        R-&gt;&gt;+DSOW: VolumeExists
        alt VolumeNotExists
            DSOW--&gt;&gt;-R: return
            R-&gt;&gt;OE: DetachVolume
            deactivate R
        else
        end

        R-&gt;&gt;+DSOW: GetVolumesToAttach
        activate R
        DSOW--&gt;&gt;-R: volumeToAttach
        R-&gt;&gt;+ASOW: VolumeNodeExists
        alt VolumeNotExists
            ASOW--&gt;&gt;-R: return
            R-&gt;&gt;OE: AttachVolume
        else
        end
        deactivate R
    end
</code></pre></td></tr></table>
</div>
</div><p>这里处理的工作其实相对更少一些，<code>Reconciler</code>  会将期望状态中的卷与实际状态进行比较，然后分离需要分离的卷、附着需要附着的卷，逻辑非常的清晰和简单。</p>
<h3 id=持久卷控制器>持久卷控制器</h3>
<p>作为集群中与 PV 和 PVC 打交道的控制器，持久卷控制器同时运行着三个 Goroutine 用于处理相应的逻辑，其中  <code>Resync</code>  协程负责从 Kubernetes 集群中同步 PV 和 PVC 的信息，而另外两个工作协程主要负消费队列中的任务：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>graph LR
    PVC(PVController)-.-&gt;R(Resync)
    PVC-.-&gt;VW(VolumeWorker)
    R-. enqueue .-&gt;VQ(VolumeQueue)
    R-. enqueue .-&gt;CQ(ClaimQueue)
    VQ-. dequeue .-&gt;VW
    CQ-. dequeue .-&gt;CW
    PVC-.-&gt;CW(ClaimWorker)
    style VQ fill:#fffede,stroke:#ebebb7
    style CQ fill:#fffede,stroke:#ebebb7
</code></pre></td></tr></table>
</div>
</div><p>这两个工作协程主要负责对需要绑定或者解绑的 PV 和 PVC 进行处理，例如，当用户创建了新的 PVC 对象时，从集群中查找该 PVC 选择的 PV 并绑定到当前的 PVC 上。</p>
<h4 id=volumeworker>VolumeWorker</h4>
<p><code>VolumeWorker</code>  协程中执行的最重要的方法其实就是  <code>syncVolume</code>，在这个方法中会根据当前 PV 对象的规格对 PV 和 PVC 进行绑定或者解绑：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>ctrl</span> <span class=o>*</span><span class=nx>PersistentVolumeController</span><span class=p>)</span> <span class=nf>syncVolume</span><span class=p>(</span><span class=nx>volume</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolume</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>ClaimRef</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>ClaimRef</span><span class=p>.</span><span class=nx>UID</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>
        <span class=kd>var</span> <span class=nx>claim</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolumeClaim</span>
        <span class=nx>claimName</span> <span class=o>:=</span> <span class=nf>claimrefToClaimKey</span><span class=p>(</span><span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>ClaimRef</span><span class=p>)</span>
        <span class=nx>obj</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nx>claims</span><span class=p>.</span><span class=nf>GetByKey</span><span class=p>(</span><span class=nx>claimName</span><span class=p>)</span>
        <span class=nx>claim</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolumeClaim</span><span class=p>)</span>

        <span class=k>if</span> <span class=nx>claim</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>claim</span><span class=p>.</span><span class=nx>UID</span> <span class=o>!=</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>ClaimRef</span><span class=p>.</span><span class=nx>UID</span> <span class=p>{</span>
            <span class=nx>claim</span> <span class=p>=</span> <span class=kc>nil</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=nx>claim</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>ctrl</span><span class=p>.</span><span class=nf>reclaimVolume</span><span class=p>(</span><span class=nx>volume</span><span class=p>)</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>claim</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>VolumeName</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
            <span class=nx>ctrl</span><span class=p>.</span><span class=nx>claimQueue</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nf>claimToClaimKey</span><span class=p>(</span><span class=nx>claim</span><span class=p>))</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>claim</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>VolumeName</span> <span class=o>==</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Name</span> <span class=p>{</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=k>if</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>HasAnnotation</span><span class=p>(</span><span class=nx>volume</span><span class=p>.</span><span class=nx>ObjectMeta</span><span class=p>,</span> <span class=nx>annDynamicallyProvisioned</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>PersistentVolumeReclaimPolicy</span> <span class=o>==</span> <span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolumeReclaimDelete</span> <span class=p>{</span>
                <span class=nx>ctrl</span><span class=p>.</span><span class=nf>reclaimVolume</span><span class=p>(</span><span class=nx>volume</span><span class=p>)</span>
            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=nx>ctrl</span><span class=p>.</span><span class=nf>unbindVolume</span><span class=p>(</span><span class=nx>volume</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前 PV 没有绑定的 PVC 对象，那么这里的  <code>reclaimVolume</code>  可能会将当前的 PV 对象根据回收策略将其放回资源池等待重用、回收或者保留；而  <code>unbindVolume</code>  会删除 PV 与 PVC 之间的关系并更新 apiserver 中保存的 Kubernetes 对象数据。</p>
<h4 id=claimworker>ClaimWorker</h4>
<p><code>ClaimWorker</code>  就是控制器用来决定如何处理一个 PVC 对象的方法了，它会在一个 PVC 对象被创建、更新或者同步时被触发，<code>syncClaim</code>  会根据当前对象中的注解决定调用  <code>syncUnboundClaim</code>  或者  <code>syncBoundClaim</code>  方法来处理相应的逻辑：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>ctrl</span> <span class=o>*</span><span class=nx>PersistentVolumeController</span><span class=p>)</span> <span class=nf>syncClaim</span><span class=p>(</span><span class=nx>claim</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolumeClaim</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>metav1</span><span class=p>.</span><span class=nf>HasAnnotation</span><span class=p>(</span><span class=nx>claim</span><span class=p>.</span><span class=nx>ObjectMeta</span><span class=p>,</span> <span class=nx>annBindCompleted</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nf>syncUnboundClaim</span><span class=p>(</span><span class=nx>claim</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nf>syncBoundClaim</span><span class=p>(</span><span class=nx>claim</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>syncUnboundClaim</code>  会处理绑定没有结束的 PVC 对象，如果当前 PVC 对象没有对应合适的 PV 存在，那么就会调用  <code>provisionClaim</code>  尝试从集群中获取新的 PV 供应，如果能够找到 PV 对象，就会通过  <code>bind</code>  方法将两者绑定：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>ctrl</span> <span class=o>*</span><span class=nx>PersistentVolumeController</span><span class=p>)</span> <span class=nf>syncUnboundClaim</span><span class=p>(</span><span class=nx>claim</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolumeClaim</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>claim</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>VolumeName</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
        <span class=nx>delayBinding</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nf>shouldDelayBinding</span><span class=p>(</span><span class=nx>claim</span><span class=p>)</span>

        <span class=nx>volume</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nx>volumes</span><span class=p>.</span><span class=nf>findBestMatchForClaim</span><span class=p>(</span><span class=nx>claim</span><span class=p>,</span> <span class=nx>delayBinding</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>volume</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>switch</span> <span class=p>{</span>
            <span class=k>case</span> <span class=nx>delayBinding</span><span class=p>:</span>
            <span class=k>case</span> <span class=nx>v1helper</span><span class=p>.</span><span class=nf>GetPersistentVolumeClaimClass</span><span class=p>(</span><span class=nx>claim</span><span class=p>)</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span><span class=p>:</span>
                <span class=nx>ctrl</span><span class=p>.</span><span class=nf>provisionClaim</span><span class=p>(</span><span class=nx>claim</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=nx>ctrl</span><span class=p>.</span><span class=nf>bind</span><span class=p>(</span><span class=nx>volume</span><span class=p>,</span> <span class=nx>claim</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>obj</span><span class=p>,</span> <span class=nx>found</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nx>volumes</span><span class=p>.</span><span class=nx>store</span><span class=p>.</span><span class=nf>GetByKey</span><span class=p>(</span><span class=nx>claim</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>VolumeName</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>found</span> <span class=p>{</span>
            <span class=nx>volume</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolume</span><span class=p>)</span>
            <span class=k>if</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>ClaimRef</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=nx>ctrl</span><span class=p>.</span><span class=nf>bind</span><span class=p>(</span><span class=nx>volume</span><span class=p>,</span> <span class=nx>claim</span><span class=p>)</span>
            <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nf>isVolumeBoundToClaim</span><span class=p>(</span><span class=nx>volume</span><span class=p>,</span> <span class=nx>claim</span><span class=p>)</span> <span class=p>{</span>
                <span class=nx>ctrl</span><span class=p>.</span><span class=nf>bind</span><span class=p>(</span><span class=nx>volume</span><span class=p>,</span> <span class=nx>claim</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>绑定的过程其实就是将 PV 和 PVC 之间建立起新的关系，更新 Spec 中的数据让两者能够通过引用 Ref 找到另一个对象并将更新后的 Kubernetes 对象存储到 apiserver 中。</p>
<p>另一个用于绑定 PV 和 PVC 对象的方法就是  <code>syncBoundClaim</code>  了，相比于  <code>syncUnboundClaim</code>  方法，该方法的实现更为简单，直接从缓存中尝试获取对应的 PV 对象：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>ctrl</span> <span class=o>*</span><span class=nx>PersistentVolumeController</span><span class=p>)</span> <span class=nf>syncBoundClaim</span><span class=p>(</span><span class=nx>claim</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolumeClaim</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>claim</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>VolumeName</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=nx>obj</span><span class=p>,</span> <span class=nx>found</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ctrl</span><span class=p>.</span><span class=nx>volumes</span><span class=p>.</span><span class=nx>store</span><span class=p>.</span><span class=nf>GetByKey</span><span class=p>(</span><span class=nx>claim</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>VolumeName</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>found</span> <span class=p>{</span>
        <span class=nx>volume</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>PersistentVolume</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>ClaimRef</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>ctrl</span><span class=p>.</span><span class=nf>bind</span><span class=p>(</span><span class=nx>volume</span><span class=p>,</span> <span class=nx>claim</span><span class=p>)</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>volume</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>ClaimRef</span><span class=p>.</span><span class=nx>UID</span> <span class=o>==</span> <span class=nx>claim</span><span class=p>.</span><span class=nx>UID</span> <span class=p>{</span>
            <span class=nx>ctrl</span><span class=p>.</span><span class=nf>bind</span><span class=p>(</span><span class=nx>volume</span><span class=p>,</span> <span class=nx>claim</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果找到了 PV 对象并且该对象没有绑定的 PVC 或者当前 PV 和 PVC 已经存在了引用就会调用  <code>bind</code>  方法对两者进行绑定。</p>
<h4 id=小结>小结</h4>
<p>无论是  <code>VolumeWorker</code>  还是  <code>ClaimWorker</code>  最终都可能会通过 apiserver 更新集群中 etcd 的数据，当然它们也会调用一些底层的插件获取新的存储供应、删除或者重用一些持久卷，我们会在下面介绍插件的工作原理。</p>
<h2 id=插件>插件</h2>
<p>Kubernetes 中的所有对卷的操作最终基本都是通过  <code>OperationExecutor</code>  来完成的，这个组件包含了用于附着、挂载、卸载和分离几个常见的操作以及对设备进行操作的一些方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>OperationExecutor</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>AttachVolume</span><span class=p>(</span><span class=nx>volumeToAttach</span> <span class=nx>VolumeToAttach</span><span class=p>,</span> <span class=nx>actualStateOfWorld</span> <span class=nx>ActualStateOfWorldAttacherUpdater</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>DetachVolume</span><span class=p>(</span><span class=nx>volumeToDetach</span> <span class=nx>AttachedVolume</span><span class=p>,</span> <span class=nx>verifySafeToDetach</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>actualStateOfWorld</span> <span class=nx>ActualStateOfWorldAttacherUpdater</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>MountVolume</span><span class=p>(</span><span class=nx>waitForAttachTimeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>,</span> <span class=nx>volumeToMount</span> <span class=nx>VolumeToMount</span><span class=p>,</span> <span class=nx>actualStateOfWorld</span> <span class=nx>ActualStateOfWorldMounterUpdater</span><span class=p>,</span> <span class=nx>isRemount</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>UnmountVolume</span><span class=p>(</span><span class=nx>volumeToUnmount</span> <span class=nx>MountedVolume</span><span class=p>,</span> <span class=nx>actualStateOfWorld</span> <span class=nx>ActualStateOfWorldMounterUpdater</span><span class=p>,</span> <span class=nx>podsDir</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
    <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>实现  <code>OperationExecutor</code>  接口的私有结构体会通过  <code>OperatorGenerator</code>  来生成一个用于挂载和卸载卷的方法，并将这个方法包装在一个  <code>GeneratedOperations</code>  结构中，在这之后操作执行器会启动一个新的 Goroutine 用于执行生成好的方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>graph LR
    OE(OperationExexutor)-. 1. 获取相关方法 .-&gt;OG(OperationGenerator)
    OG-. 2. 根据 Spec 获取插件 .-&gt;VM(VolumePluginManager)
    VM-. 3. 返回 VolumePlugin .-&gt;OG
    OG-. 4. 构建方法 .-&gt;OG
    OG-. 5. 生成一个 Operation 结构 .-&gt;OE
    OE-. 6. 运行 Operation .-&gt;NPO(NestedPendingOperations)
    NPO-. 7. 启动 Goroutine 运行生成的方法 .-&gt;Goroutine
</code></pre></td></tr></table>
</div>
</div><p><code>VolumePluginManager</code>  和  <code>VolumePlugin</code>  这两个组件在整个流程中帮我们屏蔽了底层不同类型卷的实现差异，我们能直接在上层调用完全相同的接口，剩下的逻辑都由底层的插件来负责。</p>
<p>Kubernetes 提供了插件的概念，通过  <code>Volume</code>  和  <code>Mounter</code>  两个接口支持卷类型的扩展，作为存储提供商或者不同类型的文件系统，我们都可以通过实现以上的两个接口成为 Kubernetes 存储系统中一个新的存储类型：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>VolumePlugin</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>Init</span><span class=p>(</span><span class=nx>host</span> <span class=nx>VolumeHost</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>GetPluginName</span><span class=p>()</span> <span class=kt>string</span>
    <span class=nf>GetVolumeName</span><span class=p>(</span><span class=nx>spec</span> <span class=o>*</span><span class=nx>Spec</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
    <span class=nf>NewMounter</span><span class=p>(</span><span class=nx>spec</span> <span class=o>*</span><span class=nx>Spec</span><span class=p>,</span> <span class=nx>podRef</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>opts</span> <span class=nx>VolumeOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>Mounter</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
    <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>

<span class=kd>type</span> <span class=nx>Mounter</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nx>Volume</span>
    <span class=nf>CanMount</span><span class=p>()</span> <span class=kt>error</span>
    <span class=nf>SetUp</span><span class=p>(</span><span class=nx>fsGroup</span> <span class=o>*</span><span class=kt>int64</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>SetUpAt</span><span class=p>(</span><span class=nx>dir</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>fsGroup</span> <span class=o>*</span><span class=kt>int64</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>GetAttributes</span><span class=p>()</span> <span class=nx>Attributes</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这一节中我们将介绍几种不同卷插件的实现，包括最常见的 EmptyDir、ConfigMap、Secret 和 Google 云上的 GCEPersistentDisk，这一节会简单介绍不同卷插件的实现方式，想要了解详细实现的读者可以阅读相关的源代码。</p>
<h3 id=emptydir>EmptyDir</h3>
<p>EmptyDir 是 Kubernetes 中最简单的卷了，当我们为一个 Pod 设置一个 EmptyDir 类型的卷时，其实就是在当前 Pod 对应的目录创建了一个空的文件夹，这个文件夹会随着 Pod 的删除而删除。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>ed</span> <span class=o>*</span><span class=nx>emptyDir</span><span class=p>)</span> <span class=nf>SetUpAt</span><span class=p>(</span><span class=nx>dir</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>fsGroup</span> <span class=o>*</span><span class=kt>int64</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>ed</span><span class=p>.</span><span class=nf>setupDir</span><span class=p>(</span><span class=nx>dir</span><span class=p>)</span>
    <span class=nx>volume</span><span class=p>.</span><span class=nf>SetVolumeOwnership</span><span class=p>(</span><span class=nx>ed</span><span class=p>,</span> <span class=nx>fsGroup</span><span class=p>)</span>
    <span class=nx>volumeutil</span><span class=p>.</span><span class=nf>SetReady</span><span class=p>(</span><span class=nx>ed</span><span class=p>.</span><span class=nf>getMetaDir</span><span class=p>())</span>

    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>ed</span> <span class=o>*</span><span class=nx>emptyDir</span><span class=p>)</span> <span class=nf>setupDir</span><span class=p>(</span><span class=nx>dir</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>MkdirAll</span><span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>perm</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>err</span>
    <span class=p>}</span>

    <span class=c1>// ...
</span><span class=c1></span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>SetUpAt</code>  方法其实就实现了对这种类型卷的创建工作，每当 Pod 被分配到了某个节点上，对应的文件目录就会通过  <code>MkdirAl</code>  方法创建，如果使用者配置了 medium 字段，也会选择使用相应的文件系统挂载到当前目录上，例如：tmpfs、nodev 等。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-pd</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>k8s.gcr.io/test-webserver</span><span class=w>
</span><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-container</span><span class=w>
</span><span class=w>      </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span><span class=w>        </span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/cache</span><span class=w>
</span><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-volume</span><span class=w>
</span><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-volume</span><span class=w>
</span><span class=w>      </span><span class=nt>emptyDir</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>我们经常会使用 EmptyDir 类型的卷在多个容器之间共享文件、充当缓存或者保留一些临时的日志，总而言之，这是一种经常被使用的卷类型。</p>
<h3 id=configmap-和-secret>ConfigMap 和 Secret</h3>
<p>另一种比较常见的卷就是 ConfigMap 了，首先，ConfigMap 本身就是 Kubernetes 中常见的对象了，其中的  <code>data</code>  就是一个存储了从文件名到文件内容的字段，这里的 ConfigMap 对象被挂载到文件目录时就会创建一个名为  <code>redis-config</code>  的文件，然后将文件内容写入该文件：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>ConfigMap</span><span class=w>
</span><span class=w></span><span class=nt>data</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>redis-config</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span><span class=sd>    </span><span class=w>    </span><span class=l>maxmemory 2mb    maxmemory-policy allkeys-lru</span><span class=w>
</span></code></pre></td></tr></table>
</div>
</div><p>在对 ConfigMap 类型的卷进行挂载时，总共需要完成三部分工作，首先从 apiserver 中获取当前 ConfigMap 对象，然后根据当前的 ConfigMap 生成一个从文件名到文件内容的键值对，最后构造一个 Writer 并执行  <code>Write</code>  方法写入内容：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>configMapVolumeMounter</span><span class=p>)</span> <span class=nf>SetUpAt</span><span class=p>(</span><span class=nx>dir</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>fsGroup</span> <span class=o>*</span><span class=kt>int64</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>configMap</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>getConfigMap</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>pod</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>source</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>

    <span class=nx>totalBytes</span> <span class=o>:=</span> <span class=nf>totalBytes</span><span class=p>(</span><span class=nx>configMap</span><span class=p>)</span>
    <span class=nx>payload</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>MakePayload</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>source</span><span class=p>.</span><span class=nx>Items</span><span class=p>,</span> <span class=nx>configMap</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>source</span><span class=p>.</span><span class=nx>DefaultMode</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>

    <span class=nx>writerContext</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pod %v/%v volume %v&#34;</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>pod</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>pod</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>volName</span><span class=p>)</span>
    <span class=nx>writer</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>volumeutil</span><span class=p>.</span><span class=nf>NewAtomicWriter</span><span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>writerContext</span><span class=p>)</span>
    <span class=nx>writer</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>payload</span><span class=p>)</span>

    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在涉及挂载的函数几个中，作者想要着重介绍的也就是在底层直接与文件系统打交道的  <code>writePayloadToDir</code>  方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>AtomicWriter</span><span class=p>)</span> <span class=nf>writePayloadToDir</span><span class=p>(</span><span class=nx>payload</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>FileProjection</span><span class=p>,</span> <span class=nx>dir</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>userVisiblePath</span><span class=p>,</span> <span class=nx>fileProjection</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>payload</span> <span class=p>{</span>
        <span class=nx>content</span> <span class=o>:=</span> <span class=nx>fileProjection</span><span class=p>.</span><span class=nx>Data</span>
        <span class=nx>mode</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>FileMode</span><span class=p>(</span><span class=nx>fileProjection</span><span class=p>.</span><span class=nx>Mode</span><span class=p>)</span>
        <span class=nx>fullPath</span> <span class=o>:=</span> <span class=nx>path</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>userVisiblePath</span><span class=p>)</span>
        <span class=nx>baseDir</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>fullPath</span><span class=p>)</span>

        <span class=nx>os</span><span class=p>.</span><span class=nf>MkdirAll</span><span class=p>(</span><span class=nx>baseDir</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nx>ModePerm</span><span class=p>)</span>
        <span class=nx>ioutil</span><span class=p>.</span><span class=nf>WriteFile</span><span class=p>(</span><span class=nx>fullPath</span><span class=p>,</span> <span class=nx>content</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span>
        <span class=nx>os</span><span class=p>.</span><span class=nf>Chmod</span><span class=p>(</span><span class=nx>fullPath</span><span class=p>,</span> <span class=nx>mode</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法使用了  <code>os</code>  包提供的接口完成了拼接文件名、创建相应文件目录、写入文件并且修改文件模式的工作，将 ConfigMap <code>data</code>  中的数据映射到了一个文件夹中，达到了让 Pod 中的容器可以直接通过文件系统获取内容的目的。</p>
<p>对于另一个非常常见的卷类型 Secret，Kubernetes 其实也做了几乎完全相同的工作，也是先获取 Secret 对象，然后构建最终写入到文件的键值对，最后初始化一个 Writer 并调用它的  <code>Write</code>  方法，从这里我们也能看出在卷插件这一层对于 ConfigMap 和 Secret 的处理几乎完全相同，并没有出现需要对 Secret 对象中的内容进行解密的工作。</p>
<h3 id=gcepersistentdisk>GCEPersistentDisk</h3>
<p>最后一个要介绍的卷与上面的几种都非常的不同，它在底层使用的是云服务商提供的网络磁盘，想要在一个节点上使用云磁盘其实总共需要两个步骤，首先是要将云磁盘附着到当前的节点上，这部分的工作其实就是由  <code>gcePersistentDiskAttacher</code>  完成的，每当调用  <code>AttachDisk</code>  方法时，最终都会执行云服务商提供的接口，将磁盘附着到相应的节点实例上：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>sequenceDiagram
    participant GPDA as gcePersistentDiskAttacher
    participant C as Cloud
    participant GCESM as gceServiceManager
    participant I as GCEInstances
    GPDA-&gt;&gt;+C: DiskIsAttached
    alt NotAttached
        C--&gt;&gt;-GPDA: return NotAttached
        GPDA-&gt;&gt;+C: AttachDisk
        C-&gt;&gt;+GCESM: AttachDiskOnCloudProvider
        GCESM-&gt;&gt;+I: AttachDisk
        I--&gt;&gt;-GCESM: return
        GCESM--&gt;&gt;-C: return
        C--&gt;&gt;-GPDA: return
    else
    end
</code></pre></td></tr></table>
</div>
</div><p>在方法的的最后会将该请求包装成一个 HTTP 的方法调用向  <code>https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{resourceId}/attachDisk</code>  链接发出一个 POST 请求，这个请求会将某个 GCE 上的磁盘附着到目标实例上，详细的内容可以阅读  <a href=https://cloud.google.com/compute/docs/reference/rest/v1/instances/attachDisk>相关文档</a>。</p>
<p>一旦当前的磁盘被附着到了当前节点上，我们就能跟使用其他的插件一样，把磁盘挂载到某个目录上，完成从附着到挂载的全部操作。</p>
<h2 id=总结>总结</h2>
<p>Volume 和存储系统是 Kubernetes 非常重要的一部分，它能够帮助我们在多个容器之间共享文件，同时也能够为集群提供持久存储的功能，假如 Kubernetes 没有用于持久存储的对象，我们也很难在集群中运行有状态的服务，例如：消息队列、分布式存储等。</p>
<p>对于刚刚使用 Kubernetes 的开发者来说，Volume、PV 和 PVC 确实是比较难以理解的概念，但是这却是深入使用 Kubernetes 必须要了解和掌握的，希望这篇文章能够帮助各位读者更好地理解存储系统底层的实现原理。</p>
<h2 id=相关文章>相关文章</h2>
<p>{% include related/distributed-system.md %}</p>
<h2 id=referenece>Referenece</h2>
<ul>
<li><a href=https://kubernetes.io/docs/concepts/storage/volumes/>Volumes · Kubernetes</a></li>
<li><a href=https://github.com/kubernetes/kubernetes/issues/20262>Detailed Design for Volume Attach/Detach Controller #20262</a></li>
<li><a href=https://github.com/kubernetes/kubernetes/issues/21931>Detailed Design for Volume Mount/Unmount Redesign #21931</a></li>
<li><a href=https://github.com/kubernetes/kubernetes/issues/18333>Kubernetes Volume System Redesign Proposal #18333</a></li>
<li><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>Container Storage Interface (CSI)</a></li>
</ul>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2022-04-30 09:23:49
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/alipay_reward_qrcode.png>
<span>支付宝打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/bitcoin_reward_qrcode.png>
<span>比特币打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/cloudnative/>cloudnative</a>
<a href=https://justice.bj.cn/tags/k8s/>k8s</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/12.data_struct/31.roaringbitmap/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">RoaringBitmap</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/32.cloudnative/k8s/k8s%E4%B9%8Bcsi%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/>
<span class="next-text nav-default">k8s之CSI实现原理</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2024
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=/js/fuse.min.js></script>
<script src=/js/fastsearch.js></script>
</body>
</html>