<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>AF_XDP - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=referrer content="no-referrer">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="AF_XDP 简介 AF_XDP是一种用于高性能包处理的地址簇(Address Family)。 使用XDP程序中的XDP_REDIRECT操作，可以使用bp">
<meta name=keywords content="tech,it,blog">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/21.linux/af_xdp/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.34a0cf3583dc0fd6b4e3fe24a36c076984feee75ebc2792cff33928ccdcfc628.css integrity="sha256-NKDPNYPcD9a04/4ko2wHaYT+7nXrwnks/zOSjM3Pxig=" media=screen crossorigin=anonymous>
<meta property="og:title" content="AF_XDP">
<meta property="og:description" content="AF_XDP 简介 AF_XDP是一种用于高性能包处理的地址簇(Address Family)。 使用XDP程序中的XDP_REDIRECT操作，可以使用bp">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/21.linux/af_xdp/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-06-04T10:26:13+08:00">
<meta property="article:modified_time" content="2022-06-04T10:26:13+08:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="AF_XDP">
<meta itemprop=description content="AF_XDP 简介 AF_XDP是一种用于高性能包处理的地址簇(Address Family)。 使用XDP程序中的XDP_REDIRECT操作，可以使用bp"><meta itemprop=datePublished content="2022-06-04T10:26:13+08:00">
<meta itemprop=dateModified content="2022-06-04T10:26:13+08:00">
<meta itemprop=wordCount content="10949">
<meta itemprop=keywords content="linux,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="AF_XDP">
<meta name=twitter:description content="AF_XDP 简介 AF_XDP是一种用于高性能包处理的地址簇(Address Family)。 使用XDP程序中的XDP_REDIRECT操作，可以使用bp"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<script src=/js/fuse.min.js></script>
<script src=/js/fastsearch.js></script>
<div id=fastSearch>
<input id=searchInput tabindex=0>
<ul id=searchResults>
</ul>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=search-click class="menu-item-link menu-item-search" href=javascript:void(0)>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>AF_XDP</h1>
<div class=post-meta>
<time datetime=2022-06-04 class=post-time>
2022-06-04 10:26:13
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/linux/> linux </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#简介>简介</a>
<ul>
<li></li>
</ul>
</li>
<li><a href=#tchttpsdocsciliumioenlatestbpftc-traffic-control><a href=https://docs.cilium.io/en/latest/bpf/#tc-traffic-control>TC</a></a>
<ul>
<li><a href=#返回码>返回码</a></li>
<li><a href=#加载tc-bpf程序>加载tc BPF程序</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=af_xdp>AF_XDP</h1>
<h2 id=简介>简介</h2>
<p><strong>AF_XDP</strong>是一种用于高性能包处理的地址簇(Address Family)。</p>
<p>使用XDP程序中的<strong>XDP_REDIRECT</strong>操作，可以使用<code>bpf_redirect_map（）</code>函数将入口帧重定向到其他启用XDP的网络设备。 AF_XDP套接字使XDP程序可以将帧重定向到用户空间应用程序中的内存缓冲区。</p>
<p>可以通过<code>socket()</code>系统调用创建AF_XDP socket (XSK)。每个XSK涉及两个ring：RX ring和TX ring。一个socket可以从RX ring上接收报文，并发送到TX ring。这两个rings分别通过socket选项<code>XDP_RX_RING</code> 和<code>XDP_TX_RING</code>进行注册。每个socket必须至少具有其中一个ring。RX或TX ring描述符指向内存域中的data buffer，称为UMEM。RX和TX可以共享相同的UMEM，这样一个报文无需在RX和TX之间进行拷贝。此外，如果一个报文由于重传需要保留一段时间，则指向该报文的描述符可以指向另外一个报文，这样就避免了数据的拷贝。基本流程<a href=https://www.dpdk.org/wp-content/uploads/sites/35/2018/10/pm-06-DPDK-PMD-for-AF_XDP.pdf>如下</a>：</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-39-2020-09-30-17-18-13-image.png alt></p>
<p>UMEM包含一系列大小相同的chunks，ring中的描述符通过引用帧的地址来引用该帧，该地址为整个UMEM域的偏移量。用户空间会使用合适的方式(malloc，mmap，大页内存等)为UMEM分配内存，然后使用使用新的socket选项<code>XDP_UMEM_REG</code>将内存域注册到内核中。UMEM也包含两个ring：FILL ring和COMPLETION ring。应用会使用FILL ring下发addr，让内核填写RX包数据。一旦接收到报文，RX ring会引用这些帧。COMPLETION ring包含内核传输完的帧地址，且可以被用户空间使用，用于TX或RX。因此COMPLETION ring中的帧地址为先前使用TX ring传输的地址。总之，RX和FILL ring用于RX路径，TX和COMPLETION ring用于TX路径。</p>
<p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。</p>
<p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。</p>
<p>可以在多个进程间共享UMEM 。如果一个进程需要更新UMEM，则会跳过注册UMEM和其对应的两个ring的过程。在bind调用中设置<code>XDP_SHARED_UMEM</code> 标志，并提交该进程期望共享UMEM的XSK，以及新创建的XSK socket。新进程会在其共享UMEM的RX ring中接收到帧地址引用。注意，由于ring的结构是单生产者/单消费者的，新的进程的socket必须创建独立的RX和TX ring。同样的原因，每个UMEM也只能有一个FILL和COMPLETION ring。每个进程都需要正确地处理好UMEM。</p>
<p>那么报文是怎么从XDP程序分发到XSKs的呢？通过名为<code>XSKMAP</code>(完整名为BPF_MAP_TYPE_XSKMAP`) BPF map。用户空间的应用可以将一个XSK放到该map的任意位置，然后XDP程序就可以将一个报文重定向到该map中指定的索引中，此时XDP会校验map中的XSK确实绑定到该设备和ring号。如果没有，则会丢弃该报文。如果map中的索引为空，也会丢弃该报文。因此，当前的实现中强制要求必须加载一个XDP程序(以及保证XSKMAP存在一个XSK)，这样才能通过XSK将流量传送到用户空间。</p>
<p>AF_XDP可以运行在两种模式上：<code>XDP_SKB</code>和<code>XDP_DRV</code>。如果驱动不支持XDP，则在加载XDP程序是需要明确指定使用XDP_SKB，<code>XDP_SKB</code>模式使用SKB和通用的XDP功能，并将数据复制到用户空间，是一种适用于任何网络设备的回退模式。 如果驱动支持XDP，将使用AF_XDP代码提供更好的性能，但仍然会将数据拷贝到用户空间的操作。</p>
<h5 id=术语>术语</h5>
<h6 id=umem-umem是一个虚拟的连续内存域分割为相同大小的帧>UMEM: UMEM是一个虚拟的连续内存域，分割为相同大小的帧。</h6>
<p>一个UMEM会关联一个netdev以及该netdev的队列id。通过<code>XDP_UMEM_REG</code> socket选项进行创建和配置(chunk大小，headroom，开始地址和大小)。通过<code>bind()</code>系统调用将一个UMEM绑定到一个netdev和队列id。umem的基本结构如下：</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-49-1334952-20200807102005413-1869804955.png alt></p>
<p>一个AF_XDP为一个链接到一个独立的UMEM的socket，但一个UMEM可以有多个AF_XDP socket。为了共享一个通过socket A创建的UMEM，socket B可以将结构体<code>sockaddr_xdp</code>中的成员sxdp_flags设置为<code>XDP_SHARED_UMEM</code>，并将A的文件描述符传递给结构体<code>sockaddr_xdp</code>的成员<code>sxdp_shared_umem_fd</code>。</p>
<p>UMEM有两个单生产者/单消费者ring，用于在内核和用户空间应用程序之间转移UMEM帧。</p>
<h6 id=rings>Rings</h6>
<p>有4类不同类型的ring：FILL, COMPLETION, RX 和TX，所有的ring都是单生产者/单消费者，因此用户空间的程序需要显示地同步对这些rings进行读/写的多进程/线程。</p>
<p>UMEM使用2个ring：FILL和COMPLETION。每个关联到UMEM的socket必须有1个RX队列，1个TX队列或同时拥有2个队列。如果配置了4个socket(同时使用TX和RX)，那么此时会有1个FILL ring，1个COMPLETION ring，4个TX ring和4个RX ring。</p>
<p>ring是基于首(生产者)尾(消费者)的结构。一个生产者会在结构体xdp_ring的producer成员指出的ring索引处写入数据，并增加生产者索引；一个消费者会结构体xdp_ring的consumer成员指出的ring索引处读取数据，并增加消费者索引。</p>
<p>可以通过_RING setsockopt系统调用配置和创建ring，使用mmap()，并结合合适的偏移量，将其映射到用户空间</p>
<p>ring的大小需要是2次幂。</p>
<h6 id=umem-fill-ring>UMEM Fill Ring</h6>
<p>FILL ring用于将UMEM帧从用户空间传递到内核空间，同时将UMEM地址传递给ring。例如，如果UMEM的大小为64k，且每个chunk的大小为4k，那么UMEM包含16个chunk，可以传递的地址为0到64k。</p>
<p>传递给内核的帧用于ingress路径(RX rings)。</p>
<p>用户应用也会在该ring中生成UMEM地址。注意，如果以对齐的chunk模式运行应用，则内核会屏蔽传入的地址。即，如果一个chunk大小为2k，则会屏蔽掉log2(2048) LSB的地址，意味着2048, 2050 和3000都将引用相同的chunk。如果用户应用使用非对其的chunk模式运行，那么传入的地址将保持不变。</p>
<h6 id=umem-completion-ring>UMEM Completion Ring</h6>
<p>COMPLETION Ring用于将UMEM帧从内核空间传递到用户空间，与FILL ring相同，使用了UMEM索引。</p>
<p>已经发送的从内核空间传递到用户空间的帧还可以被用户空间使用。</p>
<p>用户应用会消费该ring种的UMEM地址。</p>
<h6 id=rx-ring>RX Ring</h6>
<p>RX ring位于socket的接收侧，ring中的每个表项都是一个<code>xdp_desc</code> 结构的描述符。该描述符包含UMEM偏移量(地址)以及数据的长度。</p>
<p>如果没有帧从FILL ring传递给内核，则RX ring中不会出现任何描述符。</p>
<p>用户程序会消费该ring中的<code>xdp_desc</code>描述符。</p>
<h6 id=tx-ring>TX Ring</h6>
<p>TX Ring用于发送帧。在填充<code>xdp_desc</code>(索引，长度和偏移量)描述符后传递给该ring。</p>
<p>如果要启动数据传输，则必须调用<code>sendmsg()</code>，未来可能会放宽这种限制。</p>
<p>用户程序会给TX ring生成<code>xdp_desc</code> 描述符。</p>
<h5 id=xskmap--bpf_map_type_xskmap>XSKMAP / BPF_MAP_TYPE_XSKMAP</h5>
<p>在XDP侧会用到类型为<code>BPF_MAP_TYPE_XSKMAP</code> 的BPF map，并结合<code>bpf_redirect_map()</code>将ingress帧传递给socket。</p>
<p>用户应用会通过<code>bpf()</code>系统调用将socket插入该map。</p>
<p>注意，如果一个XDP程序尝试将帧重定向到一个与队列配置和netdev不匹配的socket时，会丢弃该帧。即，如果一个AF_XDP socket绑定到一个名为eth0，队列为17的netdev上时，只有当XDP程序指定到eth0且队列为17时，才会将数据传递给该socket。参见<code>samples/bpf/</code>获取例子</p>
<h5 id=配置标志位和socket选项>配置标志位和socket选项</h5>
<h6 id=xdp_copy-和xdp_zero_copy-bind标志>XDP_COPY 和XDP_ZERO_COPY bind标志</h6>
<p>当绑定到一个socket时，内核会首先尝试使用零拷贝进行拷贝。如果不支持零拷贝，则会回退为使用拷贝模式。即，将所有的报文拷贝到用户空间。但如果想强制指定一种特定的模式，则可以使用如下标志：如果给bind调用传递了<code>XDP_COPY</code>，则内核将强制进入拷贝模式；如果没有使用拷贝模式，则bind调用会失败，并返回错误。相反地，<code>XDP_ZERO_COPY</code> 将强制socket使用零拷贝或调用失败。</p>
<h6 id=xdp_shared_umem-bind-标志>XDP_SHARED_UMEM bind 标志</h6>
<p>该表示可以使多个socket绑定到系统的UMEM，但仅能使用系统的队列id。这种模式下，每个socket都有其各自的RX和TX ring，但UMEM只能有一个FILL ring和一个COMPLETION ring。为了使用这种模式，需要创建第一个socket，并使用正常模式进行绑定。然后创建第二个socket，含一个RX和一个TX(或二者之一)，但不会创建FILL 或COMPLETION ring(与第一个socket共享)。在bind调用中，设置<code>XDP_SHARED_UMEM</code>选项，并在sxdp_shared_umem_fd中提供初始socket的fd。以此类推。</p>
<p>那么当接收到一个报文后，应该上送到那个socket呢？答案是由XDP程序来决定。将所有的socket放到XDP_MAP中，然后将报文发送给数组中索引对应的socket。下面展示了一个简单的以轮询方式分发报文的例子：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;linux/bpf.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&#34;bpf_helpers.h&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=cp>#define MAX_SOCKS 16
</span><span class=cp></span>
<span class=k>struct</span> <span class=p>{</span>
     <span class=n>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_XSKMAP</span><span class=p>);</span>
     <span class=n>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=n>MAX_SOCKS</span><span class=p>);</span>
     <span class=n>__uint</span><span class=p>(</span><span class=n>key_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
     <span class=n>__uint</span><span class=p>(</span><span class=n>value_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
<span class=p>}</span> <span class=n>xsks_map</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>

<span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>rr</span><span class=p>;</span>

<span class=n>SEC</span><span class=p>(</span><span class=s>&#34;xdp_sock&#34;</span><span class=p>)</span> <span class=kt>int</span> <span class=n>xdp_sock_prog</span><span class=p>(</span><span class=k>struct</span> <span class=n>xdp_md</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span>
<span class=p>{</span>
     <span class=n>rr</span> <span class=o>=</span> <span class=p>(</span><span class=n>rr</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>MAX_SOCKS</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>

     <span class=k>return</span> <span class=nf>bpf_redirect_map</span><span class=p>(</span><span class=o>&amp;</span><span class=n>xsks_map</span><span class=p>,</span> <span class=n>rr</span><span class=p>,</span> <span class=n>XDP_DROP</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，由于只有一个FILL和一个COMPLETION ring，且是单生产者单消费者的ring，需要确保多处理器或多线程不会同时使用这些ring。libbpf没有提供原子同步功能。</p>
<p>当多个socket绑定到相同的umem时，libbpf会使用这种模式。然而，需要注意的是，需要在<code>xsk_socket__create</code>调用中提供<code>XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD</code> libbpf_flag，然后将其加载到自己的XDP程序中(因为libbpf没有内置路由流量功能)。</p>
<h6 id=xdp_use_need_wakeup-bind标志>XDP_USE_NEED_WAKEUP bind标志</h6>
<p>该选择支持在FILL ring和TX ring中设置一个名为<code>need_wakeup</code>的标志，用户空间作为这些ring的生产者。当在bind调用中设置了该选项，如果需要明确地通过系统调用唤醒内核来继续处理报文时，会设置<code>need_wakeup</code> 标志。</p>
<p>如果将该标志设置给FILL ring，则应用需要调用<code>poll()</code>，以便在RX ring上继续接收报文。如，当内核检测到FILL ring中没有足够的buff，且NIC的RX HW RING中也没有足够的buffer时会发生这种情况。此时会关中断，这样NIC就无法接收到任何报文(由于没有足够的buffer)，由于设置了need_wakeup，这样用户空间就可以在FILL ring上增加buffer，然后调用<code>poll()</code>，这样内核驱动就可以将这些buffer添加到HW ring上继续接收报文。</p>
<p>如果将该标志设置给TX ring，意味着应用需要明确地通知内核发送位于TX ring上的报文。可以通过调用<code>poll()</code>，或调用<code>sendto()</code>完成。</p>
<p>可以在<em>samples/bpf/xdpsock_user.c</em>中找到例子。在TX路径上使用libbpf辅助函数的例子如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>if</span> <span class=p>(</span><span class=n>xsk_ring_prod__needs_wakeup</span><span class=p>(</span><span class=o>&amp;</span><span class=n>my_tx_ring</span><span class=p>))</span>
   <span class=n>sendto</span><span class=p>(</span><span class=n>xsk_socket__fd</span><span class=p>(</span><span class=n>xsk_handle</span><span class=p>),</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MSG_DONTWAIT</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>建议启用该模式，由于减少了TX路径上的系统调用的数目，因此可以在应用和驱动运行在同一个(或不同)core的情况下提升性能。</p>
<h6 id=xdp_rxtxumem_fillumem_completion_ring-setsockopts>XDP_{RX|TX|UMEM_FILL|UMEM_COMPLETION}_RING setsockopts</h6>
<p>这些socket选项分别设置RX, TX, FILL和COMPLETION ring的描述符数量(必须至少设置RX或TX ring的描述符大小)。如果同时设置了RX和TX，就可以同时接收和发送来自应用的流量；如果仅设置了其中一个，就可以节省相应的资源。如果需要将一个UMEM绑定到socket，需要同时设置FILL ring和COMPLETION ring。如果使用了<code>XDP_SHARED_UMEM</code>标志，无需为除第一个socket之外的socket创建单独的UMEM，所有的socket将使用共享的UMEM。注意ring为单生产者单消费者结构，因此多进程无法同时访问同一个ring。参见<code>XDP_SHARED_UMEM</code>章节。</p>
<p>使用libbpf时，可以通过给<code>xsk_socket__create</code>函数的rx和tx参数设置NULL来创建Rx-only和Tx-only的socket。</p>
<p>如果创建了一个Tx-only的socket，建议不要在FILL ring中放入任何报文，否则，驱动可能会认为需要接收数据(但实际上并不是这样的)，进而影响性能。</p>
<h6 id=xdp_umem_reg-setsockopt>XDP_UMEM_REG setsockopt</h6>
<p>该socket选项会给一个socket注册一个UMEM，其对应的区域包含了可以容纳报文的buffer。该调用会使用一个指向该区域开始处的指针，以及该区域的大小。此外，还有一个UMEM可以切分的chunk大小参数(目前仅支持2K或4K)。如果一个UMEM区域的大小为128K，且chunk大小为2K，意味着该UMEM域最大可以有128K / 2K = 64个报文，且最大的报文大小为2K。</p>
<p>还有一个选项可以在UMEM中设置每个buffer的headroom。如果设置为N字节，意味着报文会从buffer的第N个字节开始，为应用保留前N个字节。最后一个选项为标志位字段，会在每个UMEM标志中单独处理。</p>
<h6 id=xdp_statistics-getsockopt>XDP_STATISTICS getsockopt</h6>
<p>获取一个socket丢弃信息，用于调试。支持的信息为：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>xdp_statistics</span> <span class=p>{</span>
       <span class=n>__u64</span> <span class=n>rx_dropped</span><span class=p>;</span> <span class=cm>/* Dropped for reasons other than invalid desc */</span>
       <span class=n>__u64</span> <span class=n>rx_invalid_descs</span><span class=p>;</span> <span class=cm>/* Dropped due to invalid descriptor */</span>
       <span class=n>__u64</span> <span class=n>tx_invalid_descs</span><span class=p>;</span> <span class=cm>/* Dropped due to invalid descriptor */</span>
<span class=p>};</span>
</code></pre></td></tr></table>
</div>
</div><h6 id=xdp_options-getsockopt>XDP_OPTIONS getsockopt</h6>
<p>获取一个XDP socket的选项。目前仅支持<code>XDP_OPTIONS_ZEROCOPY</code>，用于检查是否使用了零拷贝。</p>
<blockquote>
<p>从AF_XDP的特性上可以看到其<a href=https://pantheon.tech/what-is-af_xdp/>局限性</a>：不能使用XDP将不同的流量重定向的多个AF_XDP socket上，原因是每个AF_XDP socket必须绑定到物理接口的TX队列上。大多数的物理和仿真HW的每个接口仅支持一个RX/TX队列，因此当该接口上绑定了一个AF_XDP后，后续的绑定操作都将失败。仅有少数HW支持多RX/TX队列，且通常仅有2/4/8个队列，无法扩展给cloud中的上百个容器使用。</p>
</blockquote>
<p>更多细节参见AF_XDP<a href=https://www.kernel.org/doc/html/latest/networking/af_xdp.html>官方文档</a>以及这篇<a href=http://vger.kernel.org/lpc_net2018_talks/lpc18_paper_af_xdp_perf-v2.pdf>论文</a>。</p>
<h2 id=tchttpsdocsciliumioenlatestbpftc-traffic-control><a href=https://docs.cilium.io/en/latest/bpf/#tc-traffic-control>TC</a></h2>
<p>除了XDP，BPF还可以在网络数据路径的内核tc(traffic control)层之外使用。上文已经给出了XDP和TC的区别。</p>
<blockquote>
<ul>
<li><code>ingress</code> hook：<code>__netif_receive_skb_core() -> sch_handle_ingress()</code></li>
<li><code>egress</code> hook：<code>__dev_queue_xmit() -> sch_handle_egress()</code></li>
</ul>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-12-21-1334952-20200809204246404-1470995812.png alt></p>
</blockquote>
<p>运行在tc层的BPF程序使用的是 <code>cls_bpf</code> (cls即Classifiers的简称)分类器。在tc中，将BPF的附着点描述为一个"分类器"，这个词有点误导，因此它少描述了<code>cls_bpf</code>的所支持的功能。即一个完整的可编程的报文处理器不仅可以读取<code>skb</code>的元数据和报文数据，还可以对其进行任意修改，最后终止tc的处理，并返回裁定的action(见下)。<code>cls_bpf</code>可以认为是一个自包含的，可以管理和执行tc BPF程序的实体。</p>
<p><code>cls_bpf</code>可以包含一个或多个tc BPF程序。通常，在传统的tc方案中，分类器和action模块是分开的，每个分类器可以附加一个或多个action，一旦匹配到分类器时就会执行action。但在现代软件数据路径中使用这种模式的tc处理复杂的报文时会遇到扩展性问题。由于附加到cls_bpf的tc BPF程序是完全自包含的，因此可以有效地将解析和操作过程融合到一个单元中。幸好有了<code>cls_bpf</code>的<code>direct-action</code>模式，该模式下，仅需要返回tc action裁定结果并立即结束处理流即可，可以在网络数据流中实现可扩展的可编程报文处理流程，同时避免了action的线性迭代。<code>cls_bpf</code>是tc层中唯一能够实现这种快速路径的“分类器”模块。</p>
<p>与XDP BPF程序类似，tc BPF程序可以在运行时通过cls_bpf自动更新，而不会中断任何网络流或重启服务。</p>
<p><code>cls_bpf</code>可以附加的tc ingress和egree钩子都通过一个名为<code>sch_clsact</code>的伪qdisc进行管理。由于该伪qdisc可以同时管理ingress和egress的tc钩子，因此它是ingress qdisc的超集(也可直接替换)。对于<code>__dev_queue_xmit()</code>中的tc的egress钩子，需要注意的是，它不是在内核的qdisc root锁下运行的。因此，tc ingress和egress钩子都以无锁的方式运行在快速路径中，且这两个钩子都禁用了抢占，并运行在RCU读取侧。</p>
<p>通常在egress上会存在附着到网络设备上的qdisc，如<code>sch_mq</code>，<code>sch_fq</code>，<code>sch_fq_codel</code>或<code>sch_htb</code>，其中有些是可分类的qdisc(包含子类)，因此会要求一个报文分类机制来决定在哪里解复用数据包。该过程通过调用<code>tcf_classify()</code>进行处理，进而调用tc分类器(如果存在)。<code>cls_bpf</code>也可以附加并用于如下场景：一些在qdisc root锁下的操作可能会收到锁竞争的影响。<code>sch_clsact</code> qdisc的egress钩子出现在更早的时间点，但它不属于这个锁的范围，因此作完全独立于常规的egress qdiscs。因此，对于<code>sch_htb</code>这样的情况，<code>sch_clsact</code> qdisc可以通过qdisc root锁之外的tc BPF执行繁重的包分类工作，通过在这些 tc BPF 程序中设置 <code>skb->mark</code> 或 <code>skb->priority</code> ，这样 <code>sch_htb</code> 只需要一个简单的映射即可，不需要在root锁下执行代价高昂的报文分类工作，通过这种方式可以减少锁竞争。</p>
<p>在sch_clsact结合cls_bpf的场景下支持offloaded tc BPF程序，这种情况下，先前加载的BPF程序是从SmartNIC驱动程序jit生成的，以便在NIC上以本机方式运行。只有在<code>direct-action</code>模式下运行的<code>cls_bpf</code>程序才支持offloaded。<code>cls_bpf</code>仅支持offload一个单独的程序(无法offload多个程序)，且只有ingress支持offload BPF程序。</p>
<p>一个<code>cls_bpf</code>实例可以包含多个tc BPF程序，如果是这种情况，那么<code>TC_ACT_UNSPEC</code>程序返回码可以继续执行列表中的下一个tc BPF程序。然而，这样做的缺点是，多个程序需要多次解析相同的报文，导致性能下降。</p>
<h3 id=返回码>返回码</h3>
<p>tc的ingress和egress钩子共享相同的action来返回tc BPF程序使用的裁定结果，定义在 <code>linux/pkt_cls.h</code>系统头文件中：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#define TC_ACT_UNSPEC         (-1)
</span><span class=cp>#define TC_ACT_OK               0
</span><span class=cp>#define TC_ACT_SHOT             2
</span><span class=cp>#define TC_ACT_STOLEN           4
</span><span class=cp>#define TC_ACT_REDIRECT         7
</span></code></pre></td></tr></table>
</div>
</div><p>系统头文件中还有一些以<code>TC_ACT_*</code>开头的action变量，可以被两个钩子使用。但它们与上面的语义相同。即，从tc BPF的角度来看<code>TC_ACT_OK</code>和<code>TC_ACT_RECLASSIFY</code>的语义相同，三个<code>TC_ACT_stelled</code>、<code>TC_ACT_QUEUED</code>和<code>TC_ACT_TRAP</code>操作码的语义也是相同的。因此，对于这些情况，我们只描述 <code>TC_ACT_OK</code> 和 <code>TC_ACT_STOLEN</code> 操作码。</p>
<p>从<code>TC_ACT_UNSPEC</code>开始，表示"未指定的action"，用于以下三种场景：i)当一个offloaded tc程序的tc ingress钩子运行在<code>cls_bpf</code>的位置，则该offloaded程序将返回<code>TC_ACT_UNSPEC</code>；ii)为了在多程序场景下继续执行<code>cls_bpf</code>中的下一个BPF程序，后续的程序需要与步骤i中的offloaded tc BPF程序配合使用，但出现了一个非offloaded场景下运行的tc BPF程序；iii)<code>TC_ACT_UNSPEC</code>还可以用于单个程序场景，用于告诉内核继续使用skb，不会产生其他副作用。<code>TC_ACT_UNSPEC</code>与<code>TC_ACT_OK</code>类似，两者都会将skb通过ingress向上传递到网络栈的上层，或者通过egress向下传递到网络设备驱动程序，以便在egress进行传输。与<code>TC_ACT_OK</code>的唯一不同之处是，<code>TC_ACT_OK</code>基于tc BPF程序设定的classid来设置<code>skb->tc_index</code>，而 <code>TC_ACT_UNSPEC</code> 是通过 tc BPF 程序之外的 BPF上下文中的 <code>skb->tc_classid</code> 进行设置。</p>
<p><code>TC_ACT_SHOT</code>通知内核丢弃报文，即网络栈上层将不会在ingress的skb中看到该报文，类似地，这类报文也不会在egress中发送。<code>TC_ACT_SHOT</code>和<code>TC_ACT_STOLEN</code>本质上是相似的，仅存在部分差异：<code>TC_ACT_SHOT</code>会通知内核已经通过<code>kfree_skb()</code>释放skb，且会立即给调用者返回<code>NET_XMIT_DROP</code>；而TC_ACT_STOLEN会通过<code>consume_skb()</code>释放skb,并给上层返回<code>NET_XMIT_SUCCESS</code>，假装传输成功。perf的报文丢弃监控会记录<code>kfree_skb()</code>的操作，因此不会记录任何因为<code>TC_ACT_STOLEN</code>丢弃的报文，因为从语义上说，这些 <code>skb</code> 是被消费或排队的而不是被丢弃的。</p>
<p>最后<code>TC_ACT_REDIRECT</code> action允许tc BPF程序通过<code>bpf_redirect()</code>辅助函数将skb重定向到相同或不同的设备ingress或egress路径上。通过将报文导入其他设备的ingress或egress方向，可以最大化地实现BPF的报文转发功能。使用该方式不需要对目标网络设备做任何更改，也不需要在目标设备上运行另外一个<code>cls_bpf</code>实例。</p>
<h3 id=加载tc-bpf程序>加载tc BPF程序</h3>
<p>假设有一个名为<code>prog.o</code>的tc BPF程序，可以通过tc命令将该程序加载到网络设备山。与XDP不同，它不需要依赖驱动将BPF程序附加到设备上，下面会用到一个名为<code>em1</code>的网络设备，并将程序附加到<code>em1</code>的<code>ingress</code>报文路径上。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc qdisc add dev em1 clsact</span>
<span class=c1># tc filter add dev em1 ingress bpf da obj prog.o</span>
</code></pre></td></tr></table>
</div>
</div><p>第一步首先配置一个<code>clsact</code> qdisc。如上文所述，clsact是一个伪造的qdisc，与<code>ingress</code> qdisc类似，仅包含分类器和action，但不会提供实际的队列功能，它是附加bpf分类器所必需的。<code>clsact</code> 提供了两个特殊的钩子，称为<code>ingress</code>和<code>egress</code>，分类器可以附加到这两个钩子上。<code>ingress</code>和<code>egress</code>钩子都位于网络数据路径的中央接收和发送位置，每个经过设备的报文都会经过此处。<code>ingees</code>钩子通过内核的<code>__netif_receive_skb_core() -> sch_handle_ingress()</code>进行调用，<code>egress</code>钩子通过<code>__dev_queue_xmit() -> sch_handle_egress()</code>进行调用。</p>
<p>将程序附加到<code>egress</code>钩子上的操作为：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc filter add dev em1 egress bpf da obj prog.o</span>
</code></pre></td></tr></table>
</div>
</div><p><code>clsact</code> qdisc以无锁的方式处理来自<code>ingress</code>和<code>egress</code>方向的报文，且可以附加到一个无队列虚拟设备上，如连接到容器的<code>veth</code>设备。</p>
<p>在钩子之后，<code>tc filter</code>命令选择使用<code>bpf</code>的<code>da</code>(direct-action)模式。推荐使用并指定da<code>模式</code>，基本上意味着bpf分类器不再需要调用外部tc action模块，所有报文的修改，转发或其他action都可以通过附加的BPF程序来实现，因此处理速度更快。</p>
<p>到此位置，已经附加bpf程序，一旦有报文传输到该设备后就会执行该程序。与XDP相同，如果不使用默认的section名称，则可以在加载期间进行指定，例如，下面指定的section名为<code>foobar</code>：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc filter add dev em1 egress bpf da obj prog.o sec foobar</span>
</code></pre></td></tr></table>
</div>
</div><p>iptables2的BPF加载器允许跨程序类型使用相同的命令行语法。</p>
<p>附加的程序可以使用如下命令列出：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc filter show dev em1 ingress</span>
filter protocol all pref <span class=m>49152</span> bpf
filter protocol all pref <span class=m>49152</span> bpf handle 0x1 prog.o:<span class=o>[</span>ingress<span class=o>]</span> direct-action id <span class=m>1</span> tag c5f7825e5dac396f

<span class=c1># tc filter show dev em1 egress</span>
filter protocol all pref <span class=m>49152</span> bpf
filter protocol all pref <span class=m>49152</span> bpf handle 0x1 prog.o:<span class=o>[</span>egress<span class=o>]</span> direct-action id <span class=m>2</span> tag b2fd5adc0f262714
</code></pre></td></tr></table>
</div>
</div><p><code>prog.o:[ingress]</code>的输出说明程序段<code>ingress</code>通过文件<code>prog.o</code>进行加载，且<code>bpf</code>运行在<code>direct-action</code>模式下。上面两种情况附加了程序<code>id</code>和<code>tag</code>，其中后者表示对指令流的hash，该hash可以与目标文件或带有堆栈跟踪的perf report等相关。最后，<code>id</code>表示系统范围内的BPF程序的唯一标识符，可以使用<code>bpftool</code>来查看或dump附加的BPF程序。</p>
<p>tc可以附加多个BPF程序，它提供了其他可以链接在一起的分类器。但附加一个BPF程序已经可以完全满足需求，因为通过<code>da</code>(<code>direct-action</code>)模式可以在一个程序中实现所有的报文操作，意味着BPF程序将返回tc action裁定结果，如<code>TC_ACT_OK</code>, <code>TC_ACT_SHOT</code>等。为了获得最佳性能和灵活性，推荐使用这种方式。</p>
<p>在上述<code>show</code>命令中，在BPF的相关输出旁显示了<code>pref 49152</code> 和<code>handle 0x1</code>。如果没有通过命令行显式地提供，会自动生成的这两个输出。<code>perf</code>表明了一个优先级数字，即当附加了多个分类器时，将会按照优先级上升的顺序执行这些分类器。<code>handle</code>表示一个标识符，当一个<code>perf</code>加载了系统分类器的多个实例时起作用。由于在BPF场景下，一个程序足矣，<code>perf</code>和<code>handle</code>通常可以忽略。</p>
<p>只有在需要自动替换附加的BPF程序的情况下，才会推荐在初始化加载前指定<code>pref</code>和<code>handle</code>，这样在以后执行<code>replace</code>操作时就不必在进行查询。创建方式如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span>

<span class=c1># tc filter show dev em1 ingress</span>
filter protocol all pref <span class=m>1</span> bpf
filter protocol all pref <span class=m>1</span> bpf handle 0x1 prog.o:<span class=o>[</span>foobar<span class=o>]</span> direct-action id <span class=m>1</span> tag c5f7825e5dac396f
</code></pre></td></tr></table>
</div>
</div><p>对于原子替换，可以使用(来自文件<code>prog.o</code>中的<code>foobar</code> section的BPF程序)如下命令来更新现有的<code>ingress</code>钩子上的程序</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span>
</code></pre></td></tr></table>
</div>
</div><p>最后，为了移除所有ingress和egress上附加的程序，可以使用如下命令：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc filter del dev em1 ingress</span>
<span class=c1># tc filter del dev em1 egress</span>
</code></pre></td></tr></table>
</div>
</div><p>为了移除网络设备上的整个<code>clsact</code> qdisc，即移除掉ingress和egress钩子上附加的所有程序，可以使用如下命令：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc qdisc del dev em1 clsact</span>
</code></pre></td></tr></table>
</div>
</div><p>如果NIC和驱动也像XDP BPF程序一样支持offloaded，则tc BPF程序也可以是offloaded的。Netronome的nfp同时支持两种类型的BPF offload。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># tc qdisc add dev em1 clsact</span>
<span class=c1># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span>
Error: TC offload is disabled on net device.
We have an error talking to the kernel
</code></pre></td></tr></table>
</div>
</div><p>如果出现了如上错误，则表示首先需要通过ethtool的<code>hw-tc-offload</code>来启动tc硬件offload：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># ethtool -K em1 hw-tc-offload on</span>
<span class=c1># tc qdisc add dev em1 clsact</span>
<span class=c1># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span>
<span class=c1># tc filter show dev em1 ingress</span>
filter protocol all pref <span class=m>1</span> bpf
filter protocol all pref <span class=m>1</span> bpf handle 0x1 prog.o:<span class=o>[</span>classifier<span class=o>]</span> direct-action skip_sw in_hw id <span class=m>19</span> tag 57cd311f2e27366b
</code></pre></td></tr></table>
</div>
</div><p><code>in_hw</code>标志表示程序已经offload到了NIC中。</p>
<p>注意不能同时offload tc和XDP BPF，必须且只能选择其中之一。</p>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2022-06-04 10:26:13
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/alipay_reward_qrcode.png>
<span>支付宝打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/bitcoin_reward_qrcode.png>
<span>比特币打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/linux/>linux</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/13.algorithm/kademlia%E7%AE%97%E6%B3%95/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">Kademlia算法</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/21.linux/ebpf%E7%AE%80%E5%8F%B2/>
<span class="next-text nav-default">eBPF简史(转)</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2024
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
</body>
</html>