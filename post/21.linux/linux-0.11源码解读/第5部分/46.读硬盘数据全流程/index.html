<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>46.读硬盘数据全流程 - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=referrer content="no-referrer">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="46.读硬盘数据全流程 新建一个非常简单的 info.txt 文件。 1 2 3 4 5 $ cat &amp;gt; info.txt &amp;lt;&amp;lt;EOF name:flash age:28 language:java EOF 在命令行输入一条十分简单的命令。 1 2 [root@linux0.11] cat info.txt | wc -l 3 这条命令的意思">
<meta name=keywords content="tech,it,blog">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/21.linux/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/46.%E8%AF%BB%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.34a0cf3583dc0fd6b4e3fe24a36c076984feee75ebc2792cff33928ccdcfc628.css integrity="sha256-NKDPNYPcD9a04/4ko2wHaYT+7nXrwnks/zOSjM3Pxig=" media=screen crossorigin=anonymous>
<meta property="og:title" content="46.读硬盘数据全流程">
<meta property="og:description" content="46.读硬盘数据全流程 新建一个非常简单的 info.txt 文件。 1 2 3 4 5 $ cat > info.txt <<EOF name:flash age:28 language:java EOF 在命令行输入一条十分简单的命令。 1 2 [root@linux0.11] cat info.txt | wc -l 3 这条命令的意思">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/21.linux/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/46.%E8%AF%BB%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2024-01-08T06:47:33+08:00">
<meta property="article:modified_time" content="2024-01-08T06:47:33+08:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="46.读硬盘数据全流程">
<meta itemprop=description content="46.读硬盘数据全流程 新建一个非常简单的 info.txt 文件。 1 2 3 4 5 $ cat > info.txt <<EOF name:flash age:28 language:java EOF 在命令行输入一条十分简单的命令。 1 2 [root@linux0.11] cat info.txt | wc -l 3 这条命令的意思"><meta itemprop=datePublished content="2024-01-08T06:47:33+08:00">
<meta itemprop=dateModified content="2024-01-08T06:47:33+08:00">
<meta itemprop=wordCount content="4517">
<meta itemprop=keywords content="linux,linux-0.11源码解读,第5部分,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="46.读硬盘数据全流程">
<meta name=twitter:description content="46.读硬盘数据全流程 新建一个非常简单的 info.txt 文件。 1 2 3 4 5 $ cat > info.txt <<EOF name:flash age:28 language:java EOF 在命令行输入一条十分简单的命令。 1 2 [root@linux0.11] cat info.txt | wc -l 3 这条命令的意思"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<script src=/js/fuse.min.js></script>
<script src=/js/fastsearch.js></script>
<div id=fastSearch>
<input id=searchInput tabindex=0>
<ul id=searchResults>
</ul>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=search-click class="menu-item-link menu-item-search" href=javascript:void(0)>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>46.读硬盘数据全流程</h1>
<div class=post-meta>
<time datetime=2024-01-08 class=post-time>
2024-01-08 06:47:33
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/linux/> linux </a>
<a href=https://justice.bj.cn/categories/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/> linux-0.11源码解读 </a>
<a href=https://justice.bj.cn/categories/%E7%AC%AC5%E9%83%A8%E5%88%86/> 第5部分 </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#如果让你来设计这个函数>如果让你来设计这个函数</a></li>
<li><a href=#鸟瞰操作系统的读操作函数>鸟瞰操作系统的读操作函数</a></li>
<li><a href=#对-buf-区域的内存做校验-verify_area>对 buf 区域的内存做校验 verify_area</a></li>
<li><a href=#执行读操作-file_read>执行读操作 file_read</a></li>
<li><a href=#bmap获取全局的数据块号>bmap：获取全局的数据块号</a></li>
<li><a href=#bread将-bmap-获取的数据块号读入到高速缓冲块>bread：将 bmap 获取的数据块号读入到高速缓冲块</a></li>
<li><a href=#put_fs_byte将-bread-读入的缓冲块数据复制到用户指定的内存中>put_fs_byte：将 bread 读入的缓冲块数据复制到用户指定的内存中</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=46读硬盘数据全流程>46.读硬盘数据全流程</h1>
<p>新建一个非常简单的 info.txt 文件。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>$ cat &gt; info.txt <span class=s>&lt;&lt;EOF
</span><span class=s>name:flash
</span><span class=s>age:28
</span><span class=s>language:java
</span><span class=s>EOF</span>
</code></pre></td></tr></table>
</div>
</div><p>在命令行输入一条十分简单的命令。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=o>[</span>root@linux0.11<span class=o>]</span> cat info.txt <span class=p>|</span> wc -l
<span class=m>3</span>
</code></pre></td></tr></table>
</div>
</div><p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。 </p>
<p>上一回中，我们解释了 shell 程序是如何解释并执行我们输入的命令的，并展开讲解了管道类型命令的原理。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-50-188fd39bdd00c17dae4aa3a6d857a626.png alt=图片></p>
<p>同时也说了，在 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502475&idx=1&sn=4fcdbaa03bf6a1ca04db4013309c6aa3&chksm=c2c5b026f5b2393049efca68c429df5038fa0f317eea79fbd9ec2c661c3ec12b47a0701376a7&scene=21#wechat_redirect">第35回 | execve 加载并执行 shell 程序</a> 和 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502511&idx=1&sn=eacddbb11dd2402c561a611f708ee045&chksm=c2c5b002f5b23914ccd645d94bdc59e0322776f71f41e6744fddeca2bfa027d12a25ec6bfc8a&scene=21#wechat_redirect">第36回 | 缺页中断</a>，我们已经讲过如何通过 execve 加载并执行 shell 程序，但略过了将数据从硬盘加载到内存的逻辑细节。</p>
<p>那我们这一讲就把它扒开来看看。</p>
<p>将硬盘中的数据读入内存，听起来是个很简单的事情，但操作系统要考虑的问题很多。</p>
<h2 id=如果让你来设计这个函数>如果让你来设计这个函数</h2>
<p>我们先别急，一点点来，想想看，如果让你设计这个函数，你会怎么设计呢？</p>
<p>首先我们知道，通过 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502181&idx=1&sn=b6dcbd1d2cf930002852008a1c4e6a65&chksm=c2c5b3c8f5b23ade1532b725995dbc3b0138202555e44a6e308b84d668a2ef3041eb5cf77f86&scene=21#wechat_redirect">第32回 | 加载根文件系统</a> 中文件系统的建设。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-45-1799e829d1f383f3fdb3ff4711e5d5b7.png alt=图片></p>
<p>以及 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502230&idx=1&sn=44e023bf0b9b37261e35a6e3722bc57f&chksm=c2c5b33bf5b23a2d10a9dd36606c497f41a1c3dced57845ce7ef12741a348fab82beba462a8a&scene=21#wechat_redirect">第33回 | 打开终端设备文件</a> 讲解的打开一个文件的操作。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-39-8c5ed791084e164e6eb5f0dccbb6a7fc.png alt=图片></p>
<p>我们已经可以很方便地通过一个<strong>文件描述符 fd</strong>，寻找到存储在硬盘中的一个文件了，再具体点就是知道这个文件在硬盘中的哪几个扇区中。</p>
<p>所以，设计这个函数第一个要指定的参数就可以是 fd 了，它仅仅是个数字。当然，之所以能这样方便，就要感谢刚刚说的<strong>文件系统建设</strong>以及<strong>打开文件的逻辑</strong>这两项工作。</p>
<p>之后，我们得告诉这个函数，把这个 fd 指向的硬盘中的文件，复制到内存中的<strong>哪个位置</strong>，<strong>复制多大</strong>。</p>
<p>那更简单了，内存中的位置，我们用一个表示地址值的参数 <strong>buf</strong>，复制多大，我们用 <strong>count</strong> 来表示，单位是字节。</p>
<p>那这个函数就可以设计为。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>sys_read</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>    
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>是不是合情合理，无法反驳。</p>
<h2 id=鸟瞰操作系统的读操作函数>鸟瞰操作系统的读操作函数</h2>
<p>实际上，你刚刚设计出来的读操作函数，这正是 Linux 0.11 读操作的系统调用入口函数，在 read_write.c 这个文件里。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// read_write.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>sys_read</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>    
    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>file</span><span class=p>;</span>    
    <span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>;</span>    
    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span><span class=o>&gt;=</span><span class=n>NR_OPEN</span> <span class=o>||</span> <span class=n>count</span><span class=o>&lt;</span><span class=mi>0</span> <span class=o>||</span> <span class=o>!</span><span class=p>(</span><span class=n>file</span><span class=o>=</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>filp</span><span class=p>[</span><span class=n>fd</span><span class=p>]))</span>        
        <span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>    
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>count</span><span class=p>)</span>        
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>    
    <span class=n>verify_area</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>    
    <span class=n>inode</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>f_inode</span><span class=p>;</span>    
    <span class=k>if</span> <span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_pipe</span><span class=p>)</span>        
        <span class=k>return</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_mode</span><span class=o>&amp;</span><span class=mi>1</span><span class=p>)</span><span class=o>?</span><span class=n>read_pipe</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>)</span><span class=o>:-</span><span class=n>EIO</span><span class=p>;</span>    
    <span class=k>if</span> <span class=p>(</span><span class=n>S_ISCHR</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>))</span>        
        <span class=k>return</span> <span class=n>rw_char</span><span class=p>(</span><span class=n>READ</span><span class=p>,</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>,</span><span class=o>&amp;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>);</span>    
    <span class=k>if</span> <span class=p>(</span><span class=n>S_ISBLK</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>))</span>        
        <span class=k>return</span> <span class=n>block_read</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=o>&amp;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>    
    <span class=k>if</span> <span class=p>(</span><span class=n>S_ISDIR</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>)</span> <span class=o>||</span> <span class=n>S_ISREG</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>))</span> <span class=p>{</span>        
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=o>+</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span> <span class=o>&gt;</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_size</span><span class=p>)</span>            
            <span class=n>count</span> <span class=o>=</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_size</span> <span class=o>-</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>;</span>        
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=o>&lt;=</span><span class=mi>0</span><span class=p>)</span>            
            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>        
        <span class=k>return</span> <span class=n>file_read</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span><span class=n>file</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>    
    <span class=p>}</span>    
    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;(Read)inode-&gt;i_mode=%06o</span><span class=se>\n\r</span><span class=s>&#34;</span><span class=p>,</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>);</span>    
    <span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>那我们就分析这个函数就好了。</p>
<p>不过首先我先简化一下，去掉一些错误校验逻辑等旁路分支，并添加上注释。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// read_write.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>sys_read</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>    
    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>file</span> <span class=o>=</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>filp</span><span class=p>[</span><span class=n>fd</span><span class=p>];</span>    
    <span class=c1>// 校验 buf 区域的内存限制    
</span><span class=c1></span>    <span class=n>verify_area</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>    
    <span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>f_inode</span><span class=p>;</span>    
    <span class=c1>// 管道文件    
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_pipe</span><span class=p>)</span>        
        <span class=k>return</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_mode</span><span class=o>&amp;</span><span class=mi>1</span><span class=p>)</span><span class=o>?</span><span class=n>read_pipe</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>)</span><span class=o>:-</span><span class=n>EIO</span><span class=p>;</span>    
    <span class=c1>// 字符设备文件    
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>S_ISCHR</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>))</span>        
        <span class=k>return</span> <span class=n>rw_char</span><span class=p>(</span><span class=n>READ</span><span class=p>,</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>,</span><span class=o>&amp;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>);</span>    
    <span class=c1>// 块设备文件    
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>S_ISBLK</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>))</span>        
        <span class=k>return</span> <span class=n>block_read</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=o>&amp;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>    
    <span class=c1>// 目录文件或普通文件    
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>S_ISDIR</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>)</span> <span class=o>||</span> <span class=n>S_ISREG</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>))</span> <span class=p>{</span>        
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=o>+</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span> <span class=o>&gt;</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_size</span><span class=p>)</span>            
            <span class=n>count</span> <span class=o>=</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_size</span> <span class=o>-</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>;</span>        
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=o>&lt;=</span><span class=mi>0</span><span class=p>)</span>            
            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>        
        <span class=k>return</span> <span class=n>file_read</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span><span class=n>file</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>    
    <span class=p>}</span>    
    <span class=c1>// 不是以上几种，就报错    
</span><span class=c1></span>    <span class=n>printk</span><span class=p>(</span><span class=s>&#34;(Read)inode-&gt;i_mode=%06o</span><span class=se>\n\r</span><span class=s>&#34;</span><span class=p>,</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mode</span><span class=p>);</span>    
    <span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，整个的逻辑就非常清晰了。</p>
<p>由此也可以注意到，操作系统源码的设计比我刚刚说的更通用，我刚刚只让你设计了读取硬盘的函数，但其实在 Linux 下一切皆文件，所以这个函数将<strong>管道文件、字符设备文件、块设备文件、目录文件、普通文件</strong>分别指向了不同的具体实现。</p>
<p>那我们今天仅仅关注最常用的，读取目录文件或普通文件，并且不考虑读取的字节数大于文件本身大小这种不合理情况。</p>
<p>再简化下代码。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// read_write.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>sys_read</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>    
    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>file</span> <span class=o>=</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>filp</span><span class=p>[</span><span class=n>fd</span><span class=p>];</span>    
    <span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>f_inode</span><span class=p>;</span>    
    <span class=c1>// 校验 buf 区域的内存限制    
</span><span class=c1></span>    <span class=n>verify_area</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>    
    <span class=c1>// 仅关注目录文件或普通文件    
</span><span class=c1></span>    <span class=k>return</span> <span class=n>file_read</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span><span class=n>file</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>太棒了！没剩多少了，一个个击破！</p>
<ul>
<li>
<p>第一步，根据文件描述符 fd，在进程表里拿到了 <strong>file</strong> 信息，进而拿到了 <strong>inode</strong> 信息。</p>
</li>
<li>
<p>第二步，对 buf 区域的内存做校验。</p>
</li>
<li>
<p>第三步，调用具体的 file_read 函数进行读操作。</p>
</li>
</ul>
<p>就这三步，很简单吧～</p>
<p>在进程表 filp 中拿到 file 信息进而拿到 inode 信息这一步就不用多说了，这是在打开一个文件时，或者像管道文件一样创建出一个管道文件时，就封装好了 file 以及它的 inode 信息。</p>
<p>我们看接下来的两步。</p>
<h2 id=对-buf-区域的内存做校验-verify_area>对 buf 区域的内存做校验 verify_area</h2>
<p>对 buf 区域的内存做校验的部分，说是校验，里面还挺有说道呢。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// fork.c
</span><span class=c1></span><span class=kt>void</span> <span class=nf>verify_area</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=n>addr</span><span class=p>,</span><span class=kt>int</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>    
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>start</span><span class=p>;</span>    
    <span class=n>start</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>addr</span><span class=p>;</span>    
    <span class=n>size</span> <span class=o>+=</span> <span class=n>start</span> <span class=o>&amp;</span> <span class=mh>0xfff</span><span class=p>;</span>    
    <span class=n>start</span> <span class=o>&amp;=</span> <span class=mh>0xfffff000</span><span class=p>;</span>    
    <span class=n>start</span> <span class=o>+=</span> <span class=n>get_base</span><span class=p>(</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>ldt</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>    
    <span class=k>while</span> <span class=p>(</span><span class=n>size</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>        
        <span class=n>size</span> <span class=o>-=</span> <span class=mi>4096</span><span class=p>;</span>        
        <span class=n>write_verify</span><span class=p>(</span><span class=n>start</span><span class=p>);</span>        
        <span class=n>start</span> <span class=o>+=</span> <span class=mi>4096</span><span class=p>;</span>    
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>addr 就是刚刚的 buf，size 就是刚刚的 count。然后这里又将 addr 赋值给了 start 变量。所以代码开始，<strong>start 就表示要复制到的内存的起始地址，size 就是要复制的字节数</strong>。</p>
<p>这段代码很简单，但如果不了解内存的分段和分页机制，将会难以理解。</p>
<p>Linux 0.11 对内存是以 <strong>4K</strong> 为一页单位来划分内存的，所以内存看起来就是一个个 4K 的小格子。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-31-5021c43100f4de25b4e64fa52dfe61ca.png alt=图片></p>
<p>你看，我们假设要复制到的内存的起始地址 start 和要复制的字节数 size 在图中的那个位置。那么开始的两行计算代码。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// fork.c
</span><span class=c1></span><span class=kt>void</span> <span class=nf>verify_area</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=n>addr</span><span class=p>,</span><span class=kt>int</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>    
    <span class=p>...</span>    
    <span class=n>size</span> <span class=o>+=</span> <span class=n>start</span> <span class=o>&amp;</span> <span class=mh>0xfff</span><span class=p>;</span>    
    <span class=n>start</span> <span class=o>&amp;=</span> <span class=mh>0xfffff000</span><span class=p>;</span>    
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>就是将 start 和 size 按页对齐一下。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-23-4199a0984f5558c3069e5d6237213e5b.png alt=图片></p>
<p>然后，又由于每个进程有不同的数据段基址，所以还要加上它。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// fork.c
</span><span class=c1></span><span class=kt>void</span> <span class=nf>verify_area</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=n>addr</span><span class=p>,</span><span class=kt>int</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>    
    <span class=p>...</span>    
    <span class=n>start</span> <span class=o>+=</span> <span class=n>get_base</span><span class=p>(</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>ldt</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>    
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>具体说来就是加上当前进程的局部描述符表 LDT 中的数据段的段基址。</p>
<p><img src=/Users/justice/tmp/notebook-img/7b752dcb35de94dd8711e9a2d69d3e7e535fa9cb.png alt=图片></p>
<p>每个进程的 LDT 表，由 Linux 创建进程时的代码给规划好了。具体说来，就是如上图所示，每个进程的线性地址范围，是</p>
<p>**(进程号)<em>64M ~  (进程号+1)<em>64M</em></em></p>
<p>而对于进程本身来说，都以为自己是从零号地址开始往后的 64M，所以传入的 start 值也是以零号地址为起始地址算出来的。</p>
<p>但现在经过系统调用进入 sys_write 后会切换为内核态，内核态访问数据会通过<strong>基地址为 0 的全局描述符表中的数据段</strong>来访问数据。所以，start 要加上它自己进程的数据段基址，才对。</p>
<p>再之后，就是对这些页进行具体的验证操作。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// fork.c
</span><span class=c1></span><span class=kt>void</span> <span class=nf>verify_area</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=n>addr</span><span class=p>,</span><span class=kt>int</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>    
    <span class=p>...</span>    
    <span class=k>while</span> <span class=p>(</span><span class=n>size</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>        
        <span class=n>size</span> <span class=o>-=</span> <span class=mi>4096</span><span class=p>;</span>        
        <span class=n>write_verify</span><span class=p>(</span><span class=n>start</span><span class=p>);</span>        
        <span class=n>start</span> <span class=o>+=</span> <span class=mi>4096</span><span class=p>;</span>    
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是这些页。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-11-d80885287dd5cfd96e15fa84759213c9.png alt=图片></p>
<p>这些 write_verify 将会对这些页进行<strong>写页面验证</strong>，如果页面存在但不可写，则执行 un_wp_page 复制页面。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// memory.c
</span><span class=c1></span><span class=kt>void</span> <span class=nf>write_verify</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>address</span><span class=p>)</span> <span class=p>{</span>   
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>page</span><span class=p>;</span>    
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span> <span class=p>(</span><span class=n>page</span> <span class=o>=</span> <span class=o>*</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>address</span><span class=o>&gt;&gt;</span><span class=mi>20</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xffc</span><span class=p>))</span> <span class=p>)</span><span class=o>&amp;</span><span class=mi>1</span><span class=p>))</span>        
        <span class=k>return</span><span class=p>;</span>    
    <span class=n>page</span> <span class=o>&amp;=</span> <span class=mh>0xfffff000</span><span class=p>;</span>    
    <span class=n>page</span> <span class=o>+=</span> <span class=p>((</span><span class=n>address</span><span class=o>&gt;&gt;</span><span class=mi>10</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xffc</span><span class=p>);</span>    
    <span class=k>if</span> <span class=p>((</span><span class=mi>3</span> <span class=o>&amp;</span> <span class=o>*</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=p>)</span> <span class=n>page</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>  
        <span class=cm>/* non-writeable, present */</span>        
        <span class=n>un_wp_page</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=p>)</span> <span class=n>page</span><span class=p>);</span>    
    <span class=k>return</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>看，那个 un_wp_page 意思就是取消页面的写保护，就是写时复制的原理，在 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502033&idx=1&sn=1acfd8b7f4c805906ecd51c33d0010eb&chksm=c2c5b27cf5b23b6a41051c7f93407afc97094a4b0a36ea050616778f4d072f074602f98983b2&scene=21#wechat_redirect">第30回 | 番外篇 - 写时复制就这么几行代码</a> 已经讨论过了，这里就不做展开了。</p>
<h2 id=执行读操作-file_read>执行读操作 file_read</h2>
<p>下面终于开始进入读操作的正题了，页校验完之后，就可以真正调用 file_read 函数了。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// read_write.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>sys_read</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>    
    <span class=p>...</span>    
    <span class=k>return</span> <span class=n>file_read</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span><span class=n>file</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>count</span><span class=p>);</span>
<span class=p>}</span>
<span class=c1>// file_dev.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>file_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>left</span><span class=p>,</span><span class=n>chars</span><span class=p>,</span><span class=n>nr</span><span class=p>;</span>    
    <span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span> <span class=n>bh</span><span class=p>;</span>    
    <span class=n>left</span> <span class=o>=</span> <span class=n>count</span><span class=p>;</span>    
    <span class=k>while</span> <span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=p>{</span>        
        <span class=k>if</span> <span class=p>(</span><span class=n>nr</span> <span class=o>=</span> <span class=n>bmap</span><span class=p>(</span><span class=n>inode</span><span class=p>,(</span><span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>)</span><span class=o>/</span><span class=n>BLOCK_SIZE</span><span class=p>))</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>bh</span><span class=o>=</span><span class=n>bread</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_dev</span><span class=p>,</span><span class=n>nr</span><span class=p>)))</span>
                <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>bh</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>nr</span> <span class=o>=</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_pos</span> <span class=o>%</span> <span class=n>BLOCK_SIZE</span><span class=p>;</span>
        <span class=n>chars</span> <span class=o>=</span> <span class=n>MIN</span><span class=p>(</span> <span class=n>BLOCK_SIZE</span><span class=o>-</span><span class=n>nr</span> <span class=p>,</span> <span class=n>left</span> <span class=p>);</span>
        <span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_pos</span> <span class=o>+=</span> <span class=n>chars</span><span class=p>;</span>
        <span class=n>left</span> <span class=o>-=</span> <span class=n>chars</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>bh</span><span class=p>)</span> <span class=p>{</span>
            <span class=kt>char</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>nr</span> <span class=o>+</span> <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_data</span><span class=p>;</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>chars</span><span class=o>--&gt;</span><span class=mi>0</span><span class=p>)</span>
                <span class=n>put_fs_byte</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>++</span><span class=p>),</span><span class=n>buf</span><span class=o>++</span><span class=p>);</span>
            <span class=n>brelse</span><span class=p>(</span><span class=n>bh</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>chars</span><span class=o>--&gt;</span><span class=mi>0</span><span class=p>)</span>
                <span class=n>put_fs_byte</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=n>buf</span><span class=o>++</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_atime</span> <span class=o>=</span> <span class=n>CURRENT_TIME</span><span class=p>;</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>count</span><span class=o>-</span><span class=n>left</span><span class=p>)</span><span class=o>?</span><span class=p>(</span><span class=n>count</span><span class=o>-</span><span class=n>left</span><span class=p>)</span><span class=o>:-</span><span class=n>ERROR</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>整体看，就是一个 while 循环，每次读入一个块的数据，直到入参所要求的大小全部读完为止。</p>
<p>while 去掉，简化起来就是这样。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// file_dev.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>file_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=kt>int</span> <span class=n>nr</span> <span class=o>=</span> <span class=n>bmap</span><span class=p>(</span><span class=n>inode</span><span class=p>,(</span><span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>)</span><span class=o>/</span><span class=n>BLOCK_SIZE</span><span class=p>);</span>
    <span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span><span class=n>bh</span><span class=o>=</span><span class=n>bread</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_dev</span><span class=p>,</span><span class=n>nr</span><span class=p>);</span>
    <span class=p>...</span>
    <span class=kt>char</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>nr</span> <span class=o>+</span> <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_data</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>chars</span><span class=o>--&gt;</span><span class=mi>0</span><span class=p>)</span>
         <span class=n>put_fs_byte</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>++</span><span class=p>),</span><span class=n>buf</span><span class=o>++</span><span class=p>);</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先 bmap 获取全局数据块号，然后 bread 将数据块的数据复制到缓冲区，然后 put_fs_byte 再一个字节一个字节地将缓冲区数据复制到用户指定的内存中。</p>
<p>我们一个个看。</p>
<h2 id=bmap获取全局的数据块号>bmap：获取全局的数据块号</h2>
<p>先看第一个函数调用<code>bmap()</code>。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// file_dev.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>file_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=kt>int</span> <span class=n>nr</span> <span class=o>=</span> <span class=n>bmap</span><span class=p>(</span><span class=n>inode</span><span class=p>,(</span><span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>)</span><span class=o>/</span><span class=n>BLOCK_SIZE</span><span class=p>);</span>
    <span class=p>...</span>
<span class=p>}</span>
<span class=c1>// inode.c 
</span><span class=c1></span><span class=kt>int</span> <span class=nf>bmap</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span><span class=kt>int</span> <span class=n>block</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>_bmap</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span><span class=n>block</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>_bmap</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span><span class=kt>int</span> <span class=n>block</span><span class=p>,</span><span class=kt>int</span> <span class=n>create</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>block</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>)</span>
        <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>block</span> <span class=o>&gt;=</span> <span class=mi>7</span><span class=o>+</span><span class=mi>512</span><span class=o>+</span><span class=mi>512</span><span class=o>*</span><span class=mi>512</span><span class=p>)</span>
        <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>block</span><span class=o>&lt;</span><span class=mi>7</span><span class=p>)</span>
         <span class=c1>// zone[0] 到 zone[7] 采用直接索引，可以索引小于 7 的块号
</span><span class=c1></span>        <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>block</span><span class=o>&lt;</span><span class=mi>512</span><span class=p>)</span>
        <span class=c1>// zone[7] 是一次间接索引，可以索引小于 512 的块号
</span><span class=c1></span>        <span class=p>...</span>
    <span class=c1>// zone[8] 是二次间接索引，可以索引大于 512 的块号
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们看到整个条件判断的结构是根据 block 来划分的。</p>
<p>block 就是要读取的块号，之所以要划分，就是因为 inode 在记录文件所在块号时，采用了多级索引的方式。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-01-1799e829d1f383f3fdb3ff4711e5d5b7.png alt=图片></p>
<p>zone[0] 到 zone[7] 采用直接索引，zone[7] 是一次间接索引，zone[8] 是二次间接索引。</p>
<p>那我们刚开始读，块号肯定从零开始，所以我们就先看 block&lt;7，通过直接索引这种最简单的方式读的代码。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// inode.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>_bmap</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span><span class=kt>int</span> <span class=n>block</span><span class=p>,</span><span class=kt>int</span> <span class=n>create</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>block</span><span class=o>&lt;</span><span class=mi>7</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>create</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=n>block</span><span class=p>])</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=n>block</span><span class=p>]</span><span class=o>=</span><span class=n>new_block</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_dev</span><span class=p>))</span> <span class=p>{</span>
                <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_ctime</span><span class=o>=</span><span class=n>CURRENT_TIME</span><span class=p>;</span>
                <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_dirt</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=k>return</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=n>block</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于 create = 0，也就是并不需要创建一个新的数据块，所以里面的 if 分支也没了。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// inode.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>_bmap</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span><span class=kt>int</span> <span class=n>block</span><span class=p>,</span><span class=kt>int</span> <span class=n>create</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>block</span><span class=o>&lt;</span><span class=mi>7</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>...</span>
        <span class=k>return</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_zone</span><span class=p>[</span><span class=n>block</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，其实 bmap 返回的，就是要读入的块号，<strong>从全局看在块设备的哪个逻辑块号下</strong>。</p>
<p>也就是说，假如我想要读这个文件的第一个块号的数据，该函数返回的事你这个文件的第一个块在整个硬盘中的哪个块中。</p>
<h2 id=bread将-bmap-获取的数据块号读入到高速缓冲块>bread：将 bmap 获取的数据块号读入到高速缓冲块</h2>
<p>好了，拿到这个数据块号后，回到 file_read 函数接着看。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// file_dev.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>file_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>nr</span> <span class=o>=</span> <span class=n>bmap</span><span class=p>(</span><span class=n>inode</span><span class=p>,(</span><span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>)</span><span class=o>/</span><span class=n>BLOCK_SIZE</span><span class=p>))</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>bh</span><span class=o>=</span><span class=n>bread</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_dev</span><span class=p>,</span><span class=n>nr</span><span class=p>)))</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>nr 就是具体的数据块号，作为其中其中一个参数，传入下一个函数 bread。</p>
<p>bread 这个方法的入参除了数据块号 block（就是刚刚传入的 nr）外，还有 inode 结构中的 i_dev，表示设备号。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// buffer.c
</span><span class=c1></span><span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span> <span class=nf>bread</span><span class=p>(</span><span class=kt>int</span> <span class=n>dev</span><span class=p>,</span><span class=kt>int</span> <span class=n>block</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span> <span class=n>bh</span> <span class=o>=</span> <span class=n>getblk</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span><span class=n>block</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_uptodate</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>bh</span><span class=p>;</span>
    <span class=n>ll_rw_block</span><span class=p>(</span><span class=n>READ</span><span class=p>,</span><span class=n>bh</span><span class=p>);</span>
    <span class=n>wait_on_buffer</span><span class=p>(</span><span class=n>bh</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_uptodate</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>bh</span><span class=p>;</span>
    <span class=n>brelse</span><span class=p>(</span><span class=n>bh</span><span class=p>);</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个 bread 方法就是根据一个设备号 dev 和一个数据块号 block，将这个数据块的数据，从硬盘复制到缓冲区里。</p>
<p>关于缓冲区，已经在 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247500596&idx=1&sn=0df64f9f5133cfe8a259b8ce7b7feaeb&chksm=c2c5b999f5b2308f76095af30e8915f125f18702df9c58be7612b58e4d009c14948193974f9b&scene=21#wechat_redirect">第19回 | 缓冲区初始化 buffer_init</a> 说明过了，有些久远。而 getblk 方法，<strong>就是根据设备号 dev 和数据块号 block，申请到一个缓冲块</strong>。</p>
<p>简单说就是，先根据 hash 结构快速查找这个 dev 和 block 是否有对应存在的缓冲块。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-04-28-16667f64e237c145eb6d5a2b293987f8.png alt=图片></p>
<p>如果没有，那就从之前建立好的双向链表结构的头指针 free_list 开始寻找，直到找到一个可用的缓冲块。</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-04-13-b2c84f4078f5265eee6c3c722e185f89.png alt=图片></p>
<p>具体代码逻辑，还包含当缓冲块正在被其他进程使用，或者缓冲块对应的数据已经被修改时的处理逻辑，你可以看一看，关键流程我已加上了注释。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// buffer.c
</span><span class=c1></span><span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span> <span class=nf>bread</span><span class=p>(</span><span class=kt>int</span> <span class=n>dev</span><span class=p>,</span><span class=kt>int</span> <span class=n>block</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span> <span class=n>bh</span> <span class=o>=</span> <span class=n>getblk</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span><span class=n>block</span><span class=p>);</span>
    <span class=p>...</span>
<span class=p>}</span>
<span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span> <span class=nf>getblk</span><span class=p>(</span><span class=kt>int</span> <span class=n>dev</span><span class=p>,</span><span class=kt>int</span> <span class=n>block</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span> <span class=n>tmp</span><span class=p>,</span> <span class=o>*</span> <span class=n>bh</span><span class=p>;</span>
<span class=nl>repeat</span><span class=p>:</span>
    <span class=c1>// 先从 hash 结构中找
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>bh</span> <span class=o>=</span> <span class=n>get_hash_table</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span><span class=n>block</span><span class=p>))</span>
        <span class=k>return</span> <span class=n>bh</span><span class=p>;</span>
    <span class=c1>// 如果没有就从 free_list 开始找遍双向链表
</span><span class=c1></span>    <span class=n>tmp</span> <span class=o>=</span> <span class=n>free_list</span><span class=p>;</span>
    <span class=k>do</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>b_count</span><span class=p>)</span>
            <span class=k>continue</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bh</span> <span class=o>||</span> <span class=n>BADNESS</span><span class=p>(</span><span class=n>tmp</span><span class=p>)</span><span class=o>&lt;</span><span class=n>BADNESS</span><span class=p>(</span><span class=n>bh</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>bh</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>BADNESS</span><span class=p>(</span><span class=n>tmp</span><span class=p>))</span>
                <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>((</span><span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=o>-&gt;</span><span class=n>b_next_free</span><span class=p>)</span> <span class=o>!=</span> <span class=n>free_list</span><span class=p>);</span>
    <span class=c1>// 如果还没找到，那就说明没有缓冲块可用了，就先阻塞住等一会
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bh</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>sleep_on</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer_wait</span><span class=p>);</span>
        <span class=k>goto</span> <span class=n>repeat</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// 到这里已经说明申请到了缓冲块，但有可能被其他进程上锁了
</span><span class=c1></span>    <span class=c1>// 如果上锁了的话，就先等等
</span><span class=c1></span>    <span class=n>wait_on_buffer</span><span class=p>(</span><span class=n>bh</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_count</span><span class=p>)</span>
        <span class=k>goto</span> <span class=n>repeat</span><span class=p>;</span>
    <span class=c1>// 到这里说明缓冲块已经申请到，且没有上锁
</span><span class=c1></span>    <span class=c1>// 但还得看 dirt 位，也就是有没有被修改
</span><span class=c1></span>    <span class=c1>// 如果被修改了，就先重新从硬盘中读入新数据
</span><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_dirt</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>sync_dev</span><span class=p>(</span><span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_dev</span><span class=p>);</span>
        <span class=n>wait_on_buffer</span><span class=p>(</span><span class=n>bh</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_count</span><span class=p>)</span>
            <span class=k>goto</span> <span class=n>repeat</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>find_buffer</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span><span class=n>block</span><span class=p>))</span>
        <span class=k>goto</span> <span class=n>repeat</span><span class=p>;</span>
    <span class=c1>// 给刚刚获取到的缓冲头 bh 重新赋值
</span><span class=c1></span>    <span class=c1>// 并调整在双向链表和 hash 表中的位置
</span><span class=c1></span>    <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_count</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
    <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_dirt</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
    <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_uptodate</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
    <span class=n>remove_from_queues</span><span class=p>(</span><span class=n>bh</span><span class=p>);</span>
    <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_dev</span><span class=o>=</span><span class=n>dev</span><span class=p>;</span>
    <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_blocknr</span><span class=o>=</span><span class=n>block</span><span class=p>;</span>
    <span class=n>insert_into_queues</span><span class=p>(</span><span class=n>bh</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>bh</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>总之，经过 getblk 之后，我们就在内存中，<strong>找到了一处缓冲块</strong>，用来接下来存储硬盘中指定数据块的数据。</p>
<p>那接下来的一步，自然就是把硬盘中的数据复制到这里啦，没错，<strong>ll_rw_block</strong> 就是干这个事的。</p>
<p>这个方法的细节特别复杂，也是我看了好久才看明白的地方，我会在下一回把这个方法详细地展开讲解。</p>
<p>在这一回里，你就当它已经成功地把硬盘中的一个数据块的数据，一个字节都不差地复制到了我们刚刚申请好的缓冲区里。</p>
<p>接下来，就要通过 <strong>put_fs_byte</strong> 方法，一个字节一个字节地，将缓冲区里的数据，复制到用户指定的内存 buf 中去了，当然，只会复制 count 字节。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// file_dev.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>file_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>m_inode</span> <span class=o>*</span> <span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>filp</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=kt>int</span>  <span class=n>nr</span> <span class=o>=</span> <span class=n>bmap</span><span class=p>(</span><span class=n>inode</span><span class=p>,(</span><span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_pos</span><span class=p>)</span><span class=o>/</span><span class=n>BLOCK_SIZE</span><span class=p>);</span>
    <span class=k>struct</span> <span class=n>buffer_head</span> <span class=o>*</span><span class=n>bh</span><span class=o>=</span><span class=n>bread</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_dev</span><span class=p>,</span><span class=n>nr</span><span class=p>);</span>
    <span class=p>...</span>
    <span class=kt>char</span> <span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>nr</span> <span class=o>+</span> <span class=n>bh</span><span class=o>-&gt;</span><span class=n>b_data</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>chars</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
         <span class=n>put_fs_byte</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>++</span><span class=p>),</span><span class=n>buf</span><span class=o>++</span><span class=p>);</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=put_fs_byte将-bread-读入的缓冲块数据复制到用户指定的内存中>put_fs_byte：将 bread 读入的缓冲块数据复制到用户指定的内存中</h2>
<p>这个过程，仅仅是内存之间的复制，所以不必紧张。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>// segment.h
extern _inline void
put_fs_byte (char val, char *addr) {
    __asm__ (&#34;movb %0,%%fs:%1&#34;::&#34;r&#34; (val),&#34;m&#34; (*addr));
}
</code></pre></td></tr></table>
</div>
</div><p>有点难以理解，我改成较为好看的样子。（参考赵炯《Linux 内核完全注释 V1.9.5》）</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// segment.h
</span><span class=c1></span><span class=k>extern</span> <span class=kr>_inline</span> <span class=kt>void</span>
<span class=nf>put_fs_byte</span> <span class=p>(</span><span class=kt>char</span> <span class=n>val</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>_asm</span> <span class=n>mov</span> <span class=n>ebx</span><span class=p>,</span><span class=n>addr</span>
    <span class=n>_asm</span> <span class=n>mov</span> <span class=n>al</span><span class=p>,</span><span class=n>val</span><span class=p>;</span>
    <span class=n>_asm</span> <span class=n>mov</span> <span class=n>byte</span> <span class=n>ptr</span> <span class=nl>fs</span><span class=p>:[</span><span class=n>ebx</span><span class=p>],</span><span class=n>al</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>其实就是三个汇编指令的 mov 操作。</p>
<p>至此，我们就将数据从硬盘读入缓冲区，再从缓冲区读入用户内存，一个 read 函数完美谢幕！</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-04-00-15621404a8aa327ecc0011cdca211fa0.png alt=图片></p>
<p>首先通过 verify_area 对内存做了校验，需要写时复制的地方在这里提前进行好了。</p>
<p>接下来，file_read 方法做了读盘的全部操作，通过 bmap 获取到了硬盘全局维度的数据块号，然后 bread 将数据块数据复制到缓冲区，然后 put_fs_byte 再将缓冲区数据复制到用户内存。</p>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2024-01-08 06:47:33
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/alipay_reward_qrcode.png>
<span>支付宝打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/bitcoin_reward_qrcode.png>
<span>比特币打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/linux/>linux</a>
<a href=https://justice.bj.cn/tags/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/>linux-0.11源码解读</a>
<a href=https://justice.bj.cn/tags/%E7%AC%AC5%E9%83%A8%E5%88%86/>第5部分</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/21.linux/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/45.%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">45.解析并执行 shell 命令</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/21.linux/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/47.%E8%AF%BB%E5%8F%96%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%86%E8%8A%82/>
<span class="next-text nav-default">47.读取硬盘数据的细节</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2024
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
</body>
</html>