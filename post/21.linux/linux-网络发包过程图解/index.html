<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>Linux 网络包发送过程(转) - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=referrer content="no-referrer">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="Linux 网络包发送过程(转) 在开始今天的文章之前，我先来请大家思考几个小问题。 问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？ 问2：为什">
<meta name=keywords content="tech,it,blog">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/21.linux/linux-%E7%BD%91%E7%BB%9C%E5%8F%91%E5%8C%85%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.59a446ca0f76fe2dfc772a3a0b7512965043b4433e3e0dcf5b8ebeede14fae0c.css integrity="sha256-WaRGyg92/i38dyo6C3USllBDtEM+Pg3PW46+7eFPrgw=" media=screen crossorigin=anonymous>
<meta property="og:title" content="Linux 网络包发送过程(转)">
<meta property="og:description" content="Linux 网络包发送过程(转) 在开始今天的文章之前，我先来请大家思考几个小问题。 问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？ 问2：为什">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/21.linux/linux-%E7%BD%91%E7%BB%9C%E5%8F%91%E5%8C%85%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-06-04T10:26:13+08:00">
<meta property="article:modified_time" content="2022-06-04T10:26:13+08:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="Linux 网络包发送过程(转)">
<meta itemprop=description content="Linux 网络包发送过程(转) 在开始今天的文章之前，我先来请大家思考几个小问题。 问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？ 问2：为什"><meta itemprop=datePublished content="2022-06-04T10:26:13+08:00">
<meta itemprop=dateModified content="2022-06-04T10:26:13+08:00">
<meta itemprop=wordCount content="11077">
<meta itemprop=keywords content="linux,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Linux 网络包发送过程(转)">
<meta name=twitter:description content="Linux 网络包发送过程(转) 在开始今天的文章之前，我先来请大家思考几个小问题。 问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？ 问2：为什"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=search-btn class="menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>Linux 网络包发送过程(转)</h1>
<div class=post-meta>
<time datetime=2022-06-04 class=post-time>
2022-06-04 10:26:13
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/linux/> linux </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#linux-网络发送过程总览>Linux 网络发送过程总览</a></li>
<li><a href=#二网卡启动准备><strong>二、网卡启动准备</strong></a></li>
<li><a href=#三accept-创建新-socket><strong>三、accept 创建新 socket</strong></a></li>
<li><a href=#四发送数据真正开始><strong>四、发送数据真正开始</strong></a>
<ul>
<li><a href=#41-send-系统调用实现><strong>4.1 send 系统调用实现</strong></a></li>
<li><a href=#42-传输层处理><strong>4.2 传输层处理</strong></a></li>
<li><a href=#1传输层拷贝><strong>1）传输层拷贝</strong></a></li>
<li><a href=#2传输层发送><strong>2）传输层发送</strong></a></li>
<li><a href=#43-网络层发送处理><strong>4.3 网络层发送处理</strong></a></li>
<li><a href=#44-邻居子系统><strong>4.4 邻居子系统</strong></a></li>
<li><a href=#45-网络设备子系统><strong>4.5 网络设备子系统</strong></a></li>
<li><a href=#46-软中断调度><strong>4.6 软中断调度</strong></a></li>
<li><a href=#47-igb-网卡驱动发送><strong>4.7 igb 网卡驱动发送</strong></a></li>
<li><a href=#48-发送完成硬中断><strong>4.8 发送完成硬中断</strong></a></li>
</ul>
</li>
<li><a href=#最后><strong>最后</strong></a></li>
<li><a href=#参考><strong>参考</strong></a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=linux-网络包发送过程转>Linux 网络包发送过程(转)</h1>
<p>在开始今天的文章之前，我先来请大家思考几个小问题。</p>
<ul>
<li>问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？</li>
<li>问2：为什么你服务器上的 /proc/softirqs 里 NET_RX 要比 NET_TX 大的多的多？</li>
<li>问3：发送网络数据的时候都涉及到哪些内存拷贝操作？</li>
</ul>
<p>这些问题虽然在线上经常看到，但我们似乎很少去深究。如果真的能透彻地把这些问题理解到位，我们对性能的掌控能力将会变得更强。</p>
<p>带着这三个问题，我们开始今天对 Linux 内核网络发送过程的深度剖析。还是按照我们之前的传统，先从一段简单的代码作为切入。如下代码是一个典型服务器程序的典型的缩微代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
 <span class=n>fd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
 <span class=n>bind</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=p>...);</span>
 <span class=n>listen</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=p>...);</span>

 <span class=n>cfd</span> <span class=o>=</span> <span class=n>accept</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=p>...);</span>

 <span class=c1>// 接收用户请求
</span><span class=c1></span> <span class=n>read</span><span class=p>(</span><span class=n>cfd</span><span class=p>,</span> <span class=p>...);</span>

 <span class=c1>// 用户请求处理
</span><span class=c1></span> <span class=n>dosometing</span><span class=p>();</span> 

 <span class=c1>// 给用户返回结果
</span><span class=c1></span> <span class=n>send</span><span class=p>(</span><span class=n>cfd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>今天我们来讨论上述代码中，调用 send 之后内核是怎么样把数据包发送出去的。本文基于Linux 3.10，网卡驱动采用Intel的igb网卡举例。</p>
<h2 id=linux-网络发送过程总览>Linux 网络发送过程总览</h2>
<p>飞哥觉得看 Linux 源码最重要的是得有整体上的把握，而不是一开始就陷入各种细节。</p>
<p>我这里先给大家准备了一个总的流程图，简单阐述下 send 发送了的数据是如何一步一步被发送到网卡的。</p>
<p><img src=https://pic1.zhimg.com/80/v2-18543fabe38c2eddcb2f0eba9e0e79f4_720w.jpg alt></p>
<p>在这幅图中，我们看到用户数据被拷贝到内核态，然后经过协议栈处理后进入到了 RingBuffer 中。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知 CPU，然后清理 RingBuffer。</p>
<p>因为文章后面要进入源码，所以我们再从源码的角度给出一个流程图。</p>
<p><img src=https://pic2.zhimg.com/80/v2-b511a062c2803ecfc6931bfdcf3f2b51_720w.jpg alt></p>
<p>虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。</p>
<p>那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图：</p>
<p><img src=https://pic3.zhimg.com/80/v2-4040c1e92f7b492c522848b786285e96_720w.jpg alt></p>
<p>注意，我们今天的主题虽然是发送数据，但是硬中断最终触发的软中断却是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ ！！！（T 是 transmit 的缩写，R 表示 receive）</p>
<p><strong>意不意外，惊不惊喜？？？</strong></p>
<p>所以这就是开篇问题 1 的一部分的原因（注意，这只是一部分原因）。</p>
<blockquote>
<p>问1：在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？</p>
</blockquote>
<p>传输完成最终会触发 NET_RX，而不是 NET_TX。 所以自然你观测 /proc/softirqs 也就能看到 NET_RX 更多了。</p>
<p>好，现在你已经对内核是怎么发送网络包的有一个全局上的把握了。不要得意，我们需要了解的细节才是更有价值的地方，让我们继续！！</p>
<p>&mdash; 这里插入一份电子书资料</p>
<p>飞哥经常会收到读者的私信，询问可否推荐一些书继续深入学习内功。所以我干脆就写了篇文章。把能搜集到的电子版也帮大家汇总了一下，取需！</p>
<p><strong><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/BZv4WpKLB38KsACpJ9csNQ">答读者问，能否推荐几本有价值的参考书(含下载地址)</a></strong></p>
<p><img src=https://pic2.zhimg.com/80/v2-1fad277dcd9842c3db483dbb7a3fbfe9_720w.jpg alt></p>
<p>资料插播完毕，这回真的继续！！</p>
<h2 id=二网卡启动准备><strong>二、网卡启动准备</strong></h2>
<p>现在的服务器上的网卡一般都是支持多队列的。每一个队列上都是由一个 RingBuffer 表示的，开启了多队列以后的的网卡就会对应有多个 RingBuffer。</p>
<p><img src=https://pic4.zhimg.com/80/v2-ce24c3abe8e58f9fd4d269bd64291347_720w.jpg alt></p>
<p>网卡在启动时最重要的任务之一就是分配和初始化 RingBuffer，理解了 RingBuffer 将会非常有助于后面我们掌握发送。因为今天的主题是发送，所以就以传输队列为例，我们来看下网卡启动时分配 RingBuffer 的实际过程。</p>
<p>在网卡启动的时候，会调用到 __igb_open 函数，RingBuffer 就是在这里分配的。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>__igb_open</span><span class=p>(</span><span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>netdev</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>resuming</span><span class=p>)</span>
<span class=p>{</span>
 <span class=k>struct</span> <span class=n>igb_adapter</span> <span class=o>*</span><span class=n>adapter</span> <span class=o>=</span> <span class=n>netdev_priv</span><span class=p>(</span><span class=n>netdev</span><span class=p>);</span>

 <span class=c1>//分配传输描述符数组
</span><span class=c1></span> <span class=n>err</span> <span class=o>=</span> <span class=n>igb_setup_all_tx_resources</span><span class=p>(</span><span class=n>adapter</span><span class=p>);</span>

 <span class=c1>//分配接收描述符数组
</span><span class=c1></span> <span class=n>err</span> <span class=o>=</span> <span class=n>igb_setup_all_rx_resources</span><span class=p>(</span><span class=n>adapter</span><span class=p>);</span>

 <span class=c1>//开启全部队列
</span><span class=c1></span> <span class=n>netif_tx_start_all_queues</span><span class=p>(</span><span class=n>netdev</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在上面 __igb_open 函数调用 igb_setup_all_tx_resources 分配所有的传输 RingBuffer, 调用 igb_setup_all_rx_resources 创建所有的接收 RingBuffer。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>igb_setup_all_tx_resources</span><span class=p>(</span><span class=k>struct</span> <span class=n>igb_adapter</span> <span class=o>*</span><span class=n>adapter</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//有几个队列就构造几个 RingBuffer
</span><span class=c1></span> <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>num_tx_queues</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>igb_setup_tx_resources</span><span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>tx_ring</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>真正的 RingBuffer 构造过程是在 igb_setup_tx_resources 中完成的。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>igb_setup_tx_resources</span><span class=p>(</span><span class=k>struct</span> <span class=n>igb_ring</span> <span class=o>*</span><span class=n>tx_ring</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//1.申请 igb_tx_buffer 数组内存
</span><span class=c1></span> <span class=n>size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>igb_tx_buffer</span><span class=p>)</span> <span class=o>*</span> <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>count</span><span class=p>;</span>
 <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>tx_buffer_info</span> <span class=o>=</span> <span class=n>vzalloc</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>

 <span class=c1>//2.申请 e1000_adv_tx_desc DMA 数组内存
</span><span class=c1></span> <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>count</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>union</span> <span class=n>e1000_adv_tx_desc</span><span class=p>);</span>
 <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>,</span> <span class=mi>4096</span><span class=p>);</span>
 <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>desc</span> <span class=o>=</span> <span class=n>dma_alloc_coherent</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span> <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>,</span>
        <span class=o>&amp;</span><span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>dma</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>

 <span class=c1>//3.初始化队列成员
</span><span class=c1></span> <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>next_to_use</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
 <span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>next_to_clean</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>从上述源码可以看到，实际上一个 RingBuffer 的内部不仅仅是一个环形队列数组，而是有两个。</p>
<p>1）igb_tx_buffer 数组：这个数组是内核使用的，通过 vzalloc 申请的。<br>
2）e1000_adv_tx_desc 数组：这个数组是网卡硬件使用的，硬件是可以通过 DMA 直接访问这块内存，通过 dma_alloc_coherent 分配。</p>
<p>这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。</p>
<p><img src=https://pic1.zhimg.com/80/v2-3385217f1469def5689fc0057739df64_720w.jpg alt></p>
<p>最后调用 netif_tx_start_all_queues 开启队列。另外，对于硬中断的处理函数 igb_msix_ring 其实也是在 __igb_open 中注册的。</p>
<h2 id=三accept-创建新-socket><strong>三、accept 创建新 socket</strong></h2>
<p>在发送数据之前，我们往往还需要一个已经建立好连接的 socket。</p>
<p>我们就以开篇服务器缩微源代码中提到的 accept 为例，当 accept 之后，进程会创建一个新的 socket 出来，然后把它放到当前进程的打开文件列表中，专门用于和对应的客户端通信。</p>
<p>假设服务器进程通过 accept 和客户端建立了两条连接，我们来简单看一下这两条连接和进程的关联关系。</p>
<p><img src=https://pic4.zhimg.com/80/v2-52d6007054ead81044fef43870b3cadb_720w.jpg alt></p>
<p>其中代表一条连接的 socket 内核对象更为具体一点的结构图如下。</p>
<p><img src=https://pic4.zhimg.com/80/v2-c2bdf3847e53d464b53478491968f6ff_720w.jpg alt></p>
<p>为了避免喧宾夺主，accept 详细的源码过程这里就不介绍了，感兴趣请参考 <strong><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/OmRdUgO1guMX76EdZn11UQ">《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》</a></strong>。一文中的第一部分。</p>
<p>今天我们还是把重点放到数据发送过程上。</p>
<h2 id=四发送数据真正开始><strong>四、发送数据真正开始</strong></h2>
<h3 id=41-send-系统调用实现><strong>4.1 send 系统调用实现</strong></h3>
<p>send 系统调用的源码位于文件 net/socket.c 中。在这个系统调用里，内部其实真正使用的是 sendto 系统调用。整个调用链条虽然不短，但其实主要只干了两件简单的事情，</p>
<ul>
<li>第一是在内核中把真正的 socket 找出来，在这个对象里记录着各种协议栈的函数地址。</li>
<li>第二是构造一个 struct msghdr 对象，把用户传入的数据，比如 buffer地址、数据长度啥的，统统都装进去.</li>
</ul>
<p>剩下的事情就交给下一层，协议栈里的函数 inet_sendmsg 了，其中 inet_sendmsg 函数的地址是通过 socket 内核对象里的 ops 成员找到的。大致流程如图。</p>
<p><img src=https://pic4.zhimg.com/80/v2-33dbbf07ba4846e60c8edb671d00c07f_720w.jpg alt></p>
<p>有了上面的了解，我们再看起源码就要容易许多了。源码如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/socket.c
</span><span class=c1></span><span class=n>SYSCALL_DEFINE4</span><span class=p>(</span><span class=n>send</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>buff</span><span class=p>,</span> <span class=n>size_t</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span>
  <span class=kt>unsigned</span> <span class=kt>int</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span>
<span class=p>{</span>
 <span class=k>return</span> <span class=n>sys_sendto</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buff</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>SYSCALL_DEFINE6</span><span class=p>(......)</span>
<span class=p>{</span>
 <span class=c1>//1.根据 fd 查找到 socket
</span><span class=c1></span> <span class=n>sock</span> <span class=o>=</span> <span class=n>sockfd_lookup_light</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>err</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fput_needed</span><span class=p>);</span>

 <span class=c1>//2.构造 msghdr
</span><span class=c1></span> <span class=k>struct</span> <span class=n>msghdr</span> <span class=n>msg</span><span class=p>;</span>
 <span class=k>struct</span> <span class=n>iovec</span> <span class=n>iov</span><span class=p>;</span>

 <span class=n>iov</span><span class=p>.</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>buff</span><span class=p>;</span>
 <span class=n>iov</span><span class=p>.</span><span class=n>iov_len</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
 <span class=n>msg</span><span class=p>.</span><span class=n>msg_iovlen</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

 <span class=n>msg</span><span class=p>.</span><span class=n>msg_iov</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>iov</span><span class=p>;</span>
 <span class=n>msg</span><span class=p>.</span><span class=n>msg_flags</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
 <span class=p>......</span>

 <span class=c1>//3.发送数据
</span><span class=c1></span> <span class=n>sock_sendmsg</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>msg</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。</p>
<p>在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。</p>
<p>接着调用了 sock_sendmsg => __sock_sendmsg ==> __sock_sendmsg_nosec。在__sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/socket.c
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>__sock_sendmsg_nosec</span><span class=p>(...)</span>
<span class=p>{</span>
 <span class=p>......</span>
 <span class=k>return</span> <span class=n>sock</span><span class=o>-&gt;</span><span class=n>ops</span><span class=o>-&gt;</span><span class=n>sendmsg</span><span class=p>(</span><span class=n>iocb</span><span class=p>,</span> <span class=n>sock</span><span class=p>,</span> <span class=n>msg</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过第三节里的 socket 内核对象结构图，我们可以看到，这里调用的是 sock->ops->sendmsg 实际执行的是 inet_sendmsg。这个函数是 AF_INET 协议族提供的通用发送函数。</p>
<h3 id=42-传输层处理><strong>4.2 传输层处理</strong></h3>
<h3 id=1传输层拷贝><strong>1）传输层拷贝</strong></h3>
<p>在进入到协议栈 inet_sendmsg 以后，内核接着会找到 socket 上的具体协议发送函数。对于 TCP 协议来说，那就是 tcp_sendmsg（同样也是通过 socket 内核对象找到的）。</p>
<p>在这个函数中，内核会申请一个内核态的 skb 内存，将用户待发送的数据拷贝进去。注意这个时候不一定会真正开始发送，如果没有达到发送条件的话很可能这次调用直接就返回了。大概过程如图：</p>
<p><img src=https://pic2.zhimg.com/80/v2-ffad55e8c65199c7c6604bd394088e41_720w.jpg alt></p>
<p>我们来看 inet_sendmsg 函数的源码。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/af_inet.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>inet_sendmsg</span><span class=p>(......)</span>
<span class=p>{</span>
 <span class=p>......</span>
 <span class=k>return</span> <span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_prot</span><span class=o>-&gt;</span><span class=n>sendmsg</span><span class=p>(</span><span class=n>iocb</span><span class=p>,</span> <span class=n>sk</span><span class=p>,</span> <span class=n>msg</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个函数中会调用到具体协议的发送函数。同样参考第三节里的 socket 内核对象结构图，我们看到对于 TCP 协议下的 socket 来说，来说 sk->sk_prot->sendmsg 指向的是 tcp_sendmsg（对于 UPD 来说是 udp_sendmsg）。</p>
<p>tcp_sendmsg 这个函数比较长，我们分多次来看它。 先看这一段</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/tcp.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>tcp_sendmsg</span><span class=p>(...)</span>
<span class=p>{</span>
 <span class=k>while</span><span class=p>(...){</span>
  <span class=k>while</span><span class=p>(...){</span>
   <span class=c1>//获取发送队列
</span><span class=c1></span>   <span class=n>skb</span> <span class=o>=</span> <span class=n>tcp_write_queue_tail</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span>

   <span class=c1>//申请skb 并拷贝
</span><span class=c1></span>   <span class=p>......</span>
  <span class=p>}</span>
 <span class=p>}</span>
<span class=p>}</span>

<span class=c1>//file: include/net/tcp.h
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=nf>tcp_write_queue_tail</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>)</span>
<span class=p>{</span>
 <span class=k>return</span> <span class=n>skb_peek_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_write_queue</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>理解对 socket 调用 tcp_write_queue_tail 是理解发送的前提。如上所示，这个函数是在获取 socket 发送队列中的最后一个 skb。 skb 是 struct sk_buff 对象的简称，用户的发送队列就是该对象组成的一个链表。</p>
<p><img src=https://pic2.zhimg.com/80/v2-bb693e4a2fdae5870609d9b76133c0ad_720w.jpg alt></p>
<p>我们再接着看 tcp_sendmsg 的其它部分。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/tcp.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>tcp_sendmsg</span><span class=p>(</span><span class=k>struct</span> <span class=n>kiocb</span> <span class=o>*</span><span class=n>iocb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=k>struct</span> <span class=n>msghdr</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span>
  <span class=n>size_t</span> <span class=n>size</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//获取用户传递过来的数据和标志
</span><span class=c1></span> <span class=n>iov</span> <span class=o>=</span> <span class=n>msg</span><span class=o>-&gt;</span><span class=n>msg_iov</span><span class=p>;</span> <span class=c1>//用户数据地址
</span><span class=c1></span> <span class=n>iovlen</span> <span class=o>=</span> <span class=n>msg</span><span class=o>-&gt;</span><span class=n>msg_iovlen</span><span class=p>;</span> <span class=c1>//数据块数为1
</span><span class=c1></span> <span class=n>flags</span> <span class=o>=</span> <span class=n>msg</span><span class=o>-&gt;</span><span class=n>msg_flags</span><span class=p>;</span> <span class=c1>//各种标志
</span><span class=c1></span>
 <span class=c1>//遍历用户层的数据块
</span><span class=c1></span> <span class=k>while</span> <span class=p>(</span><span class=o>--</span><span class=n>iovlen</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>

  <span class=c1>//待发送数据块的地址
</span><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>from</span> <span class=o>=</span> <span class=n>iov</span><span class=o>-&gt;</span><span class=n>iov_base</span><span class=p>;</span>

  <span class=k>while</span> <span class=p>(</span><span class=n>seglen</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>

   <span class=c1>//需要申请新的 skb
</span><span class=c1></span>   <span class=k>if</span> <span class=p>(</span><span class=n>copy</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>

    <span class=c1>//申请 skb，并添加到发送队列的尾部
</span><span class=c1></span>    <span class=n>skb</span> <span class=o>=</span> <span class=n>sk_stream_alloc_skb</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span>
         <span class=n>select_size</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>sg</span><span class=p>),</span>
         <span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_allocation</span><span class=p>);</span>

    <span class=c1>//把 skb 挂到socket的发送队列上
</span><span class=c1></span>    <span class=n>skb_entail</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>skb</span><span class=p>);</span>
   <span class=p>}</span>

   <span class=c1>// skb 中有足够的空间
</span><span class=c1></span>   <span class=k>if</span> <span class=p>(</span><span class=n>skb_availroom</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>//拷贝用户空间的数据到内核空间，同时计算校验和
</span><span class=c1></span>    <span class=c1>//from是用户空间的数据地址 
</span><span class=c1></span>    <span class=n>skb_add_data_nocache</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=n>from</span><span class=p>,</span> <span class=n>copy</span><span class=p>);</span>
   <span class=p>}</span> 
   <span class=p>......</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数比较长，不过其实逻辑并不复杂。其中 msg->msg_iov 存储的是用户态内存的要发送的数据的 buffer。接下来在内核态申请内核内存，比如 skb，并把用户内存里的数据拷贝到内核态内存中。<strong>这就会涉及到一次或者几次内存拷贝的开销</strong>。</p>
<p><img src=https://pic3.zhimg.com/80/v2-cbd951cef795058fe8379ac46765d172_720w.jpg alt></p>
<p>至于内核什么时候真正把 skb 发送出去。在 tcp_sendmsg 中会进行一些判断。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-text data-lang=text>//file: net/ipv4/tcp.c
int tcp_sendmsg(...)
{
 while(...){
  while(...){
   //申请内核内存并进行拷贝

   //发送判断
   if (forced_push(tp)) {
    tcp_mark_push(tp, skb);
    __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);
   } else if (skb == tcp_send_head(sk))
    tcp_push_one(sk, mss_now);  
   }
   continue;
  }
 }
}
</code></pre></td></tr></table>
</div>
</div><p>只有满足 forced_push(tp) 或者 skb == tcp_send_head(sk) 成立的时候，内核才会真正启动发送数据包。其中 forced_push(tp) 判断的是未发送的数据数据是否已经超过最大窗口的一半了。</p>
<p>条件都不满足的话，<strong>这次的用户要发送的数据只是拷贝到内核就算完事了！</strong></p>
<h3 id=2传输层发送><strong>2）传输层发送</strong></h3>
<p>假设现在内核发送条件已经满足了，我们再来跟踪一下实际的发送过程。 对于上小节函数中，当满足真正发送条件的时候，无论调用的是 __tcp_push_pending_frames 还是 tcp_push_one 最终都实际会执行到 tcp_write_xmit。</p>
<p>所以我们直接从 tcp_write_xmit 看起，这个函数处理了传输层的拥塞控制、滑动窗口相关的工作。满足窗口要求的时候，设置一下 TCP 头然后将 skb 传到更低的网络层进行处理。</p>
<p><img src=https://pic2.zhimg.com/80/v2-18f6157c989ac8838e7048941260809d_720w.jpg alt></p>
<p>我们来看下 tcp_write_xmit 的源码。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/tcp_output.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>bool</span> <span class=nf>tcp_write_xmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>mss_now</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nonagle</span><span class=p>,</span>
      <span class=kt>int</span> <span class=n>push_one</span><span class=p>,</span> <span class=n>gfp_t</span> <span class=n>gfp</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//循环获取待发送 skb
</span><span class=c1></span> <span class=k>while</span> <span class=p>((</span><span class=n>skb</span> <span class=o>=</span> <span class=n>tcp_send_head</span><span class=p>(</span><span class=n>sk</span><span class=p>)))</span> 
 <span class=p>{</span>
  <span class=c1>//滑动窗口相关
</span><span class=c1></span>  <span class=n>cwnd_quota</span> <span class=o>=</span> <span class=n>tcp_cwnd_test</span><span class=p>(</span><span class=n>tp</span><span class=p>,</span> <span class=n>skb</span><span class=p>);</span>
  <span class=n>tcp_snd_wnd_test</span><span class=p>(</span><span class=n>tp</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=n>mss_now</span><span class=p>);</span>
  <span class=n>tcp_mss_split_point</span><span class=p>(...);</span>
  <span class=n>tso_fragment</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=p>...);</span>
  <span class=p>......</span>

  <span class=c1>//真正开启发送
</span><span class=c1></span>  <span class=n>tcp_transmit_skb</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>gfp</span><span class=p>);</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到我们之前在网络协议里学的滑动窗口、拥塞控制就是在这个函数中完成的，这部分就不过多展开了，感兴趣同学自己找这段源码来读。我们今天只看发送主过程，那就走到了 tcp_transmit_skb。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/tcp_output.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>tcp_transmit_skb</span><span class=p>(</span><span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span> <span class=kt>int</span> <span class=n>clone_it</span><span class=p>,</span>
    <span class=n>gfp_t</span> <span class=n>gfp_mask</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//1.克隆新 skb 出来
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=n>likely</span><span class=p>(</span><span class=n>clone_it</span><span class=p>))</span> <span class=p>{</span>
  <span class=n>skb</span> <span class=o>=</span> <span class=n>skb_clone</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>gfp_mask</span><span class=p>);</span>
  <span class=p>......</span>
 <span class=p>}</span>

 <span class=c1>//2.封装 TCP 头
</span><span class=c1></span> <span class=n>th</span> <span class=o>=</span> <span class=n>tcp_hdr</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
 <span class=n>th</span><span class=o>-&gt;</span><span class=n>source</span>  <span class=o>=</span> <span class=n>inet</span><span class=o>-&gt;</span><span class=n>inet_sport</span><span class=p>;</span>
 <span class=n>th</span><span class=o>-&gt;</span><span class=n>dest</span>  <span class=o>=</span> <span class=n>inet</span><span class=o>-&gt;</span><span class=n>inet_dport</span><span class=p>;</span>
 <span class=n>th</span><span class=o>-&gt;</span><span class=n>window</span>  <span class=o>=</span> <span class=p>...;</span>
 <span class=n>th</span><span class=o>-&gt;</span><span class=n>urg</span>   <span class=o>=</span> <span class=p>...;</span>
 <span class=p>......</span>

 <span class=c1>//3.调用网络层发送接口
</span><span class=c1></span> <span class=n>err</span> <span class=o>=</span> <span class=n>icsk</span><span class=o>-&gt;</span><span class=n>icsk_af_ops</span><span class=o>-&gt;</span><span class=n>queue_xmit</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>inet</span><span class=o>-&gt;</span><span class=n>cork</span><span class=p>.</span><span class=n>fl</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>第一件事是先克隆一个新的 skb，这里重点说下为什么要复制一个 skb 出来呢？</p>
<p>是因为 skb 后续在调用网络层，最后到达网卡发送完成的时候，这个 skb 会被释放掉。而我们知道 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 skb 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 skb 的一个拷贝。等收到 ACK 再真正删除。</p>
<p>第二件事是修改 skb 中的 TCP header，根据实际情况把 TCP 头设置好。这里要介绍一个小技巧，skb 内部其实包含了网络协议中所有的 header。在设置 TCP 头的时候，只是把指针指向 skb 的合适位置。后面再设置 IP 头的时候，在把指针挪一挪就行，避免频繁的内存申请和拷贝，效率很高。</p>
<p><img src=https://pic4.zhimg.com/80/v2-cfce7d6f807c3325de9ef21df529e4c3_720w.jpg alt></p>
<p>tcp_transmit_skb 是发送数据位于传输层的最后一步，接下来就可以进入到网络层进行下一层的操作了。调用了网络层提供的发送接口icsk->icsk_af_ops->queue_xmit()。</p>
<p>在下面的这个源码中，我们的知道了 queue_xmit 其实指向的是 ip_queue_xmit 函数。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/tcp_ipv4.c
</span><span class=c1></span><span class=k>const</span> <span class=k>struct</span> <span class=n>inet_connection_sock_af_ops</span> <span class=n>ipv4_specific</span> <span class=o>=</span> <span class=p>{</span>
 <span class=p>.</span><span class=n>queue_xmit</span>    <span class=o>=</span> <span class=n>ip_queue_xmit</span><span class=p>,</span>
 <span class=p>.</span><span class=n>send_check</span>    <span class=o>=</span> <span class=n>tcp_v4_send_check</span><span class=p>,</span>
 <span class=p>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>自此，传输层的工作也就都完成了。 数据离开了传输层，接下来将会进入到内核在网络层的实现里。</p>
<h3 id=43-网络层发送处理><strong>4.3 网络层发送处理</strong></h3>
<p>Linux 内核网络层的发送的实现位于 net/ipv4/ip_output.c 这个文件。传输层调用到的 ip_queue_xmit 也在这里。（从文件名上也能看出来进入到 IP 层了，源文件名已经从 tcp_xxx 变成了 ip_xxx。）</p>
<p>在网络层里主要处理路由项查找、IP 头设置、netfilter 过滤、skb 切分（大于 MTU 的话）等几项工作，处理完这些工作后会交给更下层的邻居子系统来处理。</p>
<p><img src=https://pic1.zhimg.com/80/v2-0070e8bac1946baba239c56a27555a00_720w.jpg alt></p>
<p>我们来看网络层入口函数 ip_queue_xmit 的源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/ip_output.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>ip_queue_xmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>flowi</span> <span class=o>*</span><span class=n>fl</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//检查 socket 中是否有缓存的路由表
</span><span class=c1></span> <span class=n>rt</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>rtable</span> <span class=o>*</span><span class=p>)</span><span class=n>__sk_dst_check</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
 <span class=k>if</span> <span class=p>(</span><span class=n>rt</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>//没有缓存则展开查找
</span><span class=c1></span>  <span class=c1>//则查找路由项， 并缓存到 socket 中
</span><span class=c1></span>  <span class=n>rt</span> <span class=o>=</span> <span class=n>ip_route_output_ports</span><span class=p>(...);</span>
  <span class=n>sk_setup_caps</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rt</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>);</span>
 <span class=p>}</span>

 <span class=c1>//为 skb 设置路由表
</span><span class=c1></span> <span class=n>skb_dst_set_noref</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rt</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>);</span>

 <span class=c1>//设置 IP header
</span><span class=c1></span> <span class=n>iph</span> <span class=o>=</span> <span class=n>ip_hdr</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
 <span class=n>iph</span><span class=o>-&gt;</span><span class=n>protocol</span> <span class=o>=</span> <span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_protocol</span><span class=p>;</span>
 <span class=n>iph</span><span class=o>-&gt;</span><span class=n>ttl</span>      <span class=o>=</span> <span class=n>ip_select_ttl</span><span class=p>(</span><span class=n>inet</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rt</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>);</span>
 <span class=n>iph</span><span class=o>-&gt;</span><span class=n>frag_off</span> <span class=o>=</span> <span class=p>...;</span>

 <span class=c1>//发送
</span><span class=c1></span> <span class=n>ip_local_out</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>ip_queue_xmit 已经到了网络层，在这个函数里我们看到了网络层相关的功能路由项查找，如果找到了则设置到 skb 上（没有路由的话就直接报错返回了）。</p>
<p>在 Linux 上通过 route 命令可以看到你本机的路由配置。</p>
<p><img src=https://pic2.zhimg.com/80/v2-026979a5417056df4cd921841ce4cb61_720w.png alt></p>
<p>在路由表中，可以查到某个目的网络应该通过哪个 Iface（网卡），哪个 Gateway（网卡）发送出去。查找出来以后缓存到 socket 上，下次再发送数据就不用查了。</p>
<p>接着把路由表地址也放到 skb 里去。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: include/linux/skbuff.h
</span><span class=c1></span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=p>{</span>
 <span class=c1>//保存了一些路由相关信息
</span><span class=c1></span> <span class=kt>unsigned</span> <span class=kt>long</span>  <span class=n>_skb_refdst</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来就是定位到 skb 里的 IP 头的位置上，然后开始按照协议规范设置 IP header。</p>
<p><img src=https://pic3.zhimg.com/80/v2-f75b423219d405ff7c6885b10ee11c0a_720w.jpg alt></p>
<p>再通过 ip_local_out 进入到下一步的处理。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/ip_output.c  
</span><span class=c1></span><span class=kt>int</span> <span class=nf>ip_local_out</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//执行 netfilter 过滤
</span><span class=c1></span> <span class=n>err</span> <span class=o>=</span> <span class=n>__ip_local_out</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>

 <span class=c1>//开始发送数据
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=n>likely</span><span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=mi>1</span><span class=p>))</span>
  <span class=n>err</span> <span class=o>=</span> <span class=n>dst_output</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
 <span class=p>......</span>
</code></pre></td></tr></table>
</div>
</div><p>在 ip_local_out => __ip_local_out => nf_hook 会执行 netfilter 过滤。如果你使用 iptables 配置了一些规则，那么这里将检测是否命中规则。 <strong>如果你设置了非常复杂的 netfilter 规则，在这个函数这里将会导致你的进程 CPU 开销会极大增加</strong>。</p>
<p>还是不多展开说，继续只聊和发送有关的过程 dst_output。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: include/net/dst.h
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>dst_output</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=k>return</span> <span class=n>skb_dst</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>output</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>此函数找到到这个 skb 的路由表（dst 条目） ，然后调用路由表的 output 方法。这又是一个函数指针，指向的是 ip_output 方法。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/ip_output.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>ip_output</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//统计
</span><span class=c1></span> <span class=p>.....</span>

 <span class=c1>//再次交给 netfilter，完毕后回调 ip_finish_output
</span><span class=c1></span> <span class=k>return</span> <span class=n>NF_HOOK_COND</span><span class=p>(</span><span class=n>NFPROTO_IPV4</span><span class=p>,</span> <span class=n>NF_INET_POST_ROUTING</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span>
    <span class=n>ip_finish_output</span><span class=p>,</span>
    <span class=o>!</span><span class=p>(</span><span class=n>IPCB</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>IPSKB_REROUTED</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 ip_output 中进行一些简单的，统计工作，再次执行 netfilter 过滤。过滤通过之后回调 ip_finish_output。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/ip_output.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>ip_finish_output</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//大于 mtu 的话就要进行分片了
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=n>skb</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>&gt;</span> <span class=n>ip_skb_dst_mtu</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>skb_is_gso</span><span class=p>(</span><span class=n>skb</span><span class=p>))</span>
  <span class=k>return</span> <span class=n>ip_fragment</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>ip_finish_output2</span><span class=p>);</span>
 <span class=k>else</span>
  <span class=k>return</span> <span class=n>ip_finish_output2</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 ip_finish_output 中我们看到，<strong>如果数据大于 MTU 的话，是会执行分片的。</strong></p>
<blockquote>
<p>实际 MTU 大小确定依赖 MTU 发现，以太网帧为 1500 字节。之前 QQ 团队在早期的时候，会尽量控制自己数据包尺寸小于 MTU，通过这种方式来优化网络性能。因为分片会带来两个问题：1、需要进行额外的切分处理，有额外性能开销。2、只要一个分片丢失，整个包都得重传。所以避免分片既杜绝了分片开销，也大大降低了重传率。</p>
</blockquote>
<p>在 ip_finish_output2 中，终于发送过程会进入到下一层，邻居子系统中。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/ipv4/ip_output.c
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>ip_finish_output2</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//根据下一跳 IP 地址查找邻居项，找不到就创建一个
</span><span class=c1></span> <span class=n>nexthop</span> <span class=o>=</span> <span class=p>(</span><span class=n>__force</span> <span class=n>u32</span><span class=p>)</span> <span class=n>rt_nexthop</span><span class=p>(</span><span class=n>rt</span><span class=p>,</span> <span class=n>ip_hdr</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>daddr</span><span class=p>);</span>  
 <span class=n>neigh</span> <span class=o>=</span> <span class=n>__ipv4_neigh_lookup_noref</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span> <span class=n>nexthop</span><span class=p>);</span>
 <span class=k>if</span> <span class=p>(</span><span class=n>unlikely</span><span class=p>(</span><span class=o>!</span><span class=n>neigh</span><span class=p>))</span>
  <span class=n>neigh</span> <span class=o>=</span> <span class=n>__neigh_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arp_tbl</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>nexthop</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>

 <span class=c1>//继续向下层传递
</span><span class=c1></span> <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=n>dst_neigh_output</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span> <span class=n>neigh</span><span class=p>,</span> <span class=n>skb</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=44-邻居子系统><strong>4.4 邻居子系统</strong></h3>
<p>邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是对网络层提供一个封装，让网络层不必关心下层的地址信息，让下层来决定发送到哪个 MAC 地址。</p>
<p>而且这个邻居子系统并不位于协议栈 net/ipv4/ 目录内，而是位于 net/core/neighbour.c。因为无论是对于 IPv4 还是 IPv6 ，都需要使用该模块。</p>
<p><img src=https://pic2.zhimg.com/80/v2-980285236de5b4b2efcf7176d1d6f9d9_720w.jpg alt></p>
<p>在邻居子系统里主要是查找或者创建邻居项，在创造邻居项的时候，有可能会发出实际的 arp 请求。然后封装一下 MAC 头，将发送过程再传递到更下层的网络设备子系统。大致流程如图。</p>
<p><img src=https://pic4.zhimg.com/80/v2-c2fffa7864d22f96118c7ce39ead1057_720w.jpg alt></p>
<p>理解了大致流程，我们再回头看源码。在上面小节 ip_finish_output2 源码中调用了 __ipv4_neigh_lookup_noref。它是在 arp 缓存中进行查找，其第二个参数传入的是路由下一跳 IP 信息。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: include/net/arp.h
</span><span class=c1></span><span class=k>extern</span> <span class=k>struct</span> <span class=n>neigh_table</span> <span class=n>arp_tbl</span><span class=p>;</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=k>struct</span> <span class=n>neighbour</span> <span class=o>*</span><span class=nf>__ipv4_neigh_lookup_noref</span><span class=p>(</span>
 <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span> <span class=n>u32</span> <span class=n>key</span><span class=p>)</span>
<span class=p>{</span>
 <span class=k>struct</span> <span class=n>neigh_hash_table</span> <span class=o>*</span><span class=n>nht</span> <span class=o>=</span> <span class=n>rcu_dereference_bh</span><span class=p>(</span><span class=n>arp_tbl</span><span class=p>.</span><span class=n>nht</span><span class=p>);</span>

 <span class=c1>//计算 hash 值，加速查找
</span><span class=c1></span> <span class=n>hash_val</span> <span class=o>=</span> <span class=n>arp_hashfn</span><span class=p>(......);</span>
 <span class=k>for</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>rcu_dereference_bh</span><span class=p>(</span><span class=n>nht</span><span class=o>-&gt;</span><span class=n>hash_buckets</span><span class=p>[</span><span class=n>hash_val</span><span class=p>]);</span>
   <span class=n>n</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span>
   <span class=n>n</span> <span class=o>=</span> <span class=n>rcu_dereference_bh</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>))</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>==</span> <span class=n>dev</span> <span class=o>&amp;&amp;</span> <span class=o>*</span><span class=p>(</span><span class=n>u32</span> <span class=o>*</span><span class=p>)</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>primary_key</span> <span class=o>==</span> <span class=n>key</span><span class=p>)</span>
   <span class=k>return</span> <span class=n>n</span><span class=p>;</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果查找不到，则调用 __neigh_create 创建一个邻居。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/neighbour.c
</span><span class=c1></span><span class=k>struct</span> <span class=n>neighbour</span> <span class=o>*</span><span class=nf>__neigh_create</span><span class=p>(......)</span>
<span class=p>{</span>
 <span class=c1>//申请邻居表项
</span><span class=c1></span> <span class=k>struct</span> <span class=n>neighbour</span> <span class=o>*</span><span class=n>n1</span><span class=p>,</span> <span class=o>*</span><span class=n>rc</span><span class=p>,</span> <span class=o>*</span><span class=n>n</span> <span class=o>=</span> <span class=n>neigh_alloc</span><span class=p>(</span><span class=n>tbl</span><span class=p>,</span> <span class=n>dev</span><span class=p>);</span>

 <span class=c1>//构造赋值
</span><span class=c1></span> <span class=n>memcpy</span><span class=p>(</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>primary_key</span><span class=p>,</span> <span class=n>pkey</span><span class=p>,</span> <span class=n>key_len</span><span class=p>);</span>
 <span class=n>n</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>=</span> <span class=n>dev</span><span class=p>;</span>
 <span class=n>n</span><span class=o>-&gt;</span><span class=n>parms</span><span class=o>-&gt;</span><span class=n>neigh_setup</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>

 <span class=c1>//最后添加到邻居 hashtable 中
</span><span class=c1></span> <span class=n>rcu_assign_pointer</span><span class=p>(</span><span class=n>nht</span><span class=o>-&gt;</span><span class=n>hash_buckets</span><span class=p>[</span><span class=n>hash_val</span><span class=p>],</span> <span class=n>n</span><span class=p>);</span>
 <span class=p>......</span>
</code></pre></td></tr></table>
</div>
</div><p>有了邻居项以后，此时仍然还不具备发送 IP 报文的能力，因为目的 MAC 地址还未获取。 调用 dst_neigh_output 继续传递 skb。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: include/net/dst.h
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>dst_neigh_output</span><span class=p>(</span><span class=k>struct</span> <span class=n>dst_entry</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> 
     <span class=k>struct</span> <span class=n>neighbour</span> <span class=o>*</span><span class=n>n</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=p>......</span>
 <span class=k>return</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>output</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>skb</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 output，实际指向的是 neigh_resolve_output。在这个函数内部有可能会发出 arp 网络请求。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/neighbour.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>neigh_resolve_output</span><span class=p>(){</span>

 <span class=c1>//注意：这里可能会触发 arp 请求
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>neigh_event_send</span><span class=p>(</span><span class=n>neigh</span><span class=p>,</span> <span class=n>skb</span><span class=p>))</span> <span class=p>{</span>

  <span class=c1>//neigh-&gt;ha 是 MAC 地址
</span><span class=c1></span>  <span class=n>dev_hard_header</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=n>ntohs</span><span class=p>(</span><span class=n>skb</span><span class=o>-&gt;</span><span class=n>protocol</span><span class=p>),</span>
           <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ha</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>skb</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>);</span>
  <span class=c1>//发送
</span><span class=c1></span>  <span class=n>dev_queue_xmit</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>当获取到硬件 MAC 地址以后，就可以封装 skb 的 MAC 头了。最后调用 dev_queue_xmit 将 skb 传递给 Linux 网络设备子系统。</p>
<h3 id=45-网络设备子系统><strong>4.5 网络设备子系统</strong></h3>
<p><img src=https://pic4.zhimg.com/80/v2-6fa56c1f95237a49703f6a0161daa7e3_720w.jpg alt></p>
<p>邻居子系统通过 dev_queue_xmit 进入到网络设备子系统中来。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/dev.c 
</span><span class=c1></span><span class=kt>int</span> <span class=nf>dev_queue_xmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//选择发送队列
</span><span class=c1></span> <span class=n>txq</span> <span class=o>=</span> <span class=n>netdev_pick_tx</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span> <span class=n>skb</span><span class=p>);</span>

 <span class=c1>//获取与此队列关联的排队规则
</span><span class=c1></span> <span class=n>q</span> <span class=o>=</span> <span class=n>rcu_dereference_bh</span><span class=p>(</span><span class=n>txq</span><span class=o>-&gt;</span><span class=n>qdisc</span><span class=p>);</span>

 <span class=c1>//如果有队列，则调用__dev_xmit_skb 继续处理数据
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=n>q</span><span class=o>-&gt;</span><span class=n>enqueue</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>rc</span> <span class=o>=</span> <span class=n>__dev_xmit_skb</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>q</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=n>txq</span><span class=p>);</span>
  <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
 <span class=p>}</span>

 <span class=c1>//没有队列的是回环设备和隧道设备
</span><span class=c1></span> <span class=p>......</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>开篇第二节网卡启动准备里我们说过，网卡是有多个发送队列的（尤其是现在的网卡）。上面对 netdev_pick_tx 函数的调用就是选择一个队列进行发送。</p>
<p>netdev_pick_tx 发送队列的选择受 XPS 等配置的影响，而且还有缓存，也是一套小复杂的逻辑。这里我们只关注两个逻辑，首先会获取用户的 XPS 配置，否则就自动计算了。代码见 netdev_pick_tx => __netdev_pick_tx。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/flow_dissector.c
</span><span class=c1></span><span class=n>u16</span> <span class=nf>__netdev_pick_tx</span><span class=p>(</span><span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//获取 XPS 配置
</span><span class=c1></span> <span class=kt>int</span> <span class=n>new_index</span> <span class=o>=</span> <span class=n>get_xps_queue</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span> <span class=n>skb</span><span class=p>);</span>

 <span class=c1>//自动计算队列
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=n>new_index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
  <span class=n>new_index</span> <span class=o>=</span> <span class=n>skb_tx_hash</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span> <span class=n>skb</span><span class=p>);}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后获取与此队列关联的 qdisc。在 linux 上通过 tc 命令可以看到 qdisc 类型，例如对于我的某台多队列网卡机器上是 mq disc。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-text data-lang=text>#tc qdisc
qdisc mq 0: dev eth0 root
</code></pre></td></tr></table>
</div>
</div><p>大部分的设备都有队列（回环设备和隧道设备除外），所以现在我们进入到 __dev_xmit_skb。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/dev.c
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>__dev_xmit_skb</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>Qdisc</span> <span class=o>*</span><span class=n>q</span><span class=p>,</span>
     <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span>
     <span class=k>struct</span> <span class=n>netdev_queue</span> <span class=o>*</span><span class=n>txq</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//1.如果可以绕开排队系统
</span><span class=c1></span> <span class=k>if</span> <span class=p>((</span><span class=n>q</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TCQ_F_CAN_BYPASS</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>qdisc_qlen</span><span class=p>(</span><span class=n>q</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
     <span class=n>qdisc_run_begin</span><span class=p>(</span><span class=n>q</span><span class=p>))</span> <span class=p>{</span>
  <span class=p>......</span>
 <span class=p>}</span>

 <span class=c1>//2.正常排队
</span><span class=c1></span> <span class=k>else</span> <span class=p>{</span>

  <span class=c1>//入队
</span><span class=c1></span>  <span class=n>q</span><span class=o>-&gt;</span><span class=n>enqueue</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>q</span><span class=p>)</span>

  <span class=c1>//开始发送
</span><span class=c1></span>  <span class=n>__qdisc_run</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码中分两种情况，1 是可以 bypass（绕过）排队系统的，另外一种是正常排队。我们只看第二种情况。</p>
<p>先调用 q->enqueue 把 skb 添加到队列里。然后调用 __qdisc_run 开始发送。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/sched/sch_generic.c
</span><span class=c1></span><span class=kt>void</span> <span class=nf>__qdisc_run</span><span class=p>(</span><span class=k>struct</span> <span class=n>Qdisc</span> <span class=o>*</span><span class=n>q</span><span class=p>)</span>
<span class=p>{</span>
 <span class=kt>int</span> <span class=n>quota</span> <span class=o>=</span> <span class=n>weight_p</span><span class=p>;</span>

 <span class=c1>//循环从队列取出一个 skb 并发送
</span><span class=c1></span> <span class=k>while</span> <span class=p>(</span><span class=n>qdisc_restart</span><span class=p>(</span><span class=n>q</span><span class=p>))</span> <span class=p>{</span>

  <span class=c1>// 如果发生下面情况之一，则延后处理：
</span><span class=c1></span>  <span class=c1>// 1. quota 用尽
</span><span class=c1></span>  <span class=c1>// 2. 其他进程需要 CPU
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>--</span><span class=n>quota</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>need_resched</span><span class=p>())</span> <span class=p>{</span>
   <span class=c1>//将触发一次 NET_TX_SOFTIRQ 类型 softirq
</span><span class=c1></span>   <span class=n>__netif_schedule</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
   <span class=k>break</span><span class=p>;</span>
  <span class=p>}</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在上述代码中，我们看到 while 循环不断地从队列中取出 skb 并进行发送。注意，这个时候其实都占用的是用户进程的系统态时间(sy)。 只有当 quota 用尽或者其它进程需要 CPU 的时候才触发软中断进行发送。</p>
<p><strong>所以这就是为什么一般服务器上查看 /proc/softirqs，一般 NET_RX 都要比 NET_TX 大的多的第二个原因</strong>。对于读来说，都是要经过 NET_RX 软中断，而对于发送来说，只有系统态配额用尽才让软中断上。</p>
<p>我们来把精力在放到 qdisc_restart 上，继续看发送过程。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>qdisc_restart</span><span class=p>(</span><span class=k>struct</span> <span class=n>Qdisc</span> <span class=o>*</span><span class=n>q</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//从 qdisc 中取出要发送的 skb
</span><span class=c1></span> <span class=n>skb</span> <span class=o>=</span> <span class=n>dequeue_skb</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
 <span class=p>...</span>

 <span class=k>return</span> <span class=n>sch_direct_xmit</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>q</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=n>txq</span><span class=p>,</span> <span class=n>root_lock</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>qdisc_restart 从队列中取出一个 skb，并调用 sch_direct_xmit 继续发送。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/sched/sch_generic.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>sch_direct_xmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>Qdisc</span> <span class=o>*</span><span class=n>q</span><span class=p>,</span>
   <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span> <span class=k>struct</span> <span class=n>netdev_queue</span> <span class=o>*</span><span class=n>txq</span><span class=p>,</span>
   <span class=n>spinlock_t</span> <span class=o>*</span><span class=n>root_lock</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//调用驱动程序来发送数据
</span><span class=c1></span> <span class=n>ret</span> <span class=o>=</span> <span class=n>dev_hard_start_xmit</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=n>txq</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=46-软中断调度><strong>4.6 软中断调度</strong></h3>
<p>在 4.5 咱们看到了如果系统态 CPU 发送网络包不够用的时候，会调用 __netif_schedule 触发一个软中断。该函数会进入到 __netif_reschedule，由它来实际发出 NET_TX_SOFTIRQ 类型软中断。</p>
<p>软中断是由内核线程来运行的，该线程会进入到 net_tx_action 函数，在该函数中能获取到发送队列，并也最终调用到驱动程序里的入口函数 dev_hard_start_xmit。</p>
<p><img src=https://pic2.zhimg.com/80/v2-7b7da5c8cebe7a05ef2fddc3b98d7ec5_720w.jpg alt></p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/dev.c
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__netif_reschedule</span><span class=p>(</span><span class=k>struct</span> <span class=n>Qdisc</span> <span class=o>*</span><span class=n>q</span><span class=p>)</span>
<span class=p>{</span>
 <span class=n>sd</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>__get_cpu_var</span><span class=p>(</span><span class=n>softnet_data</span><span class=p>);</span>
 <span class=n>q</span><span class=o>-&gt;</span><span class=n>next_sched</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
 <span class=o>*</span><span class=n>sd</span><span class=o>-&gt;</span><span class=n>output_queue_tailp</span> <span class=o>=</span> <span class=n>q</span><span class=p>;</span>
 <span class=n>sd</span><span class=o>-&gt;</span><span class=n>output_queue_tailp</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>q</span><span class=o>-&gt;</span><span class=n>next_sched</span><span class=p>;</span>

 <span class=p>......</span>
 <span class=n>raise_softirq_irqoff</span><span class=p>(</span><span class=n>NET_TX_SOFTIRQ</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在该函数里在软中断能访问到的 softnet_data 里设置了要发送的数据队列，添加到了 output_queue 里了。紧接着触发了 NET_TX_SOFTIRQ 类型的软中断。（T 代表 transmit 传输）</p>
<p>软中断的入口代码我这里也不详细扒了，感兴趣的同学参考**<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GoYDsfy9m0wRoXi_NCfCmg">《图解Linux网络包接收过程》</a>**一文中的 3.2 小节 - ksoftirqd内核线程处理软中断。</p>
<p>我们直接从 NET_TX_SOFTIRQ softirq 注册的回调函数 net_tx_action讲起。用户态进程触发完软中断之后，会有一个软中断内核线程会执行到 net_tx_action。</p>
<p><strong>牢记，这以后发送数据消耗的 CPU 就都显示在 si 这里了，不会消耗用户进程的系统时间了</strong>。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/dev.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>net_tx_action</span><span class=p>(</span><span class=k>struct</span> <span class=n>softirq_action</span> <span class=o>*</span><span class=n>h</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//通过 softnet_data 获取发送队列
</span><span class=c1></span> <span class=k>struct</span> <span class=n>softnet_data</span> <span class=o>*</span><span class=n>sd</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>__get_cpu_var</span><span class=p>(</span><span class=n>softnet_data</span><span class=p>);</span>

 <span class=c1>// 如果 output queue 上有 qdisc
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=n>sd</span><span class=o>-&gt;</span><span class=n>output_queue</span><span class=p>)</span> <span class=p>{</span>

  <span class=c1>// 将 head 指向第一个 qdisc
</span><span class=c1></span>  <span class=n>head</span> <span class=o>=</span> <span class=n>sd</span><span class=o>-&gt;</span><span class=n>output_queue</span><span class=p>;</span>

  <span class=c1>//遍历 qdsics 列表
</span><span class=c1></span>  <span class=k>while</span> <span class=p>(</span><span class=n>head</span><span class=p>)</span> <span class=p>{</span>
   <span class=k>struct</span> <span class=n>Qdisc</span> <span class=o>*</span><span class=n>q</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span>
   <span class=n>head</span> <span class=o>=</span> <span class=n>head</span><span class=o>-&gt;</span><span class=n>next_sched</span><span class=p>;</span>

   <span class=c1>//发送数据
</span><span class=c1></span>   <span class=n>qdisc_run</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
  <span class=p>}</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>软中断这里会获取 softnet_data。前面我们看到进程内核态在调用 __netif_reschedule 的时候把发送队列写到 softnet_data 的 output_queue 里了。 软中断循环遍历 sd->output_queue 发送数据帧。</p>
<p>来看 qdisc_run，它和进程用户态一样，也会调用到 __qdisc_run。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: include/net/pkt_sched.h
</span><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>qdisc_run</span><span class=p>(</span><span class=k>struct</span> <span class=n>Qdisc</span> <span class=o>*</span><span class=n>q</span><span class=p>)</span>
<span class=p>{</span>
 <span class=k>if</span> <span class=p>(</span><span class=n>qdisc_run_begin</span><span class=p>(</span><span class=n>q</span><span class=p>))</span>
  <span class=n>__qdisc_run</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后一样就是进入 qdisc_restart => sch_direct_xmit，直到驱动程序函数 dev_hard_start_xmit。</p>
<h3 id=47-igb-网卡驱动发送><strong>4.7 igb 网卡驱动发送</strong></h3>
<p>我们前面看到，无论是对于用户进程的内核态，还是对于软中断上下文，都会调用到网络设备子系统中的 dev_hard_start_xmit 函数。在这个函数中，会调用到驱动里的发送函数 igb_xmit_frame。</p>
<p>在驱动函数里，将 skb 会挂到 RingBuffer上，驱动调用完毕后，数据包将真正从网卡发送出去。</p>
<p><img src=https://pic1.zhimg.com/80/v2-dd72dd5d2ddcaa38bcde752bb5d073c4_720w.jpg alt></p>
<p>我们来看看实际的源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: net/core/dev.c
</span><span class=c1></span><span class=kt>int</span> <span class=nf>dev_hard_start_xmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span>
   <span class=k>struct</span> <span class=n>netdev_queue</span> <span class=o>*</span><span class=n>txq</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//获取设备的回调函数集合 ops
</span><span class=c1></span> <span class=k>const</span> <span class=k>struct</span> <span class=n>net_device_ops</span> <span class=o>*</span><span class=n>ops</span> <span class=o>=</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>netdev_ops</span><span class=p>;</span>

 <span class=c1>//获取设备支持的功能列表
</span><span class=c1></span> <span class=n>features</span> <span class=o>=</span> <span class=n>netif_skb_features</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>

 <span class=c1>//调用驱动的 ops 里面的发送回调函数 ndo_start_xmit 将数据包传给网卡设备
</span><span class=c1></span> <span class=n>skb_len</span> <span class=o>=</span> <span class=n>skb</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>;</span>
 <span class=n>rc</span> <span class=o>=</span> <span class=n>ops</span><span class=o>-&gt;</span><span class=n>ndo_start_xmit</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>dev</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 ndo_start_xmit 是网卡驱动要实现的一个函数，是在 net_device_ops 中定义的。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: include/linux/netdevice.h
</span><span class=c1></span><span class=k>struct</span> <span class=n>net_device_ops</span> <span class=p>{</span>
 <span class=n>netdev_tx_t</span>  <span class=p>(</span><span class=o>*</span><span class=n>ndo_start_xmit</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span>
         <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>);</span>

<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 igb 网卡驱动源码中，我们找到了。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>net_device_ops</span> <span class=n>igb_netdev_ops</span> <span class=o>=</span> <span class=p>{</span>
 <span class=p>.</span><span class=n>ndo_open</span>  <span class=o>=</span> <span class=n>igb_open</span><span class=p>,</span>
 <span class=p>.</span><span class=n>ndo_stop</span>  <span class=o>=</span> <span class=n>igb_close</span><span class=p>,</span>
 <span class=p>.</span><span class=n>ndo_start_xmit</span>  <span class=o>=</span> <span class=n>igb_xmit_frame</span><span class=p>,</span> 
 <span class=p>...</span>
<span class=p>};</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是说，对于网络设备层定义的 ndo_start_xmit， igb 的实现函数是 igb_xmit_frame。这个函数是在网卡驱动初始化的时候被赋值的。具体初始化过程参见**<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GoYDsfy9m0wRoXi_NCfCmg">《图解Linux网络包接收过程》</a>**一文中的 2.4 节，网卡驱动初始化。</p>
<p>所以在上面网络设备层调用 ops->ndo_start_xmit 的时候，会实际上进入 igb_xmit_frame 这个函数中。我们进入这个函数来看看驱动程序是如何工作的。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=k>static</span> <span class=n>netdev_tx_t</span> <span class=nf>igb_xmit_frame</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span>
      <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>netdev</span><span class=p>)</span>
<span class=p>{</span>
 <span class=p>......</span>
 <span class=k>return</span> <span class=n>igb_xmit_frame_ring</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>igb_tx_queue_mapping</span><span class=p>(</span><span class=n>adapter</span><span class=p>,</span> <span class=n>skb</span><span class=p>));</span>
<span class=p>}</span>

<span class=n>netdev_tx_t</span> <span class=nf>igb_xmit_frame_ring</span><span class=p>(</span><span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>,</span>
    <span class=k>struct</span> <span class=n>igb_ring</span> <span class=o>*</span><span class=n>tx_ring</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//获取TX Queue 中下一个可用缓冲区信息
</span><span class=c1></span> <span class=n>first</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>tx_buffer_info</span><span class=p>[</span><span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>next_to_use</span><span class=p>];</span>
 <span class=n>first</span><span class=o>-&gt;</span><span class=n>skb</span> <span class=o>=</span> <span class=n>skb</span><span class=p>;</span>
 <span class=n>first</span><span class=o>-&gt;</span><span class=n>bytecount</span> <span class=o>=</span> <span class=n>skb</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>;</span>
 <span class=n>first</span><span class=o>-&gt;</span><span class=n>gso_segs</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

 <span class=c1>//igb_tx_map 函数准备给设备发送的数据。
</span><span class=c1></span> <span class=n>igb_tx_map</span><span class=p>(</span><span class=n>tx_ring</span><span class=p>,</span> <span class=n>first</span><span class=p>,</span> <span class=n>hdr_len</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里从网卡的发送队列的 RingBuffer 中取下来一个元素，并将 skb 挂到元素上。</p>
<p><img src=https://pic1.zhimg.com/80/v2-53210da030eea44896489582bbbc13f0_720w.jpg alt></p>
<p>igb_tx_map 函数处理将 skb 数据映射到网卡可访问的内存 DMA 区域。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>igb_tx_map</span><span class=p>(</span><span class=k>struct</span> <span class=n>igb_ring</span> <span class=o>*</span><span class=n>tx_ring</span><span class=p>,</span>
      <span class=k>struct</span> <span class=n>igb_tx_buffer</span> <span class=o>*</span><span class=n>first</span><span class=p>,</span>
      <span class=k>const</span> <span class=n>u8</span> <span class=n>hdr_len</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//获取下一个可用描述符指针
</span><span class=c1></span> <span class=n>tx_desc</span> <span class=o>=</span> <span class=n>IGB_TX_DESC</span><span class=p>(</span><span class=n>tx_ring</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>

 <span class=c1>//为 skb-&gt;data 构造内存映射，以允许设备通过 DMA 从 RAM 中读取数据
</span><span class=c1></span> <span class=n>dma</span> <span class=o>=</span> <span class=n>dma_map_single</span><span class=p>(</span><span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>dev</span><span class=p>,</span> <span class=n>skb</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>DMA_TO_DEVICE</span><span class=p>);</span>

 <span class=c1>//遍历该数据包的所有分片,为 skb 的每个分片生成有效映射
</span><span class=c1></span> <span class=k>for</span> <span class=p>(</span><span class=n>frag</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>skb_shinfo</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>frags</span><span class=p>[</span><span class=mi>0</span><span class=p>];;</span> <span class=n>frag</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>

  <span class=n>tx_desc</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>.</span><span class=n>buffer_addr</span> <span class=o>=</span> <span class=n>cpu_to_le64</span><span class=p>(</span><span class=n>dma</span><span class=p>);</span>
  <span class=n>tx_desc</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>.</span><span class=n>cmd_type_len</span> <span class=o>=</span> <span class=p>...;</span>
  <span class=n>tx_desc</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>.</span><span class=n>olinfo_status</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
 <span class=p>}</span>

 <span class=c1>//设置最后一个descriptor
</span><span class=c1></span> <span class=n>cmd_type</span> <span class=o>|=</span> <span class=n>size</span> <span class=o>|</span> <span class=n>IGB_TXD_DCMD</span><span class=p>;</span>
 <span class=n>tx_desc</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>.</span><span class=n>cmd_type_len</span> <span class=o>=</span> <span class=n>cpu_to_le32</span><span class=p>(</span><span class=n>cmd_type</span><span class=p>);</span>

 <span class=cm>/* Force memory writes to complete before letting h/w know there
</span><span class=cm>  * are new descriptors to fetch
</span><span class=cm>  */</span>
 <span class=n>wmb</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>当所有需要的描述符都已建好，且 skb 的所有数据都映射到 DMA 地址后，驱动就会进入到它的最后一步，触发真实的发送。</p>
<h3 id=48-发送完成硬中断><strong>4.8 发送完成硬中断</strong></h3>
<p>当数据发送完成以后，其实工作并没有结束。因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存。</p>
<p>在**<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GoYDsfy9m0wRoXi_NCfCmg">《图解Linux网络包接收过程》</a>** 一文中的 3.1 和 3.2 小节，我们详细讲述过硬中断和软中断的处理过程。</p>
<p>在发送硬中断里，会执行 RingBuffer 内存的清理工作，如图。</p>
<p><img src=https://pic1.zhimg.com/80/v2-4a1721e48e34c50390132f018c5ad1d4_720w.jpg alt></p>
<p>再回头看一下硬中断触发软中断的源码。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=nx>static</span> <span class=nx>inline</span> <span class=nx>void</span> <span class=nf>____napi_schedule</span><span class=p>(</span><span class=o>...</span><span class=p>){</span>
 <span class=nf>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>napi</span><span class=o>-</span><span class=p>&gt;</span><span class=nx>poll_list</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>sd</span><span class=o>-</span><span class=p>&gt;</span><span class=nx>poll_list</span><span class=p>);</span>
 <span class=nf>__raise_softirq_irqoff</span><span class=p>(</span><span class=nx>NET_RX_SOFTIRQ</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里有个很有意思的细节，无论硬中断是因为是有数据要接收，还是说发送完成通知，<strong>从硬中断触发的软中断都是 NET_RX_SOFTIRQ</strong>。 这个我们在第一节说过了，这是软中断统计中 RX 要高于 TX 的一个原因。</p>
<p>好我们接着进入软中断的回调函数 igb_poll。在这个函数里，我们注意到有一行 igb_clean_tx_irq，参见源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=nx>static</span> <span class=kt>int</span> <span class=nf>igb_poll</span><span class=p>(</span><span class=kd>struct</span> <span class=nx>napi_struct</span> <span class=o>*</span><span class=nx>napi</span><span class=p>,</span> <span class=kt>int</span> <span class=nx>budget</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//performs the transmit completion operations
</span><span class=c1></span> <span class=k>if</span> <span class=p>(</span><span class=nx>q_vector</span><span class=o>-</span><span class=p>&gt;</span><span class=nx>tx</span><span class=p>.</span><span class=nx>ring</span><span class=p>)</span>
  <span class=nx>clean_complete</span> <span class=p>=</span> <span class=nf>igb_clean_tx_irq</span><span class=p>(</span><span class=nx>q_vector</span><span class=p>);</span>
 <span class=o>...</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们来看看当传输完成的时候，igb_clean_tx_irq 都干啥了。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//file: drivers/net/ethernet/intel/igb/igb_main.c
</span><span class=c1></span><span class=k>static</span> <span class=kt>bool</span> <span class=nf>igb_clean_tx_irq</span><span class=p>(</span><span class=k>struct</span> <span class=n>igb_q_vector</span> <span class=o>*</span><span class=n>q_vector</span><span class=p>)</span>
<span class=p>{</span>
 <span class=c1>//free the skb
</span><span class=c1></span> <span class=n>dev_kfree_skb_any</span><span class=p>(</span><span class=n>tx_buffer</span><span class=o>-&gt;</span><span class=n>skb</span><span class=p>);</span>

 <span class=c1>//clear tx_buffer data
</span><span class=c1></span> <span class=n>tx_buffer</span><span class=o>-&gt;</span><span class=n>skb</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
 <span class=n>dma_unmap_len_set</span><span class=p>(</span><span class=n>tx_buffer</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

 <span class=c1>// clear last DMA location and unmap remaining buffers */
</span><span class=c1></span> <span class=k>while</span> <span class=p>(</span><span class=n>tx_desc</span> <span class=o>!=</span> <span class=n>eop_desc</span><span class=p>)</span> <span class=p>{</span>
 <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>无非就是清理了 skb，解除了 DMA 映射等等。 到了这一步，传输才算是基本完成了。</p>
<p>为啥我说是基本完成，而不是全部完成了呢？因为传输层需要保证可靠性，所以 skb 其实还没有删除。它得等收到对方的 ACK 之后才会真正删除，那个时候才算是彻底的发送完毕。</p>
<h2 id=最后><strong>最后</strong></h2>
<p>用一张图总结一下整个发送过程</p>
<p><img src=https://pic4.zhimg.com/80/v2-ecb73e1531032fea52e21644f2aa1413_720w.jpg alt></p>
<p>了解了整个发送过程以后，我们回头再来回顾开篇提到的几个问题。</p>
<p><strong>1.我们在监控内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？</strong></p>
<p>在网络包的发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的事情都干了。 只有当内核态进程被切走前才会发起软中断。 发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。</p>
<p>只有一少部分情况下才会触发软中断（NET_TX 类型），由软中断 ksoftirqd 内核进程来发送。</p>
<p>所以，在监控网络 IO 对服务器造成的 CPU 开销的时候，不能仅仅只看 si，而是应该把 si、sy 都考虑进来。</p>
<p><strong>2. 在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？</strong></p>
<p>之前我认为 NET_RX 是读取，NET_TX 是传输。对于一个既收取用户请求，又给用户返回的 Server 来说。 这两块的数字应该差不多才对，至少不会有数量级的差异。但事实上，飞哥手头的一台服务器是这样的：</p>
<p><img src=https://pic1.zhimg.com/80/v2-519963353aadc56140fc233c7bdf6db0_720w.jpg alt></p>
<p>经过今天的源码分析，发现这个问题的原因有两个。</p>
<p>第一个原因是当数据发送完成以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收，还是对于发送完毕，触发的软中断都是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。</p>
<p>第二个原因是对于读来说，都是要经过 NET_RX 软中断的，都走 ksoftirqd 内核进程。而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出 NET_TX，让软中断上。</p>
<p>综上两个原因，那么在机器上查看 NET_RX 比 NET_TX 大的多就不难理解了。</p>
<p><strong>3.发送网络数据的时候都涉及到哪些内存拷贝操作？</strong></p>
<p>这里的内存拷贝，我们只特指待发送数据的内存拷贝。</p>
<p>第一次拷贝操作是内核申请完 skb 之后，这时候会将用户传递进来的 buffer 里的数据内容都拷贝到 skb 中。如果要发送的数据量比较大的话，这个拷贝操作开销还是不小的。</p>
<p>第二次拷贝操作是从传输层进入网络层的时候，每一个 skb 都会被克隆一个新的副本出来。网络层以及下面的驱动、软中断等组件在发送完成的时候会将这个副本删除。传输层保存着原始的 skb，在当网络对方没有 ack 的时候，还可以重新发送，以实现 TCP 中要求的可靠传输。</p>
<p>第三次拷贝不是必须的，只有当 IP 层发现 skb 大于 MTU 时才需要进行。会再申请额外的 skb，并将原来的 skb 拷贝为多个小的 skb。</p>
<blockquote>
<p>这里插入个题外话，大家在网络性能优化中经常听到的零拷贝，我觉得这有点点夸张的成分。TCP 为了保证可靠性，第二次的拷贝根本就没法省。如果包再大于 MTU 的话，分片时的拷贝同样也避免不了。</p>
</blockquote>
<p>看到这里，相信内核发送数据包对于你来说，已经不再是一个完全不懂的黑盒了。本文哪怕你只看懂十分之一，你也已经掌握了这个黑盒的打开方式。这在你将来优化网络性能时你就会知道从哪儿下手了。</p>
<h2 id=参考><strong>参考</strong></h2>
<ul>
<li><a href="https://link.zhihu.com/?target=https%3A//blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/">Monitoring and Tuning the Linux Networking Stack: Sending Data</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_34258344/article/details/108956205">上述文章的一个翻译版本,只翻译了一半</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//ggaaooppeenngg.github.io/zh-CN/2017/08/07/neighboring-subsystem-%25E6%25B5%2585%25E6%259E%2590/">翻译的是另外一半，neighboring subsystem 浅析</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/network_ljr14/">LINUX内核网络数据包发送（四）——LINUX NETDEVICE 子系统</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/network_ljr13/">LINUX内核网络数据包发送（三）——IP协议层分析</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/dma_bjq/">LINUX网络子系统中DMA机制的实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_43722423/article/details/103276437">Linux socket 数据发送过程深入分析</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//man7.org/linux/man-pages/man2/send.2.html">send 函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//ivanzz1001.github.io/records/post/linux/2017/11/04/linux-msghdr">Linux msghdr结构讲解</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/zhangskd/article/details/48207553">TCP的发送系列 — tcp_sendmsg()的实现（一）</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/myguaiguai/p/12069485.html">参考：send和recv背后数据的收发过程</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/luckywang1103/article/details/51422664">linux net子系统-协议层（传输层与网络层)</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/network_ljr_no1/">LINUX内核网络（一）——初探内核网络</a></li>
</ul>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2022-06-04 10:26:13
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/alipay_reward_qrcode.png>
<span>支付宝打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/bitcoin_reward_qrcode.png>
<span>比特币打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/linux/>linux</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bfuse/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">FUSE- linux用户空间文件系统(转)</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/21.linux/linux%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95/>
<span class="next-text nav-default">Linux内存管理</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
<div class=modal-dialog>
<div class=modal-content>
<div id=closeSearch title=Close class=close>X</div>
<div id=fastSearch>
<input id=searchInput tabindex=0>
<ul id=searchResults>
</ul>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2024
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script>$("#search-btn").click(function(){$(".modal-dialog").addClass("visible")}),$("#closeSearch").click(function(){$(".modal-dialog").removeClass("visible")}),$(document).click(function(a){$(a.target).closest(".modal-content, #search-btn").length||$("body").find(".modal-dialog").removeClass("visible")})</script>
<script src=/js/fuse.min.js></script>
<script src=/js/fastsearch.js></script>
</body>
</html>