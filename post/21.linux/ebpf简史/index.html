<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>eBPF简史(转) - Justice的小站</title>
<meta name=renderer content="webkit">
<meta name=referrer content="no-referrer">
<meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes">
<meta name=MobileOptimized content="width">
<meta name=HandheldFriendly content="true">
<meta name=applicable-device content="pc,mobile">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=mobile-web-app-capable content="yes">
<meta name=author content="Justice">
<meta name=description content="eBPF简史(转) 源头：一篇 1992 年的论文 考虑到 BPF 的知名度，在介绍 eBPF 之前，笔者自觉还是有必要先来回答另一个问题： 什么是 BPF? 笔者在前文中说过了，BP">
<meta name=keywords content="tech,it,blog">
<meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://justice.bj.cn/post/21.linux/ebpf%E7%AE%80%E5%8F%B2/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/sass/jane.min.34a0cf3583dc0fd6b4e3fe24a36c076984feee75ebc2792cff33928ccdcfc628.css integrity="sha256-NKDPNYPcD9a04/4ko2wHaYT+7nXrwnks/zOSjM3Pxig=" media=screen crossorigin=anonymous>
<meta property="og:title" content="eBPF简史(转)">
<meta property="og:description" content="eBPF简史(转) 源头：一篇 1992 年的论文 考虑到 BPF 的知名度，在介绍 eBPF 之前，笔者自觉还是有必要先来回答另一个问题： 什么是 BPF? 笔者在前文中说过了，BP">
<meta property="og:type" content="article">
<meta property="og:url" content="https://justice.bj.cn/post/21.linux/ebpf%E7%AE%80%E5%8F%B2/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-06-04T10:26:13+08:00">
<meta property="article:modified_time" content="2022-06-04T10:26:13+08:00"><meta property="og:site_name" content="Justice的小站">
<meta itemprop=name content="eBPF简史(转)">
<meta itemprop=description content="eBPF简史(转) 源头：一篇 1992 年的论文 考虑到 BPF 的知名度，在介绍 eBPF 之前，笔者自觉还是有必要先来回答另一个问题： 什么是 BPF? 笔者在前文中说过了，BP"><meta itemprop=datePublished content="2022-06-04T10:26:13+08:00">
<meta itemprop=dateModified content="2022-06-04T10:26:13+08:00">
<meta itemprop=wordCount content="10810">
<meta itemprop=keywords content="linux,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="eBPF简史(转)">
<meta name=twitter:description content="eBPF简史(转) 源头：一篇 1992 年的论文 考虑到 BPF 的知名度，在介绍 eBPF 之前，笔者自觉还是有必要先来回答另一个问题： 什么是 BPF? 笔者在前文中说过了，BP"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Justice's Blog</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li><li class=mobile-menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=mobile-menu-item>
<a id=openSearchMobile class="mobile-menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
<link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css>
<link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div>
<div class=modal-dialog>
<div class=modal-content>
<div id=closeSearch title=Close class=close>X</div>
<div class=modal-header>
<div class=modal-title>Search</div>
</div>
<div class=modal-body>
<script>(function(){var c='05bff2da94121334a',a=document.createElement('script'),b;a.type='text/javascript',a.async=!0,a.src=(document.location.protocol=='https:'?'https:':'http:')+'//cse.google.com/cse.js?cx='+c,b=document.getElementsByTagName('script')[0],b.parentNode.insertBefore(a,b)})()</script>
<gcse:search></gcse:search>
</div>
</div>
</div>
<header id=header class="header container">
<div class=logo-wrapper>
<a href=/ class=logo>
Justice's Blog
</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/>主页</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/post/>点滴</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/tags/>标签</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=https://justice.bj.cn/categories/>分类</a>
</li>
<li class=menu-item>
<a class=menu-item-link href=http://passer-by.com/pacman/ rel=noopener target=_blank>
更多
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg>
</i>
</a>
</li>
<li class=menu-item>
<a id=openSearch class="menu-item-link menu-item-search" href=#>
<i class=iconfont><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M973.81454219 973.81454219a91.78207815 91.78207815.0 01-129.80999631.0L682.0297247 811.83972101a425.48527711 425.48527711.0 01-230.35931791 68.16531768 428.3346319 428.3346319.0 11428.3346319-428.3346319A425.48527711 425.48527711.0 01811.83972101 682.0297247l162.02961656 161.97482118a91.83687354 91.83687354.0 01-.05479538 129.80999631zm-522.1441354-828.1209266a305.97679241 305.97679241.0 100 611.95358361 305.97679241 305.97679241.0 000-611.95358361z"/></svg>
</i>
</a>
</li>
</ul>
</nav>
</header>
<div id=mobile-panel>
<main id=main class="main bg-llight">
<div class=content-wrapper>
<div id=content class="content container">
<article class="post bg-white">
<header class=post-header>
<h1 class=post-title>eBPF简史(转)</h1>
<div class=post-meta>
<time datetime=2022-06-04 class=post-time>
2022-06-04 10:26:13
</time>
<div class=post-category>
<a href=https://justice.bj.cn/categories/linux/> linux </a>
</div>
<span id=busuanzi_container_page_pv>
| 阅读 <span id=busuanzi_value_page_pv></span>
</span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class=post-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#源头一篇-1992-年的论文>源头：一篇 1992 年的论文</a></li>
<li><a href=#什么是-bpf>什么是 BPF?</a>
<ul>
<li><a href=#pseudo-machine-language>Pseudo Machine Language</a></li>
<li><a href=#lsf-linux-下的-bpf-实现>LSF: Linux 下的 BPF 实现</a></li>
<li><a href=#演进jit-for-bpf>演进：JIT For BPF</a></li>
</ul>
</li>
<li><a href=#进化extended-bpf>进化：extended BPF</a>
<ul>
<li></li>
<li><a href=#再见了汇编>再见了汇编</a></li>
<li><a href=#bpf-程序的类别以及-map-机制>BPF 程序的类别以及 Map 机制</a></li>
<li><a href=#新的指令集>新的指令集</a></li>
<li><a href=#in-kernel-verifier>In-kernel Verifier</a></li>
<li><a href=#overview-ebpf-的架构>Overview: eBPF 的架构</a></li>
<li><a href=#追求极简bpf-compiler-collectionbcc>追求极简：BPF Compiler Collection(BCC)</a></li>
</ul>
</li>
<li><a href=#结束语>结束语</a></li>
<li><a href=#参考资源>参考资源</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h1 id=ebpf简史转>eBPF简史(转)</h1>
<h2 id=源头一篇-1992-年的论文>源头：一篇 1992 年的论文</h2>
<p>考虑到 BPF 的知名度，在介绍 eBPF 之前，笔者自觉还是有必要先来回答另一个问题：</p>
<h2 id=什么是-bpf>什么是 BPF?</h2>
<p>笔者在前文中说过了，BPF 的全称是 Berkeley Packet Filter，顾名思义，这是一个用于过滤(filter)网络报文(packet)的架构。</p>
<p>其实 BPF 可谓是名气不大，作用不小的典范：如果笔者一开始提出 BPF 的同时还捎带上大名鼎鼎的 tcpdump 或 wireshark，估计绝大部分读者都会了然了：BPF 即为 tcpdump 抑或 wireshark 乃至网络监控(Network Monitoring)领域的基石。</p>
<p>今天我们看到的 BPF 的设计，最早可以追溯到 1992 年刊行在 USENIX conference 上的一篇论文：The BSD Packet Filter: A New Architecture for User-level Packet Capture。由于最初版本的 BPF 是实现于 BSD 系统之上的，于是在论文中作者称之为"BSD Packet Filter"；后来由于 BPF 的理念渐成主流，为各大操作系统所接受，B 所代表的 BSD 便也渐渐淡去，最终演化成了今天我们眼中的 Berkeley Packet Filter。</p>
<p>诚然，无论 BSD 和 Berkeley 如何变换，其后的 Packet Filter 总是不变的，这两个单词也基本概括了 BPF 的两大核心功能：</p>
<ul>
<li>过滤(Filter): 根据外界输入的规则过滤报文；</li>
<li>复制(Copy)：将符合条件的报文由内核空间复制到用户空间；</li>
</ul>
<p>以 tcpdump 为例：熟悉网络监控(network monitoring)的读者大抵都知道 tcpdump 依赖于 pcap 库，tcpdump 中的诸多核心功能都经由后者实现，其整体工作流程如下图所示：</p>
<p>图 1. Tcpdump 工作流程</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-22-55-epbf-image001.png alt></p>
<p>由图 1 不难看出，位于内核之中的 BPF 模块是整个流程之中最核心的一环：它一方面接受 tcpdump 经由 libpcap 转码而来的滤包条件(Pseudo Machine Language) ，另一方面也将符合条件的报文复制到用户空间最终经由 libpcap 发送给 tcpdump。</p>
<p>读到这里，估计有经验的读者已经能够在脑海里大致勾勒出一个 BPF 实现的大概了，图 2 引自文献 1，读者们可以管窥一下当时 BPF 的设计：</p>
<p>图 2. BPF Overview</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-01-epbf002.png alt></p>
<p>时至今日，传统 BPF 仍然遵循图 2 的路数：途经网卡驱动层的报文在上报给协议栈的同时会多出一路来传送给 BPF，再经后者过滤后最终拷贝给用户态的应用。除开本文提及的 tcpdump，当时的 RARP 协议也可以利用 BPF 工作(Linux 2.2 起，内核开始提供 rarp 功能，因此如今的 RARP 已经不再需要 BPF 了)。</p>
<p>整体来说，BPF 的架构还是相对浅显易懂的，不过要是深入细节的话就没那么容易了：因为其中的 filter 的设计（也是文献 1 中着墨最多的地方）要复杂那么一点点。</p>
<h3 id=pseudo-machine-language>Pseudo Machine Language</h3>
<p>估计在阅读本文之前，相当数量的读者都会误以为所谓的 Filter</p>
<p>的是挂在 tcpdump 末尾处的 expression 吧，类似于图 1 中的"tcp and dst port 7070"这样。但倘若我们如下文这样在 tcpdump 的调用中加入一个-d，还会发现其中大有乾坤：</p>
<p>清单 1 tcpdump -d</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>#以下代码可以在任意支持 tcpdump 的类 Unix 平台上运行，输出大同小异   
bash-3.2$ sudo tcpdump -d -i lo tcp and dst port 7070
(000) ldh [12]
(001) jeq #0x86dd jt 2 jf 6 #检测是否为 ipv6 报文，若为假(jf)则按照 ipv4 报文处理(L006)
(002) ldb [20]
(003) jeq #0x6 jt 4 jf 15 #检测是否为 tcp 报文
(004) ldh [56]
(005) jeq #0x1b9e jt 14 jf 15 #检测是否目标端口为 7070(0x1b9e)，若为真(jt)则跳转 L014
(006) jeq #0x800 jt 7 jf 15 #检测是否为 ipv4 报文
(007) ldb [23]
(008) jeq #0x6 jt 9 jf 15 #检测是否为 tcp 报文
(009) ldh [20]
(010) jset #0x1fff jt 15 jf 11 #检测是否为 ip 分片(IP fragmentation)报文
(011) ldxb 4*([14]&amp;0xf)
(012) ldh [x + 16] #找到 tcp 报文中 dest port 的所在位置
(013) jeq #0x1b9e jt 14 jf 15 #检测是否目标端口为 7070(0x1b9e)，若为真(jt)则跳转 L014
(014) ret #262144 #该报文符合要求
(015) ret #0 #该报文不符合要求
</code></pre></td></tr></table>
</div>
</div><p>根据 man page，tcpdump 的-d 会将输入的 expression 转义为一段"human readable"的"compiled packet-matching code"。当然，如清单 1 中的内容，对于很多道行不深的读者来说，基本是"human unreadable"的，于是笔者专门加入了一些注释加以解释，但是相较于-dd 和-ddd 反人类的输出，这确可以称得上是"一目了然"的代码了。</p>
<p>这段看起来类似于汇编的代码，便是 BPF 用于定义 Filter 的伪代码，亦即图 1 中 libpcap 和内核交互的 pseudo machine language(也有一种说法是，BPF 伪代码设计之初参考过当时大行其道的 RISC 令集的设计理念)，当 BPF 工作时，每一个进出网卡的报文都会被这一段代码过滤一遍，其中符合条件的(ret #262144)会被复制到用户空间，其余的(ret #0)则会被丢弃。</p>
<p>BPF 采用的报文过滤设计的全称是 CFG(Computation Flow Graph)，顾名思义是将过滤器构筑于一套基于 if-else 的控制流(flow graph)之上，例如清单 1 中的 filter 就可以用图 3 来表示：</p>
<p>图 3 基于 CFG 实现的 filter 范例</p>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-07-epbf003.png alt></p>
<p>CFG 模型最大的优势是快，参考文献 1 中就比较了 CFG 模型和基于树型结构构建出的 CSPF 模型的优劣，得出了基于 CFG 模型需要的运算量更小的结论；但从另一个角度来说，基于伪代码的设计却也增加了系统的复杂性：一方面伪指令集已经足够让人眼花缭乱的了；另一方面为了执行伪代码，内核中还需要专门实现一个虚拟机(pseudo-machine)，这也在一定程度上提高了开发和维护的门槛。</p>
<p>当然，或许是为了提升系统的易用性，一方面 BPF 设计者们又额外在 tcpdump 中设计了我们今天常见的过滤表达式(实际实现于 libpcap，当然两者也都源于 Lawrence Berkeley Lab)，令过滤器真正意义上"Human Readable"了起来；另一方面，由于设计目标只是过滤字节流形式的报文，虚拟机及其伪指令集的设计相对会简单不少：整个虚拟机只实现了两个 32 位的寄存器，分别是用于运算的累加器 A 和通用寄存器 X；且指令集也只有寥寥 20 来个，如表 1 所示：</p>
<table>
<thead>
<tr>
<th><strong>Category</strong></th>
<th><strong>Opcodes</strong></th>
<th><strong>Address modes</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Load Instructions</strong></td>
<td>ldb</td>
<td>[k]</td>
<td>[x+k]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ldh</td>
<td>[k]</td>
<td>[x+k]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ld</td>
<td>#k</td>
<td>#len</td>
<td>M[k]</td>
<td>[k]</td>
<td>[x+k]</td>
</tr>
<tr>
<td></td>
<td>ldx</td>
<td>#k</td>
<td>#len</td>
<td>M[k]</td>
<td>4 * ([k] & 0xf)</td>
<td></td>
</tr>
<tr>
<td><strong>Store Instructions</strong></td>
<td>st</td>
<td>M[k]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>stx</td>
<td>M[k]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ALU Instruction</strong></td>
<td>add</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>sub</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>mul</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>div</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>and</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>or</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>lsh</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>rsh</td>
<td>#k</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Branch Instruction</strong></td>
<td>jmp</td>
<td>L</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>jeq</td>
<td>#k, Lt, Lf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>jgt</td>
<td>#k, Lt, Lf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>jge</td>
<td>#k, Lt, Lf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>jset</td>
<td>#k, Lt, Lf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Misc Instruction</strong></td>
<td>tax</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>txa</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Return Instruction</strong></td>
<td>ret</td>
<td>#k</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>易用性方面的提升很大程度上弥补了 BPF 本身的复杂度带来的缺憾，很大程度上推动了 BPF 的发展，此后数年，BPF 逐渐称为大众所认同，包括 Linux 在内的众多操作系统都开始将 BPF 引入了内核。</p>
<p>鉴于 Linux 上 BPF 如火如荼的大好形势，本文余下的部分笔者将基于 Linux 上的 BPF 实现进行展开。</p>
<h3 id=lsf-linux-下的-bpf-实现>LSF: Linux 下的 BPF 实现</h3>
<p>BPF 是在 1997 年首次被引入 Linux 的，当时的内核版本尚为 2.1.75。准确的说，Linux 内核中的报文过滤机制其实是有自己的名字的：Linux Socket Filter，简称 LSF。但也许是因为 BPF 名声太大了吧，连<a href=https://www.kernel.org/doc/Documentation/networking/filter.txt>内核文档</a>都不大买这个帐，直言 LSF 其实就是(aka)BPF。</p>
<p>当然，LSF 和 BPF 除了名字上的差异以外，还是有些不同的，首当其冲的分歧就是接口：传统的 BSD 开启 BPF 的方式主要是靠打开(open)/dev/bpfX 设备，之后利用 ioctl 来进行控制；而 linux 则选择了利用套接字选项(sockopt)SO_ATTACH_FILTER/SO_DETACH_FILTER 来执行系统调用，篇幅所限，这部分内容笔者就不深入了，有兴趣的读者可以通过移步<a href=http://man7.org/linux/man-pages/man7/socket.7.html>socket 的 manual page</a>或<a href=https://www.kernel.org/doc/Documentation/networking/filter.txt>内核 filter 文档</a>深入了解。这里笔者只给出一个例子来让读者们对 Linux 下的 BPF 的开发有一个直观的感受：</p>
<h5 id=清单-2-bpf-sample>清单 2 BPF Sample</h5>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;……&gt;</span><span class=cp>
</span><span class=cp></span><span class=c1>// tcpdump -dd 生成出的伪代码块
</span><span class=c1>// instruction format:
</span><span class=c1>// opcode: 16bits; jt: 8bits; jf: 8bits; k: 32bits
</span><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=n>sock_filter</span> <span class=n>code</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
    <span class=p>{</span> <span class=mh>0x28</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x0000000c</span> <span class=p>},</span> <span class=c1>// (000) ldh [12]
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x15</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mh>0x000086dd</span> <span class=p>},</span> <span class=c1>// (001) jeq #0x86dd jt 2 jf 6
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x30</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00000014</span> <span class=p>},</span> <span class=c1>// (002) ldb [20]
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x15</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mh>0x00000006</span> <span class=p>},</span> <span class=c1>// (003) jeq #0x6 jt 4 jf 15
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x28</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00000038</span> <span class=p>},</span> <span class=c1>// (004) ldh [56]
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x15</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mh>0x00000438</span> <span class=p>},</span> <span class=c1>// (005) jeq #0x438 jt 14 jf 15
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x15</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mh>0x00000800</span> <span class=p>},</span> <span class=c1>// (006) jeq #0x800 jt 7 jf 15
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x30</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00000017</span> <span class=p>},</span> <span class=c1>// (007) ldb [23]
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x15</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mh>0x00000006</span> <span class=p>},</span> <span class=c1>// (008) jeq #0x6 jt 9 jf 15
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x28</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00000014</span> <span class=p>},</span> <span class=c1>// (009) ldh [20]
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x45</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00001fff</span> <span class=p>},</span> <span class=c1>// (010) jset #0x1fff jt 15 jf 11
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0xb1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x0000000e</span> <span class=p>},</span> <span class=c1>// (011) ldxb 4*([14]&amp;0xf)
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x48</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00000010</span> <span class=p>},</span> <span class=c1>// (012) ldh [x + 16]
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x15</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mh>0x00000438</span> <span class=p>},</span> <span class=c1>// (013) jeq #0x438 jt 14 jf 15
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x6</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00040000</span> <span class=p>},</span> <span class=c1>// (014) ret #262144
</span><span class=c1></span>    <span class=p>{</span> <span class=mh>0x6</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mh>0x00000000</span> <span class=p>},</span> <span class=c1>// (015) ret #0
</span><span class=c1></span><span class=p>};</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// ……
</span><span class=c1></span>    <span class=k>struct</span> <span class=n>sock_fprog</span> <span class=n>bpf</span> <span class=o>=</span> <span class=p>{</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>code</span><span class=p>)</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sock_filter</span><span class=p>),</span> <span class=n>code</span> <span class=p>};</span>
    <span class=c1>// ……
</span><span class=c1></span>    <span class=c1>// 1. 创建 raw socket
</span><span class=c1></span>    <span class=n>s</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_PACKET</span><span class=p>,</span> <span class=n>SOCK_RAW</span><span class=p>,</span> <span class=n>htons</span><span class=p>(</span><span class=n>ETH_P_ALL</span><span class=p>));</span>
    <span class=c1>// ……
</span><span class=c1></span>    <span class=c1>// 2. 将 socket 绑定给指定的 ethernet dev
</span><span class=c1></span>    <span class=n>name</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span> <span class=c1>// ethernet dev 由 arg 1 传入
</span><span class=c1></span>    <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>addr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>addr</span><span class=p>));</span>
    <span class=n>addr</span><span class=p>.</span><span class=n>sll_ifindex</span> <span class=o>=</span> <span class=n>if_nametoindex</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
    <span class=c1>// ……
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>bind</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>addr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>addr</span><span class=p>)))</span> <span class=p>{</span>
        <span class=c1>// ……
</span><span class=c1></span>    <span class=p>}</span>
    <span class=c1>// 3. 利用 SO_ATTACH_FILTER 将 bpf 代码块传入内核
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>setsockopt</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>SOL_SOCKET</span><span class=p>,</span> <span class=n>SO_ATTACH_FILTER</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bpf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bpf</span><span class=p>)))</span> <span class=p>{</span>
        <span class=c1>// ……
</span><span class=c1></span>    <span class=p>}</span>
    <span class=k>for</span> <span class=p>(;</span> <span class=p>;)</span> <span class=p>{</span>
        <span class=n>bytes</span> <span class=o>=</span> <span class=n>recv</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 4. 利用 recv()获取符合条件的报文
</span><span class=c1></span>        <span class=c1>// ……
</span><span class=c1></span>        <span class=n>ip_header</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>iphdr</span> <span class=o>*</span><span class=p>)(</span><span class=n>buf</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>ether_header</span><span class=p>));</span>
        <span class=n>inet_ntop</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ip_header</span><span class=o>-&gt;</span><span class=n>saddr</span><span class=p>,</span> <span class=n>src_addr_str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>src_addr_str</span><span class=p>));</span>
        <span class=n>inet_ntop</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ip_header</span><span class=o>-&gt;</span><span class=n>daddr</span><span class=p>,</span> <span class=n>dst_addr_str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>dst_addr_str</span><span class=p>));</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;IPv%d proto=%d src=%s dst=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
        <span class=n>ip_header</span><span class=o>-&gt;</span><span class=n>version</span><span class=p>,</span> <span class=n>ip_header</span><span class=o>-&gt;</span><span class=n>protocol</span><span class=p>,</span> <span class=n>src_addr_str</span><span class=p>,</span> <span class=n>dst_addr_str</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>篇幅所限，清单 2 中笔者只列出了部分代码，代码分析也以注释为主。有兴趣的读者可以移步<a href=https://raw.githubusercontent.com/windywolf/example/master/eBPF/bpfsample.c>这</a><a href=https://raw.githubusercontent.com/windywolf/example/master/eBPF/bpfsample.c>里</a>阅读完全版。</p>
<p>由于主要是和过滤报文打交道，内核中(before 3.18)的 BPF 的绝大部分实现都被放在了<a href=http://elixir.free-electrons.com/linux/v2.6.39.4/source/net/core/filter.c>net/core/filter.c</a>下，篇幅原因笔者就不对代码进行详述了，文件不长，600 来行(v2.6)，比较浅显易懂，有兴趣的读者可以移步品评一下。值得留意的函数有两个，sk_attach_filter()和sk_run_filter()：前者将 filter 伪代码由用户空间复制进内核空间；后者则负责在报文到来时执行伪码解析。</p>
<h3 id=演进jit-for-bpf>演进：JIT For BPF</h3>
<p>BPF 被引入 Linux 之后，除了一些小的性能方面的调整意外，很长一段时间都没有什么动静。直到 3.0 才首次迎来了比较大的革新：在一些特定硬件平台上，BPF 开始有了用于提速的 JIT(Just-In-Time) Compiler。</p>
<p>最先实现 JIT 的是<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net>x</a><a href=http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net>8</a><a href=http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net>6</a>平台，其后包括<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/arch/arm/net>arm</a>、<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/arch/powerpc/net>ppc</a>、<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/arch/390/net>S390</a>、<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/arch/mips/net>mips</a>等一众平台纷纷跟进，到今天 Linux 的主流平台中支持 JIT For BPF 的已经占了绝大多数了。</p>
<p>BPF JIT 的接口还是简单清晰的：各平台的 JIT 编译函数都实现于<a href=http://elixir.free-electrons.com/linux/v3.10.107/source/arch/x86/net/bpf_jit_comp.c#L147>bpf_jit_compile()</a>之中(3.16 之后，开始逐步改为<a href=http://elixir.free-electrons.com/linux/v3.16/source/arch/x86/net/bpf_jit_comp.c#L869>bpf_int_jit_compile()</a>)，如果 CONFIG_BPF_JIT 被打开，则传入的 BPF 伪代码就会被传入该函数加以编译，编译结果被拿来替换掉默认的处理函数 sk_run_filter()。JIT 的实现不在本文讨论之列，其代码基本位于 arch/<platform>/net 之下，有致力于优化的同学可以尝试学习一下。</p>
<p>打开 BPF 的 JIT 很简单，只要向/proc/sys/net/core/bpf_jit_enable 写入 1 即可；对于有调试需求的开发者而言，如果写入 2 的话，还可以在内核 log 中看到载入 BPF 代码时候 JIT 生成的优化代码，内核开发者们还提供了一个更加方便的工具<a href=http://elixir.free-electrons.com/linux/v4.12.8/source/tools/net>bpf_jit_disam</a>，可以将内核 log 中的二进制转换为汇编以便阅读。</p>
<p>JIT Compiler 之后，针对 BPF 的小改进不断：如将 BPF 引入 seccomp(3.4)；添加一些 debug 工具如 bpf_asm 和 bpf_dbg(3.14)。不过比较革命性的大动作就要等到 3.17 了，这次的改进被称为 extended BPF，即 eBPF。</p>
<h2 id=进化extended-bpf>进化：extended BPF</h2>
<p>自 3.15 伊始，一个套源于 BPF 的全新设计开始逐渐进入人们的视野，并最终(3.17)被添置到了 kernel/bpf 下。这一全新设计最终被命名为了 extended BPF(eBPF)：顾名思义，有全面扩充既有 BPF 功能之意；而相对应的，为了后向兼容，传统的 BPF 仍被保留了下来，并被重命名为 classical BPF(cBPF)。</p>
<p>相对于 cBPF，eBPF 带来的改变可谓是革命性的：一方面，它已经为内核追踪(Kernel Tracing)、应用性能调优/监控、流控(Traffic Control)等领域带来了激动人心的变革；另一方面，在接口的设计以及易用性上，eBPF 也有了较大的改进。</p>
<p>Linux 内核代码的 samples 目录下有大量前人贡献的<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf>eBPF sample</a>，这里笔者先挑选其中相对简单的 sockex1 来帮助读者们建立一个 eBPF 的初步印象：</p>
<h5 id=清单-3-sockex1_userc>清单 3 sockex1_user.c</h5>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;…&gt;</span><span class=cp>
</span><span class=cp></span><span class=c1>// 篇幅所限，清单 3 和 4 都只罗列出部分关键代码，有兴趣一窥全貌的读者可以移步 http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf深入学习
</span><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>ac</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// 1. eBPF 的伪代码位于 sockex1_kern.o 中，这是一个由 llvm 生成的 elf 格式文件，指令集为 bpf;
</span><span class=c1></span>    <span class=n>snprintf</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>filename</span><span class=p>),</span> <span class=s>&#34;%s_kern.o&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>load_bpf_file</span><span class=p>(</span><span class=n>filename</span><span class=p>))</span> <span class=p>{</span>
        <span class=c1>// load_bpf_file()定义于 bpf_load.c，利用 libelf 来解析 sockex1_kern.o
</span><span class=c1></span>        <span class=c1>// 并利用 bpf_load_program 将解析出的伪代码 attach 进内核;
</span><span class=c1></span>    <span class=p>}</span>
    <span class=c1>// 2. 因为 sockex1_kern.o 中 bpf 程序的类型为 BPF_PROG_TYPE_SOCKET_FILTER
</span><span class=c1></span>    <span class=c1>// 所以这里需要用用 SO_ATTACH_BPF 来指明程序的 sk_filter 要挂载到哪一个套接字上
</span><span class=c1></span>    <span class=n>sock</span> <span class=o>=</span> <span class=n>open_raw_sock</span><span class=p>(</span><span class=s>&#34;lo&#34;</span><span class=p>);</span>
    <span class=n>assert</span><span class=p>(</span><span class=n>setsockopt</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=n>SOL_SOCKET</span><span class=p>,</span> <span class=n>SO_ATTACH_BPF</span><span class=p>,</span> <span class=n>prog_fd</span><span class=p>,</span>
    <span class=k>sizeof</span><span class=p>(</span><span class=n>prog_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
    <span class=c1>//……
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 3. 利用 map 机制获取经由 lo 发出的 tcp 报文的总长度
</span><span class=c1></span>        <span class=n>key</span> <span class=o>=</span> <span class=n>IPPROTO_TCP</span><span class=p>;</span>
        <span class=n>assert</span><span class=p>(</span><span class=n>bpf_map_lookup_elem</span><span class=p>(</span><span class=n>map_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tcp_cnt</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
        <span class=c1>// ……
</span><span class=c1></span>    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>清单 4 sockex1_kern.c</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;……&gt;</span><span class=cp>
</span><span class=cp></span><span class=c1>// 预先定义好的 map 对象
</span><span class=c1>// 这里要注意好其实 map 是需要由用户空间程序调用 bpf_create_map()进行创建的
</span><span class=c1>// 在这里定义的 map 对象，实际上会在 load_bpf_file()解析 ELF 文件的同时被解析和创建出来
</span><span class=c1>// 这里的 SEC(NAME)宏表示在当前 obj 文件中新增一个段(section)
</span><span class=c1></span><span class=k>struct</span> <span class=n>bpf_map_def</span> <span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;maps&#34;</span><span class=p>)</span> <span class=n>my_map</span> <span class=o>=</span> <span class=p>{</span>
    <span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BPF_MAP_TYPE_ARRAY</span><span class=p>,</span>
    <span class=p>.</span><span class=n>key_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>u32</span><span class=p>),</span>
    <span class=p>.</span><span class=n>value_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>),</span>
    <span class=p>.</span><span class=n>max_entries</span> <span class=o>=</span> <span class=mi>256</span><span class=p>,</span>
<span class=p>};</span>
<span class=n>SEC</span><span class=p>(</span><span class=s>&#34;socket1&#34;</span><span class=p>)</span>
<span class=kt>int</span> <span class=n>bpf_prog1</span><span class=p>(</span><span class=k>struct</span> <span class=n>__sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// 这个例子比较简单，仅仅是读取输入报文的包头中的协议位而已
</span><span class=c1></span>    <span class=c1>// 这里的 load_byte 实际指向了 llvm 的 built-in 函数 asm(llvm.bpf.load.byte)
</span><span class=c1></span>    <span class=c1>// 用于生成 eBPF 指令 BPF_LD_ABS 和 BPF_LD_IND
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>load_byte</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>ETH_HLEN</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>iphdr</span><span class=p>,</span> <span class=n>protocol</span><span class=p>));</span>
    <span class=kt>long</span> <span class=o>*</span><span class=n>value</span><span class=p>;</span>
    <span class=c1>// ……
</span><span class=c1></span>    <span class=c1>// 根据 key(&amp;index，注意这是一个指向函数的引用)获取对应的 value
</span><span class=c1></span>    <span class=n>value</span> <span class=o>=</span> <span class=n>bpf_map_lookup_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>my_map</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>index</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span>
        <span class=n>__sync_fetch_and_add</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>skb</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>);</span> <span class=c1>//这里的__sync_fetch_and_add 是 llvm 中的内嵌函数，表示 atomic 加操作
</span><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
<span class=c1>// 为了满足 GPL 毒药的需求，所有会注入内核的 BPF 代码都须显式的支持 GPL 协议
</span><span class=c1></span><span class=kt>char</span> <span class=n>_license</span><span class=p>[]</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;license&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=s>&#34;GPL&#34;</span><span class=p>;</span>
</code></pre></td></tr></table>
</div>
</div><p>对比一下清单 3&4 以及清单 2 的代码片段，很容易看出一些 eBPF 显而易见的革新：</p>
<ul>
<li>用 C 写成的 BPF 代码(sockex1_kern.o)；</li>
<li>基于 map 的内核与用户空间的交互方式；</li>
<li>全新的开发接口；</li>
</ul>
<p>除此之外，还有一些不那么明显的改进隐藏在内核之中：</p>
<ul>
<li>全新的伪指令集设计；</li>
<li>In-kernel verifier;</li>
</ul>
<p>由一个文件(net/core/filter.c)进化到一个目录(kernel/bpf)，eBPF 的蜕变三言两语间很难交代清楚，下面笔者就先基于上述的几点变化来帮助大家入个门，至于个中细节，就只能靠读者以后自己修行了。</p>
<h3 id=再见了汇编>再见了汇编</h3>
<p>利用高级语言书写 BPF 逻辑并经由编译器生成出伪代码来并不是什么新鲜的尝试，比如 libpcap 就是在代码中内嵌了一个小型编译器来分析 tcpdump 传入的 filter expression 从而生成 BPF 伪码的。只不过长久以来该功能一直没有能被独立出来或者做大做强，究其原因，主要还是由于传统的 BPF 所辖领域狭窄，过滤机制也不甚复杂，就算是做的出来，估计也不堪大用。</p>
<p>然而到了 eBPF 的时代，情况终于发生了变化：现行的伪指令集较之过去已经复杂太多，再用纯汇编的开发方式已经不合时宜，于是，自然而然的，利用 C 一类的高级语言书写 BPF 伪代码的呼声便逐渐高涨了起来。</p>
<p>目前，支持生成 BPF 伪代码的编译器只有 llvm 一家，即使是通篇使用 gcc 编译的 Linux 内核，samples 目录下的 bpf 范例也要借用 llvm 来编译完成。还是以 sockex1 为例，用户态下的代码 sockex_user.c 是利用 HOSTCC 定义的编译器编译的；但 sockex_kern.c 就需要用到 clang 和 llvm 了。在<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf/Makefile>samples/bpf/Makefile</a>中，可以看到：</p>
<h5 id=清单-5-samplesbpfmakefile>清单 5 samples/bpf/Makefile</h5>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=c># ......
</span><span class=c># List of programs to build
</span><span class=c></span><span class=nv>hostprogs-y</span> <span class=o>:=</span> test_lru_dist
<span class=nv>hostprogs-y</span> <span class=o>+=</span> sockex1
<span class=c># ……
</span><span class=c></span><span class=nv>sockex1-objs</span> <span class=o>:=</span> bpf_load.o <span class=k>$(</span>LIBBPF<span class=k>)</span> sockex1_user.o
<span class=c># ……
</span><span class=c># 注意，这里有一个小 tip，就是如果在内核的 Makefile 中，
</span><span class=c># 有某一个目标文件你不希望使用内核的通用编译规则的话(类似于本文的 sockex1_kern.o)，
</span><span class=c># 可以像这里一样，并不把该文件加入任何 xxxprogs 或 xxx-objs，
</span><span class=c># 而是直接放入 always，这样内核就会在本地 Makefile 中搜索编译规则了。
</span><span class=c></span><span class=nv>always</span> <span class=o>:=</span> <span class=k>$(</span>hostprogs-y<span class=k>)</span>
<span class=err>&lt;strong&gt;always</span> <span class=err>&lt;/strong&gt;&lt;strong&gt;+=</span> <span class=err>sockex1_kern.o&lt;/strong&gt;</span>
<span class=c># ……
</span><span class=c></span><span class=nv>LLC</span> <span class=o>?=</span> llc
<span class=nv>CLANG</span> <span class=o>?=</span> clang
<span class=c># ……
</span><span class=c># sockex1_kern.o 就是使用了下述规则编译为 BPF 代码的，请注意笔者加粗的部分
</span><span class=c></span><span class=nf>$(obj)/%.o</span><span class=o>:</span> <span class=k>$(</span><span class=nv>src</span><span class=k>)</span>/%.<span class=n>c</span>
<span class=k>$(</span><span class=nv>CLANG</span><span class=k>)</span> <span class=k>$(</span><span class=nv>NOSTDINC_FLAGS</span><span class=k>)</span> <span class=k>$(</span><span class=nv>LINUXINCLUDE</span><span class=k>)</span> <span class=k>$(</span><span class=nv>EXTRA_CFLAGS</span><span class=k>)</span> <span class=err>\</span>
<span class=err>-D__KERNEL__</span> <span class=err>-D__ASM_SYSREG_H</span> <span class=err>-Wno-unused-value</span> <span class=err>-Wno-pointer-sign</span> <span class=err>\</span>
<span class=err>-Wno-compare-distinct-pointer-types</span> <span class=err>\</span>
<span class=err>-Wno-gnu-variable-sized-type-not-at-end</span> <span class=err>\</span>
<span class=err>-Wno-address-of-packed-member</span> <span class=err>-Wno-tautological-compare</span> <span class=err>\</span>
<span class=err>-Wno-unknown-warning-option</span> <span class=err>\</span>
<span class=err>-O2</span> <span class=err>-emit-llvm</span> <span class=err>-c</span> <span class=k>$&lt;</span> <span class=err>-o</span> <span class=err>-|</span>
<span class=k>$(</span><span class=nv>LLC</span><span class=k>)</span> <span class=nv>-march</span><span class=o>=</span>bpf -filetype<span class=o>=</span>obj -o
<span class=k>$@</span>
</code></pre></td></tr></table>
</div>
</div><p>能用 C 书写 BPF 自然是便利了许多，但也不代表余下的开发工作就是一片坦途了：首先 llvm 的输出是 elf 文件，这也意味着想要获取能传入内核的代码，我们还需要额外做一段解析 elf 的工作，这也是为什么 Sample 下的范例几乎无一例外地都链接了 libelf 库；其次，同时也是比较重要的一点，不要忘记 BPF 的代码是跑在内核空间中的，因此书写时必得煞费苦心一番才好，以防一个不小心就做出个把内核干趴下的漏洞来：下文中提及的 verifier 就是为了这一点而生，每一个被放进内核的 BPF 代码，都须要经过它的检验才行。</p>
<h3 id=bpf-程序的类别以及-map-机制>BPF 程序的类别以及 Map 机制</h3>
<p>清单 3 中我们看到 sockex1_kern.o 是由 load_bpf_file()函数载入内存的，但实际上 eBPF 提供用来将 BPF 代码载入内核的正式接口函数其实是 bpf_load_program()，该接口负责通过参数向内核提供三类信息：</p>
<ul>
<li>BPF 程序的类型、</li>
<li>BPF 代码</li>
<li>代码运行时所需要的存放 log 的缓存地址(位于用户空间)；</li>
</ul>
<p>有意思的是，目前所有注入内核的 BPF 程序都需要附带 GPL 协议支持信息，bpf_load_program()的 license 参数就是用来载入协议字串的。</p>
<p>由 eBPF 伊始，BPF 程序开始有分类了，通过 bpf_load_program 的参数 bpf_prog_type，我们可以看到 eBPF 支持的程序类型。这里笔者将一些常用的类型罗列于下表之中供读者参考：</p>
<h4 id=表-2-常见-bpf_prog_type-定义>表 2 常见 bpf_prog_type 定义</h4>
<table>
<thead>
<tr>
<th><strong>bpf_prog_type</strong></th>
<th><strong>BPF prog 入口参数(R1)</strong></th>
<th><strong>程序类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BPF_PROG_TYPE_SOCKET_FILTER</strong></td>
<td><strong>struct __sk_buff</strong></td>
<td>用于过滤进出口网络报文，功能上和 cBPF 类似。</td>
</tr>
<tr>
<td><strong>BPF_PROG_TYPE_KPROBE</strong></td>
<td><strong>struct pt_regs</strong></td>
<td>用于 kprobe 功能的 BPF 代码。</td>
</tr>
<tr>
<td><strong>BPF_PROG_TYPE_TRACEPOINT</strong></td>
<td>这类 BPF 的参数比较特殊，根据 tracepoint 位置的不同而不同。</td>
<td>用于在各个 tracepoint 节点运行。</td>
</tr>
<tr>
<td><strong>BPF_PROG_TYPE_XDP</strong></td>
<td><strong>struct xdp_md</strong></td>
<td>用于控制 XDP(eXtreme Data Path)的 BPF 代码。</td>
</tr>
<tr>
<td><strong>BPF_PROG_TYPE_PERF_EVENT</strong></td>
<td><strong>struct bpf_perf_event_data</strong></td>
<td>用于定义 perf event 发生时回调的 BPF 代码。</td>
</tr>
<tr>
<td><strong>BPF_PROG_TYPE_CGROUP_SKB</strong></td>
<td><strong>struct __sk_buff</strong></td>
<td>用于在 network cgroup 中运行的 BPF 代码。功能上和 Socket_Filter 近似。具体用法可以参考范例 test_cgrp2_attach。</td>
</tr>
<tr>
<td><strong>BPF_PROG_TYPE_CGROUP_SOCK</strong></td>
<td><strong>struct bpf_sock</strong></td>
<td>另一个用于在 network cgroup 中运行的 BPF 代码，范例 test_cgrp2_sock2 中就展示了一个利用 BPF 来控制 host 和 netns 间通信的例子。</td>
</tr>
</tbody>
</table>
<p>深入对比清单 3(eBPF)和清单 2(cBPF)的实现的差异，还会发现一个比较明显的不同之处：BPF 代码进内核之后，cBPF 和内核通讯的方式是 recv()；而 eBPF 则将 socket 丢到一边，使用一种名为 map 的全新机制和内核通讯，其大致原理下图所示：</p>
<h4 id=图-4-ebpf-的-map-机制>图 4 eBPF 的 map 机制</h4>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-22-epbf004.png alt></p>
<p>从图上看，这套设计本身不复杂：位于用户空间中的应用在内核中辟出一块空间建立起一个数据库用以和 eBPF 程序交互(bpf_create_map())；数据库本身以 Key-Value 的形式进行组织，无论是从用户空间还是内核空间都可以对其进行访问，两边有着相似的接口，最终在逻辑上也都殊途同归。</p>
<p>不难发现，map 带来的最大优势是效率：相对于 cBPF 一言不合就把一个通信报文从内核空间丢出来的豪放，map 机制下的通讯耗费就要小家碧玉的多了：还是以 sockex1 为例，一次通信从内核中仅仅复制 4 个字节，而且还是已经处理好了可以直接拿来就用的，做过内核开发的人都知道这对于性能意味着什么。</p>
<p>map 机制解决的另一个问题是通信数据的多样性问题。cBPF 所覆盖的功能范围很简单，无外乎是网络监控和 seccomp 两块，数据接口设计的粗放一点也就算了；而 eBPF 的利用范围则要广的多，性能调优、内核监控、流量控制什么的应有尽有，数据接口的多样性设计就显得很必要了。下表中就列出了现有 eBPF 中的 map 机制中常见的数据类型：</p>
<h5 id=表-3-map-机制下的常见数据类型>表 3. map 机制下的常见数据类型</h5>
<table>
<thead>
<tr>
<th><strong>Category</strong></th>
<th><strong>Source</strong></th>
<th><strong>Bpf_map_type</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Array</strong></td>
<td>Arraymap.c</td>
<td>BPF_MAP_TYPE_ARRAY BPF_MAP_TYPE_CGROUP_ARRAY BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF_MAP_TYPE_PERCPU_ARRAY BPF_MAP_TYPE_ARRAY_OF_MAPS</td>
<td>实际就是数组，所以所有的 key 必须是整数。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>BPF_MAP_TYPE_PROG_ARRAY</td>
<td>该类型是一个特例，主要用于自定义函数，利用 JUMP_TAIL_CALL令跳转</td>
</tr>
<tr>
<td><strong>Hash</strong></td>
<td>Hashmap.c</td>
<td>BPF_MAP_TYPE_HASH BPF_MAP_TYPE_PERCPU_HASH BPF_MAP_TYPE_LRU_HASH BPF_MAP_TYPE_LRU_PERCPU_HASH BPF_MAP_TYPE_HASH_OF_MAPS</td>
<td>真正意义上的 map 数据类型，如果 key 值为整数以外的类型必须使用</td>
</tr>
<tr>
<td><strong>Stack Trace</strong></td>
<td>Stackmap.c</td>
<td>BPF_MAP_TYPE_STACK_TRACE</td>
<td>真正意义上的 map 数据类型，如果 key 值为整数以外的类型必须使用存储特定应用在某一特定时间点的栈状态(包括内核态和用户态)，key 只有两个：分别为内核栈 id 和用户栈 id，利用 bpf_get_stackid()获取;</td>
</tr>
<tr>
<td><strong>Longest Prefix Match Trie</strong></td>
<td>Lpm_trie.c</td>
<td>BPF_MAP_TYPE_LPM_TRIE</td>
<td>基于 Longest Prefix Match 前缀树实现，适宜处理以 CIBR 为键值时的情况</td>
</tr>
</tbody>
</table>
<h3 id=新的指令集>新的指令集</h3>
<p>eBPF 对于既有 cBPF 令集的改动量之大，以至于基本上不能认为两者还是同一种语言了。个中变化，我们可以通过反汇编清单 4 的源代码(llvm-objdump &ndash;disassemble)略知一二：</p>
<p>清单 6 Disassemble of sockex1_kern.o</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-objectivec data-lang=objectivec><span class=n>sockex1_kern</span><span class=p>.</span><span class=nl>o</span><span class=p>:</span> <span class=n>file</span> <span class=n>format</span> <span class=n>ELF64</span><span class=o>-</span><span class=n>BPF</span>
<span class=n>Disassembly</span> <span class=n>of</span> <span class=n>section</span> <span class=nl>socket1</span><span class=p>:</span>
<span class=nl>bpf_prog1</span><span class=p>:</span>
<span class=mi>0</span><span class=o>:</span> <span class=n>bf</span> <span class=mi>16</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>r6</span> <span class=o>=</span> <span class=n>r1</span>
<span class=mi>1</span><span class=o>:</span> <span class=mi>30</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mi>17</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>r0</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>u8</span> <span class=o>*</span><span class=p>)</span><span class=n>skb</span><span class=p>[</span><span class=mi>23</span><span class=p>]</span>
<span class=mi>2</span><span class=o>:</span> <span class=mi>63</span> <span class=mi>0</span><span class=n>a</span> <span class=n>fc</span> <span class=n>ff</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=o>*</span><span class=p>(</span><span class=n>u32</span> <span class=o>*</span><span class=p>)(</span><span class=n>r10</span> <span class=o>-</span> <span class=mi>4</span><span class=p>)</span> <span class=o>=</span> <span class=n>r0</span>
<span class=mi>3</span><span class=o>:</span> <span class=mi>61</span> <span class=mi>61</span> <span class=mo>04</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>r1</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>u32</span> <span class=o>*</span><span class=p>)(</span><span class=n>r6</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span>
<span class=mi>4</span><span class=o>:</span> <span class=mi>55</span> <span class=mo>01</span> <span class=mi>08</span> <span class=mo>00</span> <span class=mo>04</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=k>if</span> <span class=n>r1</span> <span class=o>!=</span> <span class=mi>4</span> <span class=k>goto</span> <span class=mi>8</span>
<span class=mi>5</span><span class=o>:</span> <span class=n>bf</span> <span class=n>a2</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>r2</span> <span class=o>=</span> <span class=n>r10</span>
<span class=mi>6</span><span class=o>:</span> <span class=mo>07</span> <span class=mo>02</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>fc</span> <span class=n>ff</span> <span class=n>ff</span> <span class=n>ff</span> <span class=n>r2</span> <span class=o>+=</span> <span class=o>-</span><span class=mi>4</span>
<span class=mi>7</span><span class=o>:</span> <span class=mi>18</span> <span class=mo>01</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>r1</span> <span class=o>=</span> <span class=mi>0ll</span>
<span class=mi>9</span><span class=o>:</span> <span class=mi>85</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>01</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>call</span> <span class=mi>1</span>
<span class=mi>10</span><span class=o>:</span> <span class=mi>15</span> <span class=mo>00</span> <span class=mo>02</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=k>if</span> <span class=n>r0</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>goto</span> <span class=mi>2</span>
<span class=mi>11</span><span class=o>:</span> <span class=mi>61</span> <span class=mi>61</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>r1</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>u32</span> <span class=o>*</span><span class=p>)(</span><span class=n>r6</span> <span class=o>+</span> <span class=mi>0</span><span class=p>)</span>
<span class=mi>12</span><span class=o>:</span> <span class=n>db</span> <span class=mi>10</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>lock</span> <span class=o>*</span><span class=p>(</span><span class=n>u64</span> <span class=o>*</span><span class=p>)(</span><span class=n>r0</span> <span class=o>+</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+=</span> <span class=n>r1</span>
<span class=nl>LBB0_3</span><span class=p>:</span>
<span class=mi>13</span><span class=o>:</span> <span class=n>b7</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>r0</span> <span class=o>=</span> <span class=mi>0</span>
<span class=mi>14</span><span class=o>:</span> <span class=mi>95</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=mo>00</span> <span class=n>exit</span>
</code></pre></td></tr></table>
</div>
</div><p>我们不用管这段汇编写了点儿什么，先跟清单 2 开头的那段 cBPF 代码对比一下两者的异同：</p>
<ul>
<li>寄存器：eBPF 支持更多的寄存器；
<ul>
<li>cBPF：A, X + stack, 32bit;</li>
<li>eBPF：R1~R10 + stack, 64bit，显然，如此的设计主要针对现在大行其道的 64 位硬件，同时更多的寄存器设计也便于运行时和真实环境下的寄存器进行对应，以提高效率；</li>
</ul>
</li>
<li>opcode：两者的格式不同；
<ul>
<li>cBPF: op 16b, jt 8b, jf 8b, K 32b;</li>
<li>eBPF: op 8b, dstReg 4b, srcReg 4b, off 16b, imm 32b;</li>
</ul>
</li>
<li>其他：sockex1_kern.o 设计的比较简单，但还是可以从中看出 eBPF 的一大改进：可以调用内核中预设好的函数（Call 1，这里指向的函数是 bpf_map_lookup_elem()，如果需要比较全的预设函数索引的话可以移步<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/include/uapi/linux/bpf.h#L494>这里</a>）。除此之外，eBPF 命令集中比较重要的新晋功能还有：
<ul>
<li>load/store 多样化：
<ul>
<li>cBPF：仅可以读 packet(即 skb)以及读写 stack；</li>
<li>eBPF：可以读写包括 stack/map/context，也即 BPF prog 的传入参数可读写。换句话说，任意传入 BPF 代码的数据流均可以被修改；</li>
</ul>
</li>
<li>除开预设函数外，开发者还可以自定义 BPF 函数(JUMP_TAIL_CALL)；</li>
<li>除了前向跳转外(Jump Forward，cBPF 支持)，还可以后向跳转(Jump Backword)；</li>
</ul>
</li>
</ul>
<p>至于 eBPF 具体的指令表，因为过于庞杂这里笔者就不作文抄公了。不过 eBPF 中的几个寄存器的利用规则这里还是可以有的，否则要读懂清单 6 中的代码略有困难：</p>
<ul>
<li>R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；</li>
<li>R1~R5：一般用于表示内核预设函数的参数；</li>
<li>R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；</li>
<li>R10：只读，用作栈指针(SP)；</li>
</ul>
<h3 id=in-kernel-verifier>In-kernel Verifier</h3>
<p>其实结合前面那么多的内容看下来不难发现 eBPF 其实近似于一种改头换面后的内核模块，只不过它比内核模块更短小精干，实现的功能也更新颖一些罢了，但无论是什么样的架构，只要存在注入的代码就会有安全隐患，eBPF 也不外如是——毕竟注入的代码是要在内核中运行的。</p>
<p>为了最大限度的控制这些隐患，cBPF 时代就开始加入了<a href=http://elixir.free-electrons.com/linux/v2.6.39.4/source/net/core/filter.c#L498>代码检查机制</a>以防止不规范的注入代码；到了 eBPF 时代则在载入程序(bpf_load_program())时加入了更复杂的<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L3544>verifier 机制</a>，在运行注入程序之前，先进行一系列的安全检查，最大限度的保证系统的安全。具体来说，verifier 机制会对注入的程序做两轮检查：</p>
<ul>
<li>首轮检查(First pass，实现于<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L2586>check_cfg()</a>)可以被认为是一次深度优先搜索，主要目的是对注入代码进行一次 DAG(Directed Acyclic Graph，有向无环图)检测，以保证其中没有循环存在；除此之外，一旦在代码中发现以下特征，verifier 也会拒绝注入：
<ul>
<li>代码长度超过上限，目前(内核版本 4.12)eBPF 的代码长度上限为 4K 条指令——这在 cBPF 时代很难达到，但别忘了 eBPF 代码是可以用 C 实现的；</li>
<li>存在可能会跳出 eBPF 代码范围的 JMP，这主要是为了防止恶意代码故意让程序跑飞；</li>
<li>存在永远无法运行(unreachable)的 eBPF 令，例如位于 exit 之后的指令；</li>
</ul>
</li>
<li>次轮检查(Second pass，实现于<a href=http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L2896>do_check()</a>)较之于首轮则要细致很多：在本轮检测中注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，所有的指令的参数（寄存器）、访问的内存、调用的函数都会被仔细的捋一遍，任何的错误都会导致注入程序被退货。由于过分细致，本轮检查对于注入程序的复杂度也有所限制：首先程序中的分支(branch)不允许超过 1024 个；其次经检测的指令数也必须在 96K 以内。</li>
</ul>
<h3 id=overview-ebpf-的架构>Overview: eBPF 的架构</h3>
<p>诚然，eBPF 设计的复杂程度已是超越 cBPF 太多太多，笔者罗里吧嗦了大半天，其实也就是将将领着大家入门的程度而已，为了便于读者们能够把前文所述的碎片知识串到一起，这里笔者将 eBPF 的大体架构草绘一番，如下图所示，希望能帮助大家对 eBPF 构建一个整体的认识。</p>
<h4 id=图-5-architecture-of-ebpf>图 5. Architecture of eBPF</h4>
<p><img src=https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-30-epbf005.png alt></p>
<h3 id=追求极简bpf-compiler-collectionbcc>追求极简：BPF Compiler Collection(BCC)</h3>
<p>现在让我们将目光聚焦到 eBPF 的使用——相信这是大部分读者最感兴趣的部分，毕竟绝大多数人其实并没有多少机会参与 eBPF 的开发——重新回到清单 3&4 中的 sockex1：说句良心话，虽然现在可以用 C 来实现 BPF，但编译出来的却仍然是 ELF 文件，开发者需要手动析出真正可以注入内核的代码。这部分工作多少有些麻烦，如果可以有一个通用的方案一步到位的生成出 BPF 代码就好了，开发者的注意力应该放在其他更有价值的地方，不是吗？</p>
<p>于是就有人设计了 BPF Compiler Collection(BCC)，BCC 是一个 python 库，但是其中有很大一部分的实现是基于 C 和 C++的，python 只不过实现了对 BCC 应用层接口的封装而已。</p>
<p>使用 BCC 进行 BPF 的开发仍然需要开发者自行利用 C 来设计 BPF 程序——但也仅此而已，余下的工作，包括编译、解析 ELF、加载 BPF 代码块以及创建 map 等等基本可以由 BCC 一力承担，无需多劳开发者费心。</p>
<p>限于篇幅关于 BCC 笔者不再过多展开，文章的最后笔者再给出一个基于 BCC 实现的 sockex1 的例子，读者可以感受一下使用 BCC 带给开发者们的便利性：</p>
<h5 id=清单-7-a-sample-of-bcc>清单 7 A sample of BCC</h5>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>bcc</span> <span class=kn>import</span> <span class=n>BPF</span>
<span class=c1># 和清单 2 一样，篇幅所限，这里只贴一部分源码，完全版请移步 https://raw.githubusercontent.com/windywolf/example/master/eBPF/bccsample.py</span>
<span class=n>interface</span><span class=o>=</span><span class=s2>&#34;ens160&#34;</span>
<span class=c1># BCC 可以接受直接将 BPF 代码嵌入 python code 之中</span>
<span class=c1># 为了方便展示笔者使用了这一功能</span>
<span class=c1># 注意：prog 中的中文注释是由于笔者需要写作之故加入，如果读者想尝试运行这段代码，</span>
<span class=c1># 则请将中文全部删除，因为目前 BCC 还不支持在内嵌 C 代码中使用中文注释</span>
<span class=n>prog</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;
</span><span class=s2>#include &lt;net/sock.h&gt;
</span><span class=s2>#include &lt;bcc/proto.h&gt;
</span><span class=s2>// BCC 中专门为 map 定义了一系列的宏，以方便使用
</span><span class=s2>// 宏中的 struct 下还定义了相应的函数，让开发者可以如 C++一般操作 map
</span><span class=s2>// 这里笔者定义了一个 array 类型的 map，名为 my_map1
</span><span class=s2>BPF_ARRAY(my_map1, long);
</span><span class=s2>// BCC 下的 BPF 程序中不再需要定义把函数或变量专门放置于某个 section 下了
</span><span class=s2>int bpf_prog1(struct __sk_buff *skb)
</span><span class=s2>{
</span><span class=s2>    // ……
</span><span class=s2>    struct ethernet_t *eth = cursor_advance(cursor, sizeof(*eth));
</span><span class=s2>    // ……
</span><span class=s2>    struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));
</span><span class=s2>    int index = ip-&gt;nextp;
</span><span class=s2>    long zero = 0; // BCC 下的 bpf 书写还是有很多坑的
</span><span class=s2>    // 例如，这里如果不去定义一个局部变量 zero，
</span><span class=s2>    // 而是直接用常量 0 作为 lookup_or_init()的变量就会报错
</span><span class=s2>    // map 类下的各个方法的具体细节可以参照 reference_guide.md
</span><span class=s2>    value = my_map1.lookup_or_init(&amp;index, &amp;zero);
</span><span class=s2>    if (value)
</span><span class=s2>        __sync_fetch_and_add(value, skb-&gt;len);
</span><span class=s2>    return 0;
</span><span class=s2>}
</span><span class=s2>&#34;&#34;&#34;</span>
<span class=n>bpf</span> <span class=o>=</span> <span class=n>BPF</span><span class=p>(</span><span class=n>text</span><span class=o>=</span><span class=n>prog</span><span class=p>,</span> <span class=n>debug</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
<span class=c1># 注入 bpf_prog1 函数</span>
<span class=n>function</span> <span class=o>=</span> <span class=n>bpf</span><span class=o>.</span><span class=n>load_func</span><span class=p>(</span><span class=s2>&#34;bpf_prog1&#34;</span><span class=p>,</span> <span class=n>BPF</span><span class=o>.</span><span class=n>SOCKET_FILTER</span><span class=p>)</span>
<span class=c1># 这是一段 SOCKET_FILTER 类型的 BPF，所以需要挂载到某一个 interface 上</span>
<span class=n>BPF</span><span class=o>.</span><span class=n>attach_raw_socket</span><span class=p>(</span><span class=n>function</span><span class=p>,</span> <span class=n>interface</span><span class=p>)</span>
<span class=c1># 利用 map 机制获取进出 interface 的各个协议的报文总长</span>
<span class=n>bpf_map</span> <span class=o>=</span> <span class=n>bpf</span><span class=p>[</span><span class=s2>&#34;my_map1&#34;</span><span class=p>]</span>
<span class=k>while</span> <span class=mi>1</span><span class=p>:</span>
    <span class=nb>print</span> <span class=p>(</span><span class=s2>&#34;TCP : </span><span class=si>{}</span><span class=s2>, UDP : </span><span class=si>{}</span><span class=s2>, ICMP: </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
<span class=n>bpf_map</span><span class=p>[</span><span class=n>socket</span><span class=o>.</span><span class=n>IPPROTO_TCP</span><span class=p>]</span><span class=o>.</span><span class=n>value</span><span class=p>,</span>
<span class=c1># …</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=结束语>结束语</h2>
<p>本文从 BPF 的源头开始，一路讲到了近年来刚刚杀青的 eBPF，虽说拘泥于篇幅，大多内容只能蜻蜓点水、浅尝辄止，但文中 BPF 的原理、设计、实现和应用均有所涉猎，勉强也能拿来入个门了。加之近年来基于 eBPF 的应用层出不穷，希望本文能激发读者们的奇思妙想，从而设计出更多基于 BPF 的优秀应用来。</p>
<h2 id=参考资源>参考资源</h2>
<ol>
<li>[Steven McCanne, Van Jacobson] The BSD Packet Filter: A New Architecture for User-level Packet Capture, BPF 的源头，可在<a href=http://www.tcpdump.org/papers/bpf-usenix93.pdf>这里</a>查阅；</li>
<li><a href=http://www.tcpdump.org/tcpdump_man.html,>http://www.tcpdump.org/tcpdump_man.html,</a> tcpdump 的 manual page;</li>
<li><a href=https://www.kernel.org/doc/Documentation/networking/filter.txt,>https://www.kernel.org/doc/Documentation/networking/filter.txt,</a> 内核的 BPF 文档；</li>
<li><a href=http://man7.org/linux/man-pages/man7/socket.7.html,>http://man7.org/linux/man-pages/man7/socket.7.html,</a> Linux 套接字的 manual page，其中有对 Linux Kernel 中 BPF 接口的大致介绍，不过论及详细程度还是不及参考文献 3 的；</li>
<li><a href=https://lwn.net/Articles/437981/>https://lwn.net/Articles/437981/</a>，LWN 上刊载的 JIT For BPF 首次被引入的消息：A JIT For Packet Filters;</li>
<li><a href=https://lwn.net/Articles/603983/,>https://lwn.net/Articles/603983/,</a> LWN 上刊载的 eBPF 的介绍文献：Extending extended BPF。由于年代久远接口相关的内容已经落后于最新代码了，权作参考；</li>
<li><a href=https://github.com/iovisor/bcc,>https://github.com/iovisor/bcc,</a> BCC 的源码，但由于编译需要比较多的依赖，如果想偷个懒的话可以移步<a href=https://hub.docker.com/r/zlim/bcc/>这里</a>直接获取 docker image；</li>
<li><a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md>bcc/reference_guide.md at master · iovisor/bcc · GitHub</a>, BCC 开发指南；</li>
<li><a href=http://elixir.free-electrons.com/linux/latest/source,>http://elixir.free-electrons.com/linux/latest/source,</a> Linux Kernel 源码阅读利器。</li>
</ol>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>文章作者</span>
<span class=item-content>Justice</span>
</p>
<p class=copyright-item>
<span class=item-title>上次更新</span>
<span class=item-content>
2022-06-04 10:26:13
</span>
</p>
<p class=copyright-item>
<span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<div class=post-reward>
<input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label>
<div class=qr-code>
<label class=qr-code-image for=reward>
<img class=image src=/image/wx_reward_qrcode.png>
<span>微信打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/alipay_reward_qrcode.png>
<span>支付宝打赏</span>
</label>
<label class=qr-code-image for=reward>
<img class=image src=/image/bitcoin_reward_qrcode.png>
<span>比特币打赏</span>
</label>
</div>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=https://justice.bj.cn/tags/linux/>linux</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/21.linux/af_xdp/>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg>
</i>
<span class="prev-text nav-default">AF_XDP</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/21.linux/ext4%E4%BB%8B%E7%BB%8D/>
<span class="next-text nav-default">Ext4文件系统架构分析(一)(转)</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg>
</i>
</a>
</nav>
</footer>
</article>
<div class="post bg-white">
<script src=https://utteranc.es/client.js repo=ZhuZhengyi/gh_comment issue-term=pathname theme=github-light crossorigin=anonymous async></script>
</div>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=icon-links>
<a href=mailto:justice_103@126.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a>
<a href=https://justice.bj.cn/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg>
</a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span>
<span class=copyright-year>
&copy;
2000 -
2023
<span class=heart>
<i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg>
</i>
</span><span class=author>
Justice
</span></span>
<span id=busuanzi_container>
访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg>
</i>
</div>
</div>
<script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript>window.MathJax={showProcessingMessages:!1,messageStyle:'none'}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script>$("#openSearch, #openSearchMobile").click(function(){$(".modal-dialog").addClass("visible")}),$("#closeSearch").click(function(){$(".modal-dialog").removeClass("visible")}),$(document).click(function(a){$(a.target).closest(".modal-content, #openSearch, #openSearchMobile").length||$("body").find(".modal-dialog").removeClass("visible")})</script>
</body>
</html>