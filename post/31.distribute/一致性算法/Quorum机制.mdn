# 分布式系统Quorum机制

## 简介

分布式系统由于不同节点的存在，分区(Part)不可避免。为了保证数据的可用性(A)，一般可采用多副本，因此存在副本一致性(Consistency)的问题。

最简单保证副本一致性的方式就是**WARO**(Write All Read One)。WARO存在极大的写放大问题，Quorum机制是

WARO牺牲了更新服务的可用性，最大程度地增强了读服务的可用性。而Quorum就是更新服务和读服务之间进行一个折衷。

Quorum机制是“抽屉原理”的一个应用。

定义如下：假设有N个副本，更新操作wi 在W个副本中更新成功之后，才认为此次更新操作wi 成功。称成功提交的更新操作对应的数据为：“成功提交的数据”。对于读操作而言，至少需要读R个副本才能读到此次更新的数据。**其中，W+R>N ，即W和R有重叠。

一般，W+R=N+1

![](data:image/png;base64,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)

假设系统中有5个副本，W=3，R=3。初始时数据为(V1，V1，V1，V1，V1）--成功提交的版本号为1

当某次更新操作在3个副本上成功后，就认为此次更新操作成功。数据变成：(V2，V2，V2，V1，V1）--成功提交后，版本号变成2

因此，最多只需要读3个副本，一定能够读到V2(此次更新成功的数据)。而在后台，可对剩余的V1 同步到V2，而不需要让Client知道。

**二，Quorum机制分析**

①Quorum机制无法保证强一致性

所谓强一致性就是：任何时刻任何用户或节点都可以读到**最近一次成功提交的副本数据**。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。

 因为，仅仅通过Quorum机制无法确定最新已经成功提交的版本号。

比如，上面的V2 成功提交后（已经写入W=3份），尽管读取3个副本时一定能读到V2，如果刚好读到的是(V2，V2，V2），则此次读取的数据是最新成功提交的数据，因为W=3，而此时刚好读到了3份V2。如果读到的是（V2，V1，V1），则无法确定是一个成功提交的版本，还需要继续再读，直到读到V2的达到3份为止，这时才能确定V2 就是已经成功提交的最新的数据。

1）如何读取最新的数据？---在已经知道最近成功提交的数据版本号的前提下，最多读R个副本就可以读到最新的数据了。

2）如何确定 最高版本号 的数据是一个成功提交的数据？---继续读其他的副本，直到读到的 最高版本号副本 出现了W次。

②基于Quorum机制选择 primary

中心节点(服务器)读取R个副本，**选择R个副本中版本号最高的副本作为新的primary**。

新选出的primary**不能**立即提供服务，还需要与至少与W个副本*完成同步*后，才能提供服务---为了保证Quorum机制的规则：W+R>N

至于如何处理同步过程中冲突的数据，则需要视情况而定。

 比如，(V2，V2，V1，V1，V1），R=3，如果读取的3个副本是：(V1，V1，V1)则高版本的 V2需要丢弃。

如果读取的3个副本是（V2，V1，V1），则低版本的V1需要同步到V2

**三，Quorum机制应用实例**

**HDFS高可用性实现**

 HDFS的运行依赖于NameNode，如果NameNode挂了，那么整个HDFS就用不了了，因此就存在单点故障(single point of failure)；其次，如果需要升级或者维护停止NameNode，整个HDFS也用不了。为了解决这个问题，采用了QJM机制(Quorum Journal Manager)实现HDFS的HA（High Availability）。注意，一开始采用的“共享存储”机制，关于共享存储机制的不足，[可参考：（还提到了QJM的优点）](http://blog.cloudera.com/blog/2012/10/quorum-based-journaling-in-cdh4-1/)

In a typical HA cluster, two separate machines are configured as NameNodes.
At any point in time, exactly one of the NameNodes is in an Active state, and the other is in a Standby state. 
The Active NameNode is responsible for all client operations in the cluster, while the Standby is simply acting as a slave,   
maintaining enough state to provide a fast failover if necessary.

为了实现HA，需要两台NameNode机器，一台是Active NameNode，负责Client请求。另一台是StandBy NameNode，负责与Active NameNode**同步数据**，从而快速 failover。

那么，这里就有个问题，StandBy NameNode是如何同步Active NameNode上的数据的呢？主要同步是哪些数据呢？

数据同步就用到了Quorum机制。同步的数据 主要是[EditLog](http://blog.cloudera.com/blog/2014/03/a-guide-to-checkpointing-in-hadoop/)。

In order for the Standby node to keep its state synchronized with the Active node, 
both nodes communicate with a group of separate daemons called “JournalNodes” (JNs). 

数据同步用到了一个第三方”集群“：Journal Nodes。Active NameNode 和 StandBy NameNode 都与JournalNodes通信，从而实现同步。

''''''''''''''''''''''''''''''''''

每次 NameNode 写 EditLog 的时候，除了向本地磁盘写入 EditLog 之外，也会并行地向 JournalNode 集群之中的每一个 JournalNode 发送写请求，只要大多数 (majority) 的 JournalNode 节点返回成功就认为向 JournalNode 集群写入 EditLog 成功。如果有 2N+1 台 JournalNode，那么根据大多数的原则，最多可以容忍有 N 台 JournalNode 节点挂掉。

**这就是：Quorum机制。每次写入JournalNode的机器数目达到大多数(W)时，就认为本次写操作成功了。**

'''''''''''''''''''''''''''''''''

这样，每次对Active NameNode中的元数据进行修改时，都会将该修改写入JournalNode集群的大多数机器中，才认为此次修改成功。

当Active NameNode宕机时，StandBy NameNode 向JournalNode同步EditLog，从而保证了HA。

Active NameNode 向 JournalNode 集群提交 EditLog 是同步的
但 Standby NameNode 采用的是定时从 JournalNode 集群上同步 EditLog 的方式，那么 Standby NameNode 内存中文件系统镜像有很大的可能是落后于 Active NameNode 的，
所以 Standby NameNode 在转换为 Active NameNode 的时候需要把落后的 EditLog 补上来。

具体的同步过程可参考： [Hadoop NameNode 高可用 (High Availability) 实现解析](https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/)

In order to provide a fast failover, it is also necessary that the Standby node have up-to-date information
regarding the location of blocks in the cluster. In order to achieve this, the DataNodes are configured with the location of both NameNodes, 
and send block location information and heartbeats to both.

此外，为了**实现快速failover**，StandBy NameNode 需要实时地与各个DataNode通信以获得每个**数据块的地址**信息。为咐要这样？

因为：每个数据块的地址信息不属于“元信息”，并没有保存在 FsImage、CheckPoint...，这是因为地址信息变化比较大。比如说，一台DataNode下线了，其上面的数据块地址信息就全无效了，而且为了达到指定的数据块“复制因子”，还需要在其他机器上复制该数据块。

而快速failover，是指Active NameNode宕机后，StandBy NameNode立即就能提供服务。因此，DataNode也需要实时向 StandBy NameNode 发送 block report

另外，还有手动failover 和 自动 failover，自动failover需要Zookeeper的支持，具体可参考官网：[HDFS High Availability Using the Quorum Journal Manager](https://hadoop.apache.org/docs/r2.7.1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html)

**如何避免“Split Brain”(脑裂)问题？**

Split Brain 是指在同一时刻有两个认为自己处于 Active 状态的 NameNode。

when a NameNode sends any message (or remote procedure call) to a JournalNode, it includes its epoch number as part of the request. 
Whenever the JournalNode receives such a message, it compares the epoch number against a locally stored value called the promised epoch. 
If the request is coming from a newer epoch, then it records that new epoch as its promised epoch.
 If instead the request is coming from an older epoch, then it rejects the request. This simple policy avoids split-brain

简单地理解如下：每个NameNode 与 JournalNodes通信时，需要带一个 epoch numbers(epoch numbers 是唯一的且只增不减)。而每个JournalNode 都有一个本地的promised epoch。拥有值大的epoch numbers 的NameNode会使得JournalNode提升自己的 promised epoch，从而占大多数，而epoch numbers较小的那个NameNode就成了少数派(Paxos协议思想)。

从而**epoch number值大的NameNode才是真正的Active NameNode**，拥有写JournalNode的权限。注意：（任何时刻只允许一个NameNode拥有写JournalNode权限）

when using the Quorum Journal Manager, only one NameNode will ever be allowed to write to the JournalNodes,
so there is no potential for corrupting the file system metadata from a split-brain scenario.

具体实现[可参考：（还提到了QJM的优点）](http://blog.cloudera.com/blog/2012/10/quorum-based-journaling-in-cdh4-1/)
