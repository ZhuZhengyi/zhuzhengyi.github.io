# [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/description/ "https://leetcode-cn.com/problems/longest-valid-parentheses/description/")

| Category   | Difficulty    | Likes | Dislikes |
| ---------- | ------------- | ----- | -------- |
| algorithms | Hard (29.67%) | 543   | -        |

**Tags**

[`string`](https://leetcode.com/tag/string "https://leetcode.com/tag/string") | [`dynamic-programming`](https://leetcode.com/tag/dynamic-programming "https://leetcode.com/tag/dynamic-programming")

**Companies**

`Unknown`

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

---

[Discussion](https://leetcode-cn.com/problems/longest-valid-parentheses/comments/ "https://leetcode-cn.com/problems/longest-valid-parentheses/comments/") | [Solution](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/ "https://leetcode-cn.com/problems/longest-valid-parentheses/solution/")

## 解法

### 动态规划

重点是把括号匹配的关系理清楚：

- `(`在前，`)`在后
- 如果`(`和`)`之间是`(...)`且`(...)`是**有效括号序列**，那么`...`一定由0到多个不定长度的**有效括号序列**组成

理清括号匹配的关系后，再思考怎么用dp去套。。。

可以用`dp[i][j] == true`来表示`[i, j]`是**有效括号序列**，但实际上不用二维数组，一维就够了，`dp[i][j] == true`记录了两个信息

- `i`到`j`的长度，即`j - i + 1`
- `i`到`j`之间，符合**有效括号序列**

这两个信息，用一维数组即可记录，`dp[i] = n`，表示以`i`为结尾的长为`n`的**有效括号序列**。那么当碰到某个字符是`)`的时候，需要找到与之匹配且没有被匹配的`(`：

- `dp[i - 1]`记录的就是以`i`为结尾的长为`n`的**最长有效括号序列**
- `i - dp[i - 1] - 1`就是与之匹配且没有被匹配的`(`所在的位置

所以长度就是：`dp[i] = (i - j + 1) + ((j - 1) >= 0 ? dp[j - 1] : 0)`

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int ans = 0;
        vector<int> dp(s.length(), 0);
        for (int i = 1; i < s.length(); i++) {
            if (s[i] == ')') {
                int j = i - dp[i - 1] - 1;
                if (j >= 0 && s[j] == '(') 
                    dp[i] = (i - j + 1) + ((j - 1) >= 0 ? dp[j - 1] : 0);
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```
