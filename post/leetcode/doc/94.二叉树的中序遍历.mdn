# [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/ "https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/")

| Category   | Difficulty      | Likes | Dislikes |
| ---------- | --------------- | ----- | -------- |
| algorithms | Medium (68.96%) | 339   | -        |

**Tags** **Companies**

给定一个二叉树，返回它的*中序  *遍历。

**示例:**

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```

**进阶:**  递归算法很简单，你可以通过迭代算法完成吗？

---

[Discussion](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/comments/ "https://leetcode-cn.com/problems/binary-tree-inorder-traversal/comments/") | [Solution](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/ "https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/")

## 代码

- 递归法

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        if root.left:
            res += self.inorderTraversal(root.left)
        res.append(root.val)
        if root.right:
            res += self.inorderTraversal(root.right)

        return res
```

- 迭代

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res

        pending = [] #
        cur = root
        while True:
            while cur: #pending current node if left exists
                pending.append(cur)
                cur = cur.left
            if not pending:
                return res
            cur = pending.pop()
            res.append(cur.val)
            cur = cur.right
```
