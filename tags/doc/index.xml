<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>doc on Justice的小站</title><link>https://justice.bj.cn/tags/doc/</link><description>Recent content in doc on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 23 Oct 2021 12:37:51 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/tags/doc/index.xml" rel="self" type="application/rss+xml"/><item><title>吃掉 N 个橘子的最少天数</title><link>https://justice.bj.cn/post/leetcode/1553.%E5%90%83%E6%8E%89-n-%E4%B8%AA%E6%A9%98%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/</link><pubDate>Sat, 23 Oct 2021 12:37:51 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/1553.%E5%90%83%E6%8E%89-n-%E4%B8%AA%E6%A9%98%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/</guid><description>吃掉 N 个橘子的最少天数 Category Difficulty Likes Dislikes algorithms Hard (26.35%) 96 - Tags Unknown Companies Unknown 厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子： 吃掉一个橘子。 如果剩余橘子数 n</description></item><item><title>二叉树的层序遍历</title><link>https://justice.bj.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link><pubDate>Sun, 10 Oct 2021 14:35:02 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid><description>二叉树的层序遍历 Category Difficulty Likes Dislikes algorithms Medium (60.88%) 391 - Tags tree | breadth-first-search Companies amazon | apple | bloomberg | facebook | linkedin | microsoft 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点</description></item><item><title>LFU缓存</title><link>https://justice.bj.cn/post/leetcode/460.lfu%E7%BC%93%E5%AD%98/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/460.lfu%E7%BC%93%E5%AD%98/</guid><description>LFU缓存 Category Difficulty Likes Dislikes algorithms Hard (34.03%) 81 - Tags design Companies amazon | google 设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。 get(key) - 如果键存在于</description></item><item><title>LRU缓存机制</title><link>https://justice.bj.cn/post/leetcode/146.lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/146.lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid><description>LRU缓存机制 Category Difficulty Likes Dislikes algorithms Medium (44.70%) 332 - Tags design Companies amazon | bloomberg | facebook | google | microsoft | palantir | snapchat | twitter | uber | yahoo | zenefits 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存</description></item><item><title>Z 字形变换</title><link>https://justice.bj.cn/post/leetcode/6.z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/6.z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid><description>Z 字形变换 Category Difficulty Likes Dislikes algorithms Medium (45.86%) 564 - Tags string Companies Unknown 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &amp;quot;LEETCODEISHIRING&amp;quot; 行数为 3 时，排列如</description></item><item><title>三数之和</title><link>https://justice.bj.cn/post/leetcode/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>三数之和 Category Difficulty Likes Dislikes algorithms Medium (25.59%) 1827 - Tags array | two-pointers Companies adobe | amazon | bloomberg | facebook | microsoft 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 *a + b</description></item><item><title>下降路径最小和 II</title><link>https://justice.bj.cn/post/leetcode/1289.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C-ii/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/1289.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C-ii/</guid><description>下降路径最小和 II Category Difficulty Likes Dislikes algorithms Hard (60.08%) 25 - Tags Unknown Companies Unknown 给你一个整数方阵 arr ，定义「非零偏移下降路径」为：从 arr 数组中的每一行选择一个数字，且按顺序选出来的数</description></item><item><title>两两交换链表中的节点</title><link>https://justice.bj.cn/post/leetcode/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description>两两交换链表中的节点 Category Difficulty Likes Dislikes algorithms Medium (63.29%) 359 - Tags linked-list Companies bloomberg | microsoft | uber 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部</description></item><item><title>两数之和</title><link>https://justice.bj.cn/post/leetcode/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>两数之和 Category Difficulty Likes Dislikes algorithms Easy (47.03%) 6994 - Tags Companies 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你</description></item><item><title>两链表数相加</title><link>https://justice.bj.cn/post/leetcode/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid><description>两链表数相加 Category Difficulty Likes Dislikes algorithms Medium (36.10%) 3467 - Tags****Companies 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能</description></item><item><title>买卖股票的最佳时机</title><link>https://justice.bj.cn/post/leetcode/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid><description>买卖股票的最佳时机 Category Difficulty Likes Dislikes algorithms Easy (52.41%) 779 - Tags array | dynamic-programming Companies amazon | bloomberg | facebook | microsoft | uber 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成</description></item><item><title>买卖股票的最佳时机 II</title><link>https://justice.bj.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</guid><description>买卖股票的最佳时机 II Category Difficulty Likes Dislikes algorithms Easy (57.53%) 613 - Tags array | greedy Companies bloomberg 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大</description></item><item><title>买卖股票的最佳时机 III</title><link>https://justice.bj.cn/post/leetcode/123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iii/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iii/</guid><description>买卖股票的最佳时机 III Category Difficulty Likes Dislikes algorithms Hard (41.21%) 308 - Tags array | dynamic-programming Companies Unknown 给定一个数组，它的第* i* 个元素是一支给定的股票在第 *i *天的价格。 设计一个算法来计算你所能获</description></item><item><title>二叉搜索树的最小绝对差</title><link>https://justice.bj.cn/post/leetcode/530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</guid><description>二叉搜索树的最小绝对差 Category Difficulty Likes Dislikes algorithms Easy (55.49%) 99 - Tags tree Companies google 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例： 1 2</description></item><item><title>二叉树展开为链表</title><link>https://justice.bj.cn/post/leetcode/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid><description>二叉树展开为链表 Category Difficulty Likes Dislikes algorithms Medium (68.83%) 340 - Tags tree | depth-first-search Companies microsoft 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 1 2 3 4 5 1 / \ 2 5 / \ \ 3 4 6 将其</description></item><item><title>二叉树的中序遍历</title><link>https://justice.bj.cn/post/leetcode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid><description>二叉树的中序遍历 Category Difficulty Likes Dislikes algorithms Medium (68.96%) 339 - Tags****Companies 给定一个二叉树，返回它的*中序 *遍历。 示例: 1 2 3 4 5 6 7 8 输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,3,2] 进阶: 递归算法很简</description></item><item><title>二叉树的直径</title><link>https://justice.bj.cn/post/leetcode/543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</guid><description>二叉树的直径 Category Difficulty Likes Dislikes algorithms Easy (47.16%) 209 - Tags tree Companies facebook | google 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条</description></item><item><title>分隔链表</title><link>https://justice.bj.cn/post/leetcode/86.%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/86.%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</guid><description>分隔链表 Category Difficulty Likes Dislikes algorithms Medium (55.90%) 158 - Tags linked-list | two-pointers Companies Unknown 给定一个链表和一个特定值* x*，对链表进行分隔，使得所有小于 *x* 的节点都在大于或等于 *x* 的节点之前。 你应当</description></item><item><title>删除排序链表中的重复元素</title><link>https://justice.bj.cn/post/leetcode/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0i/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0i/</guid><description>删除排序链表中的重复元素 Category Difficulty Likes Dislikes algorithms Easy (49.10%) 260 - Tags linked-list Companies Unknown 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 1 2 输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2 示</description></item><item><title>删除排序链表中的重复元素 II</title><link>https://justice.bj.cn/post/leetcode/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9ii/</link><pubDate>Fri, 25 Dec 2020 10:57:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9ii/</guid><description>删除排序链表中的重复元素 II Category Difficulty Likes Dislikes algorithms Medium (45.93%) 221 - Tags linked-list Companies Unknown 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 *没有重复出现 *的数字。 示</description></item></channel></rss>