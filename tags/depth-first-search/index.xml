<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>depth-first-search on Justice的小站</title><link>https://justice.bj.cn/tags/depth-first-search/</link><description>Recent content in depth-first-search on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 15 Mar 2023 13:30:59 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/tags/depth-first-search/index.xml" rel="self" type="application/rss+xml"/><item><title>前序遍历构造二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/1008.%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Wed, 15 Mar 2023 13:30:59 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/1008.%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>前序遍历构造二叉搜索树 Category Difficulty Likes Dislikes algorithms Medium (72.08%) 248 - Tags dynamic-programming | tree | depth-first-search Companies Unknown 给定一个整数数组，它表示BST(即 二叉搜索树 )的 先****序遍历 ，构造树并返回其根。</description></item><item><title>二叉树的右视图</title><link>https://justice.bj.cn/post/leetcode/doc/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link><pubDate>Wed, 15 Mar 2023 09:42:25 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid><description>二叉树的右视图 Category Difficulty Likes Dislikes algorithms Medium (65.76%) 827 - Tags tree | depth-first-search | breadth-first-search Companies amazon 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能</description></item><item><title>字符串解码</title><link>https://justice.bj.cn/post/leetcode/doc/394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link><pubDate>Wed, 08 Mar 2023 19:49:11 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid><description>字符串解码 Category Difficulty Likes Dislikes algorithms Medium (56.01%) 1124 - Tags stack | depth-first-search Companies google | yelp 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，</description></item><item><title>删除无效的括号</title><link>https://justice.bj.cn/post/leetcode/doc/301.%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link><pubDate>Thu, 08 Dec 2022 21:16:39 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/301.%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid><description>删除无效的括号 Category Difficulty Likes Dislikes algorithms Hard (55.14%) 796 - Tags depth-first-search | breadth-first-search Companies facebook 给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。 返回所有可</description></item><item><title>岛屿的最大面积</title><link>https://justice.bj.cn/post/leetcode/doc/695.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</link><pubDate>Wed, 09 Nov 2022 15:16:24 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/695.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</guid><description>岛屿的最大面积 Category Difficulty Likes Dislikes algorithms Medium (67.92%) 876 - Tags array | depth-first-search Companies Unknown 给你一个大小为 m x n 的二进制矩阵 grid 。 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要</description></item><item><title>大礼包</title><link>https://justice.bj.cn/post/leetcode/doc/638.%E5%A4%A7%E7%A4%BC%E5%8C%85/</link><pubDate>Sat, 21 May 2022 21:16:23 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/638.%E5%A4%A7%E7%A4%BC%E5%8C%85/</guid><description>大礼包 Category Difficulty Likes Dislikes algorithms Medium (64.38%) 327 - Tags dynamic-programming | depth-first-search Companies google 在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销</description></item><item><title>二叉树展开为链表</title><link>https://justice.bj.cn/post/leetcode/doc/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 10 May 2022 22:29:26 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid><description>二叉树展开为链表 Category Difficulty Likes Dislikes algorithms Medium (68.83%) 340 - Tags tree | depth-first-search Companies microsoft 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 1 2 3 4 5 1 / \ 2 5 / \ \ 3 4 6 将其</description></item><item><title>二叉树的最小深度</title><link>https://justice.bj.cn/post/leetcode/doc/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link><pubDate>Tue, 10 May 2022 22:29:26 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid><description>二叉树的最小深度 Category Difficulty Likes Dislikes algorithms Easy (49.24%) 656 - Tags tree | depth-first-search | breadth-first-search Companies Unknown 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说</description></item><item><title>有序链表转换二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Sun, 01 May 2022 21:13:29 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>有序链表转换二叉搜索树 Category Difficulty Likes Dislikes algorithms Medium (76.22%) 659 - Tags linked-list | depth-first-search Companies zenefits 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平</description></item><item><title>恢复二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Sat, 30 Apr 2022 15:21:08 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>恢复二叉搜索树 Category Difficulty Likes Dislikes algorithms Medium (60.48%) 708 - Tags tree | depth-first-search Companies Unknown 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这</description></item><item><title>将有序数组转换为二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Thu, 17 Mar 2022 09:56:25 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>将有序数组转换为二叉搜索树 Category Difficulty Likes Dislikes algorithms Easy (76.25%) 917 - Tags tree | depth-first-search Companies airbnb 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高</description></item><item><title>平衡二叉树</title><link>https://justice.bj.cn/post/leetcode/doc/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Thu, 17 Mar 2022 09:56:25 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>平衡二叉树 Category Difficulty Likes Dislikes algorithms Easy (56.52%) 872 - Tags tree | depth-first-search Companies bloomberg 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的</description></item><item><title>递增子序列</title><link>https://justice.bj.cn/post/leetcode/doc/491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link><pubDate>Fri, 18 Feb 2022 10:14:15 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid><description>递增子序列 Category Difficulty Likes Dislikes algorithms Medium (53.91%) 391 - Tags depth-first-search Companies yahoo 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序</description></item><item><title>相同的树</title><link>https://justice.bj.cn/post/leetcode/doc/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link><pubDate>Sat, 22 Jan 2022 21:40:05 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid><description>相同的树 Category Difficulty Likes Dislikes algorithms Easy (59.91%) 753 - Tags tree | depth-first-search Companies bloomberg 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有</description></item><item><title>验证二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Sat, 22 Jan 2022 21:40:05 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>验证二叉搜索树 Category Difficulty Likes Dislikes algorithms Medium (35.36%) 1387 - Tags tree | depth-first-search Companies amazon | bloomberg | facebook | microsoft 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下：</description></item><item><title>对称二叉树</title><link>https://justice.bj.cn/post/leetcode/doc/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Thu, 20 Jan 2022 09:40:30 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>对称二叉树 Category Difficulty Likes Dislikes algorithms Easy (56.66%) 1665 - Tags tree | depth-first-search | breadth-first-search Companies bloomberg | linkedin | microsoft 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 2 3 4 5 1 / \ 2 2 / \</description></item><item><title>岛屿数量</title><link>https://justice.bj.cn/post/leetcode/doc/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</link><pubDate>Sat, 23 Oct 2021 20:27:22 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</guid><description>岛屿数量 Category Difficulty Likes Dislikes algorithms Medium (47.04%) 555 - Tags depth-first-search | breadth-first-search | union-find Companies amazon | facebook | google | microsoft | zenefits 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</description></item><item><title>最近的请求次数</title><link>https://justice.bj.cn/post/leetcode/doc/933.%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</link><pubDate>Sat, 23 Oct 2021 20:27:22 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/933.%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</guid><description>最近的请求次数 Category Difficulty Likes Dislikes algorithms Easy (70.12%) 46 - Tags tree | depth-first-search Companies Unknown 写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时</description></item></channel></rss>