<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>writing-an-os-in-rust on Justice的小站</title><link>https://justice.bj.cn/categories/writing-an-os-in-rust/</link><description>Recent content in writing-an-os-in-rust on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 07 Mar 2024 11:58:54 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/categories/writing-an-os-in-rust/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU异常</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/05-cpu-exceptions/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/05-cpu-exceptions/</guid><description>CPU异常 原文：https://os.phil-opp.com/cpu-exceptions/ 原作者：@phil-opp 译者：倪广野 触发CP</description></item><item><title>使用Rust编写操作系统（一）：独立式可执行程序</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/01-freestanding-rust-binary/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/01-freestanding-rust-binary/</guid><description>使用Rust编写操作系统（一）：独立式可执行程序 我们的第一步，是在不连接标准库的前提下，创建独立的Rust可执行文件。无需底层操作系统的支撑</description></item><item><title>使用Rust编写操作系统（七）：硬件中断</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/07-hardware-interrupts/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/07-hardware-interrupts/</guid><description>使用Rust编写操作系统（七）：硬件中断 在这一章中，我们将会学习如何设置可编程中断控制器（Programmable Interrupt Controller，P</description></item><item><title>使用Rust编写操作系统（三）：VGA字符模式</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/03-vga-text-mode/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/03-vga-text-mode/</guid><description>使用Rust编写操作系统（三）：VGA字符模式 VGA字符模式（VGA text mode）是打印字符到屏幕的一种简单方式。在这篇文章中，为了包装这个模</description></item><item><title>使用Rust编写操作系统（二）：最小化内核</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/02-minimal-rust-kernel/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/02-minimal-rust-kernel/</guid><description>使用Rust编写操作系统（二）：最小化内核 这篇文章将基于x86架构（the x86 architecture）；我们是试着使用Rust语言，编写一个</description></item><item><title>使用Rust编写操作系统（四）：内核测试</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/04-testing/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/04-testing/</guid><description>使用Rust编写操作系统（四）：内核测试 本文主要讲述了在no_std环境下进行单元测试和集成测试的方法。我们将通过Rust的自定义测试框架来</description></item><item><title>使用Rust编写操作系统（附录一）：链接器参数</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/appendix-a-linker-arguments/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/appendix-a-linker-arguments/</guid><description>使用Rust编写操作系统（附录一）：链接器参数 用Rust编写操作系统时，我们可能遇到一些链接器错误。这篇文章中，我们不将更换编译目标，而传送</description></item><item><title>使用Rust编写操作系统（附录三）：禁用SIMD</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/appendix-c-disable-simd/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/appendix-c-disable-simd/</guid><description>使用Rust编写操作系统（附录三）：禁用SIMD 单指令多数据流（Single Instruction Multiple Data，SIMD）指令能够同时对多个数据字（data wor</description></item><item><title>使用Rust编写操作系统（附录二）：禁用红区</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/appendix-b-red-zone/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/appendix-b-red-zone/</guid><description>使用Rust编写操作系统（附录二）：禁用红区 红区（redzone）是System V ABI提供的一种优化的产物，它允许函数无需调整栈指针（st</description></item><item><title>双重异常</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/06-double-fault-exceptions/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/06-double-fault-exceptions/</guid><description>双重异常 原文：https://os.phil-opp.com/double-fault-exceptions/ 原作者：@phil-opp 译者</description></item><item><title>译名表</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/translation-table/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/translation-table/</guid><description>译名表 收录书中涉及专有名词的英文单词、短语，给出本书的中文译名。 采纳惯用译名为主。没有合适译名的，尽量做到信、达、雅的前提下，给出新翻译。 英</description></item><item><title>内存分配器设计</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/</link><pubDate>Wed, 22 Jan 2020 18:31:30 +0000</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/11-allocator-designs/</guid><description>这篇文章介绍了如何从头开始实现堆分配器。它提出并讨论了不同的分配器设计，包括Bump分配，基于链表的分配和固定大小的块分配。 对于这三种设计中的每一种，我们将创建一个可用于我们的内核的基本实现。</description></item><item><title>Async/Await</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/12-async-await/</link><pubDate>Sun, 29 Sep 2019 09:45:40 +0000</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/12-async-await/</guid><description>在本文中，我们将探讨协作式多任务处理以及Rust的async/await功能。我们详细研究了Rust中async/await的工作方式，包括Future trait的设计，状态机转换和pinning。然后，我们将会通过创建异步键盘任务和基本executor，将对async/await的基本支持添加到内核中。</description></item><item><title>分配堆内存</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/</link><pubDate>Sun, 29 Sep 2019 09:45:40 +0000</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/10-heap-allocation/</guid><description>这篇文章为我们的内核增加了对堆分配的支持。 首先，它介绍了动态内存，并展示了借用检查器如何防止常见的分配错误。 然后，它实现Rust的基本分配接口，创建一个堆内存区域，并设置一个分配器crate。 在这篇文章的结尾，内置分配crate的所有分配和收集类型将对我们的内核可用。</description></item><item><title>实现分页</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/09-paging-implementation/</link><pubDate>Wed, 25 Sep 2019 07:43:38 +0000</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/09-paging-implementation/</guid><description>这篇文章展示了如何在我们的内核中实现分页支持。 首先探讨了使内核可以访问物理页表帧的各种技术，并讨论了它们各自的优缺点。 然后，它实现了地址转换功能和创建新地址映射的功能。</description></item><item><title>介绍分页</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/08-introduction-to-paging/</link><pubDate>Thu, 31 Jan 2019 18:20:38 +0000</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/08-introduction-to-paging/</guid><description>这篇文章介绍了分页，这是一种非常常见的内存管理方案，我们也将将其用于我们的操作系统。 它解释了为什么需要内存隔离，分段如何工作，虚拟内存是什么，以及分页如何解决内存碎片问题。 它还探讨了x86_64架构上多级页表的布局。</description></item></channel></rss>