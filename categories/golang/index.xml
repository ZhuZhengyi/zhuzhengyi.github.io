<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Justice的小站</title><link>https://justice.bj.cn/categories/golang/</link><description>Recent content in golang on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 28 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://justice.bj.cn/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang错误处理</title><link>https://justice.bj.cn/post/14.language/golang/golang%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link><pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid><description>Golang错误处理 简介 参考 https://coolshell.cn/articles/21140.html</description></item><item><title>图解 Golang 的 GC 算法</title><link>https://justice.bj.cn/post/14.language/golang/golang-gc%E7%AE%97%E6%B3%95/</link><pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang-gc%E7%AE%97%E6%B3%95/</guid><description>图解 Golang 的 GC 算法 简介 虽然 Golang 的 GC 自打一开始，就被人所诟病，但是经过这么多年的发展，Golang 的 GC 已经改善了非常多，变得非常优秀了。 以下是 Golang GC 算</description></item><item><title>Golang 调试工具PProf</title><link>https://justice.bj.cn/post/14.language/golang/golang%E8%B0%83%E8%AF%95pprof/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E8%B0%83%E8%AF%95pprof/</guid><description>Golang 调试工具PProf 简介 pprof是golang官方自带的性能调试工具。 操作 1 2 # $ go tool pprof http://localhost:6060/debug/pprof/profile?seconds=60 参考 https://cizixs.com/2017/09/11/profiling-golang-program/</description></item><item><title>Goroutine</title><link>https://justice.bj.cn/post/14.language/golang/goroutine/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/goroutine/</guid><description>Goroutine 简介 goroutine是go中的协程。goroutine基于线程池+任务队列模型，实现了用户态的任务调度功能。 历史演化 历史上几个不同版本的</description></item><item><title>Golang Runtime</title><link>https://justice.bj.cn/post/14.language/golang/golang-runtime/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang-runtime/</guid><description>Golang Runtime 简介 Go调度器的演化 源码分析 Go 程序启动后需要对自身运行时进行初始化，其真正的程序入口由 runtime 包控制。 以 AMD64 架构上的 Linux 和 macOS 为例，分别位于：src</description></item><item><title>Golang 内存管理</title><link>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>Golang 内存管理 简介 Golang内存管理采用类似tcmalloc的分级分配算法，主要由MHeap、MCentral、MCache 3 级组成。按分配对</description></item><item><title>Go语言之cgo</title><link>https://justice.bj.cn/post/14.language/golang/golang%E4%B9%8Bcgo/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E4%B9%8Bcgo/</guid><description>Go语言之cgo 简介 Go语言通过自带的CGO的工具来支持C语言函数调用，也可以用Go语言导出C动态库接口给其它语言使用。 原理 Go的代码执行环</description></item><item><title>Golang基础</title><link>https://justice.bj.cn/post/14.language/golang/golang%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E5%9F%BA%E7%A1%80/</guid><description>Golang基础 简介 初始化 规则： 每个package 只会被初始化一次； 同一个 package，不同文件是按照文件名的顺序来初始化； 不能循环 import , 例</description></item><item><title>Golang 编程规范</title><link>https://justice.bj.cn/post/14.language/golang/golang%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</guid><description>Golang 编程规范 目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 &amp;lt;GO_PROJECT&amp;gt;/ |--pkg/ # 公有代码目录，其他的项目可以直接通过 import 引入这里的代码 |--internel/ # 私有代码目录，在其他项目引入包含</description></item><item><title>可视化Go内存管理</title><link>https://justice.bj.cn/post/14.language/golang/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>可视化Go内存管理 这篇文章基于Go 1.13的默认官方实现，有些概念细节可能会在Go的未来版本中发生变化 Go内部内存结构 首先，让我们看看Go内</description></item><item><title>Golang之unsafe</title><link>https://justice.bj.cn/post/14.language/golang/golang%E4%B9%8Bunsafe/</link><pubDate>Thu, 18 Mar 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E4%B9%8Bunsafe/</guid><description>Golang之unsafe 简介 unsafe包 unsafe 包中的几个函数都是在编译期间执行的。 1 2 3 4 5 6 type ArbitraryType int type Pointer *ArbitraryType func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr Pointer unsa</description></item><item><title>Golang Channel</title><link>https://justice.bj.cn/post/14.language/golang/golang-channel/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang-channel/</guid><description>Golang Channel 简介 Go语言channel是first-class的，可以被存储到变量中，可以作为参数传递给函数，也可以作为函数的返回值返回 定义 1 2 3 4</description></item><item><title>Golang 汇编</title><link>https://justice.bj.cn/post/14.language/golang/golang-asm/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang-asm/</guid><description>Golang 汇编 简介 golang汇编源于plan9， 参考 https://jiajunhuang.com/articles/2020_04_22-go_asm.md.html golang 汇编 — 源代码 golang-notes/assembly.md at master · cch123/golang-notes · GitHub</description></item><item><title>context</title><link>https://justice.bj.cn/post/14.language/golang/golang%E5%B8%B8%E7%94%A8%E5%BA%93/context/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E5%B8%B8%E7%94%A8%E5%BA%93/context/</guid><description>context 简介 context 是 go 1.7 引入的，用于在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。 context.Context 类型的值可以协调多个 groutine 中的代码执行 “取消”</description></item><item><title>Go generate</title><link>https://justice.bj.cn/post/14.language/golang/go-generate/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/go-generate/</guid><description>Go generate 简介 go generate命令是在Go语言 1.4 版本里面新添加的一个命令，当运行该命令时，它将扫描与当前包相关的源代码文件，找出所有包含//go</description></item><item><title>gorilla/mux</title><link>https://justice.bj.cn/post/14.language/golang/golang%E5%B8%B8%E7%94%A8%E5%BA%93/gorilla_mux/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E5%B8%B8%E7%94%A8%E5%BA%93/gorilla_mux/</guid><description>gorilla/mux 简介 gorilla/mux是一个强大的路由，小巧但是稳定高效，不仅可以支持正则路由还可以按照Method，header，host等信息匹配</description></item><item><title>gorocksdb 编译</title><link>https://justice.bj.cn/post/14.language/golang/gorocksdb%E7%BC%96%E8%AF%91/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/gorocksdb%E7%BC%96%E8%AF%91/</guid><description>gorocksdb 编译 简介 编译 1. rocksdb 5.9.2版本的编译(Mac 环境) 1 2 3 4 5 $ git clone http://github.com/homebrew/homebrew-core $ vi homebrew-core/Formula/rocksdb.rb url &amp;#34;https://github.com/facebook/rocksdb/archive/v5.9.2.tar.gz&amp;#34; sha256 &amp;#34;784023d5fea572e860938ec9041e064c9ca529a129574d7fccb74618c7e0dad8&amp;#34; $ brew install homebrew-core/Formula/rocksdb.rb 2. gorocksdb 对应版本的安装 1 2 3 4 CGO_CFLAGS=&amp;#34;-I/usr/local/Cellar/rocksdb/5.9.2/include&amp;#34; \ CGO_LDFLAGS=&amp;#34;-L/usr/local/Cellar/rocksdb/5.9.2 -lrocksdb -lstdc++ -lm -lz -lbz2 -lsnappy&amp;#34; \ go</description></item><item><title>Unsafe Pointer</title><link>https://justice.bj.cn/post/14.language/golang/golang-unsafe.pointer/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang-unsafe.pointer/</guid><description>Unsafe Pointer 前言 在大家学习 Go 的时候，肯定都学过 “Go 的指针是不支持指针运算和转换” 这个知识点。为什么呢？ 首先，Go 是一门静态语言，所有的变量都必须为</description></item></channel></rss>