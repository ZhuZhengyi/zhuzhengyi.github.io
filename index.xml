<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 07 Jan 2024 23:13:18 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>26.fork中进程基本信息的复制</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/26.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%8D%E5%88%B6/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/26.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%8D%E5%88%B6/</guid><description>&lt;h1 id="26fork中进程基本信息的复制">26.fork中进程基本信息的复制&lt;/h1>
&lt;p>书接上回，上回书咱们说到，fork 触发系统调用中断，最终调用到了 sys_fork 函数，借这个过程介绍了一次&lt;strong>系统调用&lt;/strong>的流程。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-36-57-ac20ac53da433f32fb4b63fc8a4e6216.png" alt="图片">&lt;/p>
&lt;p>那今天我们回到正题，开始讲 &lt;strong>fork&lt;/strong> 函数的原理，实际上就是 &lt;strong>sys_fork&lt;/strong> 函数干了啥。&lt;/p>
&lt;p>还是个汇编代码，但我们要关注的地方不多。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">_sys_fork:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_find_empty_process&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">testl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">js&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="nv">f&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">gs&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esi&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">edi&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">ebp&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_copy_process&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">addl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esp&lt;/span>
&lt;span class="err">1:  &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其实就是调用了两个函数。我们先从方法名直接翻译一下，猜猜意思。&lt;/p>
&lt;p>先是 &lt;strong>find_empty_process&lt;/strong>，就是找到空闲的进程槽位。&lt;/p>
&lt;p>然后 &lt;strong>copy_process&lt;/strong>，就是复制进程。&lt;/p>
&lt;p>那妥了，这个方法的意思非常简单，因为存储进程的数据结构是一个 task[64] 数组，这个是在之前 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的&lt;/a> &lt;strong>sched_init&lt;/strong> 函数的时候设置的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-05-c020554e43a7953a291a905a845b6176.png" alt="图片">&lt;/p>
&lt;p>就是先在这个数组中找一个空闲的位置，准备存一个新的进程的结构 &lt;strong>task_struct&lt;/strong>，这个结构之前在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501576&amp;amp;idx=1&amp;amp;sn=657e1c89d1007a935820d394d64f4035&amp;amp;chksm=c2c5bda5f5b234b3654c5ea2113cc0d48eee854f9f035ec69ec44bf9d964ae6cd4c181ed5880&amp;amp;scene=21#wechat_redirect">一个新进程的诞生（三）如果让你来设计进程调度&lt;/a> 也简单说过了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个结构各个字段具体赋什么值呢？&lt;/p>
&lt;p>通过 &lt;strong>copy_process&lt;/strong> 这个名字我们知道，就是复制原来的进程，也就是当前进程。&lt;/p>
&lt;p>当前只有一个进程，就是数组中位置 0 处的 &lt;strong>init_task.init&lt;/strong>，也就是零号进程，那自然就复制它咯。&lt;/p>
&lt;p>好了，以上只是我们的猜测，有了猜测再看代码会非常轻松，我们一个个函数看。&lt;/p>
&lt;p>先来 &lt;strong>find_empty_process&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">long&lt;/span> &lt;span class="n">last_pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">find_empty_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nl">repeat&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">last_pid&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EAGAIN&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一共三步，很简单。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>第一步&lt;/strong>，判断 ++last_pid 是不是小于零了，小于零说明已经超过 long 的最大值了，重新赋值为 1，起到一个保护作用，这没什么好说的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二步&lt;/strong>，一个 for 循环，看看刚刚的 last_pid 在所有 task[] 数组中，是否已经被某进程占用了。如果被占用了，那就重复执行，再次加一，然后再次判断，直到找到一个 pid 号没有被任何进程用为止。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三步&lt;/strong>，又是个 for 循环，刚刚已经找到一个可用的 pid 号了，那这一步就是再次遍历这个 task[] 试图找到一个空闲项，找到了就返回素组索引下标。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>最终，这个方法就返回 task[] 数组的索引，表示找到了一个空闲项&lt;/strong>，之后就开始往这里塞一个新的进程吧。&lt;/p>
&lt;p>由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_**pid 就是 1，也就是新进程被分配的 pid 就是 1**，然后即将要加入的 task[] 数组的索引位置，也是 1。&lt;/p>
&lt;p>好的，那我们接下来就看，怎么构造这个进程结构，塞到这个 1 索引位置的 task[] 中？&lt;/p>
&lt;p>来看 &lt;strong>copy_process&lt;/strong> 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_process(int nr,long ebp,long edi,long esi,
    long gs,long none,        
    long ebx,long ecx,long edx,        
    long fs,long es,long ds,        
    long eip,long cs,long eflags,long esp,long ss){    
        struct task_struct *p;    
        int i;    
        struct file *f;    
        p = (struct task_struct *) get_free_page();    
        if (!p)        
            return -EAGAIN;    
        task[nr] = p;    
        *p = *current;  /* NOTE! this doesn&amp;#39;t copy the supervisor stack */    
        p-&amp;gt;state = TASK_UNINTERRUPTIBLE;    
        p-&amp;gt;pid = last_pid;    
        p-&amp;gt;father = current-&amp;gt;pid;    
        p-&amp;gt;counter = p-&amp;gt;priority;    
        p-&amp;gt;signal = 0;    
        p-&amp;gt;alarm = 0;    
        p-&amp;gt;leader = 0;      /* process leadership doesn&amp;#39;t inherit */    
        p-&amp;gt;utime = p-&amp;gt;stime = 0;    
        p-&amp;gt;cutime = p-&amp;gt;cstime = 0;    
        p-&amp;gt;start_time = jiffies;    
        p-&amp;gt;tss.back_link = 0;    
        p-&amp;gt;tss.esp0 = PAGE_SIZE + (long) p;    
        p-&amp;gt;tss.ss0 = 0x10;    
        p-&amp;gt;tss.eip = eip;    
        p-&amp;gt;tss.eflags = eflags;    
        p-&amp;gt;tss.eax = 0;    
        p-&amp;gt;tss.ecx = ecx;    p-&amp;gt;tss.edx = edx;    p-&amp;gt;tss.ebx = ebx;    
        p-&amp;gt;tss.esp = esp;    p-&amp;gt;tss.ebp = ebp;    p-&amp;gt;tss.esi = esi;    
        p-&amp;gt;tss.edi = edi;    p-&amp;gt;tss.es = es &amp;amp; 0xffff;    p-&amp;gt;tss.cs = cs &amp;amp; 0xffff;    
        p-&amp;gt;tss.ss = ss &amp;amp; 0xffff;    
        p-&amp;gt;tss.ds = ds &amp;amp; 0xffff;    
        p-&amp;gt;tss.fs = fs &amp;amp; 0xffff;    
        p-&amp;gt;tss.gs = gs &amp;amp; 0xffff;    
        p-&amp;gt;tss.ldt = _LDT(nr);    
        p-&amp;gt;tss.trace_bitmap = 0x80000000;    
        if (last_task_used_math == current)        
            __asm__(&amp;#34;clts ; fnsave %0&amp;#34;::&amp;#34;m&amp;#34; (p-&amp;gt;tss.i387));    
        if (copy_mem(nr,p)) {        
            task[nr] = NULL;        
            free_page((long) p);        
            return -EAGAIN;    
        }    
        for (i=0; i&amp;lt;NR_OPEN;i++)        
            if (f=p-&amp;gt;filp[i])            
                f-&amp;gt;f_count++;    
        if (current-&amp;gt;pwd)        
            current-&amp;gt;pwd-&amp;gt;i_count++;    
        if (current-&amp;gt;root)        
            current-&amp;gt;root-&amp;gt;i_count++;    
        if (current-&amp;gt;executable)        
            current-&amp;gt;executable-&amp;gt;i_count++;    
        set_tss_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_TSS_ENTRY,&amp;amp;(p-&amp;gt;tss));    
        set_ldt_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_LDT_ENTRY,&amp;amp;(p-&amp;gt;ldt));    
        p-&amp;gt;state = TASK_RUNNING;    /* do this last, just in case */    
        return last_pid;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>艾玛，这也太多了！&lt;/p>
&lt;p>别急，大部分都是 tss 结构的复制，以及一些无关紧要的分支，看我简化下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span>         
        &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">..&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">edx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ebx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">set_tss_desc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gdt&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">FIRST_TSS_ENTRY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">set_ldt_desc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gdt&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">FIRST_LDT_ENTRY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_RUNNING&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数本来就是 fork 的难点了，所以我们慢慢来。&lt;/p>
&lt;p>首先 &lt;strong>get_free_page&lt;/strong> 会在主内存末端申请一个空闲页面，还记得我们之前在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;chksm=c2c5bb94f5b2328224fbc1309718ac7e022bfa32dbf3d6f593b23f2f58ffd0910fe80de05a7f&amp;amp;scene=21#wechat_redirect">第13回 内存初始化 mem_init&lt;/a> 里是怎么管理内存的吧？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-16-81592896590d34b5d2a86ac5f245a0e2.png" alt="图片">&lt;/p>
&lt;p>那 get_free_page 这个函数就很简单了，&lt;strong>就是遍历 mem_map[] 这个数组，找出值为零的项，就表示找到了空闲的一页内存&lt;/strong>。然后把该项置为 1，表示该页已经被使用。最后，算出这个页的内存起始地址，返回。&lt;/p>
&lt;p>然后，拿到的这个内存起始地址，就给了 task_struct 结构的 p。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span>         
        &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>于是乎，一个进程结构 task_struct 就在内存中有了一块空间，但此时还没有赋值具体的字段。别急。&lt;/p>
&lt;p>首先将这个 p 记录在进程管理结构 task[] 中。&lt;/p>
&lt;p>然后下一句&lt;code> *p = *current&lt;/code> 很简单，&lt;strong>就是把当前进程，也就是 0 号进程的 task_struct 的全部值都复制给即将创建的进程 p&lt;/strong>，目前它们两者就完全一样了。&lt;/p>
&lt;p>嗯，这就附上值了，就完全复制之前的进程的 task_struct 而已，很粗暴。&lt;/p>
&lt;p>最后的内存布局的效果就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-28-fad14d25ff86a1b16de41c6338bc2370.png" alt="图片">&lt;/p>
&lt;p>然后，进程 1 和进程 0 目前是完全复制的关系，但有一些值是需要个性化处理的，下面的代码就是把这些不一样的值覆盖掉。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">..&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">edx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ebx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PAGE_SIZE&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ss0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x10&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不一样的值，一部分是 &lt;strong>state&lt;/strong>，&lt;strong>pid&lt;/strong>，&lt;strong>counter&lt;/strong> 这种&lt;strong>进程的元信息&lt;/strong>，另一部分是 &lt;strong>tss&lt;/strong> 里面保存的各种寄存器的信息，即&lt;strong>上下文&lt;/strong>。&lt;/p>
&lt;p>这里有两个寄存器的值的赋值有些特殊，就是 ss0 和 esp0，这个表示 0 特权级也就是内核态时的 ss:esp 的指向。&lt;/p>
&lt;p>根据代码我们得知，其含义是将代码在内核态时使用的堆栈栈顶指针指向进程 task_struct 所在的 4K 内存页的最顶端，而且之后的每个进程都是这样被设置的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-38-1ed3e69dc4d8d2e9162adc6deb1cac6c.png" alt="图片">&lt;/p>
&lt;p>好了，进程槽位的申请，以及基本信息的复制，就讲完了。&lt;/p>
&lt;p>今天就这么点内容，&lt;strong>就是内存中找个地方存一个 task_struct 结构的东东，并添加到 task[] 数组里的空闲位置处，这个东东的具体字段赋值的大部分都是复制原来进程的&lt;/strong>。&lt;/p>
&lt;p>接下来将是进程页表和段表的复制，这将会决定进程之间的内存规划问题，很是精彩，也是 fork 真正的难点所在。&lt;/p></description></item><item><title>27.进程的内存规划</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/27.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/27.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="27进程的内存规划">27.进程的内存规划&lt;/h1>
&lt;p>书接上回，上回书咱们说到，&lt;strong>fork&lt;/strong> 函数为新的进程（进程 1）申请了槽位，并把全部 &lt;strong>task_struct&lt;/strong> 结构的值都从进程零复制了过来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-44-7970d5e1e0f763b9e0e69afd9dbebfa3.png" alt="图片">&lt;/p>
&lt;p>之后，覆盖了新进程自己的基本信息，包括元信息和 tss 里的寄存器信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">..&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">edx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ebx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这可以说将 fork 函数的一半都讲完了，那我们今天展开讲讲另一半，也就是 &lt;strong>copy_mem&lt;/strong> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这将会决定进程之间的内存规划问题，十分精彩，我们开始吧。&lt;/p>
&lt;hr>
&lt;p>整个函数不长，我们还是试着先直译一下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 局部描述符表 LDT 赋值    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">old_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">data_limit&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">old_code_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">code_limit&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">code_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x0f&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">data_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x17&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">new_code_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">new_data_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 拷贝页表    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">old_code_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">old_data_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">data_limit&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，其实就是&lt;strong>新进程 LDT 表项的赋值，以及页表的拷贝&lt;/strong>。&lt;/p>
&lt;h2 id="ldt-的赋值">LDT 的赋值&lt;/h2>
&lt;p>那我们先看 LDT 表项的赋值，要说明白这个赋值的意义，得先回忆一下我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499821&amp;amp;idx=1&amp;amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;amp;scene=21#wechat_redirect">第九回 | Intel 内存管理两板斧：分段与分页&lt;/a> 刚设置完页表时说过的问题。&lt;/p>
&lt;p>程序员给出的逻辑地址最终转化为物理地址要经过这几步骤。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-38-87c01d12d6cdfe079ed2674d79751a78.png" alt="图片">&lt;/p>
&lt;p>而我们已经开启了分页，那么分页机制的具体转化是这样的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-33-49c4c8a3621c3dd867e0c3c89e366ac0.png" alt="图片">&lt;/p>
&lt;p>因为有了页表的存在，所以多了&lt;strong>线性地址空间&lt;/strong>的概念，即经过分段机制转化后，分页机制转化前的地址。&lt;/p>
&lt;p>不考虑段限长的话，32 位的 CPU 线性地址空间应为 4G。现在只有四个页目录表，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-28-f1f35edd25b98b1ce4c089865d91da64.png" alt="图片">&lt;/p>
&lt;p>把这个图和全局描述符表 GDT 联系起来，这个线性地址空间，就是经过分段机制（段可能是 GDT 也可能是 LDT）后的地址，是这样对应的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-22-17ac5f973da5f1a9aaac30b117e9f9e3.png" alt="图片">&lt;/p>
&lt;p>我们给进程 0 准备的 LDT 的代码段和数据段，段基址都是 0，段限长是 640K。给进程 1，也就是我们现在正在 fork 的这个进程，其代码段和数据段还没有设置。&lt;/p>
&lt;p>所以第一步，&lt;strong>局部描述符表 LDT 的赋值&lt;/strong>，就是给上图中那两个还未设置的代码段和数据段赋值。&lt;/p>
&lt;p>其中&lt;strong>段限长&lt;/strong>，就是取自进程 0 设置好的段限长，也就是 640K。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">code_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x0f&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">data_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x17&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而&lt;strong>段基址&lt;/strong>有点意思，是取决于当前是几号进程，也就是 nr 的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">new_code_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">new_data_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的 0x4000000 等于 64M。&lt;/p>
&lt;p>也就是说，今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间（暂不考虑段限长），且紧挨着。&lt;/p>
&lt;p>接着就把 LDT 设置进了 LDT 表里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终效果如图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-16-aa192a75588df6873a9c46c74c7c174a.png" alt="图片">&lt;/p>
&lt;p>经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是&lt;strong>段式&lt;/strong>管理。&lt;/p>
&lt;p>当然，Linux 0.11 不但是分段管理，也开启了分页管理，最终形成&lt;strong>段页式&lt;/strong>的管理方式。这就涉及到下面要说的，页表的复制。&lt;/p>
&lt;p>&lt;strong>页表的复制&lt;/strong>&lt;/p>
&lt;p>OK，上面刚刚讲完段表的赋值，接下来就是页表的复制了，这也是 copy_mem 函数里的最后一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// old=0, new=64M, limit=640K    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">data_limit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>原来进程 0 有&lt;strong>一个页目录表&lt;/strong>和&lt;strong>四个页表&lt;/strong>，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-11-f1f35edd25b98b1ce4c089865d91da64.png" alt="图片">&lt;/p>
&lt;p>那么新诞生的这个进程 2，也需要一套映射关系的页表，那我们看看这些页表是怎么建立的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/* 
&lt;/span>&lt;span class="cm">*  Well, here is one of the most complicated functions in mm. It 
&lt;/span>&lt;span class="cm">* copies a range of linerar addresses by copying only the pages. 
&lt;/span>&lt;span class="cm">* Let&amp;#39;s hope this is bug-free, &amp;#39;cause this one I don&amp;#39;t want to debug :-) 
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">from&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">to&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">){&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from_page_table&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">to_page_table&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">from_dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">to_dir&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">from_dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">from&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xffc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">to_dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xffc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mh">0x3fffff&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">22&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">from_dir&lt;/span>&lt;span class="p">))&lt;/span>            
            &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">from_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mh">0xfffff000&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">from_dir&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">to_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">()&lt;/span>        
        &lt;span class="o">*&lt;/span>&lt;span class="n">to_dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">to_page_table&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">from&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="mh">0xA0&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">this_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">))&lt;/span>                
                &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="o">*&lt;/span>&lt;span class="n">to_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">LOW_MEM&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>                
                &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>                
                &lt;span class="n">this_page&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">LOW_MEM&lt;/span>&lt;span class="p">;&lt;/span>                
                &lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="p">;&lt;/span>                
                &lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">this_page&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="p">}&lt;/span>        
        &lt;span class="p">}&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">invalidate&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先不讲这个函数，我们先看看注释。&lt;/p>
&lt;p>注释是 Linus 自己写的，他说：&lt;/p>
&lt;p>&amp;ldquo;这部分是内存管理中最复杂的代码，希望这段代码没有错误（bug-free），因为我实在不想调试它！&amp;rdquo;&lt;/p>
&lt;p>可见这是一套让 Linus 都觉得烧脑的逻辑。&lt;/p>
&lt;p>虽说代码实现很复杂，但要完成的事情确实非常简单！我想我们要是产品经理，一定会和 Linus 说这么简单的功能有啥难实现的？哈哈。&lt;/p>
&lt;p>回归正题，这个函数要完成什么事情呢？&lt;/p>
&lt;p>你想，现在进程 0 的线性地址空间是 0 - 64M，进程 1 的线性地址空间是 64M - 128M。&lt;strong>我们现在要造一个进程 1 的页表，使得进程 1 和进程 0 最终被映射到的物理空间都是 0 - 64M&lt;/strong>，这样进程 1 才能顺利运行起来，不然就乱套了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-04-7c8fdea0cad3c9569d717bd4f15bf4df.png" alt="图片">&lt;/p>
&lt;p>总之，最终的效果就是：&lt;/p>
&lt;p>假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。&lt;/p>
&lt;p>假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-22-58-0fe064755cc493e1955fe810417a0ca1.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>即，进程 0 和进程 1 目前共同映射物理内存的前 640K 的空间。&lt;/strong>&lt;/p>
&lt;p>至于如何将不同地址通过不同页表映射到相同物理地址空间，很简单，举个刚刚的例子。&lt;/p>
&lt;p>刚刚的进程 1 的线性地址 64M + 0x03 用二进制表示是：&lt;/p>
&lt;p>0000010000_0000000000_000000000011&lt;/p>
&lt;p>刚刚的进程 0 的线性地址 0x03 用二进制表示是：&lt;/p>
&lt;p>0000000000_0000000000_000000000011&lt;/p>
&lt;p>根据分页机制的转化规则，&lt;strong>前 10 位表示页目录项，中间 10 位表示页表项，后 12 位表页内偏移。&lt;/strong>&lt;/p>
&lt;p>进程 1 要找的是页目录项 16 中的第 0 号页表&lt;/p>
&lt;p>进程 0 要找的是页目录项 0 中的第 0 号页表&lt;/p>
&lt;p>那只要让这俩最终找到的两个页表里的数据一模一样即可。&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500507&amp;amp;idx=1&amp;amp;sn=a7863ac6144a1fce942a91a9d573ef1a&amp;amp;chksm=c2c5b876f5b23160502f3d1e7a7d00ad43231aa49eea9809e063f010d65846c512ec87e752a0&amp;amp;scene=21#wechat_redirect">我居然会认为权威书籍写错了&amp;hellip;&lt;/a>&lt;/p>
&lt;p>由于理解起来非常简单，但代码中的计算就非常绕，所以我们就不细致分析代码了，只要理解其最终的作用就好。&lt;/p>
&lt;hr>
&lt;p>OK，本章的内容就讲完了，再稍稍展开一个未来要说的东西。还记得页表的结构吧？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-38-22-89e1ac732ea56be5a529c434daa35db2.png" alt="图片">&lt;/p>
&lt;p>其中 RW 位表示读写状态，0 表示只读（或可执行），1表示可读写（或可执行）。当然，在内核态也就是 0 特权级时，这个标志位是没用的。&lt;/p>
&lt;p>那我们看下面的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">from&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">to&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">LOW_MEM&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>                
                &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>                
                &lt;span class="p">...&lt;/span>            
            &lt;span class="p">}&lt;/span>        
        &lt;span class="p">}&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>~2 表示取反，2 用二进制表示是 10，取反就是 01，其目的是把 this_page 也就是当前的页表的 RW 位置零，也就是是&lt;strong>把该页变成只读&lt;/strong>。&lt;/p>
&lt;p>而 *from_page_table = this_page 表示&lt;strong>又把源页表也变成只读&lt;/strong>。&lt;/p>
&lt;p>也就是说，经过 fork 创建出的新进程，其页表项都是只读的，而且导致源进程的页表项也变成了只读。&lt;/p>
&lt;p>这个就是&lt;strong>写时复制&lt;/strong>的基础，新老进程一开始共享同一个物理内存空间，如果只有读，那就相安无事，但如果任何一方有写操作，由于页面是只读的，将触发缺页中断，然后就会分配一块新的物理内存给产生写操作的那个进程，此时这一块内存就不再共享了。&lt;/p>
&lt;p>这是后话了，这里先埋个伏笔。&lt;/p>
&lt;hr>
&lt;p>好了，至此 fork 中的 &lt;strong>copy_process&lt;/strong> 函数就全部被我们读完了，总共做了三件事，把整个进程的数据结构个性化地从进程 0 复制给了进程 1。&lt;/p>
&lt;p>&lt;strong>第一，原封不动复制了一下 task_struct。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-38-28-7970d5e1e0f763b9e0e69afd9dbebfa3.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第二，LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-39-00-aa192a75588df6873a9c46c74c7c174a.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第三，页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-39-07-78a2e21ba9b35003349fc7b8b289a3df.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>最后，将新老进程的页表都变成只读状态，为后面写时复制的缺页中断做准备。&lt;/strong>&lt;/p></description></item><item><title>30.写时复制</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/30.%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%B0%B1%E8%BF%99%E4%B9%88%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/30.%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%B0%B1%E8%BF%99%E4%B9%88%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81/</guid><description>&lt;h1 id="30写时复制">30.写时复制&lt;/h1>
&lt;h2 id="储备知识">储备知识&lt;/h2>
&lt;p>32 位模式下，Intel 设计了&lt;strong>页目录表&lt;/strong>和&lt;strong>页表&lt;/strong>两种结构，用来给程序员们提供分页机制。&lt;/p>
&lt;p>在 Intel Volume-3 Chapter 4.3 Figure 4-4 中给出了页表和页目录表的数据结构，PDE 就是页目录表，PTE 就是页表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-40-54-df34f4bcc1d2a784d69aca42f8497cad.png" alt="图片">&lt;/p>
&lt;p>大部分的操作系统使用的都是 4KB 的页框大小，Linux 0.11 也是，所以我们只看 4KB 页大小时的情况即可。&lt;/p>
&lt;p>一个由程序员给出的逻辑地址，&lt;strong>要先经过分段机制的转化变成线性地址，再经过分页机制的转化变成物理地址&lt;/strong>。&lt;/p>
&lt;p>Figure 4-2 给出了线性地址到物理地址，也就是&lt;strong>分页机制&lt;/strong>的转化过程。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-00-4c712a88b63050669e6197b762ec2c47.png" alt="图片">&lt;/p>
&lt;p>这里的 PDE 就是页目录表，PTE 就是页表，刚刚说过了。&lt;/p>
&lt;p>在手册接下来的 Table 4-5 和 Table 4-6 中，详细解释了页目录表和页表数据结构各字段的含义。&lt;/p>
&lt;p>Table 4-5 是页目录表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-15-738d6f034ec46e2d0b8b1b9380bf8292.png" alt="图片">&lt;/p>
&lt;p>Table 4-6 是页表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-21-b8f0ee7e3663e1cd6bd48a61e14fe155.png" alt="图片">&lt;/p>
&lt;p>他们几乎都是一样的含义，我们就只看页表就好了，看一些比较重要的位。&lt;/p>
&lt;p>&lt;strong>31:12 表示页的起始物理地址&lt;/strong>，加上线性地址的后 12 位偏移地址，就构成了最终要访问的内存的物理地址，这个就不说了。&lt;/p>
&lt;p>&lt;strong>第 0 位是 P&lt;/strong>，表示 Present，存在位。&lt;/p>
&lt;p>&lt;strong>第 1 位是 RW&lt;/strong>，表示读写权限，0 表示只读，那么此时往这个页表示的内存范围内写数据，则不允许。&lt;/p>
&lt;p>&lt;strong>第 2 位是 US&lt;/strong>，表示用户态还是内核态，0 表示内核态，那么此时用户态的程序往这个内存范围内写数据，则不允许。&lt;/p>
&lt;p>在 Linux 0.11 的 head.s 里，初次为页表设置的值如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">setup_paging:&lt;/span>&lt;span class="err">   &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="err">     &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">set&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">present&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">bit&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nv">user&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">r&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nv">w&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="err">       &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="err">       &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="err">      &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4092&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">edi&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mh">0xfff007&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">     &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="nv">Mb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">4096&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nv">r&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nv">w&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">user&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="nl">std1:&lt;/span>&lt;span class="err">  &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">stosl&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>后三位是 7，用二进制表示就是 111，即初始设置的 4 个页目录表和 1024 个页表，都是：&lt;/p>
&lt;p>&lt;strong>存在（1），可读写（1），用户态（1）&lt;/strong>&lt;/p>
&lt;p>好了，储备知识就到这里。&lt;/p>
&lt;p>如果你前面没读懂，你只需要知道，页表当中有一位是表示读\写的，而 Linux 0.11 初始化时，把它设置为了 1，表示可读写。&lt;/p>
&lt;h2 id="写时复制的本质">写时复制的本质&lt;/h2>
&lt;p>在调用 fork() 生成新进程时，新进程与原进程会共享同一内存区。只有当其中一个进程进行写操作时，系统才会为其另外分配内存页面。&lt;/p>
&lt;p>之前在我的&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499207&amp;amp;idx=1&amp;amp;sn=f00bf7653ae57faa6266bfd18287e6bb&amp;amp;chksm=c2c5876af5b20e7cdf5094696d266ee3fa09514601b021ce602ecaf0ec79857045b43e286a58&amp;amp;scene=21#wechat_redirect">操作系统系列&lt;/a>，我给过一个 Linux 0.11 进程的内存规划图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-29-cddee5516f8d72b42b2224257221667d.png" alt="图片">&lt;/p>
&lt;p>不过我们考虑写时复制并不用这么复杂，去掉些细节就是。&lt;/p>
&lt;p>原来的进程通过自己的页表占用了一定范围的物理内存空间。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-37-8cfe12fa1d81555cb760e60b4ff7f332.png" alt="图片">&lt;/p>
&lt;p>调用 fork 创建新进程时，原本页表和物理地址空间里的内容，都要进行复制，因为进程的内存空间是要隔离的嘛。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-46-416b1a8e9908e6ca5da2cb3b5c1cf408.png" alt="图片">&lt;/p>
&lt;p>但 fork 函数认为，复制物理地址空间里的内容，比较费时，&lt;strong>所以姑且先只复制页表，物理地址空间的内容先不复制&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-53-7c60b961dda9927b53216beabc6b68b6.png" alt="图片">&lt;/p>
&lt;p>如果只有读操作，那就完全没有影响，复不复制物理地址空间里的内容就无所谓了，这就很赚。&lt;strong>但如果有写操作，那就不得不把物理地址空间里的值复制一份&lt;/strong>，保证进程间的内存隔离。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-01-be6c197ac44068430c319af3e4549387.png" alt="图片">&lt;/p>
&lt;p>有写操作时，再复制物理内存，就叫&lt;strong>写时复制&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>看看代码咋写的&lt;/strong>&lt;/p>
&lt;p>有上述的现象，必然是在 fork 时，对&lt;strong>页表&lt;/strong>做了手脚，这回知道为啥储备知识里讲页表结构了吧？&lt;/p>
&lt;p>同时，只要有写操作，就会触发写时复制这个逻辑，这是咋做到的呢？答案是通过&lt;strong>中断&lt;/strong>，具体是&lt;strong>缺页中断&lt;/strong>。&lt;/p>
&lt;p>好的，首先来看 fork。&lt;/p>
&lt;p>fork 细节很多，具体可以看 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501748&amp;amp;idx=1&amp;amp;sn=2ad618817656321501b2c8e734ffefe6&amp;amp;chksm=c2c5bd19f5b2340f0ae684fa2a2a808a9a5210693736d21019ed542cf5351c3b65b2784d40ee&amp;amp;scene=21#wechat_redirect">一个新进程的诞生（六）fork 中进程基本信息的复制&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501866&amp;amp;idx=1&amp;amp;sn=64adec9179345945d095a1a1bdebcdac&amp;amp;chksm=c2c5b287f5b23b9175d8eacf7731b22823a576f78e14d8b93b2e8c9814bcb11076967d878a12&amp;amp;scene=21#wechat_redirect">一个新进程的诞生（七）透过 fork 来看进程的内存规划&lt;/a>，这里只看其中关键的复制页表的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_page_tables&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 源页表和新页表一样    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">this_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 源页表和新页表均置为只读    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>还记得知识储备当中的页表结构吧，就是把 &lt;strong>R/W&lt;/strong> 位置 &lt;strong>0&lt;/strong> 了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-09-df34f4bcc1d2a784d69aca42f8497cad.png" alt="图片">&lt;/p>
&lt;p>用刚刚的 fork 图表示就是。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-16-552dbc8bbf98616be82577037e770210.png" alt="图片">&lt;/p>
&lt;p>那么此时，再次对这块物理地址空间进行写操作时，就不允许了。&lt;/p>
&lt;p>但不允许并不是真的不允许，Intel 会触发一个&lt;strong>缺页中断&lt;/strong>，具体是 &lt;strong>0x14&lt;/strong> 号中断，中断处理程序里边怎么处理，那就由 Linux 源码自由发挥了。&lt;/p>
&lt;p>Linux 0.11 的缺页中断处理函数的开头是用汇编写的，看着太闹心了，这里我选 Linux 1.0 的代码给大家看，逻辑是一样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_page_fault&lt;/span>&lt;span class="p">(...,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">error_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>       
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">do_wp_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，根据中断异常码 &lt;strong>error_code&lt;/strong> 的不同，有不同的逻辑。&lt;/p>
&lt;p>那触发缺页中断的异常码都有哪些呢？&lt;/p>
&lt;p>在 Intel Volume-3 Chapter 4.7 Figure 4-12 中给出。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-24-6a87d410e95baed64b69c676a59b337a.png" alt="图片">&lt;/p>
&lt;p>可以看出，当 error_code 的第 0 位，也就是存在位为 0 时，会走 do_no_page 逻辑，其余情况，均走 do_wp_page 逻辑。&lt;/p>
&lt;p>我们 fork 的时候只是将读写位变成了只读，存在位仍然是 1 没有动，所以会走 &lt;strong>do_wp_page&lt;/strong> 逻辑。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_wp_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 后面这一大坨计算了 address 在页表项的指针    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">un_wp_page&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="p">(((&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xffc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mh">0xfffff000&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>        
            &lt;span class="o">*&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mh">0xffc&lt;/span>&lt;span class="p">)))));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">un_wp_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">table_entry&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">old_page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_page&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">old_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">table_entry&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 只被引用一次，说明没有被共享，那只改下读写属性就行了    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAP_NR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_page&lt;/span>&lt;span class="p">)]&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="o">*&lt;/span>&lt;span class="n">table_entry&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">invalidate&lt;/span>&lt;span class="p">();&lt;/span>        
        &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="c1">// 被引用多次，就需要复制页表了   
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">new_page&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">get_free_page&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">；&lt;/span>    
    &lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAP_NR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_page&lt;/span>&lt;span class="p">)]&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">table_entry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_page&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">invalidate&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">copy_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_page&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
    
&lt;span class="c1">// 刷新页变换高速缓冲宏函数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define invalidate() \
&lt;/span>&lt;span class="cp">    __asm__(&amp;#34;movl %%eax,%%cr3&amp;#34;::&amp;#34;a&amp;#34; (0))
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我用图直接说明这段代码的细节。&lt;/p>
&lt;p>刚刚 fork 完一个进程，是这个样子的对吧？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-32-552dbc8bbf98616be82577037e770210.png" alt="图片">&lt;/p>
&lt;p>这是我们对着这个物理空间范围，写一个值，就会触发上述函数。&lt;/p>
&lt;p>假如是进程 2 写的。&lt;/p>
&lt;p>显然此时这个物理空间被引用了大于 1 次，所以要复制页面。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">new_page&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">get_free_page&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">；&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>并且更改页面只读属性为可读写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="o">*&lt;/span>&lt;span class="n">table_entry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_page&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>图示就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-39-83b2a555e0f8961bc32a9e2bf0164040.png" alt="图片">&lt;/p>
&lt;p>是不是很简单。&lt;/p>
&lt;p>那此时如果进程 1 再写呢？那么引用次数就等于 1 了，只需要更改下页属性即可，不用进行页面复制操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAP_NR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_page&lt;/span>&lt;span class="p">)]&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
 &lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>图示就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-46-c5514f64e04562805cca100802380eb3.png" alt="图片">&lt;/p>
&lt;p>就这么简单。&lt;/p>
&lt;p>是不是从细节上看，和你原来理解的写时复制，还有点不同。&lt;/p>
&lt;p>缺页中断的处理过程中，除了写时复制原理的 do_wp_page，还有个 &lt;strong>do_no_page&lt;/strong>，是在页表项的存在位 P 为 0 时触发的。&lt;/p>
&lt;p>这个和&lt;strong>进程按需加载内存&lt;/strong>有关，如果还没加载到内存，会通过这个函数将磁盘中的数据复制到内存来，这个有时间再给大家讲。&lt;/p></description></item><item><title>31.拿到硬盘信息</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/31.%E6%8B%BF%E5%88%B0%E7%A1%AC%E7%9B%98%E4%BF%A1%E6%81%AF/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/31.%E6%8B%BF%E5%88%B0%E7%A1%AC%E7%9B%98%E4%BF%A1%E6%81%AF/</guid><description>&lt;h1 id="31拿到硬盘信息">31.拿到硬盘信息&lt;/h1>
&lt;p>上一个大部分的名字叫&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501947&amp;amp;idx=1&amp;amp;sn=cb94f53c75d674d30fb4903778c74c08&amp;amp;chksm=c2c5b2d6f5b23bc027d9652d3e9949e55fd3b101beb87f6f80dd77d8233c0b51bede73edad46&amp;amp;scene=21#wechat_redirect">一个新进程的诞生&lt;/a>，讲述了进程 0 调用了 fork 函数创建了一个新的进程 —— 进程 1，并且使其达到了可以被调度的状态，fork 就算正式完成了自己的使命。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由于 fork 函数一调用，就又多出了一个进程，子进程（进程 1）会返回 0，父进程（进程 0）返回子进程的 ID，所以 &lt;strong>init&lt;/strong> 函数只有进程 1 才会执行。&lt;/p>
&lt;p>第三部分结束后，就到了现在的第四部分，&lt;strong>shell 程序的到来&lt;/strong>。而整个第四部分的故事，就是这个 init 函数做的事情。&lt;/p>
&lt;p>虽然就一行代码，但这里的事情可多了去了，我们先看一下整体结构。我已经把单纯的日志打印和错误校验逻辑去掉了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
    &lt;span class="cm">/* nothing */&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">setsid&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cm">/* NOTE! _exit, not exit() */&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是不是看着还挺复杂？&lt;/p>
&lt;p>不过别急，今天我们就只讲第一行代码 &lt;strong>setup&lt;/strong> 的一部分，硬盘信息的获取。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">drive_info&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">dummy&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">32&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="p">}&lt;/span> 
&lt;span class="n">drive_info&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// drive_info = (*(struct drive_info *)0x90080);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先看入参。&lt;/p>
&lt;p>drive_info 是来自内存 0x90080 的数据，这部分是由之前 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499558&amp;amp;idx=1&amp;amp;sn=d5d057fae2fb835d38f82804c2649463&amp;amp;chksm=c2c5858bf5b20c9de2db5c31dd34fbe766f6c46cda17f54f4518a75fc1838f2ada6fe5717aad&amp;amp;scene=21#wechat_redirect">第5回 | 进入保护模式前的最后一次折腾内存&lt;/a> 讲的 setup.s 程序将硬盘 1 的参数信息放在这里了，包括柱面数、磁头数、扇区数等信息。&lt;/p>
&lt;p>setup 是个系统调用，会通过中断最终调用到 sys_setup 函数。关于系统调用的原理，在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501700&amp;amp;idx=1&amp;amp;sn=1b0167cf9852f89748a337d9b06c940b&amp;amp;chksm=c2c5bd29f5b2343ff01c68f1cbc654fbb12148f00eff8c21bb2e725a6054a7a6fbddbc253afb&amp;amp;scene=21#wechat_redirect">第25回 | 通过 fork 看一次系统调用&lt;/a> 中已经讲得很清楚了，此处不再赘述。&lt;/p>
&lt;p>所以直接看 sys_setup 函数，我仍然是对代码做了少许的简化，去掉了日志打印和错误判断分支，并且仅当作只有一块硬盘，去掉了一层 for 循环。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">cyl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">wpcom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">ctl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">lzone&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">sect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BIOS&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">start_sect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">nr_sects&lt;/span> &lt;span class="o">=&lt;/span>         
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">sect&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">cyl&lt;/span>&lt;span class="p">;&lt;/span>        
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x300&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">partition&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x1BE&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">start_sect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_sect&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">nr_sects&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nr_sects&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">brelse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>        
    &lt;span class="n">rd_load&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">mount_root&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好，我们一点点看。&lt;/p>
&lt;p>先看第一部分，硬盘基本信息的赋值的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">cyl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">wpcom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">ctl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">lzone&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">sect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">BIOS&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BIOS&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>刚刚说了，入参 BIOS 是来自内存 0x90080 的数据，这部分是由之前 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499558&amp;amp;idx=1&amp;amp;sn=d5d057fae2fb835d38f82804c2649463&amp;amp;chksm=c2c5858bf5b20c9de2db5c31dd34fbe766f6c46cda17f54f4518a75fc1838f2ada6fe5717aad&amp;amp;scene=21#wechat_redirect">第5回 | 进入保护模式前的最后一次折腾内存&lt;/a> 讲的 setup.s 程序将硬盘 1 的参数信息放在这里了，包括柱面数、磁头数、扇区数等信息。&lt;/p>
&lt;p>所以，一开始先往 &lt;strong>hd_info&lt;/strong> 数组的 0 索引处存上这些信息。我们假设就只有一块硬盘，所以这个数组也只有一个元素。&lt;/p>
&lt;p>这个数组里的结构就是 &lt;strong>hd_i_struct&lt;/strong>，就表示硬盘的参数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">hd_i_struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 磁头数、每磁道扇区数、柱面数、写前预补偿柱面号、磁头着陆区柱面号、控制字节
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">sect&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cyl&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">wpcom&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">lzone&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ctl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">hd_i_struct&lt;/span> &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">；&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终效果就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-15-236e6b679d1b0b4a40a120a5560c910f.png" alt="图片">&lt;/p>
&lt;p>OK，我们继续。&lt;/p>
&lt;p>看第二部分，硬盘分区表的设置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">hd_struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">start_sect&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">nr_sects&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">start_sect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">nr_sects&lt;/span> &lt;span class="o">=&lt;/span>
&lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">sect&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">hd_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">cyl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x300&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">partition&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x1BE&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">start_sect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_sect&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">hd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">nr_sects&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nr_sects&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">brelse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>只看最终效果，就是给 hd 数组的五项附上了值。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-24-0336099857554cd84661ff773ebadbff.png" alt="图片">&lt;/p>
&lt;p>这表示硬盘的分区信息，每个分区用 &lt;strong>start_sect&lt;/strong> 和 &lt;strong>nr_sects&lt;/strong>，也就是开始扇区和总扇区数来记录。&lt;/p>
&lt;p>这些信息是从哪里获取的呢？就是在硬盘的第一个扇区的 0x1BE 偏移处，这里存储着该硬盘的分区信息，只要把这个地方的数据拿到就 OK 了。&lt;/p>
&lt;p>所以 bread 就是干这事的，从硬盘读取数据。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x300&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一个参数 0x300 是第一块硬盘的主设备号，就表示要读取的块设备是硬盘一。第二个参数 0 表示读取第一个块，一个块为 1024 字节大小，也就是连续读取硬盘开始处 0 ~ 1024 字节的数据。&lt;/p>
&lt;p>拿到这部分数据后，再取 0x1BE 偏移处，就得到了分区信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">partition&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x1BE&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就这么点事。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-30-139aa1b335d8b4f1ade362a2c1613631.png" alt="图片">&lt;/p>
&lt;p>至于如何从硬盘中读取指定位置（块）的数据，也就是 &lt;strong>bread&lt;/strong> 函数的内部实现，那是相当复杂的，涉及到与缓冲区配合的部分，还有读写请求队列的设置，以及中断。&lt;/p>
&lt;p>当然，这个函数就是经典的问题，&lt;strong>从硬盘中读取数据的原理&lt;/strong>，但这些都不影响主流程，因为仅仅是把硬盘某位置的数据读到内存而已，先不去深入细节，细节部分将在第五部分展开说明。&lt;/p>
&lt;p>OK，目前我们已经把硬盘的基本信息存入了 hd_info[]，把硬盘的分区信息存入了 hd[]，我们继续往下看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">rd_load&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">mount_root&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就剩两个函数了。&lt;/p>
&lt;p>其中 &lt;strong>rd_load&lt;/strong> 是当有 ramdisk 时，也就是虚拟内存盘，才会执行。虚拟内存盘是通过软件将一部分内存（RAM）模拟为硬盘来使用的一种技术，一种小玩法而已，我们就先当做没有，否则很影响看主流程的心情。&lt;/p>
&lt;p>&lt;strong>mount_root&lt;/strong> 直译过来就是&lt;strong>加载根&lt;/strong>，再多说几个字是&lt;strong>加载根文件系统&lt;/strong>，有了它之后，操作系统才能从一个根开始找到所有存储在硬盘中的文件，所以它是文件系统的基石，很重要。&lt;/p>
&lt;p>为了加载根文件系统，或者说所谓的加载根文件系统，就是把硬盘中的数据加载到内存里，以文件系统的数据格式来解读这些信息。&lt;/p>
&lt;p>所以第一，需要硬盘本身就有文件系统的信息，硬盘不能是裸盘，这个不归操作系统管，你为了启动我的 Linux 0.11，必须拿来一块做好了文件系统的硬盘来。&lt;/p>
&lt;p>第二，需要读取硬盘的数据到内存，那就必须需要知道硬盘的参数信息，这就是我们本讲所做的事情的意义。&lt;/p></description></item><item><title>32.加载根文件系统</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/32.%E5%8A%A0%E8%BD%BD%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/32.%E5%8A%A0%E8%BD%BD%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="32加载根文件系统">32.加载根文件系统&lt;/h1>
&lt;p>书接上回，上回书咱们说到，我们已经把硬盘的基本信息存入了 hd_info[]。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-43-4052e8eeeeb60e0ca6d1be52b74e555d.png" alt="图片">&lt;/p>
&lt;p>把硬盘的分区信息存入了 hd[]。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-50-24869c8c809a0a50594ed3ce9f90b87a.png" alt="图片">&lt;/p>
&lt;p>并且留了个读取硬盘数据的 &lt;code>bread()&lt;/code> 函数没有讲，等主流程讲完再展开这些函数的细节，我知道这是你们关心的内容。&lt;/p>
&lt;p>这些都是 &lt;code>setup()&lt;/code> 方法里做的事情，也就是进程 0 fork 出的进程 1 所执行的第一个方法。&lt;/p>
&lt;p>今天我们说 setup 方法中的最后一个函数 &lt;code>mount_root()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">mount_root&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>mount_root&lt;/code> 直译过来就是&lt;strong>加载根&lt;/strong>。&lt;/p>
&lt;p>再多说几个字是&lt;strong>加载根文件系统&lt;/strong>，有了它之后，操作系统才能从一个&lt;strong>根儿&lt;/strong>开始找到所有存储在硬盘中的文件，所以它是文件系统的基石，很重要。&lt;/p>
&lt;p>我们翻开看看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">free&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">super_block&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">file_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_dev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_wait&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">read_super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">mi&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">iget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">mi&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_count&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="p">;&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_isup&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_imount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pwd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_nzones&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_zmap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_ninodes&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_imap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单。&lt;/p>
&lt;p>从整体上说，它就是要把硬盘中的数据，以文件系统的格式进行解读，加载到内存中设计好的数据结构，这样操作系统就可以通过内存中的数据，以文件系统的方式访问硬盘中的一个个文件了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-59-b6a1ff570c88d23ff34e68d3d09ab079.png" alt="图片">&lt;/p>
&lt;p>那其实搞清楚两个事情即可：&lt;/p>
&lt;p>&lt;strong>第一，硬盘中的文件系统格式是怎样的？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第二，内存中用于文件系统的数据结构有哪些？&lt;/strong>&lt;/p>
&lt;p>我们一个个来。&lt;/p>
&lt;h2 id="硬盘中的文件系统格式是怎样的">硬盘中的文件系统格式是怎样的&lt;/h2>
&lt;p>首先硬盘中的文件系统，无非就是硬盘中的一堆数据，我们按照一定格式去解析罢了。&lt;/p>
&lt;p>Linux-0.11 中的文件系统是 &lt;strong>MINIX&lt;/strong> 文件系统，它就长成这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-05-6c55cea738db22bf57e6208ce3091919.png" alt="图片">&lt;/p>
&lt;p>每一个块结构的大小是 1024 字节，也就是 1KB，硬盘里的数据就按照这个结构，妥善地安排在硬盘里。&lt;/p>
&lt;p>可是硬盘中凭什么就有了这些信息呢？这就是个鸡生蛋蛋生鸡的问题了。你可以先写一个操作系统，然后给一个硬盘做某种文件系统类型的格式化，这样你就得到一个有文件系统的硬盘了，有了这个硬盘，你的操作系统就可以成功启动了。&lt;/p>
&lt;p>总之，想个办法给这个硬盘写上数据呗。&lt;/p>
&lt;p>好了，现在我们简单看看 MINIX 文件系统的格式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>引导块&lt;/strong>就是我们系列最开头说的启动区，当然不一定所有的硬盘都有启动区，但我们还是得预留出这个位置，以保持格式的统一。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>超级块&lt;/strong>用于描述整个文件系统的整体信息，我们看它的字段就知道了，有后面的 inode 数量，块数量，第一个块在哪里等信息。有了它，整个硬盘的布局就清晰了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>inode 位图和块位图&lt;/strong>，就是位图的基本操作和作用了，表示后面 inode 和块的使用情况，和我们之前讲的内存占用位图 mem_map[] 是类似的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>再往后，&lt;strong>inode&lt;/strong> 存放着每个文件或目录的元信息和索引信息，元信息就是文件类型、文件大小、修改时间等，索引信息就是大小为 9 的 i_zone[9] 块数组，表示这个文件或目录的具体数据占用了哪些块。&lt;/p>
&lt;p>其中块数组里，0~6 表示直接索引，7 表示一次间接索引，8 表示二次间接索引。当文件比较小时，比如只占用 2 个块就够了，那就只需要 zone[0] 和 zone[1] 两个直接索引即可。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-14-8d12e13b175dce0c8d804f933c9dae18.png" alt="图片">&lt;/p>
&lt;p>再往后，就都是存放具体文件或目录实际信息的&lt;strong>块&lt;/strong>了。如果是一个普通文件类型的 inode 指向的块，那里面就直接是文件的二进制信息。如果是一个目录类型的 inode 指向的块，那里面存放的就是这个目录下的文件和目录的 inode 索引以及文件或目录名称等信息。&lt;/p>
&lt;p>好了，文件系统格式的说明，我们就简单说明完毕了，MINIX 文件系统已经过时，你可以阅读我之前写的 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247494176&amp;amp;idx=1&amp;amp;sn=b4680b50090bb3c7b9c49379241c536c&amp;amp;chksm=c2c5908df5b2199b361885b32b07ab0f597ab25cd1d70bb75ca13fb897c200285685318f145f&amp;amp;scene=21#wechat_redirect">图解 | 你管这破玩意叫文件系统？&lt;/a>来全面了解一个 ext2 文件系统的来龙去脉，基本思想都是一样的。&lt;/p>
&lt;h2 id="内存中用于文件系统的数据结构有哪些">内存中用于文件系统的数据结构有哪些&lt;/h2>
&lt;p>赶紧回过头来看我们的代码，是如何加载以这样一种格式存放在硬盘里的数据，以被我们操作系统所管控的。&lt;/p>
&lt;p>从头看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">f_mode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">f_flags&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">f_count&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f_inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">off_t&lt;/span> &lt;span class="n">f_pos&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">file_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>把 64 个 &lt;strong>file_table&lt;/strong> 里的 f_count 清零。&lt;/p>
&lt;p>&lt;strong>这个 file_table 表示进程所使用的文件&lt;/strong>，进程每使用一个文件，都需要记录在这里，包括文件类型、文件 inode 索引信息等，而这个 f_count 表示被引用的次数，此时还没有引用，所以设置为零。&lt;/p>
&lt;p>而这个 file_table 的索引（当然准确说是进程的filp索引才是），就是我们通常说的文件描述符。比如有如下命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;hello&amp;#34;&lt;/span> &amp;gt; &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就表示把 hello 输出到 0 号文件描述符。&lt;/p>
&lt;p>0 号文件描述符是哪个文件呢？就是 file_table[0] 所表示的文件。&lt;/p>
&lt;p>这个文件在哪里呢？注意到 file 结构里有个 f_inode 字段，通过 f_inode 即可找到它的 inode 信息，inode 信息包含了一个文件所需要的全部信息，包括文件的大小、文件的类型、文件所在的硬盘块号，这个所在硬盘块号，就是文件的位置咯。&lt;/p>
&lt;p>接着看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">super_block&lt;/span> &lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">super_block&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_dev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_wait&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>又是把一个数组 &lt;strong>super_block&lt;/strong> 做清零工作。&lt;/p>
&lt;p>这个 super_block 存在的意义是，操作系统与一个设备以文件形式进行读写访问时，就需要把这个设备的超级块信息放在这里。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-22-6c55cea738db22bf57e6208ce3091919.png" alt="图片">&lt;/p>
&lt;p>这样通过这个超级块，就可以掌控这个设备的文件系统全局了。&lt;/p>
&lt;p>果然，接下来的操作，就是读取硬盘的超级块信息到内存中来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">read_super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>read_super 就是读取硬盘中的超级块。&lt;/p>
&lt;p>接下来，读取根 inode 信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mi&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">iget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后把该 inode 设置为当前进程（也就是进程 1）的当前工作目录和根目录。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pwd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后记录块位图信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_nzones&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_zmap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后记录 inode 位图信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_ninodes&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_imap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就完事了。&lt;/p>
&lt;p>其实整体上就是把硬盘中文件系统的各个信息，搬到内存中。之前的图可以说非常直观了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-31-b6a1ff570c88d23ff34e68d3d09ab079.png" alt="图片">&lt;/p>
&lt;p>有了内存中的这些结构，我们就可以顺着根 inode，找到所有的文件了。&lt;/p>
&lt;p>至此，加载根文件系统的 &lt;strong>mount_root&lt;/strong> 函数就全部结束了。同时，让我们回到全局视野，发现 &lt;strong>setup&lt;/strong> 函数也一并结束了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mount_root&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>setup 的主要工作就是我们今天所讲的，&lt;strong>加载根文件系统&lt;/strong>。&lt;/p>
&lt;p>我们继续往下看 init 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到这相信你也明白了。&lt;/p>
&lt;p>之前 setup 函数的一番折腾，加载了根文件系统，顺着根 inode 可以找到所有文件，就是为了下一行 open 函数可以通过文件路径，从硬盘中把一个文件的信息方便地拿到。&lt;/p>
&lt;p>在这里，我们 open 了一个 &lt;strong>/dev/tty0&lt;/strong> 的文件，那我们接下来的焦点就在这个 /dev/tty0 是个啥？&lt;/p></description></item><item><title>33.打开终端设备文件</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/33.%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/33.%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6/</guid><description>&lt;h1 id="33打开终端设备文件">33.打开终端设备文件&lt;/h1>
&lt;p>书接上回，上回书咱们说到， setup 函数的一番折腾，加载了根文件系统，顺着根 inode 可以找到所有文件，为后续工作奠定了基础。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-43-1082bc1ad88d82d1c2950c0ea6f2672d.png" alt="图片">&lt;/p>
&lt;p>而有了这个功能后，下一行 open 函数可以通过文件路径，从硬盘中把一个文件的信息方便地拿到。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那我们接下来的焦点就在这个 open 函数，以及它要打开的文件 /dev/tty0，还有后面的两个 dup。&lt;/p>
&lt;p>open 函数会触发 0x80 中断，最终调用到 sys_open 这个系统调用函数，相信你已经很熟悉了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// open.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="n">file_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">mode&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mo">0777&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">umask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">close_on_exec&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file_table&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open_namei&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISCHR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">leader&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MINOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">pgrp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pgrp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">iput&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EPERM&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISBLK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">check_disk_change&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这么大一坨别怕，我们慢慢来分析，我先用一张图来描述这一大坨代码的作用。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-51-4e1e11ee5c327696e756e8faea876958.png" alt="图片">&lt;/p>
&lt;ul>
&lt;li>第一步，在进程文件描述符数组 filp 中找到一个空闲项。**还记得进程的 task_struct 结构吧，其中有一个 filp 数组的字段，就是我们常说的文件描述符数组，这里先找到一个空闲项，将空闲地方的索引值即为 fd。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">])&lt;/span>
            &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由于此时当前进程，也就是进程 1，还没有打开过任何文件，所以 0 号索引处就是空闲的，fd 自然就等于 0。&lt;/p>
&lt;ul>
&lt;li>第二步，在系统文件表 file_table 中找到一个空闲项。**一样的玩法。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file_table&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意到，进程的 filp 数组大小是 20，系统的 file_table 大小是 64，可以得出，每个进程最多打开 20 个文件，整个系统最多打开 64 个文件。&lt;/p>
&lt;ul>
&lt;li>第三步，将进程的文件描述符数组项和系统的文件表项，对应起来。**代码中就是一个赋值操作。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>第四步，根据文件名从文件系统中找到这个文件。其实相当于找到了这个 tty0 文件对应的 &lt;code>inode&lt;/code>信息。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// filename = &amp;#34;/dev/tty0&amp;#34;
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="c1">// flag = O_RDWR 读写
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="c1">// 不是创建新文件，所以 mode 没用
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="c1">// inode 是返回参数
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">open_namei&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来判断 tty0 这个 inode 是否是字符设备，如果是字符设备文件，那么如果设备号是 4 的话，则设置当前进程的 tty 号为该 inode 的子设备号。并设置当前进程tty 对应的tty 表项的父进程组号等于进程的父进程组号。&lt;/p>
&lt;p>这里我们暂不展开讲。&lt;/p>
&lt;ul>
&lt;li>最后第五步，填充 file 数据。其实就是初始化这个 f，包括刚刚找到的 inode 值。最后返回给上层文件描述符 fd 的值，也就是零。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后再回过头看这张图，是不是就有感觉了？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-58-4e1e11ee5c327696e756e8faea876958.png" alt="图片">&lt;/p>
&lt;p>其实打开一个文件，即刚刚的 open 函数，就是在上述操作后，返回一个 int 型的数值 fd，称作文件描述符。&lt;/p>
&lt;p>之后我们就可以对着这个文件描述符进行读写。&lt;/p>
&lt;p>之所以可以这么方便，是由于通过这个文件描述符，最终能够找到其对应文件的 inode 信息，有了这个信息，就能够找到它在磁盘文件中的位置（当然文件还分为常规文件、目录文件、字符设备文件、块设备文件、FIFO 特殊文件等，这个之后再说），进行读写。&lt;/p>
&lt;p>比如&lt;strong>读函数&lt;/strong>的系统调用入口。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>写函数&lt;/strong>的系统调用入口。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_write&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>入参都有个 int 型的文件描述符 fd，就是刚刚 open 时返回的，就这么简单。&lt;/p>
&lt;p>好，我们回过头看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上一讲中我们讲了 setup 加载根文件系统的事情。&lt;/p>
&lt;p>这一讲中利用之前 setup 加载过的根文件系统，通过 open 函数，根据文件名找到并打开了一个文件。&lt;/p>
&lt;p>打开文件，返回给上层的是一个文件描述符，然后操作系统底层进行了一系列精巧的构造，使得一个进程可以通过一个文件描述符 fd，找到对应文件的 inode 信息。&lt;/p>
&lt;p>好了，我们接着再往下看两行代码。接下来，两个一模一样的 dup 函数，什么意思呢？&lt;/p>
&lt;p>其实，刚刚的 open 函数返回的为 0 号 fd，这个&lt;strong>作为标准输入设备&lt;/strong>。&lt;/p>
&lt;p>接下来的 dup 为 1 号 fd 赋值，这个作为&lt;strong>标准输出设备&lt;/strong>。&lt;/p>
&lt;p>再接下来的 dup 为 2 号 fd 赋值，这个作为&lt;strong>标准错误输出设备&lt;/strong>。&lt;/p>
&lt;p>熟不熟悉？这就是我们 Linux 中常说的 &lt;strong>stdin&lt;/strong>、&lt;strong>stdout&lt;/strong>、&lt;strong>stderr&lt;/strong>。&lt;/p>
&lt;p>那这个 dup 又是什么原理呢？非常简单，首先仍然是通过系统调用方式，调用到 sys_dup 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fildes&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">dupfd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fildes&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// fd 是要复制的文件描述符
&lt;/span>&lt;span class="c1">// arg 是指定新文件描述符的最小数值
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">dupfd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">arg&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">])&lt;/span>
            &lt;span class="n">arg&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="k">else&lt;/span>
            &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我仍然是把一些错误校验的旁路逻辑去掉了。&lt;/p>
&lt;p>那这个函数的逻辑非常单纯，&lt;strong>就是从进程的 filp 中找到下一个空闲项，然后把要复制的文件描述符 fd 的信息，统统复制到这里&lt;/strong>。&lt;/p>
&lt;p>那根据上下文，这一步其实就是把 0 号文件描述符，复制到 1 号文件描述符，那么 0 号和 1 号文件描述符，就统统可以通过一条路子，找到最终 tty0 这个设备文件的 inode 信息了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-46-08-45e22ae155910d541480988ea306382e.png" alt="图片">&lt;/p>
&lt;p>那下一个 dup 就自然理解了吧，直接再来一张图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-46-15-91ee0fed302ffa91c33c2bdbf8b0423b.png" alt="图片">&lt;/p>
&lt;p>气不气，消耗了你两次流量，谁让你不懂呢，哈哈哈哈~&lt;/p>
&lt;p>ok，进程 1 的 init 函数的前四行就讲完了，此时进程 1 已经比进程 0 多了&lt;strong>与 外设交互的能力&lt;/strong>，具体说来是 tty0 这个外设（也是个文件，因为 Linux 下一切皆文件）交互的能力，这句话怎么理解呢？什么叫多了这个能力？&lt;/p>
&lt;p>因为进程 fork 出自己子进程的时候，这个 filp 数组也会被复制，那么当进程 1 fork 出进程 2 时，进程 2 也会拥有这样的映射关系，也可以操作 tty0 这个设备，这就是“能力”二字的体现。&lt;/p>
&lt;p>而进程 0 是不具备与外设交互的能力的，因为它并没有打开任何的文件，filp 数组也就没有任何作用。&lt;/p>
&lt;p>进程 1 刚刚创建的时候，是 fork 的进程 0，所以也不具备这样的能力，而通过 setup 加载根文件系统，open 打开 tty0 设备文件等代码，使得进程 1 具备了与外设交互的能力，同时也使得之后从进程 1 fork 出来的进程 2 也天生拥有和进程 1 同样的与外设交互的能力。&lt;/p>
&lt;p>好了，本文就讲到这里，再往后看两行找找感觉，我们就结束。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d buffers = %d bytes buffer space&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">NR_BUFFERS&lt;/span>&lt;span class="p">,&lt;/span> \
        &lt;span class="n">NR_BUFFERS&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Free mem: %d bytes&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来的两行是个打印语句，其实就是基于刚刚打开并创建的 0,1,2 三个文件描述符而做出的操作。&lt;/p>
&lt;p>刚刚也说了 1 号文件描述符被当做标准输出，那我们进入 printf 的实现看看有没有用到它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">fmt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">va_list&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">va_start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fmt&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">printbuf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">vsprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">printbuf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fmt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">va_end&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，中间有个 write 函数，传入了 1 号文件描述符作为第一个参数。&lt;/p>
&lt;p>细节我们先不展开，这里知道它肯定是顺着这个描述符寻找到了相应的 tty0 也就是终端控制台设备，并输出在了屏幕上。我们赶紧看看实际上有没有输出。&lt;/p>
&lt;p>仍然是 bochs 启动 Linux 0.11 看效果。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-46-24-b0d3099e6fddc9d6f21c69ba69646610.png" alt="图片">&lt;/p>
&lt;p>看到了吧，真的输出了，你偷偷改下这里的源码，再看看这里的输出有没有变化吧！&lt;/p>
&lt;p>经过今天的讲解之后，init 函数后面又要 fork 子进程了，也标志着进程 1 的工作基本结束了，准确说是能力建设的工作结束了，接下来就是控制流程和创建新的进程了，可以到开头的全局视角中展望一下。&lt;/p></description></item><item><title>35.扒开execve的皮</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/35.execve%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8Cshell%E7%A8%8B%E5%BA%8F/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/35.execve%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8Cshell%E7%A8%8B%E5%BA%8F/</guid><description>&lt;h1 id="35扒开execve的皮">35.扒开execve的皮&lt;/h1>
&lt;p>书接上回，上回书咱们说到，进程 1 再次通过 fork 函数创建了进程 2，且进程 2 通过 close 和 open 函数，将 0 号文件描述符指向的标准输入 /dev/tty0 更换为指向 /etc/rc 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时进程 2 和进程 1 几乎是完全一样的。&lt;/p>
&lt;p>接下来进程 2 就将变得不一样了，会通过一个经典的，也是最难理解的 &lt;strong>execve&lt;/strong> 函数调用，使自己摇身一变，成为 &lt;strong>/bin/sh&lt;/strong> 程序继续运行！&lt;/p>
&lt;p>我们先打开 execve，开一下它的调用链。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">argv_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">envp_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;HOME=/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="c1">// 调用方
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 宏定义
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">_syscall3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 通过系统调用进入到这里
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">EIP&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x1C&lt;/span>
&lt;span class="nl">_sys_execve&lt;/span>&lt;span class="p">:&lt;/span>    
    &lt;span class="n">lea&lt;/span> &lt;span class="n">EIP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">pushl&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">call&lt;/span> &lt;span class="n">_do_execve&lt;/span>    
    &lt;span class="n">addl&lt;/span> &lt;span class="err">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>    
    &lt;span class="n">ret&lt;/span>
&lt;span class="c1">// 最终执行的函数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">do_execve&lt;/span>&lt;span class="p">(&lt;/span>        
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">eip&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="n">envp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
        &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501700&amp;amp;idx=1&amp;amp;sn=1b0167cf9852f89748a337d9b06c940b&amp;amp;chksm=c2c5bd29f5b2343ff01c68f1cbc654fbb12148f00eff8c21bb2e725a6054a7a6fbddbc253afb&amp;amp;scene=21#wechat_redirect">第25回 | 通过 fork 看一次系统调用&lt;/a> 已经详细分析了整个调用链中的栈以及参数传递的过程。&lt;/p>
&lt;p>所以这里我们就不再赘述，直接把这里的参数传过来的样子写出来。&lt;/p>
&lt;p>&lt;strong>eip&lt;/strong> 调用方触发系统调用时由 CPU 压入栈空间中的 eip 的指针 。&lt;/p>
&lt;p>&lt;strong>tmp&lt;/strong> 是一个无用的占位参数。&lt;/p>
&lt;p>&lt;strong>filename&lt;/strong> 是 &amp;ldquo;/bin/sh&amp;rdquo;&lt;/p>
&lt;p>&lt;strong>argv&lt;/strong> 是 { &amp;ldquo;/bin/sh&amp;rdquo;, NULL }&lt;/p>
&lt;p>&lt;strong>envp&lt;/strong> 是 { &amp;ldquo;HOME=/&amp;rdquo;, NULL }&lt;/p>
&lt;p>好了，接下来我们看看整个 &lt;strong>do_execve&lt;/strong> 函数，它非常非常长！我先把整个结构列出。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 检查文件类型和权限等
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;span class="c1">// 读取文件的第一块数据到缓冲区
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;span class="c1">// 如果是脚本文件，走这里
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">脚本文件判断逻辑&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 如果是可执行文件，走这里
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 一堆校验可执行文件是否能执行的判断
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 进程管理结构的调整
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 释放进程占有的页面
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 调整线性地址空间、参数列表、堆栈地址等
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 设置 eip 和 esp，这里是 execve 变身大法的关键！
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整理起来的步骤就是。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>检查文件类型和权限等;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读取文件的第一块数据到缓冲区;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>脚本文件与可执行文件的判断;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>校验可执行文件是否能执行;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程管理结构的调整;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>释放进程占有的页面;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调整线性地址空间、参数列表、堆栈地址等;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置 eip 和 esp，完成摇身一变&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>如果去掉一些逻辑校验和判断，那核心逻辑就是&lt;strong>加载文件&lt;/strong>、&lt;strong>调整内存&lt;/strong>、&lt;strong>开始执行&lt;/strong>三个步骤，&lt;/p>
&lt;p>由于这些部分的内容已经非常复杂了，所以我们就去掉那些逻辑校验的部分，直接挑主干逻辑进行讲解，以便带大家认清 execve 的本质。&lt;/p>
&lt;p>走你~&lt;/p>
&lt;h2 id="读取文件开头1kb的数据">读取文件开头1KB的数据&lt;/h2>
&lt;p>先是根据文件名，找到并读取文件里的内容&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 根据文件名 /bin/sh 获取 inode    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">namei&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 根据 inode 读取文件第一块数据（1024KB）    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，&lt;strong>就是读取了文件（/bin/sh）第一个块&lt;/strong>，也就是 1KB 的数据，&lt;/p>
&lt;p>在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502181&amp;amp;idx=1&amp;amp;sn=b6dcbd1d2cf930002852008a1c4e6a65&amp;amp;chksm=c2c5b3c8f5b23ade1532b725995dbc3b0138202555e44a6e308b84d668a2ef3041eb5cf77f86&amp;amp;scene=21#wechat_redirect">第32回 | 加载根文件系统&lt;/a> 里说过文件系统的结构，所以代码里 &lt;strong>inode -&amp;gt; i_zone[0]&lt;/strong> 就刚好是文件开头的 1KB 数据。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-51-05-ab9a08e64c651eae5174b887b6b97738.png" alt="图片">&lt;/p>
&lt;p>OK，现在这 1KB 的数据，就已经在内存中了，但还没有解析。&lt;/p>
&lt;h2 id="解析这-1kb-的数据为-exec-结构">&lt;strong>解析这 1KB 的数据为 exec 结构&lt;/strong>&lt;/h2>
&lt;p>接下来的工作就是解析它，本质上就是按照指定的数据结构来解读罢了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">exec&lt;/span> &lt;span class="n">ex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">exec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先从刚刚读取文件返回的缓冲头指针中取出数据部分 &lt;strong>bh -&amp;gt; data&lt;/strong>，也就是文件前 1024 个字节，此时还是一段读不懂的二进制数据。&lt;/p>
&lt;p>然后按照 exec 这个结构体对其进行解析，它便有了生命。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">exec&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 魔数    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">a_magic&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 代码区长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_text&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 数据区长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_data&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 未初始化数据区长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_bss&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 符号表长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_syms&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 执行开始地址    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 代码重定位信息长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_trsize&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 数据重定位信息长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_drsize&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面的代码就是 exec 结构体，这是 &lt;strong>a.out&lt;/strong> 格式文件的头部结构，现在的 Linux 已经弃用了这种古老的格式，改用 ELF 格式了，但大体的思想是一致的。&lt;/p>
&lt;p>这个结构体里的字段表示什么，等我们用到了再说，你可以先通过我的注释自己体会下。&lt;/p>
&lt;h2 id="判断是脚本文件还是可执行文件">&lt;strong>判断是脚本文件还是可执行文件&lt;/strong>&lt;/h2>
&lt;p>我们写一个 Linux 脚本文件的时候，通常可以看到前面有这么一坨东西。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="cp">#!/bin/sh
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">#!/usr/bin/python&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你有没有想过为什么我们通常可以直接执行这样的文件？其实逻辑就在下面这个代码里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;#&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;!&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">brelse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到，很简单粗暴地判断前面两个字符是不是 &lt;strong>#!&lt;/strong>，如果是的话，就走&lt;strong>脚本文件&lt;/strong>的执行逻辑。&lt;/p>
&lt;p>当然，我们现在的 /bin/sh 是个&lt;strong>可执行的二进制文件&lt;/strong>，不符合这样的条件，所以这个 if 语句里面的内容我们也可以不看了，直接看外面，执行可执行二进制文件的逻辑。&lt;/p>
&lt;p>第一步就是 brelse 释放这个缓冲块，因为已经把这个缓冲块内容解析成 exec 结构保存到我们程序的栈空间里了，那么这个缓冲块就可以释放，用于其他读取磁盘时的缓冲区。&lt;/p>
&lt;p>不重要，我们继续往下看。&lt;/p>
&lt;h2 id="准备参数空间">&lt;strong>准备参数空间&lt;/strong>&lt;/h2>
&lt;p>我们执行 /bin/sh 时，还给它传了 argc 和 envp 参数，就是通过下面这一系列代码来实现的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define PAGE_SIZE 4096
&lt;/span>&lt;span class="cp">#define MAX_ARG_PAGES 32
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x1FFFC = 128K - 4    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PAGE_SIZE&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">MAX_ARG_PAGES&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x1FFF5 = 128K - 4 - 7    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// p = 0x1FFED = 128K - 4 - 7 - 8    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x3FFFFED = 64M - 4 - 7 - 8    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">change_ldt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_text&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">MAX_ARG_PAGES&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">PAGE_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// p = 0x3FFFFD0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">create_tables&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 设置栈指针    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>准备参数空间的过程，同时也伴随着一个表示地址的 unsigned long p 的计算轨迹。&lt;/p>
&lt;p>有点难以理解，别急，我们一点点分析就会恍然大悟。&lt;/p>
&lt;p>开头一行计算出的 p 值为&lt;/p>
&lt;p>&lt;strong>p = 4096 * 32 - 4 = 0x20000 - 4 = 128K - 4&lt;/strong>&lt;/p>
&lt;p>为什么是这个数呢？整个这块讲完你就会知道，这表示&lt;strong>参数表&lt;/strong>，每个进程的参数表大小为 &lt;strong>128K&lt;/strong>，在每个进程地址空间的&lt;strong>最末端&lt;/strong>。&lt;/p>
&lt;p>还记得之前的一张图么？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-53-d3d0724d13664fbdf2ae5f5e23a6e720.png" alt="图片">&lt;/p>
&lt;p>我们说过，&lt;strong>每个进程通过不同的局部描述符在线性地址空间中瓜分出不同的空间&lt;/strong>，一个进程占 &lt;strong>64M&lt;/strong>，我们单独把这部分表达出来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-47-8893fd2eba2113faebdaf3e88b171f6d.png" alt="图片">&lt;/p>
&lt;p>参数表为 128K，就表示每个进程的线性地址空间的末端 128K，是为参数表保留的，目前这个 p 就指向了参数表的开始处（偏移 4 字节）。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-39-35c25c3f8a431516f4efd555834e8747.png" alt="图片">&lt;/p>
&lt;p>接下来两个 &lt;strong>copy_strings&lt;/strong> 就是往这个参数表里面存放信息，不过具体存放的只是字符串常量值的信息，随后他们将被引用，有点像 Java 里 class 文件的字符串常量池思想。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x1FFF5 = 128K - 4 - 7    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// p = 0x1FFED = 128K - 4 - 7 - 8    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>具体说来，&lt;strong>envp&lt;/strong> 表示字符串参数 &lt;strong>&amp;ldquo;HOME=/&amp;quot;&lt;/strong>，&lt;strong>argv&lt;/strong> 表示字符串参数 &lt;strong>&amp;quot;/bin/sh&amp;rdquo;&lt;/strong>，两个 copy 就表示把这个字符串参数往参数表里存，相应地指针 p 也往下移动（共移动了 7 + 8 = 15 个字节），和压栈的效果是一样的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-27-590141556318be26eccd87d69315da70.png" alt="图片">&lt;/p>
&lt;p>当然，这个只是示意图，实际上这些字符串都是紧挨着的，我们通过 debug 查看参数表位置处的内存便可以看到真正存放的方式。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-19-99c28ea7d149b106bdad8afbdb5b7328.png" alt="图片">&lt;/p>
&lt;p>可以看到，两个字符串乖乖地被安排在了参数表内存处，且参数与参数之间用 00 也就是 NULL 来分隔。&lt;/p>
&lt;p>接下来是&lt;strong>更新局部描述符&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">#define PAGE_SIZE 4096
#define MAX_ARG_PAGES 32
// exec.c
int do_execve(...) {
    ...
    // p = 0x3FFFFED = 64M - 4 - 7 - 8
    p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，就是根据 &lt;strong>ex.a_text&lt;/strong> 修改局部描述符中的&lt;strong>代码段限长&lt;/strong> code_limit，其他没动。&lt;/p>
&lt;p>ex 结构里的 a_text 是生成 /bin/sh 这个 a.out 格式的文件时，写在头部的值，用来表示代码段的长度。至于具体是怎么生成的，我们无需关心。&lt;/p>
&lt;p>由于这个函数返回值是数据段限长，也就是 64M，所以最终的 p 值被调整为了以每个进程的线性地址空间视角下的地址偏移，大家可以仔细想想怎么算的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-49-29-b00b53243d9da16b6274c1069db1a7d9.png" alt="图片">&lt;/p>
&lt;p>接下来就是真正&lt;strong>构造参数表&lt;/strong>的环节了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define PAGE_SIZE 4096
&lt;/span>&lt;span class="cp">#define MAX_ARG_PAGES 32
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x3FFFFD0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">create_tables&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>刚刚仅仅是往参数表里面丢入了需要的字符串常量值信息，现在就需要真正把参数表构建起来。&lt;/p>
&lt;p>我们展开 &lt;strong>create_tables&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/* 
&lt;/span>&lt;span class="cm">* create_tables() parses the env- and arg-strings in new user 
&lt;/span>&lt;span class="cm">* memory and creates the pointer tables from them, and puts their 
&lt;/span>&lt;span class="cm">* addresses on the &amp;#34;stack&amp;#34;, returning the new stack pointer value. 
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">create_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">envc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">sp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mh">0xfffffffc&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">sp&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">envc&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">envp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">sp&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">argv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">sp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">sp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">sp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">get_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">))&lt;/span> 
            &lt;span class="cm">/* nothing */&lt;/span> &lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">get_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">))&lt;/span> 
            &lt;span class="cm">/* nothing */&lt;/span> &lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可能稍稍有点烧脑，不过如果你一行一行仔细分析，不难分析出就是把参数表空间变成了如下样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-49-17-792d0104babe901033e4d0b09c4fce55.png" alt="图片">&lt;/p>
&lt;p>最后，将 sp 返回给 p，这个 p 将作为一个新的栈顶指针，给即将要完成替换的 /bin/sh 程序，也就是下面的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 设置栈指针    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为什么这样操作就可以达到更换栈顶指针的作用呢？那我们结合着更换代码指针 PC 来进行讲解。&lt;/p>
&lt;h2 id="heading">&lt;/h2>
&lt;p>&lt;strong>设置 eip 和 esp，完成摇身一变&lt;/strong>&lt;/p>
&lt;p>下面这两行就是 execve 完成摇身一变的关键，解释了它为什么能做到变成一个新程序开始执行的关键密码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">eip&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>     
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>什么叫一个新程序开始执行呢？&lt;/p>
&lt;p>其实本质上就是，&lt;strong>代码指针 eip 和栈指针 esp 指向了一个新的地方&lt;/strong>。&lt;/p>
&lt;p>代码指针 eip 决定了 CPU 将执行哪一段指令，栈指针 esp 决定了 CPU 压栈操作的位置，以及读取栈空间数据的位置，在高级语言视角下就是&lt;strong>局部变量&lt;/strong>以及&lt;strong>函数调用链的栈帧&lt;/strong>。&lt;/p>
&lt;p>所以这两行代码，第一行重新设置了&lt;strong>代码指针 eip&lt;/strong> 的值，指向 /bin/sh 这个 a.out 格式文件的头结构 exec 中的 a_entry 字段，表示该&lt;strong>程序的入口地址&lt;/strong>。&lt;/p>
&lt;p>第二行重新设置了&lt;strong>栈指针 esp&lt;/strong> 的值，指向了我们经过一路计算得到的 p，也就是图中 sp 的值。将这个值作为新的栈顶十分合理。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-49-08-792d0104babe901033e4d0b09c4fce55.png" alt="图片">&lt;/p>
&lt;p>eip 和 esp 都设置好了，那么程序摇身一变的工作，自然就结束了，非常简单。&lt;/p>
&lt;p>至于为什么往 eip 的 0 和 3 索引位置处写入数据，就可以达到替换 eip 和 esp 的目的，那我们就得看看这个 eip 变量是怎么来的了。&lt;/p>
&lt;p>&lt;strong>计算机的世界没有魔法&lt;/strong>&lt;/p>
&lt;p>还记得 execve 的调用链么？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">argv_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">envp_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;HOME=/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="c1">// 调用方
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 宏定义
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">_syscall3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 通过系统调用进入到这里
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">EIP&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x1C&lt;/span>
&lt;span class="nl">_sys_execve&lt;/span>&lt;span class="p">:&lt;/span>    
    &lt;span class="n">lea&lt;/span> &lt;span class="n">EIP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">pushl&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">call&lt;/span> &lt;span class="n">_do_execve&lt;/span>    
    &lt;span class="n">addl&lt;/span> &lt;span class="err">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>    
    &lt;span class="n">ret&lt;/span>
&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">do_execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">eip&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>     
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>千万别忘了，我们这个 &lt;strong>do_execve&lt;/strong> 函数，是通过一开始的 &lt;strong>execve&lt;/strong> 函数触发了&lt;strong>系统调用&lt;/strong>来到的这里。&lt;/p>
&lt;p>系统调用是一种&lt;strong>中断&lt;/strong>，前面说过，中断时 CPU 会给栈空间里压入一定的信息，这部分信息是死的，查手册可以查得到。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-48-59-41fc6288b7591149cb1f904a1610e7be.png" alt="图片">&lt;/p>
&lt;p>然后，进入中断以后，通过系统调用查表进入到 &lt;strong>_sys_execve&lt;/strong> 这里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">EIP&lt;/span>&lt;span class="err"> = &lt;/span>&lt;span class="mh">0x1C&lt;/span>
&lt;span class="nl">_sys_execve:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">lea&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">EIP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esp&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_do_execve&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">addl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esp&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到没？在真正调用 &lt;strong>do_execve&lt;/strong> 函数时，&lt;strong>_sys_execve&lt;/strong> 这段代码偷偷地插入了一个小步骤，就是把当前栈顶指针 esp 偏移到 EIP 处的地址值给当做第一个参数 &lt;strong>unsigned long * eip&lt;/strong> 传入进来了。&lt;/p>
&lt;p>而偏移 EIP 处的位置，恰好就是中断时压入的 EIP 的值的位置，表示中断发生前的指令寄存器的值。&lt;/p>
&lt;p>所以 eip[0] 就表示栈空间里的 EIP 位置，eip[3] 就表示栈空间里的 ESP 位置。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-48-51-28a17b4d53100d5c622e736db98fbcdc.png" alt="图片">&lt;/p>
&lt;p>由于我们现在处于中断，所以&lt;strong>中断返回&lt;/strong>后，也就是 do_execve 这个函数 return 之后，就会寻找中断返回前的这几个值（包括 eip 和 esp）进行恢复。&lt;/p>
&lt;p>这里有疑惑的同学，看下我之前写的 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247498208&amp;amp;idx=1&amp;amp;sn=b784f8b4e627ebd1bfb9810d194fdb80&amp;amp;chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&amp;amp;scene=21#wechat_redirect">认认真真的聊聊中断&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247498246&amp;amp;idx=1&amp;amp;sn=efca37b5dcb06271eb19500b2c2597f1&amp;amp;chksm=c2c580abf5b209bdacd5cba9728723af1f725016960d334067f9cc979b721f29f860d612ec1b&amp;amp;scene=21#wechat_redirect">认认真真的聊聊&amp;quot;软&amp;quot;中断&lt;/a> 这两篇文章，我认为把中断的原理彻底讲清楚了，不过其实就是读 CPU 手册罢了。&lt;/p>
&lt;p>所以如果我们把这个栈空间里的 eip 和 esp 进行替换，换成执行 /bin/sh 所需要的 eip 和 esp，那么中断返回的**&amp;ldquo;恢复&amp;rdquo;**工作，就犹如**&amp;ldquo;跳转&amp;rdquo;**到一个新程序那里一样，其实是我们欺骗了 CPU，达到了 execve 这个函数的魔法效果。&lt;/p>
&lt;p>所以，&lt;strong>计算机的世界里根本没有魔法&lt;/strong>，就是通过这一点点细节而完成的，只是大部分人都不愿意花时间去细究这些细节罢了。&lt;/p></description></item><item><title>36.缺页中断</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/36.%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/36.%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD/</guid><description>&lt;h1 id="36缺页中断">36.缺页中断&lt;/h1>
&lt;p>书接上回，上回书咱们说到，进程 2 通过 &lt;strong>execve&lt;/strong> 函数，将自己摇身一变成为 &lt;strong>/bin/sh&lt;/strong> 程序，也就是 &lt;strong>shell&lt;/strong> 程序开始执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么此时进程 2 就是 shell 程序了。&lt;/p>
&lt;p>再进一步讲，相当于之前的进程 1 通过 &lt;strong>fork + execve&lt;/strong> 这两个函数的组合，创建了一个新的进程去加载并执行了 shell 程序。&lt;/p>
&lt;p>我们在 Linux 里执行一个程序，比如在命令行中 ./xxx，其内部实现逻辑都是 fork + execve 这个原理。&lt;/p>
&lt;p>当然，此时我们仅仅是通过 execve，使得下一条 CPU 指令将会执行到 /bin/sh 程序所在的内存起始位置处，也就是 /bin/sh 头部结构中 &lt;strong>a_entry&lt;/strong> 所描述的地址。&lt;/p>
&lt;p>但有个问题是，我们仅仅将 /bin/sh 文件的头部加载到了内存，其他部分并没有进行加载，那我们是怎么执行到的 /bin/sh 的程序指令呢？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-22-2ddc77fe8686ba8e985c099d1efe6d7d.png" alt="图片">&lt;/p>
&lt;p>我们就带着这个问题，开始今天的探索。&lt;/p>
&lt;h2 id="跳转到一个不存在的地址会发生什么">跳转到一个不存在的地址会发生什么&lt;/h2>
&lt;p>/bin/sh 这个文件并不是 Linux 0.11 源码里的内容，Linux 0.11 只管按照 a.out 这种格式去解读它，跳转到 a.out 格式头部数据结构 &lt;strong>exec.a_entry&lt;/strong> 所指向的内存地址去执行指令。&lt;/p>
&lt;p>所以这个 a_entry 的值是多少，就完全取决于硬盘中 /bin/sh 这个文件是怎么构造的了，我们简单点，就假设它为 &lt;strong>0&lt;/strong>，这表示随后的 CPU 将跳转到 0 地址处进行执行。&lt;/p>
&lt;p>当然，这个 0 仅仅表示&lt;strong>逻辑地址&lt;/strong>，既没有进行分段，也没有进行分页。&lt;/p>
&lt;p>之前说过无数次了，Linux 0.11 的每个进程是通过不同的局部描述符在线性地址空间中瓜分出不同的空间，一个进程占 64M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-29-a49168ac30ab0b1f45ae4daac902533d.png" alt="图片">&lt;/p>
&lt;p>由于我们现在所处的代码是属于进程 2，所以逻辑地址 0 通过分段机制映射到线性地址空间，就是 &lt;strong>0x8000000&lt;/strong>，表示 &lt;strong>128M&lt;/strong> 位置处。&lt;/p>
&lt;p>好，128M 这个线性地址，随后将会通过&lt;strong>分页机制&lt;/strong>的映射转化为物理地址，这才定位到最终的真实物理内存。&lt;/p>
&lt;p>可是，128M 这个线性地址并没有页表映射它，也就是因为上面我们说的，我们除了 /bin/sh 文件的头部加载到了内存外，其他部分并没有进行加载操作。&lt;/p>
&lt;p>&lt;strong>再准确点说，是 0x8000000 这个线性地址的访问，遇到了页表项的存在位 P 等于 0 的情况。&lt;/strong>&lt;/p>
&lt;p>一旦遇到了这种情况，CPU 会触发一个中断：&lt;strong>页错误（Page-Fault）&lt;/strong>，这在 Intel 手册 Volume-3 Chapter 4.7 章节里给出了这个信息。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-36-228eec2d7f2b4640d7441ca0d4aa7be9.png" alt="图片">&lt;/p>
&lt;p>当然，Page-Fault 在很多情况都会触发，具体是因为什么情况触发的，CPU 会帮我们保存在中断的出错码 &lt;strong>Error Code&lt;/strong> 里，这在随后的 Figure 4-12 中给出了详细的出错码说明。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-42-371d5c9369c149d21699fa1f594c81f2.png" alt="图片">&lt;/p>
&lt;p>这块之所以讲这么详细，因为我想让大家知道一切的原理都有最一手资料的来源，这些一手资料写的都非常详细和友好，大家完全不必道听途说，也不必毫无头绪地搜索网上的博客。&lt;/p>
&lt;p>当然，与本文相关的，就是这个&lt;strong>存在位 P&lt;/strong>。&lt;/p>
&lt;p>当触发这个 Page-Fault 中断后，就会进入 Linux 0.11 源码中的 &lt;strong>page_fault&lt;/strong> 方法，由于 Linux 0.11 的 page_fault 是汇编写的，很不直观，这里我选 Linux 1.0 的代码给大家看，逻辑是一样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_page_fault&lt;/span>&lt;span class="p">(...,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">error_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>       
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">do_wp_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 &lt;strong>error_code&lt;/strong> 的不同，有不同的逻辑。&lt;/p>
&lt;p>刚刚说了，这个中断是由于 &lt;strong>0x8000000&lt;/strong> 这个线性地址的访问，遇到了页表项的&lt;strong>存在位 P&lt;/strong> 等于 0 的情况，所以 error_code 的第 0 位就是 0，会走 &lt;strong>do_no_page&lt;/strong> 逻辑。&lt;/p>
&lt;p>之前在讲 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502033&amp;amp;idx=1&amp;amp;sn=1acfd8b7f4c805906ecd51c33d0010eb&amp;amp;chksm=c2c5b27cf5b23b6a41051c7f93407afc97094a4b0a36ea050616778f4d072f074602f98983b2&amp;amp;scene=21#wechat_redirect">第30回 | 番外篇 - 写时复制就这么几行代码&lt;/a> 的时候，讲了 &lt;strong>do_wp_page&lt;/strong>，这是在 P=1 时的逻辑，文章的结尾我说过，后面会把页表项的存在位 P 为 0 时触发的 do_no_page 逻辑讲给大家，这不就来了么。&lt;/p>
&lt;p>do_wp_page 叫&lt;strong>页写保护中断&lt;/strong>，do_no_page 叫&lt;strong>缺页中断&lt;/strong>。&lt;/p>
&lt;p>好了，我们用了很大篇幅，说明白了跳转到一个 P=0 的地址会发生什么，接下来就是具体看 do_no_page 函数的逻辑咯。&lt;/p>
&lt;h2 id="缺页中断-do_no_page">缺页中断 do_no_page&lt;/h2>
&lt;p>我们先一睹为快它的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">end_data&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">get_empty_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">share_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">()))&lt;/span>        
        &lt;span class="n">oom&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="cm">/* remember that 1 block is used for header */&lt;/span>    
    &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">4096&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">end_data&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">tmp&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">free_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">oom&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们仍然是去掉一些不重要的分支，假设跳转不会超过数据末端 end_data，也没有共享内存页面，申请空闲内存时也不会内存不足产生 oom 等，将程序简化如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="c1">// 计算这个地址在文件中的哪个数据块 1    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就简单多了，我们还是一点点看。&lt;/p>
&lt;p>首先，缺页产生的线性地址，之前假设过了，是 0x8000000，也就是进程 2 自己线性地址空间的起始处 128M 这个位置。&lt;/p>
&lt;p>由于我们的页表映射是以&lt;strong>页&lt;/strong>为单位的，所以首先计算出 address 所在的页，其实就是完成一次 &lt;strong>4KB 的对齐&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时 address 对齐后仍然是 0x8000000。&lt;/p>
&lt;p>这个地址是整个线性地址空间的地址，但对于进程 2 自己来说，需要计算出相对于进程 2 的偏移地址，也就是去掉进程 2 的段基址部分。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的 current-&amp;gt;start_code 就是进程 2 的段基址，也是 128M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-51-a49168ac30ab0b1f45ae4daac902533d.png" alt="图片">&lt;/p>
&lt;p>所以偏移地址 tmp 计算后等于 &lt;strong>0&lt;/strong>，这和我们之前假设的 a_entry = 0 是一致的。&lt;/p>
&lt;p>接下来很简单，就是寻找一个空闲页。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 &lt;strong>get_free_page&lt;/strong> 是用汇编语言写的，其实就是去 &lt;strong>mem_map[]&lt;/strong> 中寻找一个值为 0 的位置，这就表示找到了空闲内存。&lt;/p>
&lt;p>这部分忘记的同学，可以看一下 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;scene=21#wechat_redirect">第13回 | 主内存初始化 mem_init&lt;/a>，之前苦苦建立的一些初始化的数据结构，就用上了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-57-150f714f07d49eae3c6ee4a2cda35b6e.png" alt="图片">&lt;/p>
&lt;p>找到一页物理内存后，当然是把硬盘中的数据加载进来，下面的代码就是完成这个工作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 计算这个地址在文件中的哪个数据块 1    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从硬盘的哪个位置开始读呢？&lt;/p>
&lt;p>首先 0 内存地址，应该就对应着这个文件 0 号数据块，当然由于 /bin/sh 这个 a.out 格式的文件使用了 1 个数据块作为头部 exec 结构，所以我们&lt;strong>跳过头部&lt;/strong>，从文件 1 号数据块开始读。&lt;/p>
&lt;p>读多少块呢？&lt;/p>
&lt;p>因为硬盘中的 1 个数据块为 1024 字节，而一页内存为 4096 字节，所以要读 4 块，这就是 nr[4] 的缘故。&lt;/p>
&lt;p>之后读取数据主要是两个函数，&lt;strong>bmap&lt;/strong> 负责将相对于文件的数据块转换为相对于整个硬盘的数据块，比如这个文件的第 1 块数据，可能对应在整个硬盘的第 24 块的位置。&lt;/p>
&lt;p>&lt;strong>bread_page&lt;/strong> 就是连续读取 4 个数据块到 1 页内存的函数，这个函数原理就复杂了，之后第五部分会讲这块的内容，但站在用户层的效果很好理解，就是把硬盘数据复制到内存罢了。&lt;/p>
&lt;p>OK，现在硬盘上所需要的内容已经被读入物理内存了。&lt;/p>
&lt;p>最后一步完成&lt;strong>页表的映射&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是因为我们此时仅仅是申请了物理内存页，并且把硬盘数据复制了进来，但我们并没有把这个物理内存页和线性地址空间的内存页进行映射，也就是没建立相关的&lt;strong>页表&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-45-05-b7d999c9bc53aea332ff6ddfa99b976d.png" alt="图片">&lt;/p>
&lt;p>建立页表的映射，由于 Linux 0.11 使用的是二级页表，所以实际上就是写入&lt;strong>页目录项&lt;/strong>和&lt;strong>页表项&lt;/strong>的过程，我把 &lt;strong>put_page&lt;/strong> 函数简化了一下，只考虑页目录项还不存在的场景。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">page_table&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 找到页目录项    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xffc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 写入页目录项    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 写入页表项    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">page_table&lt;/span>&lt;span class="p">[(&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0x3ff&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>大家可以结合页目录表和页表的数据结构看一下，很简单，就是个计算过程。&lt;/p>
&lt;p>关于页目录表和页表这些&lt;strong>分页&lt;/strong>相关的知识，可以回顾之前的 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499821&amp;amp;idx=1&amp;amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;amp;scene=21#wechat_redirect">第9回 | Intel 内存管理两板斧：分段与分页&lt;/a>，这里就不再赘述。&lt;/p>
&lt;h2 id="缺页中断返回">缺页中断返回&lt;/h2>
&lt;p>好了，这就是整个缺页中断处理的过程，本质上就是加载硬盘对应位置的数据，然后建立页表的过程。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="c1">// 计算这个地址在文件中的哪个数据块 1    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再回过头看整个代码，是不是清晰了不少？&lt;/p>
&lt;p>好，那我们再往上看，我们之前是在进程 2 里执行了 execve 函数将程序替换成 /bin/sh，也就是 shell 程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>execve 函数返回后，CPU 就跳转到 /bin/sh 程序的第一行开始执行，但由于跳转到的线性地址不存在，所以引发了今天我们讲的&lt;strong>缺页中断&lt;/strong>，把硬盘里 /bin/sh 所需要的内容加载到了内存，此时缺页中断返回。&lt;/p>
&lt;p>返回后，CPU 会再次尝试跳转到 0x8000000 这个线性地址，此时由于缺页中断的处理结果，&lt;strong>使得该线性地址已有对应的页表进行映射&lt;/strong>，所以顺利地映射到了物理地址，也就是 /bin/sh 的代码部分（从硬盘加载过来的），那接下来就终于可以执行 /bin/sh 程序，也就是 shell 程序了。&lt;/p>
&lt;p>那这个 shell 程序到底是啥呢？他的代码并不在 Linux 0.11 的源码里，所以我们的重点将不是分析它的源码，仅仅了解它的原理即可。&lt;/p></description></item><item><title>37.shell程序跑起来了</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/37.shell%E7%A8%8B%E5%BA%8F%E8%B7%91%E8%B5%B7%E6%9D%A5%E4%BA%86/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/37.shell%E7%A8%8B%E5%BA%8F%E8%B7%91%E8%B5%B7%E6%9D%A5%E4%BA%86/</guid><description>&lt;h1 id="37shell程序跑起来了">37.shell程序跑起来了&lt;/h1>
&lt;p>书接上回，上回书咱们说到，Linux 通过缺页中断处理过程，将 /bin/sh 的代码从硬盘加载到了内存，此时便可以正式执行 shell 程序了。&lt;/p>
&lt;p>这个 &lt;strong>shell&lt;/strong> 程序，也就是 Linux 0.11 中要执行的这个 &lt;strong>/bin/sh&lt;/strong> 程序，它的源码并没有体现在 Linux 0.11 源码中。&lt;/p>
&lt;p>也可以说，不论这个 /bin/sh 是个啥文件，哪怕只是个 hello world 程序，Linux 0.11 的启动过程中也会傻傻地去执行它。&lt;/p>
&lt;p>但同时，shell 又是一个我们再熟悉不过的东西了。&lt;/p>
&lt;p>在我的腾讯云服务器上（用 Termius 连接），它是这个样子的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-53-23-857b2b6631eb7bb07a4fc061025682ad.png" alt="图片">&lt;/p>
&lt;p>在我的 Ubuntu 16.04 虚拟机上，它是这个样子的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-53-16-0077490b1ad5479c216149b3735e5091.png" alt="图片">&lt;/p>
&lt;p>在我的 mac 电脑上，它是这个样子的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-53-09-191788d081819e114830381befa0779d.png" alt="图片">&lt;/p>
&lt;p>没错，它就是我们通常说的那个命令行黑窗口。&lt;/p>
&lt;p>当然 shell 只是一个标准，具体的实现可以有很多，比如在我的 Ubuntu 16.04 上，具体的 shell 实现是 bash。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">flash:~$ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$SHELL&lt;/span>
/bin/bash
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而在我的 mac 上，具体的实现是 zsh。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">~ &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$SHELL&lt;/span>
/bin/zsh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，默认的 shell 实现也可以手动进行设置并更改。&lt;/p>
&lt;p>还有个有意思的事，shell 前面的提示符，是否可以修改呢？&lt;/p>
&lt;p>我的腾讯云服务器上，提示符是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@VM-24-11-centos ~&lt;span class="o">]&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我的 Ubuntu 虚拟机上，提示符是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">flash:~$
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我的 mac 电脑上更简单，提示符是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">~
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我现在觉得我那个腾讯云服务器上的提示符太长了怎么办？我们先查看一个变量 PS1 的值&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@VM-24-11-centos ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># echo $PS1&lt;/span>
&lt;span class="o">[&lt;/span>&lt;span class="se">\u&lt;/span>@&lt;span class="se">\h&lt;/span> &lt;span class="se">\W&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="se">\$&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后，我们直接把这个值给改了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@VM-24-11-centos ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># echo $PS1&lt;/span>
&lt;span class="o">[&lt;/span>&lt;span class="se">\u&lt;/span>@&lt;span class="se">\h&lt;/span> &lt;span class="se">\W&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="se">\$&lt;/span>
&lt;span class="o">[&lt;/span>root@VM-24-11-centos ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># PS1=[呵呵呵]&lt;/span>
&lt;span class="o">[&lt;/span>呵呵呵&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到神奇的事情发生了，前面的提示符变成了我们自己定义的样子。&lt;/p>
&lt;p>其实我就想说，shell 程序也仅仅是个程序而已，它的输出，它的输入，它的执行逻辑，是完全可以通过阅读程序源码来知道的，和一个普通的程序并没有任何区别。&lt;/p>
&lt;p>好了，接下来我们就阅读一下 shell 程序的源码，只需要找到它的一个具体实现即可。但是 bash，zsh 等实现都过于复杂，很多东西对于我们学习完全没必要。&lt;/p>
&lt;p>所以这里我通过一个非常非常精简的 shell 实现，即 &lt;strong>xv6&lt;/strong> 里的 shell 实现为例，来进行讲解。&lt;/p>
&lt;p>xv6 是一个非常非常经典且简单的操作系统，是由麻省理工学院为操作系统工程的课程开发的一个&lt;strong>教学目的的操作系统&lt;/strong>，所以非常适合操作系统的学习。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-52-34-30d5758f1d83213e5b24e1b042c10e45.png" alt="图片">&lt;/p>
&lt;p>而在它的源代码中，又恰好实现了一个简单的 shell 程序，所以阅读它的代码，对我们这个系列课程来说，简直再合适不过了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-52-24-4b52112c9a3b29208486d536e8333e3e.png" alt="图片">&lt;/p>
&lt;p>看到没，甚至在这么一个小小的截图里，已经可以完整展示 sh.c 里全部的 main 方法代码了。&lt;/p>
&lt;p>但我仍然十分贪婪，即便是这么短的代码，我也帮你把一些多余的校验逻辑去掉，再去掉关于 cd 命令的特殊处理分支，来一个最干净的版本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="c1">// 读取命令    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>        
        &lt;span class="c1">// 创建新进程        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="c1">// 执行命令            
&lt;/span>&lt;span class="c1">&lt;/span>            &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parsecmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">));&lt;/span>        
        &lt;span class="c1">// 等待进程退出        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="n">wait&lt;/span>&lt;span class="p">();&lt;/span>   
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，shell 程序变得异常简单了！&lt;/p>
&lt;p>总得来说，shell 程序就是个死循环，它永远不会自己退出，除非我们手动终止了这个 shell 进程。&lt;/p>
&lt;p>在死循环里面，shell 就是不断读取（&lt;strong>getcmd&lt;/strong>）我们用户输入的命令，创建一个新的进程（&lt;strong>fork&lt;/strong>），在新进程里执行（&lt;strong>runcmd&lt;/strong>）刚刚读取到的命令，最后等待（&lt;strong>wait&lt;/strong>）进程退出，再次进入读取下一条命令的循环中。&lt;/p>
&lt;p>由此你是不是也感受到了 xv6 源码的简单之美，真的是见名知意，当你跟我走完这个 Linux 0.11 之旅后，再去阅读 xv6 的源码你会觉得非常舒服，因为 Linux 0.11 很多地方都用了非常骚的编码技巧，使得理解起来很困难，谁让 Linus 这么特立独行呢。&lt;/p>
&lt;p>我们之前说过 shell 就是不断 &lt;strong>fork + execve&lt;/strong> 完成执行一个新程序的功能的，那 execve 在哪呢？&lt;/p>
&lt;p>那我们就要看执行命令的 runcmd 代码了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">cmd&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">execcmd&lt;/span> &lt;span class="n">ecmd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">execcmd&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ecmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ecmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里我又省略了很多代码，比如遇到管道命令 PIPE，遇到命令集合 LIST 时的处理逻辑，我们仅仅看单纯执行一条命令的逻辑。&lt;/p>
&lt;p>可以看到，就是简简单单调用了个 exec 函数，这个 exec 是 xv6 代码里的名字，在 Linux 0.11 里就是我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502475&amp;amp;idx=1&amp;amp;sn=4fcdbaa03bf6a1ca04db4013309c6aa3&amp;amp;chksm=c2c5b026f5b2393049efca68c429df5038fa0f317eea79fbd9ec2c661c3ec12b47a0701376a7&amp;amp;scene=21#wechat_redirect">第35回 | execve 加载并执行 shell 程序&lt;/a> 里讲的 execve 函数。&lt;/p>
&lt;p>shell 执行一个我们所指定的程序，就和我们在 Linux 0.11 里通过 fork + execve 函数执行了 /bin/sh 程序是一个道理。&lt;/p>
&lt;p>你看，fork 和 execve 函数你一旦懂了，shell 程序的原理你就直接秒懂了。&lt;/p>
&lt;p>而 fork 和 execve 函数的原理，其实如果你非常熟练地掌握中断、虚拟内存、文件系统、进程调度等更为底层的基础知识，其实也不难理解。&lt;/p>
&lt;p>所以，根基真的很重要，本回已经到操作系统启动流程的最后一哆嗦了，如果你现在感觉十分混乱，最好的办法就是，不断去啃之前那些你认为&amp;quot;无聊的&amp;quot;、&amp;ldquo;没用的&amp;quot;章节。&lt;/p>
&lt;p>好了，今天的 shell 就到这里了，毕竟我们是讲 Linux 0.11 核心流程的系列，不必过多深入 shell 这个应用程序。&lt;/p>
&lt;p>接下来有个问题，shell 程序执行了，操作系统就结束了么？&lt;/p></description></item><item><title>38.操作系统启动完毕</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/38.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%AE%8C%E6%AF%95/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/38.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%AE%8C%E6%AF%95/</guid><description>&lt;h1 id="38操作系统启动完毕">38.操作系统启动完毕&lt;/h1>
&lt;p>书接上回，上回书咱们说到一个 shell 程序的执行原理，至此我们的操作系统终于将控制权转交给了 shell，由 shell 程序和我们人类进行友好的交互。&lt;/p>
&lt;p>其实到这里，操作系统的使命就基本结束了。&lt;/p>
&lt;p>此时我想到了之前有人问过我的一个问题，他说为什么现在的电脑开机后和操作系统启动前，还隔着好长一段时间，这段时间运行的代码是什么？&lt;/p>
&lt;p>在我的继续追问下才知道，他说的操作系统的开始部分，是我们看到了诸如 Windows 登陆画面的时候。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-53-41-488dd0b0c480abf2ad5087cca704b669.png" alt="图片">&lt;/p>
&lt;p>这个登陆画面就和我们 Linux 0.11 里讲的这个 shell 程序一样，已经可以说标志着操作系统启动完毕了，通过 shell 不断接受用户命令并执行命令的死循环过程中。&lt;/p>
&lt;p>甚至在 Linux 0.11 里根本都找不到 shell 的源代码，说明 Linux 0.11 并没有认为 shell 是操作系统的一部分，它只是个普通的用户程序，和你在操作系统里自己写个 hello world 编译成 a.out 执行一样。在执行这个 shell 程序前已经可以认为操作系统启动完毕了。&lt;/p>
&lt;p>操作系统就是初始化了一堆数据结构进行管理，并且提供了一揽子&lt;strong>系统调用&lt;/strong>接口供上层的应用程序调用，仅此而已。再多做点事就是提供一些常用的用户程序，但这不是必须的。&lt;/p>
&lt;p>OK，上一回我留了一个问题，shell 程序执行了，操作系统就结束了么？&lt;/p>
&lt;p>此时我们不妨从宏观视角来看一下当前的进度。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-53-34-429be4ee91d6dcb936f9ddbe91f4be13.png" alt="图片">&lt;/p>
&lt;p>看最右边的蓝色部分的流程即可。&lt;/p>
&lt;p>我们先是建立了操作系统的一些最基本的环境与管理结构，然后由进程 0 fork 出处于用户态执行的进程 1，进程 1 加载了文件系统并打开终端文件，紧接着就 fork 出了进程 2，进程 2 通过我们刚刚讲述的 execve 函数将自己替换成了 shell 程序。&lt;/p>
&lt;p>如果看代码的话，其实我们此时处于一个以 rc 为标准输入的 shell 程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span>
&lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="c1">// 一个以 rc 为标准输入的 shell
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">}&lt;/span>
    &lt;span class="c1">// 等待这个 shell 结束
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
            &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 大的死循环，不再退出了
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="c1">// 一个以 tty0 终端为标准输入的 shell
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="p">...&lt;/span>
            &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
            &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">);&lt;/span>
        &lt;span class="p">}&lt;/span>
        &lt;span class="c1">// 这个 shell 退出了继续进大的死循环
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
                &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="p">...&lt;/span>
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是 open 了 /etc/rc， 然后 execve 了 /bin/sh 的这个程序，代码中标记为蓝色的部分。&lt;/p>
&lt;p>shell 程序有个特点，就是如果标准输入为一个普通文件，比如 /etc/rc，那么文件读取后就会使得 shell 进程退出，&lt;/p>
&lt;p>如果是字符设备文件，比如由我们键盘输入的 /dev/tty0，则不会使 shell 进程退出。&lt;/p>
&lt;p>这就使得标准输入为 /etc/rc 文件的 shell 进程在读取完 /etc/rc 这个文件并执行这个文件里的命令后，就退出了。&lt;/p>
&lt;p>所以，这个 /etc/rc 文件可以写一些你觉得在正式启动大死循环的 shell 程序之前，要做的一些事，比如启动一个登陆程序，让用户输入用户名和密码。&lt;/p>
&lt;p>好了，那作为这个 shell 程序的父进程，也就是进程 0，在检测到 shell 进程退出后，就会继续往下走。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 一个以 rc 为标准输入的 shell    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 等待这个 shell 结束    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 大的死循环，不再退出了    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面的 &lt;strong>while(1)&lt;/strong> 死循环里，是和创建第一个 shell 进程的代码几乎一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 大的死循环，不再退出了    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="c1">// 一个以 tty0 终端为标准输入的 shell        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="p">}&lt;/span>        
        &lt;span class="c1">// 这个 shell 退出了继续进大的死循环        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>                
                &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>只不过它的标准输入被替换成了 &lt;strong>tty0&lt;/strong>，也就是接受我们键盘的输入。&lt;/p>
&lt;p>这个 shell 程序不会退出，它会不断接受我们键盘输入的命令，然后通过 fork+execve 函数执行我们的命令，这在上一回讲过了。&lt;/p>
&lt;p>当然，如果这个 shell 进程也退出了，那么操作系统也不会跳出这个大循环，而是继续重试。&lt;/p>
&lt;p>整个操作系统到此为止，看起来就是这个样子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 初始化环境    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 外层操作系统大循环    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="c1">// 内层 shell 程序小循环        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="c1">// 读取命令 read            
&lt;/span>&lt;span class="c1">&lt;/span>            &lt;span class="p">...&lt;/span>            
            &lt;span class="c1">// 创建进程 fork            
&lt;/span>&lt;span class="c1">&lt;/span>            &lt;span class="p">...&lt;/span>            
            &lt;span class="c1">// 执行命令 execve            
&lt;/span>&lt;span class="c1">&lt;/span>            &lt;span class="p">...&lt;/span>        
        &lt;span class="p">}&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，这只是表层的。&lt;/p>
&lt;p>除此之外，这里所有的键盘输入、系统调用、进程调度，统统都需要&lt;strong>中断&lt;/strong>来驱动，所以很久之前我说过，&lt;strong>操作系统就是个中断驱动的死循环&lt;/strong>，就是这个道理。&lt;/p>
&lt;p>OK！到此为止，操作系统终于启动完毕，达到了怠速的状态，它本身设置好了一堆中断处理程序，随时等待着中断的到来进行处理，同时它运行了一个 shell 程序用来接受我们普通用户的命令，以同人类友好的方式进行交互。&lt;/p>
&lt;p>完美！&lt;/p></description></item><item><title>42.用键盘输入一条命令</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/42.%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/42.%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="42用键盘输入一条命令">42.用键盘输入一条命令&lt;/h1>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; info.txt &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">name:flash
&lt;/span>&lt;span class="s">age:28
&lt;/span>&lt;span class="s">language:java
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span> cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;span class="m">3&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。&lt;/p>
&lt;p>我们先从最初始的状态开始说起。&lt;/p>
&lt;p>最初始的状态，电脑屏幕前只有这么一段话。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span>$
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后，我们按下按键 &amp;lsquo;c&amp;rsquo;，将会变成这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span>$ c
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们再按下 &amp;lsquo;a&amp;rsquo;&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span> ca
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来，我们再依次按下 &amp;rsquo;t'、空格、&amp;lsquo;i&amp;rsquo; 等等，才变成了这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span> cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们今天就要解释这个看起来十分&amp;quot;正常&amp;quot;的过程。&lt;/p>
&lt;p>凭什么我们按下键盘后，屏幕上就会出现如此的变化呢？老天爷规定的么？&lt;/p>
&lt;p>我们就从按下键盘上的 &amp;lsquo;c&amp;rsquo; 键开始说起。&lt;/p>
&lt;p>首先，得益于 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500190&amp;amp;idx=1&amp;amp;sn=b0bebe846b55f7e29fc009e1b6587214&amp;amp;chksm=c2c5bb33f5b23225845ab699d1b8fcee39a04ca98a48ebf0e2c22584b638fa0b0839d1212485&amp;amp;scene=21#wechat_redirect">第16回 | 控制台初始化 tty_init&lt;/a> 中讲述的一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// console.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">keyboard_interrupt&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们成功将键盘中断绑定在了 &lt;strong>keyboard_interrupt&lt;/strong> 这个中断处理函数上，也就是说当我们按下键盘 &amp;lsquo;c&amp;rsquo; 时，CPU 的中断机制将会被触发，最终执行到这个 keyboard_interrupt 函数中。&lt;/p>
&lt;p>我们来到 keyboard_interrupt 函数一探究竟。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">keyboard_interrupt:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 读取键盘扫描码    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">inb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mh">0x60&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">al&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 调用对应按键的处理函数    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nv">key_table&lt;/span>&lt;span class="p">(,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 0 作为参数，调用 &lt;/span>&lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，首先通过 IO 端口操作，从键盘中读取了刚刚产生的键盘扫描码，就是刚刚按下 &amp;lsquo;c&amp;rsquo; 的时候产生的键盘扫描码。&lt;/p>
&lt;p>随后，在 key_table 中寻找不同按键对应的不同处理函数，比如普通的一个字母对应的字符 &amp;lsquo;c&amp;rsquo; 的处理函数为 do_self，该函数会将扫描码转换为 ASCII 字符码，并将自己放入一个队列里，我们稍后再说这部分的细节。&lt;/p>
&lt;p>接下来，就是调用 &lt;strong>do_tty_interrupt&lt;/strong> 函数，见名知意就是处理终端的中断处理函数，注意这里传递了一个参数 0。&lt;/p>
&lt;p>我们接着探索，打开&lt;code>do_tty_interrupt()&lt;/code> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数几乎什么都没做，将 keyboard_interrupt 时传入的参数 0，作为 tty_table 的索引，找到 tty_table 中的第 0 项作为下一个函数的入参，仅此而已。&lt;/p>
&lt;p>tty_table 是&lt;strong>终端设备表&lt;/strong>，在 Linux 0.11 中定义了三项，分别是&lt;strong>控制台&lt;/strong>、&lt;strong>串行终端 1&lt;/strong> 和&lt;strong>串行终端 2&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="n">tty_table&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="p">{...},&lt;/span>
&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* initial pgrp */&lt;/span>
&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* initial stopped */&lt;/span>
&lt;span class="n">con_write&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="cm">/* console read-queue */&lt;/span>
        &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="cm">/* console write-queue */&lt;/span>
        &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="cm">/* console secondary queue */&lt;/span>
    &lt;span class="p">},&lt;/span>
    &lt;span class="p">{...},&lt;/span>
    &lt;span class="p">{...}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们用的往屏幕上输出内容的终端，就是 0 号索引位置处的控制台终端，所以我将另外两个终端定义的代码省略掉了。&lt;/p>
&lt;p>tty_table 终端设备表中的每一项结构，是 tty_struct，用来描述一个终端的属性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">termios&lt;/span> &lt;span class="n">termios&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">pgrp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">stopped&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="n">read_q&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="n">write_q&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="n">secondary&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tail&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">proc_list&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">TTY_BUF_SIZE&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>说说其中较为关键的几个。&lt;/p>
&lt;p>&lt;strong>termios&lt;/strong> 是定义了终端的各种模式，包括读模式、写模式、控制模式等，这个之后再说。&lt;/p>
&lt;p>&lt;code>void (*write)(struct tty_struct * tty)&lt;/code> 是一个接口函数，在刚刚的 tty_table 中我们也可以看出被定义为了 con_write，也就是说今后我们调用这个 0 号终端的写操作时，将会调用的是这个 con_write 函数，这不就是接口思想么。&lt;/p>
&lt;p>还有三个队列分别为&lt;strong>读队列 read_q&lt;/strong>，&lt;strong>写队列 write_q&lt;/strong> 以及一个&lt;strong>辅助队列 secondary&lt;/strong>。&lt;/p>
&lt;p>这些有什么用，我们通通之后再说，跟着我接着看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">signed&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">FULL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="c1">// 从 read_q 中取出字符        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="n">GETCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="c1">// 这里省略了一大坨行规则处理代码        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="p">...&lt;/span>        
        &lt;span class="c1">// 将处理过后的字符放入 secondary        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="n">PUTCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">wake_up&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">proc_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>展开 &lt;strong>copy_to_cooked&lt;/strong> 函数我们发现，一个大体的框架已经有了。&lt;/p>
&lt;p>在 &lt;code>copy_to_cooked()&lt;/code> 函数里就是个大循环，只要读队列 &lt;code>read_q&lt;/code> 不为空，且辅助队列 &lt;code>secondary&lt;/code>没有满，就不断从 read_q 中取出字符，经过一大坨的处理，写入 secondary 队列里。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-09-64bde8b13c3537b65e20a05a43d5b859.png" alt="图片">&lt;/p>
&lt;p>否则，就唤醒等待这个辅助队列 &lt;code>secondary&lt;/code> 的进程，之后怎么做就由进程自己决定。&lt;/p>
&lt;p>我们接着看，中间的一大坨处理过程做了什么事情呢？&lt;/p>
&lt;p>这一大坨有太多太多的 if 判断，但都是围绕着同一个目的，我们举其中一个简单的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define IUCLC   0001000
&lt;/span>&lt;span class="cp">#define _I_FLAG(tty,f)  ((tty)-&amp;gt;termios.c_iflag &amp;amp; f)
&lt;/span>&lt;span class="cp">#define I_UCLC(tty) _I_FLAG((tty),IUCLC)
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 这里省略了一大坨行规则处理代码    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">I_UCLC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="n">c&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">tolower&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>简单说，就是通过判断 tty 中的 termios，来决定对读出的字符 c 做一些处理。&lt;/p>
&lt;p>在这里，就是判断 termios 中的 c_iflag 中的第 4 位是否为 1，来决定是否要将读出的字符 c 由大写变为小写。&lt;/p>
&lt;p>这个 termios 就是定义了终端的&lt;strong>模式&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">termios&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_iflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* input mode flags */&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_oflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* output mode flags */&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_cflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* control mode flags */&lt;/span>
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_lflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* local mode flags */&lt;/span>
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c_line&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* line discipline */&lt;/span>
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c_cc&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NCCS&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="cm">/* control characters */&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>比如刚刚的是否要将大写变为小写，是否将回车字符替换成换行字符，是否接受键盘控制字符信号如 ctrl + c 等。&lt;/p>
&lt;p>这些模式不是 Linux 0.11 自己乱想出来的，而是实现了 &lt;strong>POSIX.1&lt;/strong> 中规定的 &lt;strong>termios 标准&lt;/strong>，具体可以参见：&lt;/p>
&lt;p>&lt;a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html#tag_11">https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html#tag_11&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-18-488c77e0563de2fb7c5d236bff535d52.png" alt="图片">&lt;/p>
&lt;p>好了，我们目前可以总结出，按下键盘后做了什么事情。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-25-ad92b915fd5f7244fc05788755acfae2.png" alt="图片">&lt;/p>
&lt;p>这里我们应该产生几个疑问。&lt;/p>
&lt;h2 id="一读队列-read_q-里的字符是什么时候放进去的">一、读队列 read_q 里的字符是什么时候放进去的？&lt;/h2>
&lt;p>还记不记得最开始讲的 keyboard_interrupt 函数，我们有一个方法没有展开讲。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">keyboard_interrupt:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 读取键盘扫描码    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">inb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mh">0x60&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">al&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 调用对应按键的处理函数    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nv">key_table&lt;/span>&lt;span class="p">(,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 0 作为参数，调用 &lt;/span>&lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是这个 &lt;strong>key_table&lt;/strong>，我们将其展开。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">key_table:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.long&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">none&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">03&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">s0&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">es&lt;/span>&lt;span class="nv">c&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.long&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="err">   &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">04&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">07&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.long&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="err">   &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">23&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">d&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">f&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">g&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">h&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，普通的字符 abcd 这种，对应的处理函数是 &lt;strong>do_self&lt;/strong>，我们再继续展开。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">do_self:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 扫描码转换为 &lt;/span>&lt;span class="nf">ASCII&lt;/span>&lt;span class="err"> 码    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">lea&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">key_map&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">ebx&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">1: &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">ebx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">al&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 放入队列    &lt;/span>
&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">put_queue&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到最后调用了 &lt;strong>put_queue&lt;/strong> 函数，顾名思义&lt;strong>放入队列&lt;/strong>，看来我们要找到答案了，继续展开。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">table_list&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">write_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">write_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">write_q&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="c1">// keyboard.s
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nl">put_queue&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="p">...&lt;/span>
    &lt;span class="n">movl&lt;/span> &lt;span class="n">table_list&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">edx&lt;/span>
    &lt;span class="err">#&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">queue&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">console&lt;/span>
    &lt;span class="n">movl&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">edx&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">ecx&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，put_queue 正是操作了我们 tty_table 数组中的零号位置，也就是控制台终端 tty 的 &lt;strong>read_q 队列&lt;/strong>，进行入队操作。&lt;/p>
&lt;p>答案揭晓了，那我们的整体流程图也可以再丰富起来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-32-7a7eca40cdfef3ea9c30af70fd830b85.png" alt="图片">&lt;/p>
&lt;h2 id="二放入-secondary-队列之后呢">二、放入 secondary 队列之后呢？&lt;/h2>
&lt;p>按下键盘后，一系列代码将我们的字符放入了 secondary 队列中，然后呢？&lt;/p>
&lt;p>这就涉及到上层进程调用终端的读函数，将这个字符取走了。&lt;/p>
&lt;p>上层经过库函数、文件系统函数等，最终会调用到 tty_read 函数，将字符从 secondary 队列里取走。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tty_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">channel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">GETCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>取走后要干嘛，那就是上层应用程序去决定的事情了。&lt;/p>
&lt;p>假如要写到控制台终端，那上层应用程序又会经过库函数、文件系统函数等层层调用，最终调用到 &lt;strong>tty_write&lt;/strong> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tty_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">channel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">PUTCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">write_q&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数首先会将字符 c 放入 &lt;strong>write_q&lt;/strong> 这个队列，然后调用 tty 里设定的 write 函数。&lt;/p>
&lt;p>终端控制台这个 tty 我们之前说了，初始化的 write 函数是 &lt;strong>con_write&lt;/strong>，也就是 console 的写函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// console.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>      
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500190&amp;amp;idx=1&amp;amp;sn=b0bebe846b55f7e29fc009e1b6587214&amp;amp;chksm=c2c5bb33f5b23225845ab699d1b8fcee39a04ca98a48ebf0e2c22584b638fa0b0839d1212485&amp;amp;scene=21#wechat_redirect">第16回 | 控制台初始化 tty_init&lt;/a> 提到了，最终会配合显卡，在我们的屏幕上输出我们给出的字符。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-42-ec27c844306f4a807e83316c7b33b583.png" alt="图片">&lt;/p>
&lt;p>那我们的图又可以补充了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-48-66917ca73ea365075ba2701bd6df35fd.png" alt="图片">&lt;/p>
&lt;p>核心点就是三个队列 &lt;strong>read_q&lt;/strong>，&lt;strong>secondary&lt;/strong> 以及 &lt;strong>write_q&lt;/strong>。&lt;/p>
&lt;p>其中 read_q 是键盘按下按键后，进入到键盘中断处理程序 keyboard_interrupt 里，最终通过 put_queue 函数字符放入 read_q 这个队列。&lt;/p>
&lt;p>secondary 是 read_q 队列里的未处理字符，通过 copy_to_cooked 函数，经过一定的 termios 规范处理后，将处理过后的字符放入 secondary。（处理过后的字符就是成&amp;quot;熟&amp;quot;的字符，所以叫 cooked，是不是很形象？）&lt;/p>
&lt;p>然后，进程通过 tty_read 从 secondary 里读字符，通过 tty_write 将字符写入 write_q，最终 write_q 中的字符可以通过 con_write 这个控制台写函数，将字符打印在显示器上。&lt;/p>
&lt;p>这就完成了从键盘输入到显示器输出的一个循环，也就是本回所讲述的内容。&lt;/p>
&lt;p>好了，现在我们已经成功做到可以把这样一个字符串输入并回显在显示器上了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span>$ cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么接下来，shell 程序具体是如何读入这个字符串，读入后又是怎么处理的呢？&lt;/p></description></item><item><title>43.shell 程序读取你的命令</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/43.shell%E7%A8%8B%E5%BA%8F%E8%AF%BB%E5%8F%96%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/43.shell%E7%A8%8B%E5%BA%8F%E8%AF%BB%E5%8F%96%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="43shell-程序读取你的命令">43.shell 程序读取你的命令&lt;/h1>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; info.txt &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">name:flash
&lt;/span>&lt;span class="s">age:28
&lt;/span>&lt;span class="s">language:java
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span>$ cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;span class="m">3&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。&lt;/p>
&lt;p>在&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502876&amp;amp;idx=1&amp;amp;sn=2c34491abd6ea14c9c7ccc3d2d9827c1&amp;amp;chksm=c2c5b6b1f5b23fa7bdf9c3e2bf811b84da937d30a2c9825ceba8a57c2c3e8e157dedae0bfc8d&amp;amp;scene=21#wechat_redirect">上一回&lt;/a>，我们详细解读了从键盘敲击出这个命令，到屏幕上显示出这个命令，中间发生的事情。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-59-8497ea11709af99bb411bfad007ec4c7.png" alt="图片">&lt;/p>
&lt;p>那今天，我们接着往下走，下一步就是，&lt;strong>shell 程序如何读取到你输入的这条命令的&lt;/strong>。&lt;/p>
&lt;p>这里我们需要知道两件事情。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>键盘输入的字符，此时已经到达了控制台终端 tty 结构中的 &lt;strong>secondary&lt;/strong> 这个队列里。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>shell 程序将通过上层的 &lt;strong>read&lt;/strong> 函数调用，来读取这些字符。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="c1">// 读取命令
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="c1">// 创建新进程
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 执行命令
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parsecmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="c1">// 等待进程退出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">getcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nbuf&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">gets&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nbuf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">gets&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cc&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">){&lt;/span>
&lt;span class="n">cc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cc&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;\r&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
    &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;\0&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，shell 程序会通过 &lt;strong>getcmd&lt;/strong> 函数最终调用到 &lt;strong>read&lt;/strong> 函数一个字符一个字符读入，直到读到了换行符（\n 或 \r）的时候，才返回。&lt;/p>
&lt;p>读入的字符在 buf 里，遇到换行符后，这些字符将作为一个完整的命令，传入给 &lt;code>runcmd()&lt;/code> 函数，真正执行这个命令。&lt;/p>
&lt;p>那我们接下来的任务就是，看一下这个 read 函数是怎么把之前键盘输入并转移到 secondary 这个队列里的字符给读出来的。&lt;/p>
&lt;p>&lt;code>read()&lt;/code> 函数是个用户态的库函数，最终会通过&lt;strong>系统调用&lt;/strong>中断，执行 &lt;code>sys_read()&lt;/code>函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// read_write.c
&lt;/span>&lt;span class="c1">// fd = 0, count = 1
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="c1">// 校验 buf 区域的内存限制    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 管道文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_pipe&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="n">read_pipe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:-&lt;/span>&lt;span class="n">EIO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 字符设备文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISCHR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">rw_char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">READ&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 块设备文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISBLK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">block_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 目录文件或普通文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISDIR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">S_ISREG&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="c1">// 不是以上几种，就报错    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">printk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;(Read)inode-&amp;gt;i_mode=%06o&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关键地方我已经标上了注释，整体结构不看细节的话特别清晰。&lt;/p>
&lt;p>这个最上层的 &lt;code>sys_read()&lt;/code>，把读取&lt;strong>管道文件&lt;/strong>、&lt;strong>字符设备文件&lt;/strong>、&lt;strong>块设备文件&lt;/strong>、&lt;strong>目录文件&lt;/strong>或&lt;strong>普通文件&lt;/strong>，都放在了同一个方法里处理，这个方法作为所有读操作的统一入口，由此也可以看出 linux 下一切皆文件的思想。&lt;/p>
&lt;p>read 的第一个参数是 0，也就是 0 号文件描述符，之前我们在讲第四部分的时候说过，shell 进程是由进程 1 通过 fork 创建出来的，而进程 1 在 init 的时候打开了 &lt;strong>/dev/tty0&lt;/strong> 作为 0 号文件描述符。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而这个 /dev/tty0 的文件类型，也就是其 inode 结构中表示文件类型与属性的 &lt;strong>i_mode&lt;/strong> 字段，表示为&lt;strong>字符型设备&lt;/strong>，所以最终会走到 &lt;strong>rw_char&lt;/strong> 这个子方法下，文件系统的第一层划分就走完了。&lt;/p>
&lt;p>接下来我们看 rw_char 这个方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// char_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="n">crw_ptr&lt;/span> &lt;span class="n">crw_table&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* nodev */&lt;/span>
&lt;span class="n">rw_memory&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/mem etc */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/fd */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/hd */&lt;/span>
    &lt;span class="n">rw_ttyx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/ttyx */&lt;/span>
    &lt;span class="n">rw_tty&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/tty */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/lp */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="cm">/* unnamed pipes */&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">rw_char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">rw&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">off_t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="n">crw_ptr&lt;/span> &lt;span class="n">call_addr&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="n">NRDEVS&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ENODEV&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">call_addr&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">crw_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">)]))&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ENODEV&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">call_addr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">MINOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 dev 这个参数，计算出主设备号为 4，次设备号为 0，所以将会走到 &lt;strong>rw_ttyx&lt;/strong> 方法继续执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// char_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">rw_ttyx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">rw&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">minor&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">off_t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="n">READ&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="n">tty_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">minor&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>        
        &lt;span class="n">tty_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">minor&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 &lt;strong>rw == READ&lt;/strong> 走到读操作分支 &lt;strong>tty_read&lt;/strong>，这就终于快和上一讲的故事接上了。&lt;/p>
&lt;p>以下是 tty_read 函数，我省略了一些关于信号和超时时间等非核心的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">// channel=0, nr=1
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tty_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">channel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">channel&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="p">}&lt;/span>        
        &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">GETCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="n">put_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!--&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> 
                &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">));&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>入参有三个参数，非常简单。&lt;/p>
&lt;p>&lt;strong>channel&lt;/strong> 为 0，表示 tty_table 里的控制台终端这个具体的设备。&lt;strong>buf&lt;/strong> 是我们要读取的数据拷贝到内存的位置指针，也就是用户缓冲区指针。&lt;strong>nr&lt;/strong> 为 1，表示我们要读出 1 个字符。&lt;/p>
&lt;p>&lt;strong>整个方法，其实就是不断从 secondary 队列里取出字符，然后放入 buf 指所指向的内存。&lt;/strong>&lt;/p>
&lt;p>如果要读取的字符数 nr 被减为 0，说明已经完成了读取任务，或者说 secondary 队列为空，说明不论你任务完没完成我都没有字符让你继续读了，那此时调用 &lt;strong>sleep_if_empty&lt;/strong> 将线程&lt;strong>阻塞&lt;/strong>，等待被唤醒。&lt;/p>
&lt;p>其中 GETCH 就是个宏，改变 secondary 队列的队头队尾指针，你自己写个队列数据结构，也是这样的操作，不再展开讲解。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define GETCH(queue,c) \
&lt;/span>&lt;span class="cp">    (void)({c=(queue).buf[(queue).tail];INC((queue).tail);})
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同理，判空逻辑就更为简单了，就是队列头尾指针是否相撞。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define EMPTY(a) ((a).head == (a).tail)
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>理解了这些小细节之后，再明白一行关键的代码，整个 read 到 tty_read 这条线就完全可以想明白了。&lt;/p>
&lt;p>那就是队列为空，即不满足继续读取条件的时候，让进程阻塞的 &lt;strong>sleep_if_empty&lt;/strong>，我们看看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cli&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">signal&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">interruptible_sleep_on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">proc_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">interruptible_sleep_on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">tmp&lt;/span>&lt;span class="o">=*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nl">repeat&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_INTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">schedule&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">tmp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们先只看一句关键的代码，就是将当前进程的状态设置为可中断等待。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_INTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么执行到进程调度程序时，当前进程将不会被调度，也就相当于阻塞了，不熟悉进程调度的同学可以复习一下 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501576&amp;amp;idx=1&amp;amp;sn=657e1c89d1007a935820d394d64f4035&amp;amp;scene=21#wechat_redirect">第23回 | 如果让你来设计进程调度&lt;/a>。&lt;/p>
&lt;p>进程被调度了，什么时候被唤醒呢？&lt;/p>
&lt;p>当我们再次按下键盘，使得 secondary 队列中有字符时，也就打破了为空的条件，此时就应该将之前的进程唤醒了，这在上一回 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502876&amp;amp;idx=1&amp;amp;sn=2c34491abd6ea14c9c7ccc3d2d9827c1&amp;amp;chksm=c2c5b6b1f5b23fa7bdf9c3e2bf811b84da937d30a2c9825ceba8a57c2c3e8e157dedae0bfc8d&amp;amp;scene=21#wechat_redirect">第42回 | 用键盘输入一条命令&lt;/a> 一讲中提到过了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">wake_up&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">proc_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到，在 copy_to_cooked 里，在将 read_q 队列中的字符处理后放入 secondary 队列中的最后一步，就是唤醒 &lt;strong>wake_up&lt;/strong> 这个队列里的等待进程。&lt;/p>
&lt;p>而 wake_up 函数更为简单，就是修改一下状态，使其变成可运行的状态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">wake_up&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">(&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>总体流程就是这个样子的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-01-26-608d437c4943b3178c216f4463a0683b.png" alt="图片">&lt;/p>
&lt;p>当然，进程的阻塞与唤醒是个体系，还有很多细节，我们下一回再仔细展开这部分的内容。&lt;/p></description></item><item><title>44.进程的阻塞与唤醒</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/44.%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/44.%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/</guid><description>&lt;h1 id="44进程的阻塞与唤醒">44.进程的阻塞与唤醒&lt;/h1>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; info.txt &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">name:flash
&lt;/span>&lt;span class="s">age:28
&lt;/span>&lt;span class="s">language:java
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span> cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;span class="m">3&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。&lt;/p>
&lt;p>在上一回中，我们分析了一下 shell 进程是如何读取你的命令的，流程如下图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-01-36-cdd47028c56bcc4b82f02ebb7199750d.png" alt="图片">&lt;/p>
&lt;p>当然，这里的 &lt;strong>sleep_on&lt;/strong> 和 &lt;strong>wake_up&lt;/strong> 是进程的阻塞与唤醒机制的实现，我们没有展开讲解。&lt;/p>
&lt;p>那我们今天，就详细看看这块的逻辑。&lt;/p>
&lt;p>首先，表示进程的数据结构是 task_struct，其中有一个 &lt;strong>state&lt;/strong> 字段表示进程的状态，它在 Linux 0.11 里有五种枚举值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// shed.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define TASK_RUNNING 0 &lt;/span>&lt;span class="c1">// 运行态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define TASK_INTERRUPTIBLE 1 &lt;/span>&lt;span class="c1">// 可中断等待状态。
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define TASK_UNINTERRUPTIBLE 2 &lt;/span>&lt;span class="c1">// 不可中断等待状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define TASK_ZOMBIE 3 &lt;/span>&lt;span class="c1">// 僵死状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define TASK_STOPPED 4 &lt;/span>&lt;span class="c1">// 停止
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当进程首次被创建时，也就是 fork 函数执行后，它的初始状态是 0，也就是运行态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// system_call.s
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nl">_sys_fork&lt;/span>&lt;span class="p">:&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">call&lt;/span> &lt;span class="n">_copy_process&lt;/span>    
    &lt;span class="p">...&lt;/span>
    
&lt;span class="c1">// fork.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">copy_process&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_RUNNING&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>只有当处于运行态的进程，才会被调度机制选中，送入 CPU 开始执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">schedule&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TASK_RUNNING&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">switch_to&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上我简单列出了关键代码，基本可以描绘进程调度的大体框架了，不熟悉的朋友还请回顾下 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501576&amp;amp;idx=1&amp;amp;sn=657e1c89d1007a935820d394d64f4035&amp;amp;scene=21#wechat_redirect">第23回 | 如果让你来设计进程调度&lt;/a>。&lt;/p>
&lt;p>所以，使得一个进程阻塞的方法非常简单，并不需要什么魔法，只需要将其 &lt;strong>state&lt;/strong> 字段，变成&lt;strong>非 TASK_RUNNING&lt;/strong> 也就是非运行态，即可让它暂时不被 CPU 调度，也就达到了阻塞的效果。&lt;/p>
&lt;p>同样，唤醒也非常简单，就是再将对应进程的 state 字段变成 TASK_RUNNING 即可。&lt;/p>
&lt;p>&lt;strong>Linux 0.11 中的阻塞与唤醒，就是 sleep_on 和 wake_up 函数。&lt;/strong>&lt;/p>
&lt;p>其中 sleep_on 函数将 state 变为 &lt;code>TASK_UNINTERRUPTIBLE&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">sleep_on&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">schedule&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">tmp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而 wake_up 函数将 state 变回为 TASK_RUNNING，也就是 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">wake_up&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是不是非常简单？&lt;/p>
&lt;p>当然 sleep_on 函数除了改变 state 状态之外，还有些难理解的操作，我们先试着来分析一下。&lt;/p>
&lt;p>当首次调用 sleep_on 函数时，比如 tty_read 在 secondary 队列为空时调用 sleep_on，传入的 *p 为 NULL，因为此时还没有等待 secondary 这个队列的任务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>     
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">proc_list&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="n">secondary&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">tty_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">channel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">interruptible_sleep_on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">proc_list&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>   
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过 *&lt;em>tmp = &lt;em>p&lt;/em>&lt;/em> 和 *&lt;strong>p = current&lt;/strong> 两个赋值操作，此时：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">tmp = NULL
*p = 当前任务
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同时也使得 proc_list 指向了当前任务的 task_struct。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-01-47-4d4e09bcd90863f3898b0b101a31822a.png" alt="图片">&lt;/p>
&lt;p>当有另一个进程调用了 tty_read 读取了同一个 tty 的数据时，就需要再次 sleep_on，此时携带的 *p 就是一个指向了之前的&amp;quot;当前任务&amp;quot;的结构体。&lt;/p>
&lt;p>那么经过 tmp = *p 和 *p = current 两个赋值操作后，会变成这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-01-54-a18dc66254adef739242e2e4e23dea8c.png" alt="图片">&lt;/p>
&lt;p>也就是说，通过每一个当前任务所在的代码块中的 tmp 变量，总能找到上一个正在同样等待一个资源的进程，因此也就形成了一个链表。&lt;/p>
&lt;p>那么，当某进程调用了 wake_up 函数唤醒 proc_list 上指向的第一个任务时，改任务变会在 sleep_on 函数执行完 schedule() 后被唤醒并执行下面的代码，把 tmp 指针指向的上一个任务也同样唤醒。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">sleep_on&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">schedule&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">tmp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>永远记住，唤醒其实就是把 state 变成 0 而已。&lt;/p>
&lt;p>而上一个进程唤醒后，和这个被唤醒的进程一样，也会走过它自己的 sleep_on 函数的后半段，把它的上一个进程，也就是上上一个进程唤醒。&lt;/p>
&lt;p>那么上上一个进程，又会唤醒上上上一个进程，上上上一个进程，又会&amp;hellip;&lt;/p>
&lt;p>看懂了没，通过一个 wake_up 函数，以及上述这种 tmp 变量的巧妙设计，我们就能制造出唤醒的一连串连锁反应。&lt;/p>
&lt;p>当然，唤醒后谁能优先抢到资源，那就得看调度的时机以及调度的机制了，对我们来说相当于听天由命了。&lt;/p>
&lt;p>OK，现在我们的 shell 进程，通过 read 函数，中间经过了层层封装，以及后面经过了阻塞与唤醒这一番折腾后，终于把键盘输入的字符们，成功由 tty 中的 secondary 队列，读取并存放与 buf 指向的内存地址处。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span>$ cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来，就该解析并执行这条命令了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="c1">// 读取命令    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>        
        &lt;span class="c1">// 创建新进程        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="c1">// 执行命令            
&lt;/span>&lt;span class="c1">&lt;/span>            &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parsecmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">));&lt;/span>        
        &lt;span class="c1">// 等待进程退出        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="n">wait&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也就是上述函数中的 &lt;strong>runcmd&lt;/strong> 命令。&lt;/p></description></item><item><title>45.解析并执行 shell 命令</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/45.%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/45.%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="45解析并执行-shell-命令">45.解析并执行 shell 命令&lt;/h1>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; info.txt &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">name:flash
&lt;/span>&lt;span class="s">age:28
&lt;/span>&lt;span class="s">language:java
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11]$ cat info.txt | wc -l
3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。 &lt;/p>
&lt;p>在上一回中，我们讲述了进程在读取你的命令字符串时，可能经历的进程的阻塞与唤醒，也即 Linux 0.11 中的 sleep_on 与 wake_up 函数。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-03-37-b1081aa058fc25b4ce4ac4da512af159.png" alt="图片">&lt;/p>
&lt;p>接下来，shell 程序就该解析并执行这条命令了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="c1">// 读取命令
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="c1">// 创建新进程
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 执行命令
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parsecmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="c1">// 等待进程退出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也就是上述函数中的 &lt;code>runcmd()&lt;/code> 命令。&lt;/p>
&lt;p>首先 &lt;code>parsecmd()&lt;/code> 函数会将读取到 buf 的字符串命令做解析，生成一个 cmd 结构的变量，传入 &lt;code>runcmd()&lt;/code> 函数中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">cmd&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">switch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="k">case&lt;/span> &lt;span class="nl">EXEC&lt;/span>&lt;span class="p">:&lt;/span>        
            &lt;span class="n">ecmd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">execcmd&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">;&lt;/span>        
            &lt;span class="p">...&lt;/span>        
            &lt;span class="n">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ecmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ecmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">);&lt;/span>        
            &lt;span class="p">...&lt;/span>         
            &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>            
        &lt;span class="k">case&lt;/span> &lt;span class="nl">REDIR&lt;/span>&lt;span class="p">:&lt;/span> 
            &lt;span class="p">...&lt;/span>        
        &lt;span class="k">case&lt;/span> &lt;span class="nl">LIST&lt;/span>&lt;span class="p">:&lt;/span> 
            &lt;span class="p">...&lt;/span>        
        &lt;span class="k">case&lt;/span> &lt;span class="nl">PIPE&lt;/span>&lt;span class="p">:&lt;/span> 
            &lt;span class="p">...&lt;/span>        
        &lt;span class="k">case&lt;/span> &lt;span class="nl">BACK&lt;/span>&lt;span class="p">:&lt;/span> 
            &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后就如上述代码所示，根据 cmd 的 type 字段，来判断应该如何执行这个命令。&lt;/p>
&lt;p>比如最简单的，就是直接执行，也即 &lt;strong>EXEC&lt;/strong>。&lt;/p>
&lt;p>如果命令中有分号 ; 说明是多条命令的组合，那么就当作 &lt;strong>LIST&lt;/strong> 拆分成多条命令依次执行。&lt;/p>
&lt;p>如果命令中有竖线 | 说明是管道命令，那么就当作 &lt;strong>PIPE&lt;/strong> 拆分成两个并发的命令，同时通过管道串联起输入端和输出端，来执行。&lt;/p>
&lt;p>我们这个命令，很显然就是个管道命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span>$ cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>管道理解起来非常简单，但是实现细节却是略微复杂。&lt;/p>
&lt;p>所谓管道，也就是上述命令中的 |，实现的就是将 | &lt;strong>左边的程序的****输出&lt;/strong>（stdout）作为 | &lt;strong>右边的程序的输入&lt;/strong>（stdin），就这么简单。&lt;/p>
&lt;p>那我们看看，它是如何实现的，我们走到 runcmd 方法中的 PIPE 这个分支里，也就是当解析出输入的命令是一个管道命令时，所应该做的处理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// xv6-public sh.c
void runcmd(struct cmd *cmd) {    
    ...    
    int p[2];    
    ...    
    case PIPE:        
        pcmd = (struct pipecmd*)cmd;        
        pipe(p);        
        if(fork() == 0) {            
            close(1);            
            dup(p[1]);            
            close(p[0]);            
            close(p[1]);            
            runcmd(pcmd-&amp;gt;left);        
        }        
        if(fork() == 0) {            
            close(0);            
            dup(p[0]);            
            close(p[0]);            
            close(p[1]);            
            runcmd(pcmd-&amp;gt;right);        
        }        
        close(p[0]);        
        close(p[1]);        
        wait(0);        
        wait(0);        
        break;    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，我们构造了一个大小为 2 的数组 &lt;strong>p&lt;/strong>，然后作为 pipe 的参数传了进去。&lt;/p>
&lt;p>这个 pipe 函数，最终会调用到系统调用的 &lt;strong>sys_pipe&lt;/strong>，我们先不看代码，通过 man page 查看 pipe 的用法与说明。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-03-25-f3d2e77e6f0858d548f88186ab3895c9.png" alt="图片">&lt;/p>
&lt;p>可以看到，pipe 就是创建一个&lt;strong>管道&lt;/strong>，将传入数组 p 的 p[0] 指向这个管道的读口，p[1] 指向这个管道的写口，画图就是这样子的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-03-16-fac567632afdb3bad7fc9f04d71c34e1.png" alt="图片">&lt;/p>
&lt;p>当然，这个管道的本质是一个&lt;strong>文件&lt;/strong>，但是是属于&lt;strong>管道类型的文件&lt;/strong>，所以它的本质的本质实际上是一块&lt;strong>内存&lt;/strong>。&lt;/p>
&lt;p>这块内存被当作管道文件对上层提供了像访问文件一样的读写接口，只不过其中一个进程只能读，另一个进程只能写，所以再次抽象一下就像一个管道一样，数据从一端流向了另一段。&lt;/p>
&lt;p>你说它是内存也行，说它是文件也行，说它是管道也行，看你抽象到那一层了，这个之后再展开细讲，先让你迷糊迷糊。&lt;/p>
&lt;p>回过头看程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">cmd&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">case&lt;/span> &lt;span class="nl">PIPE&lt;/span>&lt;span class="p">:&lt;/span>        
        &lt;span class="n">pcmd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">pipecmd&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">pipe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>            
            &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>            
            &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>            
            &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pcmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="p">}&lt;/span>        
        &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>            
            &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>            
            &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>            
            &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pcmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="p">}&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>        
        &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在调用完 pipe 搞出了这样一个管道并绑定了 p[0] 和 p[1] 之后，又分别通过 fork 创建了两个进程，其中第一个进程执行了&lt;strong>管道左边的程序&lt;/strong>，第二个进程执行了&lt;strong>管道右边的程序&lt;/strong>。&lt;/p>
&lt;p>由于 fork 出的子进程会原封不动复制父进程打开的文件描述符，所以目前的状况如下图所示。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-03-03-8cd3009894a0fe125b68bb05ca6cc0e9.png" alt="图片">&lt;/p>
&lt;p>当然，由于每个进程，一开始都打开了 0 号标准输入文件描述符，1 号标准输出文件描述符和 2 号标准错误输出文件描述符，所以目前把文件描述符都展开就是这个样子。（父进程的我就省略了）&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-02-51-c0aa8512f2cf8f100c2b7ba5c68675dd.png" alt="图片">&lt;/p>
&lt;p>现在这个线条很乱，不过没关系，看代码。左边进程随后进行了如下操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// fs/pipe.c
...
if(fork() == 0) {    
    close(1);    
    dup(p[1]);    
    close(p[0]);    
    close(p[1]);    
    runcmd(pcmd-&amp;gt;left);
}
...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>即关闭（close）了 1 号标准输出文件描述符，复制（dup）了 p[1] 并填充在了 1 号文件描述符上（因为刚刚关闭后空缺出来了），然后又把 p[0] 和 p[1] 都关闭（close）了。&lt;/p>
&lt;p>最终的效果就是，将1号文件描述符，也就是标准输出，指向了 p[1] 管道的写口，也就是 p[1] 原来所指向的地方。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-02-39-cac9d09d2a5f519a2b65d14e1462dbf9.png" alt="图片">&lt;/p>
&lt;p>同理，右边进程也进行了类似的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// fs/pipe.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">...&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pcmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>只不过，最终是将 0 号标准输入指向了管道的读口。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-02-30-e128a26a62662093d44f59b0697a2550.png" alt="图片">&lt;/p>
&lt;p>这是两个子进程的操作，再看父进程。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">cmd&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">pipe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{...}&lt;/span>    
    &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{...}&lt;/span>    
    &lt;span class="c1">// 父进程    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你没有看错，&lt;strong>父进程仅仅是将 p[0] 和 p[1] 都关闭掉了&lt;/strong>，也就是说，父进程执行的 pipe，仅仅是为两个子进程申请的文件描述符，对于自己来说并没有用处。&lt;/p>
&lt;p>那么我们忽略父进程，最终，&lt;strong>其实就是创建了两个进程，左边的进程的标准输出指向了管道（写），右边的进程的标准输入指向了同一个管道（读）&lt;/strong>，看起来就是下面的样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-02-22-c758a43e6a132ad990a85dc24f3e7c2a.png" alt="图片">&lt;/p>
&lt;p>而管道的本质就是一个文件，只不过是管道类型的文件，再本质就是一块内存。&lt;/p>
&lt;p>所以这一顿操作，其实就是把两个进程的文件描述符，指向了一个文件罢了，就这么点事情。&lt;/p>
&lt;p>那么此时，再让我们看看 sys_pipe 函数的细节。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// fs/pipe.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_pipe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">fildes&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">NR_FILE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">file_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file_table&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">NR_OPEN&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">];&lt;/span>            
            &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">get_pipe_inode&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
            &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>        
            &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
            &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>       &lt;span class="cm">/* read */&lt;/span>    
    &lt;span class="n">f&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>       &lt;span class="cm">/* write */&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">fildes&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">fildes&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不出我们所料，和&lt;strong>进程打开一个文件&lt;/strong>的步骤是差不多的，可以回顾下 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502230&amp;amp;idx=1&amp;amp;sn=44e023bf0b9b37261e35a6e3722bc57f&amp;amp;chksm=c2c5b33bf5b23a2d10a9dd36606c497f41a1c3dced57845ce7ef12741a348fab82beba462a8a&amp;amp;scene=21#wechat_redirect">第33回 | 打开终端设备文件&lt;/a> 这一回，下图是进程打开一个文件时的步骤。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-02-15-e4a17061bf10b8a6b52f5a9d5ce06214.png" alt="图片">&lt;/p>
&lt;p>而 pipe 方法与之相同的是，都是从进程中的&lt;strong>文件描述符表 filp&lt;/strong> 数组和系统的&lt;strong>文件系统表 file_table&lt;/strong> 数组中寻找空闲项并绑定。&lt;/p>
&lt;p>不同的是，打开一个文件的前提是文件已经存在了，根据文件名找到这个文件，并提取出它的 inode 信息，填充好 file 数据。&lt;/p>
&lt;p>而 pipe 方法中并不是打开一个已存在的文件，而是&lt;strong>创建一个新的管道类型的文件&lt;/strong>，具体是通过 &lt;strong>get_pipe_inode&lt;/strong> 方法，返回一个 inode 结构。然后，填充了两个 file 结构的数据，都指向了这个 inode，其中一个的 f_mode 为 1 也就是写，另一个是 2 也就是读。（f_mode 为文件的操作模式属性，也就是 RW 位的值）&lt;/p>
&lt;p>创建管道的方法 get_pipe_inode 方法如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// fs.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define PIPE_HEAD(inode) ((inode).i_zone[0])
&lt;/span>&lt;span class="cp">#define PIPE_TAIL(inode) ((inode).i_zone[1])
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">// inode.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">get_pipe_inode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_empty_inode&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">；&lt;/span>
&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">get_free_page&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">；&lt;/span>
&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* sum of readers/writers */&lt;/span>
    &lt;span class="n">PIPE_HEAD&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PIPE_TAIL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_pipe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，正常文件的 inode 中的 i_size 表示文件大小，而管道类型文件的 i_size 表示供管道使用的这一页内存的起始地址。&lt;/p>
&lt;p>OK，管道的原理在这里就说完了，最终我们就是实现了一个进程的输出指向了另一个进程的输入。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-02-07-c758a43e6a132ad990a85dc24f3e7c2a.png" alt="图片">&lt;/p>
&lt;p>回到最开始的 runcmd 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">cmd&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">switch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nl">EXEC&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">ecmd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">execcmd&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">cmd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ecmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ecmd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nl">REDIR&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nl">LIST&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nl">PIPE&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nl">BACK&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果展开每个 switch 分支你会发现，不论是更换当前目录的 &lt;strong>REDIR&lt;/strong> 也就是 cd 命令，还是用分号分隔开的 &lt;strong>LIST&lt;/strong> 命令，还是我们上面讲到的 &lt;strong>PIPE&lt;/strong> 命令，最终都会被拆解成一个个可以被解析为 &lt;strong>EXEC&lt;/strong> 类型的命令。&lt;/p>
&lt;p>EXEC 类型会执行到 &lt;strong>exec&lt;/strong> 这个方法，在 Linux 0.11 中，最终会通过系统调用执行到 &lt;strong>sys_execve&lt;/strong> 方法。&lt;/p>
&lt;p>这个方法就是最终加载并执行具体程序的过程，在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502475&amp;amp;idx=1&amp;amp;sn=4fcdbaa03bf6a1ca04db4013309c6aa3&amp;amp;chksm=c2c5b026f5b2393049efca68c429df5038fa0f317eea79fbd9ec2c661c3ec12b47a0701376a7&amp;amp;scene=21#wechat_redirect">第35回 | execve 加载并执行 shell 程序&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502511&amp;amp;idx=1&amp;amp;sn=eacddbb11dd2402c561a611f708ee045&amp;amp;chksm=c2c5b002f5b23914ccd645d94bdc59e0322776f71f41e6744fddeca2bfa027d12a25ec6bfc8a&amp;amp;scene=21#wechat_redirect">第36回 | 缺页中断&lt;/a>，我们已经讲过如何通过 execve 加载并执行 shell 程序了，并且在加载 shell 程序时，并不会立即将磁盘中的数据加载到内存，而是会在真正执行 shell 程序时，引发缺页中断，从而按需将磁盘中的数据加载到内存。&lt;/p>
&lt;p>这个流程在本回我们就不再赘述了，不过当初在讲这块流程以及其它需要将数据从硬盘加载到内存的逻辑时，总是跳过这一步的细节。&lt;/p>
&lt;p>那么我们下一回，就彻底把这个硬盘到内存的流程拆开了讲解！&lt;/p></description></item><item><title>46.读硬盘数据全流程</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/46.%E8%AF%BB%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Sun, 07 Jan 2024 23:13:18 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/46.%E8%AF%BB%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B/</guid><description>&lt;h1 id="46读硬盘数据全流程">46.读硬盘数据全流程&lt;/h1>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ cat &amp;gt; info.txt &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;span class="s">name:flash
&lt;/span>&lt;span class="s">age:28
&lt;/span>&lt;span class="s">language:java
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>root@linux0.11&lt;span class="o">]&lt;/span> cat info.txt &lt;span class="p">|&lt;/span> wc -l
&lt;span class="m">3&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。 &lt;/p>
&lt;p>上一回中，我们解释了 shell 程序是如何解释并执行我们输入的命令的，并展开讲解了管道类型命令的原理。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-50-188fd39bdd00c17dae4aa3a6d857a626.png" alt="图片">&lt;/p>
&lt;p>同时也说了，在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502475&amp;amp;idx=1&amp;amp;sn=4fcdbaa03bf6a1ca04db4013309c6aa3&amp;amp;chksm=c2c5b026f5b2393049efca68c429df5038fa0f317eea79fbd9ec2c661c3ec12b47a0701376a7&amp;amp;scene=21#wechat_redirect">第35回 | execve 加载并执行 shell 程序&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502511&amp;amp;idx=1&amp;amp;sn=eacddbb11dd2402c561a611f708ee045&amp;amp;chksm=c2c5b002f5b23914ccd645d94bdc59e0322776f71f41e6744fddeca2bfa027d12a25ec6bfc8a&amp;amp;scene=21#wechat_redirect">第36回 | 缺页中断&lt;/a>，我们已经讲过如何通过 execve 加载并执行 shell 程序，但略过了将数据从硬盘加载到内存的逻辑细节。&lt;/p>
&lt;p>那我们这一讲就把它扒开来看看。&lt;/p>
&lt;p>将硬盘中的数据读入内存，听起来是个很简单的事情，但操作系统要考虑的问题很多。&lt;/p>
&lt;h2 id="如果让你来设计这个函数">如果让你来设计这个函数&lt;/h2>
&lt;p>我们先别急，一点点来，想想看，如果让你设计这个函数，你会怎么设计呢？&lt;/p>
&lt;p>首先我们知道，通过 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502181&amp;amp;idx=1&amp;amp;sn=b6dcbd1d2cf930002852008a1c4e6a65&amp;amp;chksm=c2c5b3c8f5b23ade1532b725995dbc3b0138202555e44a6e308b84d668a2ef3041eb5cf77f86&amp;amp;scene=21#wechat_redirect">第32回 | 加载根文件系统&lt;/a> 中文件系统的建设。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-45-1799e829d1f383f3fdb3ff4711e5d5b7.png" alt="图片">&lt;/p>
&lt;p>以及 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502230&amp;amp;idx=1&amp;amp;sn=44e023bf0b9b37261e35a6e3722bc57f&amp;amp;chksm=c2c5b33bf5b23a2d10a9dd36606c497f41a1c3dced57845ce7ef12741a348fab82beba462a8a&amp;amp;scene=21#wechat_redirect">第33回 | 打开终端设备文件&lt;/a> 讲解的打开一个文件的操作。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-39-8c5ed791084e164e6eb5f0dccbb6a7fc.png" alt="图片">&lt;/p>
&lt;p>我们已经可以很方便地通过一个&lt;strong>文件描述符 fd&lt;/strong>，寻找到存储在硬盘中的一个文件了，再具体点就是知道这个文件在硬盘中的哪几个扇区中。&lt;/p>
&lt;p>所以，设计这个函数第一个要指定的参数就可以是 fd 了，它仅仅是个数字。当然，之所以能这样方便，就要感谢刚刚说的&lt;strong>文件系统建设&lt;/strong>以及&lt;strong>打开文件的逻辑&lt;/strong>这两项工作。&lt;/p>
&lt;p>之后，我们得告诉这个函数，把这个 fd 指向的硬盘中的文件，复制到内存中的&lt;strong>哪个位置&lt;/strong>，&lt;strong>复制多大&lt;/strong>。&lt;/p>
&lt;p>那更简单了，内存中的位置，我们用一个表示地址值的参数 &lt;strong>buf&lt;/strong>，复制多大，我们用 &lt;strong>count&lt;/strong> 来表示，单位是字节。&lt;/p>
&lt;p>那这个函数就可以设计为。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是不是合情合理，无法反驳。&lt;/p>
&lt;h2 id="鸟瞰操作系统的读操作函数">鸟瞰操作系统的读操作函数&lt;/h2>
&lt;p>实际上，你刚刚设计出来的读操作函数，这正是 Linux 0.11 读操作的系统调用入口函数，在 read_write.c 这个文件里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// read_write.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="n">NR_OPEN&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">]))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_pipe&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="n">read_pipe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:-&lt;/span>&lt;span class="n">EIO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISCHR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">rw_char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">READ&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISBLK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">block_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISDIR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">S_ISREG&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">printk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;(Read)inode-&amp;gt;i_mode=%06o&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那我们就分析这个函数就好了。&lt;/p>
&lt;p>不过首先我先简化一下，去掉一些错误校验逻辑等旁路分支，并添加上注释。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// read_write.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="c1">// 校验 buf 区域的内存限制    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 管道文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_pipe&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="n">read_pipe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:-&lt;/span>&lt;span class="n">EIO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 字符设备文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISCHR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">rw_char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">READ&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 块设备文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISBLK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">block_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 目录文件或普通文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISDIR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">S_ISREG&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="c1">// 不是以上几种，就报错    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">printk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;(Read)inode-&amp;gt;i_mode=%06o&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样，整个的逻辑就非常清晰了。&lt;/p>
&lt;p>由此也可以注意到，操作系统源码的设计比我刚刚说的更通用，我刚刚只让你设计了读取硬盘的函数，但其实在 Linux 下一切皆文件，所以这个函数将&lt;strong>管道文件、字符设备文件、块设备文件、目录文件、普通文件&lt;/strong>分别指向了不同的具体实现。&lt;/p>
&lt;p>那我们今天仅仅关注最常用的，读取目录文件或普通文件，并且不考虑读取的字节数大于文件本身大小这种不合理情况。&lt;/p>
&lt;p>再简化下代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// read_write.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 校验 buf 区域的内存限制    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 仅关注目录文件或普通文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">return&lt;/span> &lt;span class="n">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>太棒了！没剩多少了，一个个击破！&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一步，根据文件描述符 fd，在进程表里拿到了 &lt;strong>file&lt;/strong> 信息，进而拿到了 &lt;strong>inode&lt;/strong> 信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二步，对 buf 区域的内存做校验。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三步，调用具体的 file_read 函数进行读操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>就这三步，很简单吧～&lt;/p>
&lt;p>在进程表 filp 中拿到 file 信息进而拿到 inode 信息这一步就不用多说了，这是在打开一个文件时，或者像管道文件一样创建出一个管道文件时，就封装好了 file 以及它的 inode 信息。&lt;/p>
&lt;p>我们看接下来的两步。&lt;/p>
&lt;h2 id="对-buf-区域的内存做校验-verify_area">对 buf 区域的内存做校验 verify_area&lt;/h2>
&lt;p>对 buf 区域的内存做校验的部分，说是校验，里面还挺有说道呢。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// fork.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">addr&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">size&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xfff&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">start&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">start&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">size&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">write_verify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">start&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>addr 就是刚刚的 buf，size 就是刚刚的 count。然后这里又将 addr 赋值给了 start 变量。所以代码开始，&lt;strong>start 就表示要复制到的内存的起始地址，size 就是要复制的字节数&lt;/strong>。&lt;/p>
&lt;p>这段代码很简单，但如果不了解内存的分段和分页机制，将会难以理解。&lt;/p>
&lt;p>Linux 0.11 对内存是以 &lt;strong>4K&lt;/strong> 为一页单位来划分内存的，所以内存看起来就是一个个 4K 的小格子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-31-5021c43100f4de25b4e64fa52dfe61ca.png" alt="图片">&lt;/p>
&lt;p>你看，我们假设要复制到的内存的起始地址 start 和要复制的字节数 size 在图中的那个位置。那么开始的两行计算代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// fork.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">size&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xfff&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">start&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是将 start 和 size 按页对齐一下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-23-4199a0984f5558c3069e5d6237213e5b.png" alt="图片">&lt;/p>
&lt;p>然后，又由于每个进程有不同的数据段基址，所以还要加上它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// fork.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">start&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>具体说来就是加上当前进程的局部描述符表 LDT 中的数据段的段基址。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/7b752dcb35de94dd8711e9a2d69d3e7e535fa9cb.png" alt="图片">&lt;/p>
&lt;p>每个进程的 LDT 表，由 Linux 创建进程时的代码给规划好了。具体说来，就是如上图所示，每个进程的线性地址范围，是&lt;/p>
&lt;p>**(进程号)&lt;em>64M ~  (进程号+1)&lt;em>64M&lt;/em>&lt;/em>&lt;/p>
&lt;p>而对于进程本身来说，都以为自己是从零号地址开始往后的 64M，所以传入的 start 值也是以零号地址为起始地址算出来的。&lt;/p>
&lt;p>但现在经过系统调用进入 sys_write 后会切换为内核态，内核态访问数据会通过&lt;strong>基地址为 0 的全局描述符表中的数据段&lt;/strong>来访问数据。所以，start 要加上它自己进程的数据段基址，才对。&lt;/p>
&lt;p>再之后，就是对这些页进行具体的验证操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// fork.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">size&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">write_verify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">start&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也就是这些页。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-11-d80885287dd5cfd96e15fa84759213c9.png" alt="图片">&lt;/p>
&lt;p>这些 write_verify 将会对这些页进行&lt;strong>写页面验证&lt;/strong>，如果页面存在但不可写，则执行 un_wp_page 复制页面。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">write_verify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>   
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xffc&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">page&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">page&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xffc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>  
        &lt;span class="cm">/* non-writeable, present */&lt;/span>        
        &lt;span class="n">un_wp_page&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，那个 un_wp_page 意思就是取消页面的写保护，就是写时复制的原理，在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502033&amp;amp;idx=1&amp;amp;sn=1acfd8b7f4c805906ecd51c33d0010eb&amp;amp;chksm=c2c5b27cf5b23b6a41051c7f93407afc97094a4b0a36ea050616778f4d072f074602f98983b2&amp;amp;scene=21#wechat_redirect">第30回 | 番外篇 - 写时复制就这么几行代码&lt;/a> 已经讨论过了，这里就不做展开了。&lt;/p>
&lt;h2 id="执行读操作-file_read">执行读操作 file_read&lt;/h2>
&lt;p>下面终于开始进入读操作的正题了，页校验完之后，就可以真正调用 file_read 函数了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// read_write.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// file_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">)))&lt;/span>
                &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span>
            &lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">chars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MIN&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">nr&lt;/span> &lt;span class="p">,&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="p">);&lt;/span>
        &lt;span class="n">filp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">left&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">;&lt;/span>
            &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="n">put_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
            &lt;span class="n">brelse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
        &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="n">put_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
        &lt;span class="p">}&lt;/span>
    &lt;span class="p">}&lt;/span>
    &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_atime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CURRENT_TIME&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:-&lt;/span>&lt;span class="n">ERROR&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整体看，就是一个 while 循环，每次读入一个块的数据，直到入参所要求的大小全部读完为止。&lt;/p>
&lt;p>while 去掉，简化起来就是这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// file_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
         &lt;span class="n">put_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先 bmap 获取全局数据块号，然后 bread 将数据块的数据复制到缓冲区，然后 put_fs_byte 再一个字节一个字节地将缓冲区数据复制到用户指定的内存中。&lt;/p>
&lt;p>我们一个个看。&lt;/p>
&lt;h2 id="bmap获取全局的数据块号">bmap：获取全局的数据块号&lt;/h2>
&lt;p>先看第一个函数调用&lt;code>bmap()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// file_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// inode.c 
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">_bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">_bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">create&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="p">...&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">block&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">512&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">512&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">512&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="p">...&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span>
         &lt;span class="c1">// zone[0] 到 zone[7] 采用直接索引，可以索引小于 7 的块号
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="p">...&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">512&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="c1">// zone[7] 是一次间接索引，可以索引小于 512 的块号
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// zone[8] 是二次间接索引，可以索引大于 512 的块号
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们看到整个条件判断的结构是根据 block 来划分的。&lt;/p>
&lt;p>block 就是要读取的块号，之所以要划分，就是因为 inode 在记录文件所在块号时，采用了多级索引的方式。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-05-01-1799e829d1f383f3fdb3ff4711e5d5b7.png" alt="图片">&lt;/p>
&lt;p>zone[0] 到 zone[7] 采用直接索引，zone[7] 是一次间接索引，zone[8] 是二次间接索引。&lt;/p>
&lt;p>那我们刚开始读，块号肯定从零开始，所以我们就先看 block&amp;lt;7，通过直接索引这种最简单的方式读的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// inode.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">_bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">create&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">create&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">])&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">new_block&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
                &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_ctime&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">CURRENT_TIME&lt;/span>&lt;span class="p">;&lt;/span>
                &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dirt&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
            &lt;span class="p">}&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">];&lt;/span>
    &lt;span class="p">}&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由于 create = 0，也就是并不需要创建一个新的数据块，所以里面的 if 分支也没了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// inode.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">_bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">create&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="p">...&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">];&lt;/span>
    &lt;span class="p">}&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到，其实 bmap 返回的，就是要读入的块号，&lt;strong>从全局看在块设备的哪个逻辑块号下&lt;/strong>。&lt;/p>
&lt;p>也就是说，假如我想要读这个文件的第一个块号的数据，该函数返回的事你这个文件的第一个块在整个硬盘中的哪个块中。&lt;/p>
&lt;h2 id="bread将-bmap-获取的数据块号读入到高速缓冲块">bread：将 bmap 获取的数据块号读入到高速缓冲块&lt;/h2>
&lt;p>好了，拿到这个数据块号后，回到 file_read 函数接着看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// file_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">)))&lt;/span>
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>nr 就是具体的数据块号，作为其中其中一个参数，传入下一个函数 bread。&lt;/p>
&lt;p>bread 这个方法的入参除了数据块号 block（就是刚刚传入的 nr）外，还有 inode 结构中的 i_dev，表示设备号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// buffer.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getblk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_uptodate&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">ll_rw_block&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">READ&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="n">wait_on_buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_uptodate&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">brelse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 bread 方法就是根据一个设备号 dev 和一个数据块号 block，将这个数据块的数据，从硬盘复制到缓冲区里。&lt;/p>
&lt;p>关于缓冲区，已经在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500596&amp;amp;idx=1&amp;amp;sn=0df64f9f5133cfe8a259b8ce7b7feaeb&amp;amp;chksm=c2c5b999f5b2308f76095af30e8915f125f18702df9c58be7612b58e4d009c14948193974f9b&amp;amp;scene=21#wechat_redirect">第19回 | 缓冲区初始化 buffer_init&lt;/a> 说明过了，有些久远。而 getblk 方法，&lt;strong>就是根据设备号 dev 和数据块号 block，申请到一个缓冲块&lt;/strong>。&lt;/p>
&lt;p>简单说就是，先根据 hash 结构快速查找这个 dev 和 block 是否有对应存在的缓冲块。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-04-28-16667f64e237c145eb6d5a2b293987f8.png" alt="图片">&lt;/p>
&lt;p>如果没有，那就从之前建立好的双向链表结构的头指针 free_list 开始寻找，直到找到一个可用的缓冲块。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-04-13-b2c84f4078f5265eee6c3c722e185f89.png" alt="图片">&lt;/p>
&lt;p>具体代码逻辑，还包含当缓冲块正在被其他进程使用，或者缓冲块对应的数据已经被修改时的处理逻辑，你可以看一看，关键流程我已加上了注释。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// buffer.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getblk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">getblk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nl">repeat&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="c1">// 先从 hash 结构中找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_hash_table&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 如果没有就从 free_list 开始找遍双向链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">free_list&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">bh&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">BADNESS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">BADNESS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">BADNESS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_next_free&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">free_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 如果还没找到，那就说明没有缓冲块可用了，就先阻塞住等一会
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">sleep_on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">buffer_wait&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 到这里已经说明申请到了缓冲块，但有可能被其他进程上锁了
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果上锁了的话，就先等等
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">wait_on_buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 到这里说明缓冲块已经申请到，且没有上锁
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 但还得看 dirt 位，也就是有没有被修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果被修改了，就先重新从硬盘中读入新数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_dirt&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">sync_dev&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_dev&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">wait_on_buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">find_buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 给刚刚获取到的缓冲头 bh 重新赋值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 并调整在双向链表和 hash 表中的位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_dirt&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_uptodate&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">remove_from_queues&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_dev&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_blocknr&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">insert_into_queues&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>总之，经过 getblk 之后，我们就在内存中，&lt;strong>找到了一处缓冲块&lt;/strong>，用来接下来存储硬盘中指定数据块的数据。&lt;/p>
&lt;p>那接下来的一步，自然就是把硬盘中的数据复制到这里啦，没错，&lt;strong>ll_rw_block&lt;/strong> 就是干这个事的。&lt;/p>
&lt;p>这个方法的细节特别复杂，也是我看了好久才看明白的地方，我会在下一回把这个方法详细地展开讲解。&lt;/p>
&lt;p>在这一回里，你就当它已经成功地把硬盘中的一个数据块的数据，一个字节都不差地复制到了我们刚刚申请好的缓冲区里。&lt;/p>
&lt;p>接下来，就要通过 &lt;strong>put_fs_byte&lt;/strong> 方法，一个字节一个字节地，将缓冲区里的数据，复制到用户指定的内存 buf 中去了，当然，只会复制 count 字节。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// file_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">put_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="put_fs_byte将-bread-读入的缓冲块数据复制到用户指定的内存中">put_fs_byte：将 bread 读入的缓冲块数据复制到用户指定的内存中&lt;/h2>
&lt;p>这个过程，仅仅是内存之间的复制，所以不必紧张。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// segment.h
extern _inline void
put_fs_byte (char val, char *addr) {
    __asm__ (&amp;#34;movb %0,%%fs:%1&amp;#34;::&amp;#34;r&amp;#34; (val),&amp;#34;m&amp;#34; (*addr));
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有点难以理解，我改成较为好看的样子。（参考赵炯《Linux 内核完全注释 V1.9.5》）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// segment.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">extern&lt;/span> &lt;span class="kr">_inline&lt;/span> &lt;span class="kt">void&lt;/span>
&lt;span class="nf">put_fs_byte&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">addr&lt;/span>
    &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">byte&lt;/span> &lt;span class="n">ptr&lt;/span> &lt;span class="nl">fs&lt;/span>&lt;span class="p">:[&lt;/span>&lt;span class="n">ebx&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">al&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其实就是三个汇编指令的 mov 操作。&lt;/p>
&lt;p>至此，我们就将数据从硬盘读入缓冲区，再从缓冲区读入用户内存，一个 read 函数完美谢幕！&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-04-00-15621404a8aa327ecc0011cdca211fa0.png" alt="图片">&lt;/p>
&lt;p>首先通过 verify_area 对内存做了校验，需要写时复制的地方在这里提前进行好了。&lt;/p>
&lt;p>接下来，file_read 方法做了读盘的全部操作，通过 bmap 获取到了硬盘全局维度的数据块号，然后 bread 将数据块数据复制到缓冲区，然后 put_fs_byte 再将缓冲区数据复制到用户内存。&lt;/p></description></item></channel></rss>