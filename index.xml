<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 20 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>98.验证二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;h1 id="98验证二叉搜索树httpsleetcode-cncomproblemsvalidate-binary-search-treedescription-httpsleetcode-cncomproblemsvalidate-binary-search-treedescription">&lt;a href="https://leetcode-cn.com/problems/validate-binary-search-tree/description/" title="https://leetcode-cn.com/problems/validate-binary-search-tree/description/">98.验证二叉搜索树&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Medium (35.36%)&lt;/td>
&lt;td>1387&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree">&lt;code>tree&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search">&lt;code>depth-first-search&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>amazon&lt;/code> | &lt;code>bloomberg&lt;/code> | &lt;code>facebook&lt;/code> | &lt;code>microsoft&lt;/code>&lt;/p>
&lt;p>给你一个二叉树的根节点 &lt;code>root&lt;/code> ，判断其是否是一个有效的二叉搜索树。&lt;/p>
&lt;p>&lt;strong>有效&lt;/strong> 二叉搜索树定义如下：&lt;/p>
&lt;ul>
&lt;li>节点的左子树只包含 &lt;strong>小于&lt;/strong> 当前节点的数。&lt;/li>
&lt;li>节点的右子树只包含 &lt;strong>大于&lt;/strong> 当前节点的数。&lt;/li>
&lt;li>所有左子树和右子树自身必须也是二叉搜索树。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：root = [2,1,3]
输出：true
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>树中节点数目范围在&lt;code>[1, 104]&lt;/code> 内&lt;/li>
&lt;li>&lt;code>-231 &amp;lt;= Node.val &amp;lt;= 231 - 1&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/validate-binary-search-tree/comments/" title="https://leetcode-cn.com/problems/validate-binary-search-tree/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/" title="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>ChubaoFS DataNode</title><link>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-datanode/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-datanode/</guid><description>&lt;h1 id="chubaofs-datanode">ChubaoFS DataNode&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>chubaofs datanode 是chubaofs中的数据存储节点，用于将chubaofs中的文件数据存储在磁盘中；&lt;/p>
&lt;p>chubaofs 中的datanode数据以&lt;code>dataPartition&lt;/code>为单位进行管理。&lt;code>dataPartition&lt;/code>是datanode中进行数据管理的最高单位。&lt;/p>
&lt;h2 id="大文件小文件">大文件/小文件&lt;/h2>
&lt;p>文件系统中，每个文件存在元数据。由于磁盘和内存的性能成本差别，导致同一个文件系统对于大小文件的操作管理成本存在显著的差异。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于小文件，其单个文件数据量少，平均磁盘操作成本巨大，且元数据数量膨胀快；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大文件数据文件大，顺序读写可以获得较低的磁盘操作成本，取得较高的性能，元数据相对总数据量成本低；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因此同一个文件系统对于大小文件很难使用同一策略来满足高效低费存储需求。&lt;/p>
&lt;p>chubaofs对于大小文件的读写使用了不同的策略，以此满足大小文件的不同需求。&lt;/p>
&lt;p>chubaofs中的小文件是客户端指定，小于一定大小（默认为：1MB）的文件。可以通过客户端配置参数&lt;code>tinySize&lt;/code>指定。&lt;/p>
&lt;p>每个客户端文件的前1MB字节内的文件都使用&lt;code>TinyExtent&lt;/code>进行存储管理，&lt;/p>
&lt;p>大于&lt;code>1MB&lt;/code>的文件部分使用&lt;code>NormalExtent&lt;/code>方式进行存储管理。&lt;/p>
&lt;h2 id="顺序写随机写">顺序写/随机写&lt;/h2>
&lt;p>ChubaoFS同时支持&lt;code>顺序写&lt;/code>和&lt;code>随机写&lt;/code>两种文件写入方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>顺序写&lt;/code>: 指写入的数据每次只往文件末尾追加;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>随机写&lt;/code>: 指覆盖之前已经写过的文件内容;&lt;/p>
&lt;p>客户端在发起写请求时，根据写入数据的偏移是否已经存在，来决定使用那种写入方式；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>顺序写&lt;/code>: 使用主从方式进行副本间同步数据, 对应的存储引擎；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>随机写&lt;/code>: 使用Raft协议来在数据副本间同步数据；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// sdk/data/stream/stream_writer.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Streamer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">flags&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">total&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">requests&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">writeSize&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ExtentKey&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//已存在旧写入数据extentkey
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">writeSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">doOverwrite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//随机覆盖写
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">writeSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">doWrite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FileOffset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//顺序写
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="datanode目录结构">datanode目录结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>datanode配置文件中的&lt;code>disks&lt;/code>指定了每个datanode dp的存储磁盘；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中包含一系列&lt;code>datapartition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>和命名的目录，用于存储对应dp；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中还可能包含&lt;code>expired_dataparition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>的过期dp，这些dp是在master中不存在的；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## datanode配置文件中的disks设置datanode管理的哪些disk； &lt;/span>
$ cat /opt/chubaofs/conf/datanode.json
...
&lt;span class="s2">&amp;#34;disks&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;/data/hdfs10:159978629365&amp;#34;&lt;/span>, //磁盘目录：可用大小
&lt;span class="s2">&amp;#34;/data/hdfs12:159978629365&amp;#34;&lt;/span>,
...
&lt;span class="o">]&lt;/span>,
...
&lt;span class="c1">## 每个disk中包含一系列的dp目录&lt;/span>
$ ls -1 /data/hdfs10
...
datapartition_1001_128849018880 //正常dp，1001：dpid，128849018880：dpsize
datapartition_1003_128849018880
datapartition_1004_128849018880
...
expired_datapartition_2004_128849018880 //过期dp，在master中 不存在的dp
...
&lt;span class="c1">## 每个dp包含一系列的extent file 和dp 元数据&lt;/span>
$ tree /data/hdfs10/datapartition_1001_128849018880
├── &lt;span class="m">1&lt;/span>
├── &lt;span class="m">10&lt;/span>
├── &lt;span class="m">11&lt;/span>
├── &lt;span class="m">12&lt;/span>
├── &lt;span class="m">13&lt;/span>
├── &lt;span class="m">14&lt;/span>
├── &lt;span class="m">15&lt;/span>
├── &lt;span class="m">16&lt;/span>
...
├── &lt;span class="m">63&lt;/span>
├── &lt;span class="m">64&lt;/span>
├── &lt;span class="m">7&lt;/span>
├── &lt;span class="m">8&lt;/span>
├── &lt;span class="m">9&lt;/span> //extent file， 1-64, tiny extent file&lt;span class="p">;&lt;/span> 1000-, normal extent file
├── APPLY //dp apply index, 里面存储了当前dp.appliedID&lt;span class="o">(&lt;/span>raft rsm apply index&lt;span class="o">)&lt;/span>
├── .apply //apply index临时文件
├── EXTENT_CRC //extent file crc,
├── EXTENT_META //extent meta
├── .meta //临时META文件，
├── META //dp meta
├── NORMALEXTENT_DELETE //
├── TINYEXTENT_DELETE
└── wal_1001 //raft wal
├── 0000000000000001-0000000000000001.log
└── META
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="datapartition">DataPartition&lt;/h2>
&lt;h3 id="dp存储">dp存储&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>datanode配置文件中的&lt;code>disks&lt;/code>指定了每个datanode dp的存储磁盘；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中包含一系列&lt;code>datapartition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>和命名的目录，用于存储对应dp；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中还可能包含&lt;code>expired_dataparition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>的过期dp，这些dp是在master中不存在的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个dp&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="apply文件">APPLY文件:&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>保存当前dp的&lt;code>appliedID&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dp的&lt;code>StartRaftLoggingSchedule()&lt;/code>协程周期性(10s)将dp的appliedID 写入到APPLY文件中(先写.apply,后move);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dp&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="meta文件">META文件&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>META保存了当前dp的配置元信息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当dp配置信息改变时，由&lt;code>PersistMetadata()&lt;/code>将dp的配置元信息持久化到该文件中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dp加载时(LoadDataPartition)，从META中读取dp元信息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写入时机包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>dp创建时；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>周期性truncate raft log时，lastTruncateID发生改变；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>raft 配置变更；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="err">//&lt;/span> &lt;span class="err">cat&lt;/span> &lt;span class="err">/data/hdfs&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="err">/datapartition_&lt;/span>&lt;span class="mi">1001&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="mi">128849018880&lt;/span>&lt;span class="err">/META&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;VolumeID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;weqewqe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;PartitionID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1001&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;PartitionSize&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">128849018880&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;CreateTime&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-11-29 18:26:21&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;Peers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;addr&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10.201.69.20:17310&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;addr&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10.201.74.33:17310&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;addr&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10.201.76.21:17310&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;Hosts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;10.201.74.33:17310&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;10.201.69.20:17310&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;10.201.76.21:17310&amp;#34;&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;DataPartitionCreateType&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;LastTruncateID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="extent_meta">EXTENT_META&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>metadataFp&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保存baseExtentID + PreAllocSpaceExtentID, 2个uint64, 总共16字节；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h3 id="extent_crc">EXTENT_CRC&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>verifyExtentFp: 保存dp所有normal extent crc;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>extent 加载时，根据extentID， 从EXTENT_CRC中加载对应extent 的crc到extent header 中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>normal extent写入时, 根据offset，size计算blockNo(128K为一个Block);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果刚好是一个整block, 将crc写入&lt;code>EXTENT_CRC&lt;/code>文件; 否则规整化后，写0&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>每个datapartition存储目录中有一个&lt;code>EXTENT_CRC&lt;/code>文件，用于保存该datapartition 所有&lt;code>normal_extent&lt;/code>的crc校验头；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>EXTENT_CRC&lt;/code>文件由多个4KB大小的校验块组成，每个校验块存储一个&lt;code>normal_extent&lt;/code>的crc校验；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个4KB的校验块由1000个4B的CRC检验数据组成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>datanode节点在加载normal_extent时，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">|crc|
| 4 | 4 |... | 4 | 4 |... |
|--------------|--------------|---------------|
4k 4k
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="extent-file">extent file&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>TinyExtent file(id: 1-64):&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Normal Extent file:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>写请求追加写到extent文件末尾；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>normal extent file最大128MB, 写入前会对写入数据offset，size进行检查，超出128MB时无法写入；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="normalextent_delete">NORMALEXTENT_DELETE&lt;/h3>
&lt;h3 id="tinyextent_delete">TINYEXTENT_DELETE&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>记录本dp已经删除过的tiny extent 数据块, 在第一次调用fallocate puchhole后记录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个被删除的tiny extent 数据块记录为24Byte，按&lt;code>&amp;lt;extentID&amp;gt;&amp;lt;offset&amp;gt;&amp;lt;size&amp;gt;&lt;/code>这个依次追加到该文件中；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h4 id="status">&lt;strong>Status&lt;/strong>&lt;/h4>
&lt;h2 id="extent">Extent&lt;/h2>
&lt;p>每个dp包含多个&lt;code>extent&lt;/code>, 每个extent 对应一个extent file，用于存储数据。&lt;/p>
&lt;p>extent file大小限制为128MB, 每个datapartition 包含的extent 个数不超过2000个(256GB)&lt;/p>
&lt;p>extent分为&lt;code>NormalExtent&lt;/code> 和 &lt;code>TinyExtent&lt;/code> 两种类型。&lt;/p>
&lt;h3 id="tinyextent">TinyExtent&lt;/h3>
&lt;ul>
&lt;li>id范围: [1, 64]&lt;/li>
&lt;li>在每个dp加载时，会通过&lt;/li>
&lt;/ul>
&lt;h3 id="normalextent">NormalExtent&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>id: [1000, +)&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="extentstore">ExtentStore&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>datanode 数据存储目录结构&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>EXTENT_META&lt;/code>: &lt;code>metadataFp&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>EXTENT_CRC&lt;/code>: &lt;code>verifyExtentFp&lt;/code>, 存储当前datapartition 的所有&lt;code>normal_extent&lt;/code>crc校验数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TINYEXTENT_DELETE&lt;/code>: &lt;code>tinyExtentDeleteFp&lt;/code>,&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tinyextent中的删除">TinyExtent中的删除&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>删除的extent数据段offset必须是4K对齐的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先通过seek从文件中找到从offset开始的DATA起始位置newoffset；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过newoffset 和 offset之间的关系判断要删除的数据段是否已被删除；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>总共有以下4种情形：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>其中第2中的数据完全落在Hole中，其中数据已经删除过；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其他情况都需要通过fallocate PunchHole来打洞删除从offset开始的size长的数据；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// 情形1：待删除数据区offset+size完全落在DATA区域, newoffset == offset
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^-----+
offset size
// 情形2：待删除数据区offset+size完全落在HOLE区域， newoffset - offset &amp;gt; size
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^---+ ^
offset newoffset
// 情形3：待删除数据区offset+size部分落在DATA区域；
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^----------+
offset size
// 情形4：待删除数据区offset+size部分落在DATA区域；
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^-------------+
offset ^newoffset
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="datapartition加载">DataPartition加载&lt;/h2>
&lt;h2 id="datapartition修复">DataPartition修复&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个dp在新建和加载后会启动一个&lt;code>statusUpdateScheduler()&lt;/code>协程;&lt;/p>
&lt;ul>
&lt;li>
&lt;p>该协程每过1min会先更新一下dp状态(计算usage，更新status)，并交替启动repair任务(TinyExtent, NormalExtent交替分开)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每5min会启动&lt;code>ReloadSnapshot()&lt;/code>任务；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Repair任务由&lt;code>LaunchRepair()&lt;/code>启动；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先检查dp状态, &lt;code>Unavailable&lt;/code>状态的dp不参与修复；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后&lt;code>updateRelicas()&lt;/code>从master获取最新的副本ip；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查是否为leader，非leader退出，不启动 修复；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后由&lt;code>repair()&lt;/code>函数执行修复任务；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>Flink Shuffle 原理</title><link>https://justice.bj.cn/post/30.architech/flink/flink-shuffle%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/flink/flink-shuffle%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="flink-shuffle-原理">Flink Shuffle 原理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/developer/article/1441420">批流统一计算引擎的动力源泉—Flink Shuffle机制的重构与优化 - 云+社区 - 腾讯云&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://flink-learning.org.cn/article/detail/444b58f5786ef3a36f50f42df3c55f27?spm=a2csy.flink.0.0.49493bdcKsn88l&amp;amp;tab=suoyou&amp;amp;page=2">Flink 中文社区 | 中文学习教程&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.oschina.net/news/171564/flink-remote-shuffle-open-source">https://www.oschina.net/news/171564/flink-remote-shuffle-open-source&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Flink-基本</title><link>https://justice.bj.cn/post/30.architech/flink/flink%E5%9F%BA%E7%A1%80/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/flink/flink%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="flink-基本">Flink-基本&lt;/h1>
&lt;h2 id="数据流">数据流&lt;/h2>
&lt;p>数据流就是一个无界（unbounded）的事件序列。事件（Event）可以是监控报警数据、传感器感知数据、信用卡交易、用户在APP上的行为&amp;hellip;随着数据量的爆炸式增长，单台机器无法处理庞大的数据流，一般需要多台机器并行地处理，因此需要一种并行的流式计算引擎来对大数据场景下的数据流做处理。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-44a4023fff6f8d0944cece45b24a25ec_1440w.jpg" alt="">&lt;/p>
&lt;p>有界和无界数据 来源：Flink官网&lt;/p>
&lt;h2 id="流式计算的衡量指标延迟和吞吐">流式计算的衡量指标：延迟和吞吐&lt;/h2>
&lt;p>在批量计算场景，主要通过一次计算的总时间来评价性能。在流式计算场景，数据源源不断地流入系统，计算引擎对每个数据处理地越快越好，计算引擎能处理的数据量越大越好。例如处理实时的Twitter文本数据案例，如果系统只能处理一个人发的Tweet或处理时间长达一天，那说明这个系统非常不靠谱。为了衡量流式计算的“快”和“量”两方面的性能，一般用延迟（Latency）和吞吐（Throughput）这两个指标。&lt;/p>
&lt;p>&lt;strong>延迟 Latency&lt;/strong>&lt;/p>
&lt;p>延迟表示一个事件被系统处理的总时间，一般以毫秒为单位。根据业务应用不同，我们一般关心平均延迟和分位延迟（Percentile Latency）。假设一个煎饼摊就是一个流式计算系统，每个顾客来购买煎饼是它所需要处理的事件，从顾客到达到顾客拿到购买的煎饼并付费离开，就是这个顾客的延迟。如果正赶上了早餐高峰期，顾客极有可能排队，这个排队时间也要算在延迟时间中。例如，99分位延迟表示系统处理前99%顾客所需的最长时间，也就是对所有顾客延迟排名后，第99%的那个时间。一般商业系统更关注分位延迟，因为分位延迟比平均延迟能反应出这个系统的一些潜在问题。还是以煎饼摊为例，一般煎饼中都有薄脆，薄脆是单独制作的，如果薄脆制作的速度跟不上煎饼制作的速度，那在高峰期，将拖慢整个过程的延迟，部分用户会因为等待时间过久而放弃排队。&lt;/p>
&lt;p>延迟对于很多流式计算非常重要，比如欺诈检测、告警监控等等。像Flink这样的流式计算引擎可以将延迟降到毫秒级别，如果用mini-batch的方法处理同样的问题，很可能是分钟级到小时级的延迟，因为计算引擎必须等待一批数据达到才开始进行计算。&lt;/p>
&lt;p>&lt;strong>吞吐 Throughput&lt;/strong>&lt;/p>
&lt;p>吞吐表示一个系统最大能处理多少事件，一般以单位时间处理的事件数量为单位。需要注意的是，吞吐除了与引擎自身设计有关，也与数据源发送过来的事件数据量有关，有可能计算引擎的最大吞吐量远大于数据源的数据量。比如，煎饼摊可能在早七点到九点的需求最高，很可能出现大量排队的情况，但另外的时间几乎不需要排队等待。假设一天能提供1000个煎饼，服务10个小时，那它的平均吞吐量为100个/小时；仅早上2小时的高峰期就提供了600个煎饼，它的峰值吞吐量是300个/小时。比起平均吞吐量，峰值吞吐量更影响用户体验，如果峰值吞吐量低，也会导致用户等待时间过久而放弃排队。早高峰时，一般用户都需要排队等待，排队的过程被称作缓存（Buffering）。如果仍然有大量事件进入缓存，很可能超出系统的极限，就会出现反压问题（Backpressure），这时候就需要一些优雅的策略来处理类似问题，否则会造成系统崩溃，用户体验极差。&lt;/p>
&lt;p>&lt;strong>延迟与吞吐&lt;/strong>&lt;/p>
&lt;p>延迟与吞吐其实并不是相互孤立的，他们相互影响。如果延迟高，那么很可能造成吞吐低，系统处理不了太多事件。为了优化这两个指标，一种办法是提高煎饼师傅的制作速度，当用户量大到超过单个煎饼师傅的瓶颈时，接着就需要考虑再增加一个煎饼师傅。这也是当前大数据系统都在采用的并行(parallelism)策略，如果一个机器做不了或做得不够快，那就用更多的机器一起来做。&lt;/p>
&lt;h2 id="数据流图">数据流图&lt;/h2>
&lt;p>数据流图描述了数据如何在不同的操作间流动。数据流图一般是一个有向图，图中的节点是一个算子（Operator），表示某种运算，边表示数据间的相互依赖关系或数据的流动方向。算子从输入读取数据，进行一些计算，接着将计算结果发送到下一个算子。Source是所有计算的开始，Sink是所有计算的终点。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-e9d18ef9720eb373896825ccfd66635c_1440w.png" alt="">&lt;/p>
&lt;p>一个解析Twitter标签的数据流图逻辑视角 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>上图从逻辑角度描述数据的流动，对于一个Twitter数据流，接收输入源后需要将Twitter文本中的#井号标签去除，提取关键词，再对关键词做词频统计。这样一个图并没有考虑大数据情况下跨计算节点计算的问题，它只是一种处理问题的逻辑思路，因此称之为逻辑视角。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-aa6d4062c5fbe69b8f118823a8a72c76_1440w.jpg" alt="">&lt;/p>
&lt;p>数据流图的物理视角 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>实现一个能够处理大数据的分布式系统，需要考虑在多个节点上并行计算。上图将逻辑视角细化为物理视角。Source发出的数据会兵分两路，被分配到两个节点上，在各自节点上进行&amp;quot;Extract hashtags&amp;quot;和&amp;quot;Count&amp;quot;运算。每个&amp;quot;Extract hashtags&amp;quot;和&amp;quot;Count&amp;quot;运算只处理一部分数据。最终数据要聚合到Sink上。&lt;/p>
&lt;h2 id="数据交换策略">数据交换策略&lt;/h2>
&lt;p>在物理视角中，我们看到数据经历了跨节点的数据交换。比如，我们要统计&amp;quot;Flink&amp;quot;这个单词出现的次数，各个节点可能都会解析出&amp;quot;Flink&amp;quot;这个单词，但是我们最终要的是所有节点上的&amp;quot;Flink&amp;quot;单词的总和。因此从&amp;quot;Extract hashtags&amp;quot;到&amp;quot;Count&amp;quot;，发生了数据交换，所有的&amp;quot;Flink&amp;quot;被发送到第一个节点上，才能做词频求和统计。在这个任务中，同一个词需要交换到同一个节点上，就是一种数据交换。&lt;/p>
&lt;p>在流式计算场景，某个节点及节点上的数据通常被称为分区（partition）。&lt;/p>
&lt;p>数据交换一般有以下几种策略。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-f4e055bfad75c037ea5c07acc26481bd_1440w.jpg" alt="">&lt;/p>
&lt;p>数据交换策略 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;ul>
&lt;li>Forward：数据在一个分区上前向传播，无需跨节点通信。&lt;/li>
&lt;li>Broadcast：将数据发送到所有分区上，需要大量的跨节点通信开销。&lt;/li>
&lt;li>Key-Based：按照某个key将数据做分片，某个key的所有数据都会分配到一个分区上。刚才词频统计的例子中，就是以单词为key进行的分片处理。&lt;/li>
&lt;li>Random：将数据做随机均匀分片，以避某个分区上的数据过大。&lt;/li>
&lt;/ul>
&lt;h2 id="状态-state">状态 State&lt;/h2>
&lt;p>状态是流式计算特有的概念。比如刚才计算词频的例子，要统计实时数据流一分钟内的单词词频，一方面要处理每一瞬间新流入的数据，另一方面要保存之前一分钟内已经进入系统的单词词频。再举一个告警的例子，当系统在监听到“高温”事件后10分钟内又监听到“冒烟”的事件，系统必须及时报警，系统必须把“高温”的事件作为状态记录下来，并判断这个状态下十分钟内是否有“冒烟”事件。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-48e2ac54d3ca4a9040e4b37a71f31d20_1440w.jpg" alt="">&lt;/p>
&lt;p>无状态算子 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>上图中的圆圈就是一个无状态算子，它将每个输入方框都转化成黑色。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-1f07121b4f763eca8a89057add6ac6a2_1440w.jpg" alt="">&lt;/p>
&lt;p>有状态算子 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>上图的圆圈是一个有状态算子，计算的是一个数据流中的最小值。它需要保存一个当前的最小值作为状态，并根据新事件来不断更新这个状态。&lt;/p>
&lt;p>流式计算要处理无界的数据流，要注意如果将这些状态不断增长，最后造成数据爆炸，因此会使用一些机制来限制状态的数据总量。&lt;/p>
&lt;p>综上，实现一个流式计算系统非常复杂，需要考虑几个因素：&lt;/p>
&lt;ol>
&lt;li>系统必须能有效管理状态。因为一般的计算既依赖当前事件，也依赖之前事件产生的状态。&lt;/li>
&lt;li>设计能够管理状态的并行算法极具挑战。一般将数据按照某个key进行切片，将一组大数据切分成小的分区，每个分区单独维护状态数据。&lt;/li>
&lt;li>当系统出现错误而挂掉重启时，必须能够保证之前保存的状态数据也能恢复，否则重启后很多计算结果有可能是错误的。一般使用checkpoint来解决这个问题。&lt;/li>
&lt;/ol>
&lt;p>可见，流式计算系统比批量计算系统更难实现。&lt;/p>
&lt;h2 id="窗口">窗口&lt;/h2>
&lt;p>我们一般要对流式数据以窗口的形式做聚合统计分析。一般有如下几种定义窗口的方式。&lt;/p>
&lt;p>&lt;strong>Tumbling&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-dbfc6013f3dadf1bae2c6802ae35ff97_1440w.jpg" alt="">&lt;/p>
&lt;p>Count-Based Tumbling Window 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-36611d45c569176cc03ab990bf7acfc8_1440w.jpg" alt="">&lt;/p>
&lt;p>Time-based Tumbing Window 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>Tumbling窗口互不重叠且一般是定长的，可以是固定事件数目，也可以是固定时间间隔。&lt;/p>
&lt;p>&lt;strong>Sliding&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-6666b3b8ccf8e39d18d558770f5a3d86_1440w.jpg" alt="">&lt;/p>
&lt;p>Sliding Window 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>滑动窗口的窗口与窗口之间有滑动间隔（Slide）。&lt;/p>
&lt;p>&lt;strong>Session&lt;/strong>&lt;/p>
&lt;p>Session是一个用户与互联网应用交互的概念，一般指用户在APP或网站上的一系列行为。比如，用户在淘宝上短时间有大量的搜索和点击的行为，这一些列行为组成了一个Session，接着可能因为一些其他因素，用户暂停了与APP的交互，过一会用户又返回了APP，经过一系列搜索、点击、与客服沟通，最终下单。Session窗口的长度并不固定，因此不能简单用上面两种形式的窗口来建模。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-b34efc018a871410e8747363c53754be_1440w.jpg" alt="">&lt;/p>
&lt;p>Session Window 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>Session窗口没有固定长度，一般使用Session Gap将数据做分组。&lt;/p>
&lt;p>&lt;strong>并行物理视角&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-7ea5729416de90dffe8f1414e6484e49_1440w.jpg" alt="">&lt;/p>
&lt;p>Parallel Count-based Tumbling Window 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>前面讲的几种窗口都是从全局视角定义的逻辑窗口，实际上数据是在不同分区上的。例如，接受一个传感器数据流，我们可以根据传感器id作为key，将来自同一个传感器的事件都切分到一个分区上。每个分区的数据是独立的，其窗口策略也是独立的。例如上图所示的，同一颜色的事件被分到同一个分区上，组成固定长度为2的窗口。&lt;/p>
&lt;h2 id="时间语义">时间语义&lt;/h2>
&lt;p>&lt;strong>“一分钟”真的是一分钟吗？&lt;/strong>&lt;/p>
&lt;p>你可能觉得时间是最简单不过的事情，没什么可讨论的，恰恰相反，在很多应用场景，时间有着不同的意义。“一分钟”真的是一分钟吗？&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-36ba1b13b076e27eac94a37077165604_1440w.jpg" alt="">&lt;/p>
&lt;p>穿越隧道的一分钟 来源：Streaming Processing With Apache Flink&lt;/p>
&lt;p>假设你坐高铁并玩王者荣耀消磨时间，王者荣耀在最终计算MVP时，要考虑的一个因素是玩家每分钟释放技能次数。在一波团战中，你疯狂抢了三个人头，正当你觉得稳拿MVP时，高铁穿越进了隧道，手机丢失信号，你掉线了！好在高铁在隧道里只停留了几十秒，APP缓存了你掉线时的数据，并在信号恢复后将缓存数据传回了服务器。在这种情形下，时间比想象中更复杂，有一个时间记录事件实际发生的时间（Event Time），还有一个时间是事件上传到服务器后，服务器处理时间（Processing Time）。&lt;/p>
&lt;p>比如，你旁边的小伙伴跟你一起开黑，他的手机运营商更给力，进隧道后没有丢信号，如果都使用Processing Time，在丢失信号的这段时间，你的数据没有计算进去，显然对你来说是不公平的。但是当信号恢复，数据重传到服务器，再根据Event Time重新计算一次，那就非常公平了。我们可以根据Event Time复现一个事件序列的顺序，因此，使用Event Time是最准确的。&lt;/p>
&lt;p>&lt;strong>Watermark&lt;/strong>&lt;/p>
&lt;p>虽然使用Event Time更准确，但问题在于，因为各种不可控因素，事件上报会有延迟，那么最多要等待多长时间呢？从服务器的角度来看，在事件到达之前，我们也无法确定是否有事件已经延迟，如何设置Event Time时间窗口成了很大的问题。比如刚才的例子，我们要统计一分钟内的实时数据，考虑到事件的延迟，如何设置合理的等待时间，以等待一分钟内所有事件都到达服务器？也正因为这个问题，流式计算比批量计算在准确性上有差距，因为批量计算一般以更长的一段时间为一个批次，一个批次内延迟上报的数据比一个时间窗口内延迟上报的数据相对比例更少。比如某个电商平台上，去计算一件商品每分钟点击次数，使用一天的总数除以分钟数的计算方法，比使用一分钟时间窗口实时的点击次数更准确。可以看到，数据的实时性和准确性二者不可得兼，必须取一个平衡。&lt;/p>
&lt;p>Watermark是一种折中解决方案，它假设某个时间点上，不会有比这个时间点更晚的上报数据。当算子接受到一个Watermark后，它会假定后续不会再接收到这个时间窗口的内容，然后会触发对当前时间窗口的计算。比如，一种 Eager Watermark 策略的等待延迟上报的时间非常短，这样能保证低延迟，但是会导致错误率上升。在实际应用中，Watermark设计多长非常有挑战。还是以刚才手机游戏的例子，系统不知道玩家这次掉线的原因是什么，可能是在穿越隧道，也可能是坐飞机进入飞行模式，还有可能把这个游戏删了再也不玩了。&lt;/p>
&lt;p>&lt;strong>Processing Time 与 Event Time&lt;/strong>&lt;/p>
&lt;p>那既然Event Time似乎可以解决一切问题，为什么还要使用Processing Time？前面也提到了，为了处理延迟上报或顺序错乱的事件，需要使用一些机制来做等待，这样会导致延迟上升。在某些场景可能对准确性要求不高，但是要求实时性更高，Processing Time就更合适一些。&lt;/p>
&lt;h2 id="投递保障">投递保障&lt;/h2>
&lt;p>事件进入到计算引擎，如果引擎遇到故障并重启，该事件是否被成功处理了呢？一般有三种结果。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>At Most Once&lt;/strong>: 每个事件最多被处理一次，也就是说，有可能某些事件没有被处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>At Least Once&lt;/strong>: 每个事件至少被处理一次，如果系统遇到故障，系统重启后该事件会被再次处理一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Exactly Once&lt;/strong>: 每个事件只被处理一次，无论是否有故障重启。&amp;ldquo;Exactly Once&amp;quot;意味着事件不能有任何丢失，也必须保障状态也&amp;quot;Exactly Once&amp;rdquo;。Flink实现了&amp;quot;Exactly Once&amp;quot;语义。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>本文简述了流式大数据处理引擎的一些基础概念，包括数据流、数据流图、衡量指标、状态、时间、以及投递保障，每个流式计算引擎的实现过程都要面对这些问题，Flink对这些问题做出了具体实现。&lt;/p></description></item><item><title>RocksDB</title><link>https://justice.bj.cn/post/30.architech/rocksdb/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/rocksdb/</guid><description>&lt;h1 id="rocksdb">RocksDB&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>RocksDB是Facebook基于LevelDB开发的一种嵌入式Key-value存储系统，该数据库能够充分利用闪存的性能，大大提升应用服务器的速度。
这是一个c++库,用于存储键和值,可以是任意大小的字节流。支持原子读和写。
RocksDB具有高度灵活的配置功能,可以通过配置使其运行在各种各样的生产环境,包括纯内存,Flash,硬盘或HDFS。它支持各种压缩算法，并提供了便捷的生产环境维护和调试工具。&lt;/p>
&lt;ul>
&lt;li>内存结构memtable&lt;/li>
&lt;li>类似事务日志角色的WAL文件：&lt;/li>
&lt;li>持久化的SST文件：&lt;/li>
&lt;/ul>
&lt;h2 id="写流程">写流程&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/25-09-36-56-image-20190905182525925.png" alt="image-20190905182525925">&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/25-09-37-55-image-20190905182625720.png" alt="image-20190905182625720">&lt;/p>
&lt;p>SST file&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&amp;lt;beginning_of_file&amp;gt;
[data block 1] // 具体的 KV 数据
[data block 2] // 具体的 KV 数据
...
[data block N] // 具体的 KV 数据
[meta block 1: filter block] // Filter 信息，比如 bloom filter
[meta block 2: index block] // data block 对应的 index，查询中通过对 index block 进行二分查找来定位到具体的 data block
... (compression/range deletion/stats block)
[meta block K: future extended block]
[metaindex block]
[Footer]
&amp;lt;end_of_file&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="compaction">Compaction&lt;/h2>
&lt;h3 id="compaction策略">Compaction策略&lt;/h3>
&lt;ul>
&lt;li>Leveled Compaction（默认策略）：Compaction 触发频率相对高，读放大低，写放大高&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/facebook/rocksdb/wiki/Universal-Compaction">Universal Compaction&lt;/a>：Compaction 触发频率相对低，读放大高，写放大低&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/facebook/rocksdb/wiki/FIFO-compaction-style">FIFO Compaction&lt;/a>：几乎不发生 Compaction，读放大高，写放大几乎没有&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/pdev/p/11277784.html">RocksDB解析 - Pentium.Labs - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/458148962">https://zhuanlan.zhihu.com/p/458148962&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Spark 文件 IO 分析</title><link>https://justice.bj.cn/post/30.architech/spark/spark-shuffle/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/spark/spark-shuffle/</guid><description>&lt;h1 id="spark-文件-io-分析">Spark 文件 IO 分析&lt;/h1>
&lt;hr>
&lt;!-- slide -->
&lt;h2 id="1-spark-简介">1. Spark 简介&lt;/h2>
&lt;p>Spark 是一种是基于内存计算的大数据并行计算框架，主要分为 Driver、Worker 两个组件，可通过 yarn，mesos、k8s 进行调度。其主要架构如下：&lt;/p>
&lt;!-- slide -->
&lt;hr>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/20-11-33-12-2022-01-20-11-33-00-image.png" alt="">&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>DriverNode：复制任务的提交及任务上下文相关的处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WorkerNode：复制任务的执行，每个 workerNode 可并行执行多个 executor，每个 executor&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- slide -->
&lt;h2 id="2-spark-计算模型">2. Spark 计算模型&lt;/h2>
&lt;p>Spark 将数据抽象为RDD(弹性数据集)，并根据数据的依赖关系将RDD计算过程划分为一个个stage，RDD随着计算在各个stage中随着计算，在计算过程中需要处理大量数据，其涉及的 IO 主要包括以下几个：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-53-31-2020-02-28-09-24-02-image.png?token=AARMIEVIQE4ND7JBHD4V6PC7B7AWU" alt="">&lt;/p>
&lt;!-- slide -->
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>输入&lt;/strong>：任务开始从外部数据源读取以构建输入 RDD，支持多种实现接口：hdfs, file, s3 等；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>输出&lt;/strong>：计算任务结束后的数据输出，写入到外部存储；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Shuffle&lt;/strong>：两个 stage 之间的数据操作，包括可分为 shuffle write，shuffle read 两个阶段；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Spill&lt;/strong>：Shuffle 过程中有些操作需要大量的内存，为避免 jvm 的 oom，需要将缓存数据临时存入磁盘中，这个过程称为 spill；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- slide -->
&lt;hr>
&lt;h2 id="3-spark-shuffle">3. Spark Shuffle&lt;/h2>
&lt;p>Spark 2 个 Stage间需要对所有中间数据进行重排，这个过程称为Shuffle。Shuffle 过程需要操作大量的数据，无法全部在内存中完成，因此数据需要进行存储到磁盘中。Shuffle过程分为Shuffle Write 和 Shuffle Read两个阶段。&lt;/p>
&lt;p>Shuffle Write将上一个 stage 的 输出数据写入磁盘中，并且把数据位置元信息上报到 driver 的中， Shuffle Read在下一个 stage 开始，根据数据位置元信息，拉取对应的数据作为该stage的输入。&lt;/p>
&lt;!-- slide -->
&lt;hr>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-53-39-2020-01-21-15-56-38-image.png?token=AARMIETM4ITB45WP3FYARUK7B7AXE" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="shuffle-write">Shuffle Write&lt;/h3>
&lt;p>shuffle write 由上一个 stage 的 ShuffleMapTask 执行，基本过程是将上一个 stage 的数据重新按下一个 stage 的 Reduce 任务重新分区，便于下一个 stage 处理。&lt;/p>
&lt;p>spark 中 shuffle write 有 3 种具体的实现，基本流程如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>shuffleMapTask 将数据(records)写入根据 key 做到内存缓冲区中（每个 partition 对应一个 bucket 缓存区），如果开启了 spill，则检查是否需要 spill。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若需要 spill，将集合中的数据根据 partitionId 和 key（若需要）分区和顺序溢写到一个临时的磁盘文件，并释放内存新建一个 map 放数据，每次溢写都是写一个新的临时文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写完后，需要将所有的临时文件进行合并(merge)，此时需要将所有的临时文件读取出来，并合并写入最终磁盘文件中，并根据索引文件记录分区映射关系；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后 executor 将文件地址封装到 MapStatus，通过 MapOutputTrackerWorker 发送给 Driver 的 MapOutputTrackerMaste；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 SortShuffleWriter 中，文件合并前，需要先使用 externalsort 对数据进行排序，此时可能会触发 spill 生成很多的临时小文件。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-54-17-2020-01-20-17-32-11-image.png?token=AARMIEVGAURFDEMH5HETJO27B7AZQ" alt="">&lt;/p>
&lt;hr>
&lt;p>shuffle write 默认有三种实现：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BypassMergeSortShuffleWriter：通过hash将map先按partition输出到不同的临时文件中，最后按分区合并到一个data文件中，并生成一个index文件记录每个分区在data文件中的位置；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SortShuffleWriter：先在内存中对数据进行排序(堆排，中间可能spill许多临时文件)，；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UnsafeShuffleWriter：SortShuffleWriter 的改进，使用序列化后的数组进行排序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="shuffle-read">Shuffle Read&lt;/h3>
&lt;p>shuffle read 是在下一个 stage 的开始之前的 ResultTask 中执行，主要作用是获取前一个 stage 各个节点的对应分区的数据数据，以供 reduce 处理。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-54-25-2020-01-20-17-51-58-image.png?token=AARMIEVM6VDNXU6TNFLBBCS7B7A2O" alt="">&lt;/p>
&lt;hr>
&lt;p>Shuffle Read 主要分为 fetch 和 aggreation 两个步骤：&lt;/p>
&lt;ul>
&lt;li>fetch&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>shuffle read 开始后，通过 BlockTransferService 从 Driver 获取 ShuffleMapTask 上报的 write mapOut 生成的文件，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据文件是否在同一个节点分别调用 getRemoteValues 和 getLocalValue 拉取对应分区的 FileSegment；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拉取的数据放着内存缓冲区中，根据&lt;code>spark.shuffle.spill&lt;/code>参数判断是否需要 spill 到磁盘。缓冲区大小由&lt;code>spark.reducer.maxMbInFlight&lt;/code>（默认：5MB）设置。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>aggregate&lt;/li>
&lt;/ul>
&lt;p>spark shuffle write 后的数据不一定是全局有序的，在合并时，使用 hashmap 来处理从 filesegment 反序列化后生成的 record。&lt;/p>
&lt;hr>
&lt;h2 id="4-spark-shuffle-改进">4. Spark Shuffle 改进&lt;/h2>
&lt;p>shuffle 作为连接 spark stage 中间的过程，涉及大量的数据操作，是整个计算过程的一大瓶颈，为此对 shuffle 问题及改进一直在进行。&lt;/p>
&lt;hr>
&lt;h3 id="41-external-shuffle-service">4.1 External Shuffle Service&lt;/h3>
&lt;p>Spark 支持单独的服务来处理读取请求。这个单独的服务叫做 ExternalShuffleService，运行在每台主机上，管理该主机的所有 Executor 节点生成的 shuffle 数据。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-54-40-2020-01-13-10-58-11-image.png?token=AARMIETC53OSQITSP5MZQMC7B7A3I" alt="">&lt;/p>
&lt;hr>
&lt;p>ESS 存在的问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>External Shuffle Service 存在失效问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与 executor 节点紧密部署，不利于隔离，尤其在容器环境；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>计算与存储未分离&lt;/strong>&lt;/p>
&lt;hr>
&lt;h3 id="42-spark-1529spark-1529-support-dfs-based-shuffle-in-addition-to-netty-shuffle---asf-jirahttpsissuesapacheorgjirabrowsespark-1529">4.2 [SPARK-1529](&lt;a href="https://issues.apache.org/jira/browse/SPARK-1529">[SPARK-1529] Support DFS based shuffle in addition to Netty shuffle - ASF JIRA&lt;/a>)&lt;/h3>
&lt;p>扩展了 shuffle 的文件系统接口，在 localFileSystem 上增加了 DistributedFileSystem，支持 HDFS 来存储 shuffle 数据，未实现，问题：spill 过程中可能产生很多小文件，hdfs 小文件写性能差（ ~15%）&lt;/p>
&lt;hr>
&lt;h3 id="43-httpsissuesapacheorgjirabrowsespark-25299">4.3 &lt;a href="https://issues.apache.org/jira/browse/SPARK-25299">https://issues.apache.org/jira/browse/SPARK-25299&lt;/a>&lt;/h3>
&lt;p>讨论了现有 external shuffle service 的不足，提出了几种使用远程存储的改进方案；&lt;/p>
&lt;p>在官方 Spark Issue 中提到了用分布式文件系统代替本地磁盘进行 shuffle 数据存取的提案。&lt;/p>
&lt;hr>
&lt;h3 id="44-splash">4.4 Splash&lt;/h3>
&lt;p>&lt;a href="https://github.com/MemVerge/splash">https://github.com/MemVerge/splash&lt;/a>&lt;/p>
&lt;p>支持不同存储插件的 shuffle 管理组件，支持 hdfs、nfs、s3 等多种存储接口。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-54-53-2020-01-21-15-07-54-image.png?token=AARMIEVMKYL3PHGHCIXHH2K7B7A4G" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="45-alluxio-for-shuffle">4.5 Alluxio for Shuffle&lt;/h3>
&lt;p>搜狗使用 alluxio 来存储 shuffle 数据实践&lt;a href="https://zhuanlan.zhihu.com/p/89384057"># 搜狗实战案例：基于 Alluxio 优化 Spark Shuffle 性能&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-55-04-2020-01-21-17-45-45-image.png?token=AARMIEXNAT27INOAH3WTI5C7B7A4Q" alt="">&lt;/p>
&lt;p>效果：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>ReduceTask 可以直接从 Alluxio 获取所需 shuffle 数据，无需重算，避免原生的 Spark 会报 shuffle fetch failure 从而导致出现重算错误；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>性能能够得到了比较大的提升；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="5-spark-shuffle-with-chubaofs">5. Spark Shuffle with ChubaoFS&lt;/h2>
&lt;p>chubaofs 作为分布式文件系统，同时支持顺序写、随机写，支持大文件批量写的同时对小文件进行有比较好的优化性能，为解决 spark shuffle 的问题提供了很好的选择&lt;/p>
&lt;hr>
&lt;h3 id="方案-1fuseclientcsi">方案 1：FuseClient/CSI&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-55-14-2020-01-22-11-05-43-image.png?token=AARMIEUZE4ONMAK2DDXUV3C7B7A5C" alt="">&lt;/p>
&lt;hr>
&lt;p>该方案主要使用 chubaofs 的 fuseclient 挂载 chubaofs 共享目录到 spark 的&lt;code>spark.local.dir&lt;/code>本地目录上，使用 chubaofs fuseclient 为 spark shuffle 提供分布式共享存储&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>可直接在现有 spark 平台使用，无开发量；&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>shuffle read 阶段，存在间接重复传输问题，占用网络带宽；&lt;/li>
&lt;li>fuse client / csi 部署&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="方案-2native-sdk-接口">方案 2：Native SDK 接口&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-55-22-2020-01-22-11-04-14-image.png?token=AARMIESIQRDFKLXFBIHUDW27B7A5S" alt="">&lt;/p>
&lt;hr>
&lt;p>该方案通过在 Spark 中集成 ChubaoFS native SDK 方式使用 ChubaoFS，Spark 的 driver，worker 通过 native sdk 获取数据。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>避免 shuffle read 数据重复传输；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持 shuffle 文件合并选项，优化性能；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>需要开发 chubao fs native sdk 接口；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要开发 spark chubaofs shuffle filestore 接口；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="方案-3splash--fuseclientnativesdk">方案 3：Splash + FuseClient/NativeSDK&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/07/16-10-55-31-2020-01-22-11-03-20-image.png?token=AARMIEURB5CK6QSVKGZEELC7B7A6C" alt="">&lt;/p>
&lt;hr>
&lt;p>该方案使用 splash 提供的共享存储目录接入 chubaofs，提供 spark shuffle 提供共享存储&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>splash 作为插件，和 spark 源码相对独立；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>fetch 不存在两次读问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开发工作量少；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>splash 没有经过验证，不够成熟；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="rss">RSS&lt;/h2>
&lt;p>remote shuffle service， 是 JD 大数据 spark 团队自研的 shuffle service，是针对 spark 官方 ESS 的不足做的一个改进，其改进有如下几点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将 ess 原来的每个 executor node 部署独立出来，成为单独的服务集群，并提供 shuffle write/shuffle read 功能（原 ess 主要提供 shuffle read）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优化 reduce 流程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现 executor 的存储计算分离，有利于容器化部署及资源调度；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>其后端存储初期使用本地文件系统，后期将使用分布式存储(alluxio,cfs 等)；&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/20-11-31-26-2022-01-20-11-31-18-image.png" alt="">&lt;/p>
&lt;hr>
&lt;p>优点：&lt;/p>
&lt;ol>
&lt;li>只需与 rss 适配，开发量少；&lt;/li>
&lt;/ol>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>依赖 rss；&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://xuechendi.github.io/2019/04/15/Spark-Shuffle-and-Spill-Explained">https://xuechendi.github.io/2019/04/15/Spark-Shuffle-and-Spill-Explained&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/u012369535/article/details/90757029">https://blog.csdn.net/u012369535/article/details/90757029&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/u012369535/article/details/90757029">https://blog.csdn.net/u012369535/article/details/90757029&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/55954840">https://zhuanlan.zhihu.com/p/55954840&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://chengfeng96.com/blog/2019/03/20/Spark-Shuffle%E8%B0%83%E7%A0%94%E7%AC%94%E8%AE%B0/">http://chengfeng96.com/blog/2019/03/20/Spark-Shuffle%E8%B0%83%E7%A0%94%E7%AC%94%E8%AE%B0/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.google.com/document/d/1uCkzGGVG17oGC6BJ75TpzLAZNorvrAU3FRd2X-rVHSM/edit#heading=h.f360gce84q8o">[SPARK-25299][DISCUSSION] Improving Spark Shuffle Reliability - Google 文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.waitingforcode.com/apache-spark/external-shuffle-service-apache-spark/read">https://www.waitingforcode.com/apache-spark/external-shuffle-service-apache-spark/read&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhmin.github.io/2019/08/05/spark-external-shuffle-service/">https://zhmin.github.io/2019/08/05/spark-external-shuffle-service/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/MapReduce">MapReduce - 维基百科，自由的百科全书&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://bbs.huaweicloud.com/blogs/118178">https://bbs.huaweicloud.com/blogs/118178&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://jerryshao.me/2014/01/04/spark-shuffle-detail-investigation/">http://jerryshao.me/2014/01/04/spark-shuffle-detail-investigation/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/w1992wishes/article/details/88750748">【Spark】Spark 存储原理&amp;ndash;读数据过程_w1992wishes 的博客-CSDN 博客&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://kmanong.top/kmn/qxw/form/article?id=12487&amp;amp;cate=93">http://kmanong.top/kmn/qxw/form/article?id=12487&amp;amp;cate=93&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/rkannan82/spark/commits/dfs_shuffle">https://github.com/rkannan82/spark/commits/dfs_shuffle&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://issues.apache.org/jira/browse/SPARK-1529">[SPARK-1529] Support DFS based shuffle in addition to Netty shuffle - ASF JIRA&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.google.com/document/d/1uCkzGGVG17oGC6BJ75TpzLAZNorvrAU3FRd2X-rVHSM/edit#">[SPARK-25299][DISCUSSION] Improving Spark Shuffle Reliability - Google 文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://lists.apache.org/thread.html/4e8734c0d76cd94ca70d70e7de2ea4ebef1852490dc9d319d70606c3@1461694815@%3Cdev.spark.apache.org%3E">Pony Mail!&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/89384057"># 搜狗实战案例：基于 Alluxio 优化 Spark Shuffle 性能&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/apache/spark/pull/22777">https://github.com/apache/spark/pull/22777&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/MemVerge/splash/">GitHub - MemVerge/splash: Splash, a flexible Spark shuffle manager that supports user-defined storage backends for shuffle data storage and exchange&lt;/a>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/apache/spark/pull/22005">[SPARK-16817][CORE][WIP] Use Alluxio to improve stability of shuffle by replication of shuffle data by Chopinxb · Pull Request #22005 · apache/spark · GitHub&lt;/a>: alluxio shuffle manager, Use Alluxio to improve stability of shuffle by replication of shuffle dataloyiit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git.jd.com/weixiuli/spark-shuffle-service/issues/1">https://git.jd.com/weixiuli/spark-shuffle-service/issues/1&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/b6ecl1k7BS8O/article/details/84949433">Apache Spark Shuffle I/O 在 Facebook 的优化_Hadoop技术博文-CSDN博客&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/ChouYarn/p/7169472.html">Spark源码阅读之存储体系&amp;ndash;存储体系概述与shuffle服务 - ChouYarn - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhangchenchen.github.io/2018/09/26/deep-in-spark-shuffle/">Inf&amp;ndash; 深入理解 Spark shuffle | Solar&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://toutiao.io/posts/eicdjo/preview">彻底搞懂 Spark 的 shuffle 过程（shuffle write） - 开发者头条&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://shiyanjun.cn/archives/1655.html">简单之美 | Spark Shuffle过程分析：Map阶段处理流程&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/don_chiang709/article/details/85340236">Spark Shuffle Read 阶段里的 fetch block 源码分析_大数据_don_chiang709的专栏-CSDN博客&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>SPARK-25299- 改进Spark Shuffle可靠性</title><link>https://justice.bj.cn/post/30.architech/spark/spark-25299/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/spark/spark-25299/</guid><description>&lt;h1 id="spark-25299-改进spark-shuffle可靠性">SPARK-25299: 改进Spark Shuffle可靠性&lt;/h1>
&lt;hr>
&lt;h2 id="背景动机">背景动机&lt;/h2>
&lt;p>在分布式计算中，&lt;em>shuffle&lt;/em>表示多个不同计算单元之间的数据交换。spark用shuffle来表示不同executor之间的数据重组，最常见于RDD的重新分区。合并和聚合类的RDD 需要通过shuffle来重建新分区，相同分区键值的数据集需要重新定位到同一个executor中。&lt;/p>
&lt;p>已经有很多工作来改善shuffle的性能和可靠性。Spark Shuffle一个重要的行为就是Spark shuffle时将读写大量的磁盘文件，同时维护一份这些文件在不同executor 节点上的记录。在Spark 1.2 中，开发者实现了external shuffle service。 该组件将shuffle 分区文件的 位置，文件块映射及偏移保存在一个文件中。这样，当executor失效时，shuffle service还能继续提供shuffle服务，而不像之前，如果executor失败，则需要重新计算。&lt;/p>
&lt;hr>
&lt;h2 id="external-shuffle-service存在的问题">External Shuffle Service存在的问题&lt;/h2>
&lt;p>当前external shuffle service通过远程shuffle服务来读取不同节点上的数据，而executor进程仍然将shuffle数据写入本地存储。这种架构存在一些不足，尤其在容器环境如K8s和Docker。下图&lt;/p>
&lt;p>当前实现存在以下问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>缺乏隔离机制&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>扩展问题&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="设计目标">设计目标&lt;/h2>
&lt;hr>
&lt;h2 id="方案讨论">方案讨论&lt;/h2>
&lt;h3 id="方案1通过shuffle-service-上传shuffle-数据">方案1：通过Shuffle Service 上传Shuffle 数据&lt;/h3>
&lt;p>shuffle service作为文件服务器接收shuffle 写入数据流。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-03-26-10-31-47-image.png" alt="">&lt;/p>
&lt;h4 id="优点">优点：&lt;/h4>
&lt;ul>
&lt;li>后端shuffle文件流程(indexing、caching等)对应用完全透明，应用层无需其他配置；&lt;/li>
&lt;/ul>
&lt;h4 id="缺点">缺点：&lt;/h4>
&lt;ul>
&lt;li>每次shuffle文件需要写3次：executor-&amp;gt; ess proxy, ess proxy -&amp;gt; shuffle service host, shuffle service host -&amp;gt; back storage&lt;/li>
&lt;/ul>
&lt;h3 id="方案2shuffle-service提供远程文件uri">方案2：shuffle service提供远程文件URI&lt;/h3>
&lt;p>executor使用远程文件系统代替本地文件系统存储这些shuffle文件，shuffle service充当数据库维护shuffle文件路径。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-03-26-10-31-25-image.png" alt="">&lt;/p>
&lt;h4 id="优点-1">优点&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>相比方案一，只有元数据需要跨多路存储；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>相比方案1更少的改动；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="缺点-1">缺点&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>spark 应用配置增加后端存储相关配置；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有应用能直接访问后端存储；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="方案3使用分布式存储">方案3：使用分布式存储&lt;/h3>
&lt;p>应用程序本身可以维护有关该应用程序的shuffle文件的所有信息，因此完全不需要外部shuffle服务。该实现大致如下：
应用程序本身会跟踪分区ID到文件位置+文件内偏移量之间的映射。
所有文件位置都在某个远程文件存储层中。
执行程序直接针对后端存储系统打开和关闭流以shuffle文件。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-03-26-10-30-59-image.png" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在此解决方案中，我们删除了外部随机播放服务，因此剩下的唯一组件是随机播放数据存储系统和Spark应用程序本身。 Spark应用程序可以隔离，而存储系统可以与访问其数据的计算作业分离。此解决方案解决了隔离方面描述的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于我们没有外部随机播放服务，因此该解决方案的可扩展性通常会落在Spark随机播放操作的可扩展性以及随机数据存储系统的可扩展性上。后者是一个众所周知的领域，有大量现有工作，而前者可能会有所改进，但需要单独努力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行程序可以自由关闭，并且写入的随机数据仍然可以通过持久后备存储使用。我们不再需要担心单独系统的正常运行时间。因此，该解决方案解决了围绕可靠性，停机时间和工作浪费而描述的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在容器中运行的Spark应用程序可以访问远程存储系统以进行随机读取和写入。该解决方案与容器化的运行时兼容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只要在分布式文件系统中的各个节点之间复制混洗块，该系统中就不应存在单个瓶颈。我们没有一个单一的组件可以一次加载所有索引文件-所有执行程序都将导出需要以分布式方式获取的元数据和数据。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="实现细节">实现细节：&lt;/h4>
&lt;h4 id="优点-2">优点&lt;/h4>
&lt;ul>
&lt;li>架构及实现简单，无须独立的shuffle service；&lt;/li>
&lt;/ul>
&lt;h4 id="缺点-2">缺点&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>清理数据是不可靠的。假设Spark应用程序收到kill -9信号。在这种情况下，Spark应用程序无法清理自己的随机播放文件。没有其他组件知道此类文件的存在和生命周期。因此，文件可能会无限期地保留在那里。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有效读取索引文件比较困难。以前，如果两个不同的执行者向shuffle服务请求相同的索引文件，则shuffle服务可以在两次调用之间缓存索引文件。但是，现在混洗元数据必须从后备存储中读取两次-每个执行者一次。索引文件的跨执行者缓存变得更加困难。&lt;/p>
&lt;ul>
&lt;li>支持本地缓存的分布式存储有所缓解。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="方案4备份数据至分布式文件系统">方案4：备份数据至分布式文件系统&lt;/h3>
&lt;p>相比方案3直接将数据写入远端存储，该方案先将数据写入到本地存储，后异步将数据上传至远端分布式存储系统中。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-03-26-10-27-34-image.png" alt="">&lt;/p>
&lt;h4 id="优点-3">优点&lt;/h4>
&lt;ul>
&lt;li>executor不崩溃时拥有更少的网络hops；&lt;/li>
&lt;/ul>
&lt;h4 id="缺点-3">缺点&lt;/h4>
&lt;ul>
&lt;li>
&lt;h3 id="方案5">方案5：&lt;/h3>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-03-26-10-33-34-image.png" alt="">&lt;/p>
&lt;h2 id="性能影响">性能影响&lt;/h2>
&lt;hr>
&lt;h2 id="参考">参考&lt;/h2></description></item><item><title>STL容器</title><link>https://justice.bj.cn/post/14.language/c++/stl/stl%E5%AE%B9%E5%99%A8/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/c++/stl/stl%E5%AE%B9%E5%99%A8/</guid><description>&lt;h1 id="stl容器">STL容器&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>容器库是类模板与算法的汇集，允许程序员简单地访问常见数据结构，例如队列、链表和栈。有三类容器——顺序容器、关联容器和无序关联容器——每种都被设计为支持不同组的操作。&lt;/p>
&lt;p>容器管理为其元素分配的存储空间，并提供直接或间接地通过迭代器（拥有类似指针属性的对象）访问它们的函数。&lt;/p>
&lt;p>大多数容器拥有至少几个常见的成员函数，并共享功能。特定应用的最佳容器不仅依赖于提供的功能，还依赖于对于不同工作量的效率。&lt;/p>
&lt;h3 id="顺序容器">顺序容器&lt;/h3>
&lt;p>顺序容器是实现能按顺序访问的数据结构。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>容器类型&lt;/th>
&lt;th>版本&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/array" title="cpp/container/array">array&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>静态的连续数组 (类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/vector" title="cpp/container/vector">vector&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;td>动态的连续数组(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/deque" title="cpp/container/deque">deque&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;td>双端队列(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/forward_list" title="cpp/container/forward list">forward_list&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>单链表(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/list" title="cpp/container/list">list&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;td>双链表(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="c1">// vector
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="c1">// C++11 初始化器列表语法：
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;the&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;frogurt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;is&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;also&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;cursed&amp;#34;&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words1: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// words2 == words1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">words1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">words1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words2: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words2&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// words3 == words1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">words1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words3: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words3&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// words4 为 {&amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;}
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Mo&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words4: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words4&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="关联容器">关联容器&lt;/h3>
&lt;p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>容器类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/set" title="cpp/container/set">set&lt;/a>&lt;/td>
&lt;td>唯一键的集合，按照键排序 (类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/map" title="cpp/container/map">map&lt;/a>&lt;/td>
&lt;td>键值对的集合，按照键排序，键是唯一的(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/multiset" title="cpp/container/multiset">multiset&lt;/a>&lt;/td>
&lt;td>键的集合，按照键排序(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/multimap" title="cpp/container/multimap">multimap&lt;/a>&lt;/td>
&lt;td>键值对的集合，按照键排序(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="无序关联容器">无序关联容器&lt;/h3>
&lt;p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>版本&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_set" title="cpp/container/unordered set">unordered_set&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>唯一键的集合，按照键生成散列 (类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_map" title="cpp/container/unordered map">unordered_map&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>键值对的集合，按照键生成散列，键是唯一的(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_multiset" title="cpp/container/unordered multiset">unordered_multiset&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>键的集合，按照键生成散列(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_multimap" title="cpp/container/unordered multimap">unordered_multimap&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>键值对的集合，按照键生成散列&lt;br>(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="容器适配器">容器适配器&lt;/h3>
&lt;p>容器适配器提供顺序容器的不同接口。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;a href="https://zh.cppreference.com/w/cpp/container/stack" title="cpp/container/stack">stack&lt;/a>&lt;/th>
&lt;th>适配一个容器以提供栈（LIFO 数据结构） &lt;br>(类模板)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/queue" title="cpp/container/queue">queue&lt;/a>&lt;/td>
&lt;td>适配一个容器以提供队列（FIFO 数据结构）&lt;br>(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/priority_queue" title="cpp/container/priority queue">priority_queue&lt;/a>&lt;/td>
&lt;td>适配一个容器以提供优先级队列&lt;br>(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="span">span&lt;/h3>
&lt;p>&lt;code>span&lt;/code> 是相接的对象序列上的非占有视图，某个其他对象占有序列的存储。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;a href="https://zh.cppreference.com/w/cpp/container/span" title="cpp/container/span">span&lt;/a>&lt;br>&lt;br>(C++20)&lt;/th>
&lt;th>对象的连续序列上的无所有权视图 &lt;br>(类模板)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h3 id="迭代器非法化">迭代器非法化&lt;/h3>
&lt;p>只读方法决不非法化迭代器或引用。修改容器内容的方法可能非法化迭代器和/或引用，总结于此表格。&lt;/p>
&lt;p>此处&lt;strong>插入&lt;/strong>指代任何添加一或多个元素到容器的方法，而&lt;strong>擦除&lt;/strong>指代任何从容器移除一或多个元素的方法。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>插入方法的例子是 &lt;a href="https://zh.cppreference.com/w/cpp/container/set/insert" title="cpp/container/set/insert">std::set::insert&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/map/emplace" title="cpp/container/map/emplace">std::map::emplace&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/vector/push_back" title="cpp/container/vector/push back">std::vector::push_back&lt;/a> 和 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque/push_front" title="cpp/container/deque/push front">std::deque::push_front&lt;/a> 。&lt;/p>
&lt;ul>
&lt;li>注意 &lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_map/operator_at" title="cpp/container/unordered map/operator at">std::unordered_map::operator[]&lt;/a> 也算，因为它可能插入元素到 map 中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>擦除方法的例子是 &lt;a href="https://zh.cppreference.com/w/cpp/container/set/erase" title="cpp/container/set/erase">std::set::erase&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back" title="cpp/container/vector/pop back">std::vector::pop_back&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque/pop_front" title="cpp/container/deque/pop front">std::deque::pop_front&lt;/a> 和 &lt;a href="https://zh.cppreference.com/w/cpp/container/map/clear" title="cpp/container/map/clear">std::map::clear&lt;/a> 。&lt;/p>
&lt;ul>
&lt;li>&lt;code>clear&lt;/code> 非法化所有迭代器和引用。因为它擦除所有元素，这在技术上遵照上述规则。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>尾后迭代器需要特别留意。通常像指向未被擦除元素的正常迭代器一般非法化此迭代器。故 &lt;a href="https://zh.cppreference.com/w/cpp/container/set/end" title="cpp/container/set/end">std::set::end&lt;/a> 决不被非法化， &lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_set/end" title="cpp/container/unordered set/end">std::unordered_set::end&lt;/a> 仅在重哈希时被非法化， &lt;a href="https://zh.cppreference.com/w/cpp/container/vector/end" title="cpp/container/vector/end">std::vector::end&lt;/a> 始终被非法化（因为它始终出现在被修改元素后），以此类推。&lt;/p>
&lt;ul>
&lt;li>例外：删除 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque" title="cpp/container/deque">std::deque&lt;/a> 末元素的擦除操作&lt;em>会&lt;/em>非法化尾后迭代器，尽管它不是容器的被擦除元素（或者说根本不是元素）。与 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque" title="cpp/container/deque">std::deque&lt;/a> 迭代器的通用规则结合后，最终结果是&lt;em>不&lt;/em>非法化 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque/end" title="cpp/container/deque/end">std::deque::end&lt;/a> 的唯一修改操作是删除首元素，而非末元素的擦除。&lt;/li>
&lt;/ul>
&lt;h3 id="线程安全">线程安全&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>能同时在不同容器上由不同线程调用所有容器函数。更广泛而言， C++ 标准库函数不读取能通过其他线程访问的对象，除非这些对象能直接或间接地经由函数参数，包含 this 指针访问;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能同时在同一容器上由不同线程调用 const 成员函数。而且，成员函数 &lt;code>begin()&lt;/code> 、 &lt;code>end()&lt;/code>, &lt;code>rbegin()&lt;/code> 、 &lt;code>rend()&lt;/code> 、 &lt;code>front()&lt;/code> 、 &lt;code>back()&lt;/code> 、 &lt;code>data()&lt;/code> 、 &lt;code>find()&lt;/code> 、 &lt;code>lower_bound()&lt;/code> 、 &lt;code>upper_bound()&lt;/code> 、 &lt;code>equal_range()&lt;/code> 、 &lt;code>at()&lt;/code> 和除了关联容器中的 &lt;code>operator[]&lt;/code> 对于线程安全的目标表现如同 const （即它们亦能同时在同一容器上由不同线程调用）。更广泛而言， C++ 标准库函数不修改对象，除非这些对象能直接或间接地经由函数参数，包含 this 指针访问。&lt;br>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同一容器中不同元素能由不同线程同时修改，除了 std::vector&lt;bool> 的元素（例如， &lt;a href="https://zh.cppreference.com/w/cpp/thread/future" title="cpp/thread/future">std::future&lt;/a> 对象的 vector 能从多个线程接收值）;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>迭代器操作（例如自增迭代器）读但不修改底层容器，而且能与同一容器上的其他迭代器操作同时由 const 成员函数执行。非法化任何迭代器的容器操作修改容器，且不能与任何在既存迭代器上的操作同时执行，即使这些迭代器未被非法化;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同一容器上的元素可以同时由不指定为访问这些元素的函数修改。更广泛而言， C++ 标准库函数不间接读取能从其参数访问的对象（包含容器的其他对象），除非其规定要求如此；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何情况下，容器操作（还有算法，或其他 C++ 标准库函数）可于内部并行化，只要不更改用户可见的结果（例如 &lt;a href="https://zh.cppreference.com/w/cpp/algorithm/transform" title="cpp/algorithm/transform">std::transform&lt;/a> 可并行化，但指定了按顺序观览序列的每个元素的 &lt;a href="https://zh.cppreference.com/w/cpp/algorithm/for_each" title="cpp/algorithm/for each">std::for_each&lt;/a> 不行） | (C++11 起)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="成员函数表格">成员函数表格&lt;/h3></description></item><item><title>STL简介</title><link>https://justice.bj.cn/post/14.language/c++/stl/stl%E7%AE%80%E4%BB%8B/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/c++/stl/stl%E7%AE%80%E4%BB%8B/</guid><description>&lt;h1 id="stl简介">STL简介&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>STL，Standard Template Library，是C++标准委员会推出的c++标准库。主要由6大组成部分：容器（containers）、算法（algorithms）、迭代器（iterators）、仿函数（functors）、配接器（adapters）、空间配置器（allocator）。&lt;/p>
&lt;h2 id="容器container">容器(container)&lt;/h2>
&lt;p>容器对常见数据结构的封装。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>容器&lt;/th>
&lt;th>类模板&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>(类模板)&lt;/th>
&lt;th>版本&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>顺序容器&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/array" title="cpp/container/array">array&lt;/a>&lt;/td>
&lt;td>静态数组&lt;/td>
&lt;td>(类模板)&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/vector" title="cpp/container/vector">vector&lt;/a>&lt;/td>
&lt;td>动态数组&lt;/td>
&lt;td>(类模板)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/deque" title="cpp/container/deque">deque&lt;/a>&lt;/td>
&lt;td>双端队列&lt;/td>
&lt;td>(类模板)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/forward_list" title="cpp/container/forward list">forward_list&lt;/a>&lt;/td>
&lt;td>单链表&lt;/td>
&lt;td>(类模板)&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/list" title="cpp/container/list">list&lt;/a>&lt;/td>
&lt;td>双链表&lt;/td>
&lt;td>(类模板)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>关联容器&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/set" title="cpp/container/set">set&lt;/a>&lt;/td>
&lt;td>集合&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/map" title="cpp/container/map">map&lt;/a>&lt;/td>
&lt;td>映射&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/multiset" title="cpp/container/multiset">multiset&lt;/a>&lt;/td>
&lt;td>复值集合&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/multimap" title="cpp/container/multimap">multimap&lt;/a>&lt;/td>
&lt;td>复键映射&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>无序关联容器&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_set" title="cpp/container/unordered set">unordered_set&lt;/a>&lt;/td>
&lt;td>无序集合(hash集合)&lt;/td>
&lt;td>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_map" title="cpp/container/unordered map">unordered_map&lt;/a>&lt;/td>
&lt;td>无序映射()&lt;/td>
&lt;td>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_multiset" title="cpp/container/unordered multiset">unordered_multiset&lt;/a>&lt;/td>
&lt;td>无序复值集合&lt;/td>
&lt;td>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_multimap" title="cpp/container/unordered multimap">unordered_multimap&lt;/a>&lt;/td>
&lt;td>无序哈希映射&lt;/td>
&lt;td>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="算法">算法&lt;/h2>
&lt;h2 id="迭代器">迭代器&lt;/h2></description></item><item><title>不同的二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;h1 id="不同的二叉搜索树httpsleetcode-cncomproblemsunique-binary-search-treesdescription-httpsleetcode-cncomproblemsunique-binary-search-treesdescription">&lt;a href="https://leetcode-cn.com/problems/unique-binary-search-trees/description/" title="https://leetcode-cn.com/problems/unique-binary-search-trees/description/">不同的二叉搜索树&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Medium (69.94%)&lt;/td>
&lt;td>1502&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/dynamic-programming" title="https://leetcode.com/tag/dynamic-programming">&lt;code>dynamic-programming&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree">&lt;code>tree&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>snapchat&lt;/code>&lt;/p>
&lt;p>给你一个整数 &lt;code>n&lt;/code> ，求恰由 &lt;code>n&lt;/code> 个节点组成且节点值从 &lt;code>1&lt;/code> 到 &lt;code>n&lt;/code> 互不相同的 &lt;strong>二叉搜索树&lt;/strong> 有多少种？返回满足题意的二叉搜索树的种数。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：n = 3
输出：5
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：n = 1
输出：1
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= n &amp;lt;= 19&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/unique-binary-search-trees/comments/" title="https://leetcode-cn.com/problems/unique-binary-search-trees/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/" title="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> ## 解题思路
&lt;/span>&lt;span class="cm"> * 动态规划
&lt;/span>&lt;span class="cm"> G(n): n个节点二叉排序树的个数
&lt;/span>&lt;span class="cm"> f(i): 为以i为根的二叉搜索树的个数，
&lt;/span>&lt;span class="cm"> 则
&lt;/span>&lt;span class="cm"> G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)
&lt;/span>&lt;span class="cm"> 当i为根节点时，其左子树节点个数为 i-1 个，右子树节点为 n-i，则
&lt;/span>&lt;span class="cm"> f(i) = G(i-1) * G(n-i)
&lt;/span>&lt;span class="cm"> 综合得到 卡特兰数 公式
&lt;/span>&lt;span class="cm"> G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)
&lt;/span>&lt;span class="cm">
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">numTrees&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>专题1：二叉树相关</title><link>https://justice.bj.cn/post/leetcode/doc/%E4%B8%93%E9%A2%981%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/%E4%B8%93%E9%A2%981%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/</guid><description>&lt;h1 id="专题1二叉树相关">专题1：二叉树相关&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>二叉树是一个递归的结构&lt;/p>
&lt;h2 id="相关题目">相关题目&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="../94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">94.二叉树的中序遍历&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>后序遍历&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="../100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91">100.相同的树&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="../101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">101.对称二叉树&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="../102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">102.二叉树的层序遍历&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>路径和&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="../543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">543.二叉树的直径&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="../617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91">617.合并二叉树&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>对称二叉树</title><link>https://justice.bj.cn/post/leetcode/doc/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>&lt;h1 id="对称二叉树httpsleetcode-cncomproblemssymmetric-treedescription-httpsleetcode-cncomproblemssymmetric-treedescription">&lt;a href="https://leetcode-cn.com/problems/symmetric-tree/description/" title="https://leetcode-cn.com/problems/symmetric-tree/description/">对称二叉树&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Easy (56.66%)&lt;/td>
&lt;td>1665&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree">&lt;code>tree&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search">&lt;code>depth-first-search&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/breadth-first-search" title="https://leetcode.com/tag/breadth-first-search">&lt;code>breadth-first-search&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>bloomberg&lt;/code> | &lt;code>linkedin&lt;/code> | &lt;code>microsoft&lt;/code>&lt;/p>
&lt;p>给定一个二叉树，检查它是否是镜像对称的。&lt;/p>
&lt;p>例如，二叉树 &lt;code>[1,2,2,3,4,4,3]&lt;/code> 是对称的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> 1
/ \
2 2
/ \ / \
3 4 4 3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是下面这个 &lt;code>[1,2,2,null,3,null,3]&lt;/code> 则不是镜像对称的:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> 1
/ \
2 2
\ \
3 3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>进阶：&lt;/strong>&lt;/p>
&lt;p>你可以运用递归和迭代两种方法解决这个问题吗？&lt;/p>
&lt;hr>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/symmetric-tree/comments/" title="https://leetcode-cn.com/problems/symmetric-tree/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode-cn.com/problems/symmetric-tree/solution/" title="https://leetcode-cn.com/problems/symmetric-tree/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> ## 解题思路
&lt;/span>&lt;span class="cm"> * * 解法一：递归法
&lt;/span>&lt;span class="cm"> * * 转化为镜像树问题；
&lt;/span>&lt;span class="cm"> * * 镜像子树：根节点相等 且 相互的左子树，右子树互为镜像子树；
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">bool&lt;/span> &lt;span class="n">isSymmetric&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">isMirrorByRec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//return isMirrorByIter(root, root);
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// check p,q is mirror
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">isMirrorByRec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span>
&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isMirrorByRec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isMirrorByRec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">)&lt;/span> &lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> ## 解法二：迭代法
&lt;/span>&lt;span class="cm"> * 使用一个队列层历该树；
&lt;/span>&lt;span class="cm"> * 初始将root入队两次；
&lt;/span>&lt;span class="cm"> * 然后每次队列出队时，
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">bool&lt;/span> &lt;span class="nf">isMirrorByIter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">q&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>最小覆盖子串</title><link>https://justice.bj.cn/post/leetcode/doc/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</guid><description>&lt;h1 id="最小覆盖子串httpsleetcode-cncomproblemsminimum-window-substringdescription-httpsleetcode-cncomproblemsminimum-window-substringdescription">&lt;a href="https://leetcode-cn.com/problems/minimum-window-substring/description/" title="https://leetcode-cn.com/problems/minimum-window-substring/description/">最小覆盖子串&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Hard (43.18%)&lt;/td>
&lt;td>1565&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/hash-table" title="https://leetcode.com/tag/hash-table">&lt;code>hash-table&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/two-pointers" title="https://leetcode.com/tag/two-pointers">&lt;code>two-pointers&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/string" title="https://leetcode.com/tag/string">&lt;code>string&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/sliding-window" title="https://leetcode.com/tag/sliding-window">&lt;code>sliding-window&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>facebook&lt;/code> | &lt;code>linkedin&lt;/code> | &lt;code>snapchat&lt;/code> | &lt;code>uber&lt;/code>&lt;/p>
&lt;p>给你一个字符串 &lt;code>s&lt;/code> 、一个字符串 &lt;code>t&lt;/code> 。返回 &lt;code>s&lt;/code> 中涵盖 &lt;code>t&lt;/code> 所有字符的最小子串。如果 &lt;code>s&lt;/code> 中不存在涵盖 &lt;code>t&lt;/code> 所有字符的子串，则返回空字符串 &lt;code>&amp;quot;&amp;quot;&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>注意：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对于 &lt;code>t&lt;/code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 &lt;code>t&lt;/code> 中该字符数量。&lt;/li>
&lt;li>如果 &lt;code>s&lt;/code> 中存在这样的子串，我们保证它是唯一的答案。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;ADOBECODEBANC&amp;#34;, t = &amp;#34;ABC&amp;#34;
输出：&amp;#34;BANC&amp;#34;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;a&amp;#34;, t = &amp;#34;a&amp;#34;
输出：&amp;#34;a&amp;#34;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入: s = &amp;#34;a&amp;#34;, t = &amp;#34;aa&amp;#34;
输出: &amp;#34;&amp;#34;
解释: t 中两个字符 &amp;#39;a&amp;#39; 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= s.length, t.length &amp;lt;= 105&lt;/code>&lt;/li>
&lt;li>&lt;code>s&lt;/code> 和 &lt;code>t&lt;/code> 由英文字母组成&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>进阶&lt;/strong>：你能设计一个在 &lt;code>o(n)&lt;/code> 时间内解决此问题的算法吗？&lt;/p>
&lt;hr>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/minimum-window-substring/comments/" title="https://leetcode-cn.com/problems/minimum-window-substring/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/" title="https://leetcode-cn.com/problems/minimum-window-substring/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;h3 id="滑动窗口">滑动窗口&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>右指针r: 当窗口未完整包含目标字符串t时，r右移，增大窗口范围；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>左指针l: 当窗口已经完整包含目标字符串t时，l右移，减小窗口范围，获取包含目标字符串最小长度；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * ## 解题思路
&lt;/span>&lt;span class="cm"> * * 滑动窗口
&lt;/span>&lt;span class="cm"> * * 右指针r: 如果当前窗口没有完整包含t，则r右移，扩大窗口范围，直到窗口完整包含t；
&lt;/span>&lt;span class="cm"> * * 左指针l: 如果当前已经完整包含t，则l右移，减小窗口范围，直到窗口为完整包含t的最小窗口；
&lt;/span>&lt;span class="cm"> * *
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">minWindow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">string&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">unordered_map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">s_map&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//当前窗口内字符数统计
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">unordered_map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">t_map&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//目标字符数统计
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">valid_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//当前窗口内的有效字符数
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 初始化目标hash数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="nl">c&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">t_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">s_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">]]&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//当前窗口内字符数+1；
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//当前字符统计数未超过目标字符统计数是，
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">]]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">t_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">]])&lt;/span> &lt;span class="n">valid_count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 当前窗口内左字符有效字符数&amp;gt;目标字符数，滑动左指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">]]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">t_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">]])&lt;/span> &lt;span class="n">s_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]]&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 刚好
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">valid_count&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">res&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">res&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">substr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>相同的树</title><link>https://justice.bj.cn/post/leetcode/doc/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid><description>&lt;h1 id="相同的树httpsleetcode-cncomproblemssame-treedescription-httpsleetcode-cncomproblemssame-treedescription">&lt;a href="https://leetcode-cn.com/problems/same-tree/description/" title="https://leetcode-cn.com/problems/same-tree/description/">相同的树&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Easy (59.91%)&lt;/td>
&lt;td>753&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree">&lt;code>tree&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search">&lt;code>depth-first-search&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>bloomberg&lt;/code>&lt;/p>
&lt;p>给你两棵二叉树的根节点 &lt;code>p&lt;/code> 和 &lt;code>q&lt;/code> ，编写一个函数来检验这两棵树是否相同。&lt;/p>
&lt;p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：p = [1,2,3], q = [1,2,3]
输出：true
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：p = [1,2], q = [1,null,2]
输出：false
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：p = [1,2,1], q = [1,1,2]
输出：false
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>两棵树上的节点数目都在范围 &lt;code>[0, 100]&lt;/code> 内&lt;/li>
&lt;li>&lt;code>-104 &amp;lt;= Node.val &amp;lt;= 104&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/same-tree/comments/" title="https://leetcode-cn.com/problems/same-tree/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode-cn.com/problems/same-tree/solution/" title="https://leetcode-cn.com/problems/same-tree/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> ## 解题思路
&lt;/span>&lt;span class="cm"> * 解法一：递归法
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">bool&lt;/span> &lt;span class="n">isSameTree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span>
&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isSameTree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isSameTree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>ElasticSearch基础</title><link>https://justice.bj.cn/post/30.architech/elasticsearch/es%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/elasticsearch/es%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="elasticsearch基础">ElasticSearch基础&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Elasticsearch 是一个基于lucene的分布式可扩展的近实时搜索和分析引擎。&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/07-14-03-48-2022-01-07-14-03-43-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>一个 ES Index 在集群模式下，有多个 Node （节点）组成。每个节点就是 ES 的Instance (实例)。&lt;/li>
&lt;li>每个节点上会有多个 shard （分片）， P1 P2 是主分片, R1 R2 是副本分片&lt;/li>
&lt;li>每个分片上对应着就是一个 Lucene Index（底层索引文件）&lt;/li>
&lt;li>Lucene Index 是一个统称
&lt;ul>
&lt;li>由多个 Segment （段文件，就是倒排索引）组成。每个段文件存储着就是 Doc 文档。&lt;/li>
&lt;li>commit point记录了所有 segments 的信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Lucene索引结构&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/09-17-11-59-2022-01-09-17-11-56-image.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/09-17-11-19-2022-01-09-17-11-13-image.png" alt="">&lt;/p>
&lt;h3 id="lucene索引处理流程">Lucene索引处理流程&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/09-17-09-44-2022-01-09-17-09-40-image.png" alt="">&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>分布式存储&lt;/li>
&lt;li>近实时检索&lt;/li>
&lt;/ul>
&lt;h2 id="核心概念">核心概念&lt;/h2>
&lt;ul>
&lt;li>索引(index):&lt;/li>
&lt;li>分片(shard):&lt;/li>
&lt;li>分段(segment):&lt;/li>
&lt;li>Translog:&lt;/li>
&lt;/ul>
&lt;h2 id="数据类型">数据类型&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Elasticsearch中每个field都要精确对应一个数据类型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类型包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>keyword：不需要分词，进行过滤、排序、聚合等操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>text：分词，用于全文搜索，无法排序，聚合等操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>integer：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="写流程">写流程&lt;/h3>
&lt;p>创建索引的过程：&lt;/p>
&lt;ul>
&lt;li>准备待索引的原文档，数据来源可能是文件、数据库或网络&lt;/li>
&lt;li>对文档的内容进行分词组件处理，形成一系列的Term&lt;/li>
&lt;li>索引组件对文档和Term处理，形成字典和倒排表&lt;/li>
&lt;/ul>
&lt;p>搜索索引的过程：&lt;/p>
&lt;ul>
&lt;li>对查询语句进行分词处理，形成一系列Term&lt;/li>
&lt;li>根据倒排索引表查找出包含Term的文档，并进行合并形成符合结果的文档集&lt;/li>
&lt;li>比对查询语句与各个文档相关性得分，并按照得分高低返回&lt;/li>
&lt;/ul>
&lt;h2 id="单文档写入流程">单文档写入流程&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/09-17-17-45-2022-01-09-17-17-40-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>客户端向 Node 1 发送新建、索引或者删除请求。&lt;/li>
&lt;li>节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。&lt;/li>
&lt;li>Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。&lt;/li>
&lt;/ul>
&lt;h2 id="常用操作">常用操作&lt;/h2>
&lt;ul>
&lt;li>清空index数据&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># create index&lt;/span>
curl -X PUT http://192.168.0.10:20000/test6 --header &lt;span class="s2">&amp;#34;Content-Type: application/json&amp;#34;&lt;/span> -d index.json
cat index.json
&lt;span class="c1"># delete index&lt;/span>
curl -X DELETE http://192.168.0.10:20000/test6
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="tfidf">TF/IDF&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>TF(Term Frequency, 词频): 词(Term)在文档中出现的频率；&lt;/p>
&lt;p>$ tf(t\in d) = \sqrt{frequency} $&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IDF(Invert Doc Frequency, 逆向文档频率): 索引中文档数量除以所有包含该词的文档数&lt;/p>
&lt;p>$ idf(t) = 1 + log ( numDocs / (docFreq + 1)) $&lt;/p>
&lt;/li>
&lt;li>
&lt;p>norm(字段长度归一值): 字段中词数平方根的倒数,&lt;/p>
&lt;p>$ norm(d) = 1 / \sqrt{numTerms} $&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://pdai.tech/md/db/nosql-es/elasticsearch-y-th-2.html">ES详解 - 原理：ES原理知识点补充和整体结构 | Java 全栈知识体系&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item></channel></rss>