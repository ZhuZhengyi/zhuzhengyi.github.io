<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 24 Apr 2024 12:53:56 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Stable Diffusion</title><link>https://justice.bj.cn/post/50.ml/stable_diffusion/</link><pubDate>Wed, 24 Apr 2024 12:53:56 +0800</pubDate><guid>https://justice.bj.cn/post/50.ml/stable_diffusion/</guid><description>&lt;h1 id="stable-diffusion">Stable Diffusion&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>Stable diffusion是一个基于Latent Diffusion Models（LDMs）实现的的文图生成（text-to-image）模型;&lt;/li>
&lt;li>能够创造出既逼真又具有艺术风格的图像;&lt;/li>
&lt;/ul>
&lt;h2 id="功能">功能&lt;/h2>
&lt;ul>
&lt;li>文本生成图片(text2img): 输入文本描述, 输出图片;&lt;/li>
&lt;li>图片生成图片(img2img): 输入图片+文本, 输出图片;&lt;/li>
&lt;li>图片融合: 两张不同图片生成一张新的图片;&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>text-to-image包含3个步骤:&lt;/p>
&lt;ol>
&lt;li>文本编码器(Text Encoder)将提示词(Prompt) 编码成一个77 x 768 维度的特征词向量;&lt;/li>
&lt;li>图片信息生成器(Image Information Creator)将特征词向量和一张随机图一起转化到一个 Latent Space（潜空间）里，然后根据这些特征向量，将随机图「降噪」为一个「中间产物」;&lt;/li>
&lt;li>图片解码器(Image Decoder)将生成的中间产物解码成真正的图片;&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/20240421152317.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/20240422073809.png" alt="SD原理">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://sspai.com/post/85704#!">深入浅出理解 AI 生图模型 Stable Diffusion&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/640545463">一文读懂Stable Diffusion 论文原理+代码超详细解读&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cvmart.net/community/detail/8041">stable diffusion原理解读&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Linux IO 之 文件系统的架构(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84/</guid><description>&lt;h1 id="linux-io-之-文件系统的架构转">Linux IO 之 文件系统的架构(转)&lt;/h1>
&lt;h3 id="vfs和文件系统总结">VFS和文件系统总结&lt;/h3>
&lt;p>一切都是文件： VFS&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/42fc84d8385cd6f0bf3c2573f2e58eea_1702x1054.png" alt="">&lt;/p>
&lt;p>文件系统的设计，类似抽象基类，面向对象的思想。&lt;/p>
&lt;p>虚函数都必须由底层派生出的实例实现，使用成员函数 file_operations。在linux里面的文件操作，底层都要实现file_operations，抽象出owner，write，open，release。所以，无论是字符块，还是文件系统的文件，最终操作就必须是file_operations。&lt;/p>
&lt;p>例如，实现一个字符设备驱动，就是去实现file_operations。VFS_read时就会调用字符设备的file_operations。&lt;/p>
&lt;hr>
&lt;p>块设备的两种访问方法:&lt;/p>
&lt;p>一是访问裸分区，&lt;/p>
&lt;p>二是访问文件系统。&lt;/p>
&lt;p>当直接访问裸分区，是通过fs/block_dev.c 中的 file_operations def_blk_fops，也有read,write,open，一切继承到file_operations。如果是访问文件系统，就会通过实现 {ext4}_file_operations 来对接VFS对文件的操作。&lt;/p>
&lt;p>块设备驱动就不需要知道file_operations，无论是裸设备，还是文件系统的file。他们实现的file_operations是把linux中的各种设备，hook进 VFS的方法。&lt;/p>
&lt;h3 id="文件最终如何转化成对磁盘的访问">文件最终如何转化成对磁盘的访问？&lt;/h3>
&lt;p>file_operation 跟pagecache 以及硬盘的关系？&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/1072c5381bd5ae4a96ebd0ec110a1a25_1686x1186.png" alt="">&lt;/p>
&lt;p>整个文件系统里，除了放文件本身的数据，还包括文件的管理数据，包括&lt;/p>
&lt;ul>
&lt;li>super block，保存在全局的 superblock结构中。&lt;/li>
&lt;li>inode，是文件的唯一特定标识，文件系统使用bitmap来标识，inode是否使用。&lt;/li>
&lt;li>block bitmap，来表示这些block是否占用，它在改变文件大小，创建删除等操作时，都会改变。&lt;/li>
&lt;li>inode table/diagram ： bitmap 只是表示inode和block是否被占用。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://box.kancloud.cn/f00f3c82d9785e742b49db1975721a00_1666x1202.png" alt="">&lt;/p>
&lt;h3 id="超级块目录inode">超级块、目录、inode&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>file_system_type： 文件系统的类型，mount/umount 的时候会用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>superblock：包含super_operations，其中包含如何分配/销毁一个inode。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>inode：包含 inode_operations 和 file_operations。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> file_operations里面记录这种类型的文件包含哪些操作。
inode_operations里面包含如何生成新的inode，根据文件名字找到inode，如何mkdir,unlink.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>dentry: 对应路径，目录在文件系统里面是一个特殊的文件，文件的内容是一个inode和文件的表格。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>file:&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://box.kancloud.cn/8d9afa6c6797f98151f5f2ef9835d096_796x509.png" alt="">&lt;/p>
&lt;ul>
&lt;li>inode表：包含文件的一些基本信息，大小，创建日期，属性。还有一些成员指向硬盘所在的位置。
申请slab区域，比如 ext4_inode_cache , ext3_inode_cache. 这些cache会创建单独的slab，这些slab和内存里的page一一对应。&lt;/li>
&lt;/ul>
&lt;p>ext2/ext4文件系统中存在间接映射表。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/aedf91b68e0ddc9140f5cca3a57f162b_1574x1116.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/d2504c197b79aecf377855f29a810ba1_1498x1112.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/8116806badcf819ebf297c067976978c_1596x1094.png" alt="">&lt;/p>
&lt;p>硬盘里的inode diagram里的数据结构，在内存中会通过slab分配器，组织成 xxx_inode_cache，出现在meminfo的可回收的内存。 inode表也会记录每一个inode 在硬盘中摆放的位置。&lt;/p>
&lt;h3 id="目录的组织">目录的组织&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/43f11c7e2cc0fcc45e7891c932f82895_1464x1074.png" alt="">&lt;/p>
&lt;p>目录(dentry)在硬盘里是一个特殊的文件，和之前的file结构体不同。目录在硬盘中对应一个inode，记录文件的名字和inode号。查找一个文件时，文件系统的 根inode和目录，根据根目录和根inode，找到根目录所在硬盘的位置。再去做字符串匹配，能够找到 /A/B/ 。inode表也会记录每一个inode 在硬盘中摆放的位置。&lt;/p>
&lt;h3 id="发现并读取usrbinxxx的全流程">发现并读取/usr/bin/xxx的全流程&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/44f2fbe905a636b07986d3b69f795351_1680x1066.png" alt="">&lt;/p>
&lt;p>如上图，当你在硬盘查找 /usr/bin/emacs文件时，从根的inode和dentry，根据/的inode表，找到/ 目录文件所在的硬盘中的位置，读硬盘/目录文件的内容，发现 usr 对应inode 2, bin 对应inode 3, share 对应inode4。再去查inode表，inode 2所在硬盘的位置，即/usr 目录文件所在硬盘的位置。读出内容包括 var 对应 inode 10, bin 对应inode 11, opt对应inode 12，。&lt;/p>
&lt;p>这个过程会查找很多inode和 dentry，这些都会通过 icache 和dcache缓存。&lt;/p>
&lt;h2 id="符号链接-与-硬链接">符号链接 与 硬链接&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/b52f2fdfec772ded1282a69aa9e56b53_1216x794.png" alt="">&lt;/p>
&lt;p>文件名是特殊目录文件的内容，比如 A目录下有b\c\d，其实就是 A这个目录文件，里面对应目录b,c,d和对应inode的表。&lt;/p>
&lt;p>硬链接：在硬盘中是同一个inode存在，在目录文件中多了一个目录和inode对应。&lt;/p>
&lt;p>符号链接：是linux中是真实存在的实体文件，文件内容指向 其他文件。符号链接和文件是不同的inode。&lt;/p>
&lt;ol>
&lt;li>硬链接不能跨本地文件系统&lt;/li>
&lt;li>硬链接不能针对目录&lt;/li>
&lt;li>针对目录的软链接，用rm -fr 删除不了目录里的内容&lt;/li>
&lt;li>针对目录的软链接，&amp;ldquo;cd ..&amp;ldquo;进的是软链接所在目录的上级目录&lt;/li>
&lt;li>可以对文件执行unlink或rm，但是不能对目录执行unlink&lt;/li>
&lt;/ol>
&lt;h2 id="文件系统中的icache-和-dcache">文件系统中的icache 和 dcache&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/4200715ec3487a8ffb56d2281824275b_1204x806.png" alt="">&lt;/p>
&lt;p>文件系统在实现时，在vfs这一层的 inode cache 和 dentry cache，不管硬盘的系统，跨所有文件系统的通用信息。&lt;/p>
&lt;p>针对这些cache，这些可以回收的slab，linux提供了专门的slab shrink- 收缩函数。
最后所有可回收的内存，都必须通过&lt;code>LRU算法&lt;/code>去回收。
有些自己申请的 reclaim的内存，由于没有写 shrink函数，所以就无法进行内存的回收。&lt;/p>
&lt;h2 id="文件读写如何通过file_operation-和pagecache的关系">文件读写如何通过file_operation 和pagecache的关系，&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/71ce1fb31cdeed119f972c8b1771972c_1524x1100.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/6ed93b05cf6600220d744a0dcae115f9_1126x724.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/bdbb3ff0a3278c93493379a0f6076fc8_1202x730.png" alt="">&lt;/p>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Linux文件系统基础知识(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="linux文件系统基础知识转">Linux文件系统基础知识(转)&lt;/h1>
&lt;h3 id="文件系统的基本组成">文件系统的基本组成&lt;/h3>
&lt;p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。&lt;/p>
&lt;p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。&lt;/p>
&lt;p>Linux 最经典的一句话是：「&lt;strong>一切皆文件&lt;/strong>」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。&lt;/p>
&lt;p>Linux 文件系统会为每个文件分配两个数据结构：&lt;strong>索引节点（&lt;em>index node&lt;/em>）和目录项（&lt;em>directory entry&lt;/em>）&lt;/strong>，它们主要用来记录文件的元信息和目录层次结构。&lt;/p>
&lt;ul>
&lt;li>索引节点，也就是 &lt;em>inode&lt;/em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、&lt;strong>数据在磁盘的位置&lt;/strong>等等。索引节点是文件的&lt;strong>唯一&lt;/strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以&lt;strong>索引节点同样占用磁盘空间&lt;/strong>。&lt;/li>
&lt;li>目录项，也就是 &lt;em>dentry&lt;/em>，用来记录文件的名字、&lt;strong>索引节点指针&lt;/strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，&lt;strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。&lt;/p>
&lt;p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。&lt;/p>
&lt;blockquote>
&lt;p>目录项和目录是一个东西吗？&lt;/p>
&lt;/blockquote>
&lt;p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。&lt;/p>
&lt;p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。&lt;/p>
&lt;p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。&lt;/p>
&lt;blockquote>
&lt;p>那文件数据是如何存储在磁盘的呢？&lt;/p>
&lt;/blockquote>
&lt;p>磁盘读写的最小单位是&lt;strong>扇区&lt;/strong>，扇区的大小只有 &lt;code>512B&lt;/code> 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。&lt;/p>
&lt;p>所以，文件系统把多个扇区组成了一个&lt;strong>逻辑块&lt;/strong>，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 &lt;code>4KB&lt;/code>，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。&lt;/p>
&lt;p>以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-9d77e25913894df26b0374ceae25c605_1440w.jpg" alt="">&lt;/p>
&lt;p>索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。&lt;/p>
&lt;p>另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。&lt;/p>
&lt;p>- &lt;em>超级块&lt;/em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。&lt;/p>
&lt;p>- &lt;em>索引节点区&lt;/em>，用来存储索引节点； - &lt;em>数据块区&lt;/em>，用来存储文件或目录数据；&lt;/p>
&lt;p>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：&lt;/p>
&lt;ul>
&lt;li>超级块：当文件系统挂载时进入内存；&lt;/li>
&lt;li>索引节点区：当文件被访问时进入内存；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="虚拟文件系统">虚拟文件系统&lt;/h3>
&lt;p>文件系统的种类众多，而操作系统希望&lt;strong>对用户提供一个统一的接口&lt;/strong>，于是在用户层与文件系统层引入了中间层，这个中间层就称为&lt;strong>虚拟文件系统（&lt;em>Virtual File System，VFS&lt;/em>）。&lt;/strong>&lt;/p>
&lt;p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。&lt;/p>
&lt;p>在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-b92499b17ed11bc279689ecdb6efb4b6_1440w.jpg" alt="">&lt;/p>
&lt;p>Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：&lt;/p>
&lt;ul>
&lt;li>&lt;em>磁盘文件系统&lt;/em>，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。&lt;/li>
&lt;li>&lt;em>内存文件系统&lt;/em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 &lt;code>/proc&lt;/code> 和 &lt;code>/sys&lt;/code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。&lt;/li>
&lt;li>&lt;em>网络文件系统&lt;/em>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。&lt;/li>
&lt;/ul>
&lt;p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。&lt;/p>
&lt;hr>
&lt;h3 id="文件的使用">文件的使用&lt;/h3>
&lt;p>我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-bb6dc369fbf16afbdb088c6c7c26d9cc_1440w.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">打开文件&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,...);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">写数据&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">关闭文件&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面简单的代码是读取一个文件的过程：&lt;/p>
&lt;ul>
&lt;li>首先用 &lt;code>open&lt;/code> 系统调用打开文件，&lt;code>open&lt;/code> 的参数中包含文件的路径名和文件名。&lt;/li>
&lt;li>使用 &lt;code>write&lt;/code> 写数据，其中 &lt;code>write&lt;/code> 使用 &lt;code>open&lt;/code> 所返回的&lt;strong>文件描述符&lt;/strong>，并不使用文件名作为参数。&lt;/li>
&lt;li>使用完文件后，要用 &lt;code>close&lt;/code> 系统调用关闭文件，避免资源的泄露。&lt;/li>
&lt;/ul>
&lt;p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong>文件描述符&lt;/strong>」，所以说文件描述符是打开文件的标识。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-4d1f24d7102933f32a560a1cbdfce6da_1440w.jpg" alt="">&lt;/p>
&lt;p>操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p>
&lt;ul>
&lt;li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的； -&lt;/li>
&lt;li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目； -&lt;/li>
&lt;li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取； -&lt;/li>
&lt;li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/li>
&lt;/ul>
&lt;p>在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。&lt;/p>
&lt;p>所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。&lt;/p>
&lt;p>我们来分别看一下，读文件和写文件的过程：&lt;/p>
&lt;ul>
&lt;li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。&lt;/li>
&lt;li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。&lt;/li>
&lt;/ul>
&lt;p>所以说，&lt;strong>文件系统的基本操作单位是数据块&lt;/strong>。&lt;/p>
&lt;hr>
&lt;h3 id="文件的存储">文件的存储&lt;/h3>
&lt;p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p>
&lt;ul>
&lt;li>连续空间存放方式&lt;/li>
&lt;li>非连续空间存放方式&lt;/li>
&lt;/ul>
&lt;p>其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。&lt;/p>
&lt;p>不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。&lt;/p>
&lt;h3 id="连续空间存放方式">连续空间存放方式&lt;/h3>
&lt;p>连续空间存放方式顾名思义，&lt;strong>文件存放在磁盘「连续的」物理空间中&lt;/strong>。这种模式下，文件的数据都是紧密相连，&lt;strong>读写效率很高&lt;/strong>，因为一次磁盘寻道就可以读出整个文件。&lt;/p>
&lt;p>使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p>
&lt;p>所以，&lt;strong>文件头里需要指定「起始块的位置」和「长度」&lt;/strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p>
&lt;p>注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-7fc9cbf9c253d0ee84af8f61c605d50f_1440w.jpg" alt="">&lt;/p>
&lt;p>连续空间存放的方式虽然读写效率高，&lt;strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong>&lt;/p>
&lt;p>如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-5e0b69486a4e42554941c93a44d538e0_1440w.jpg" alt="">&lt;/p>
&lt;p>另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。&lt;/p>
&lt;p>那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。&lt;/p>
&lt;h3 id="非连续空间存放方式">非连续空间存放方式&lt;/h3>
&lt;p>非连续空间存放方式分为「链表方式」和「索引方式」。&lt;/p>
&lt;blockquote>
&lt;p>我们先来看看链表的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式存放是&lt;strong>离散的，不用连续的&lt;/strong>，于是就可以&lt;strong>消除磁盘碎片&lt;/strong>，可大大提高磁盘空间的利用率，同时&lt;strong>文件的长度可以动态扩展&lt;/strong>。根据实现的方式的不同，链表可分为「&lt;strong>隐式链表&lt;/strong>」和「&lt;strong>显式链接&lt;/strong>」两种形式。&lt;/p>
&lt;p>文件要以「&lt;strong>隐式链表&lt;/strong>」的方式存放的话，&lt;strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong>，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-b3d581a3d561f3386a497d5622180c81_1440w.jpg" alt="">&lt;/p>
&lt;p>隐式链表的存放方式的&lt;strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong>。隐式链接分配的&lt;strong>稳定性较差&lt;/strong>，系统在运行过程中由于软件或者硬件错误&lt;strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong>&lt;/p>
&lt;p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong>显式链接&lt;/strong>」，它指&lt;strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong>，该表在整个磁盘仅设置一张，&lt;strong>每个表项中存放链接指针，指向下一个数据块号&lt;/strong>。&lt;/p>
&lt;p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为&lt;strong>文件分配表（&lt;em>File Allocation Table，FAT&lt;/em>）&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-848b55299135f1775cb9fa5e6f9f9272_1440w.jpg" alt="">&lt;/p>
&lt;p>由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong>提高了检索速度&lt;/strong>，而且&lt;strong>大大减少了访问磁盘的次数&lt;/strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是&lt;strong>不适用于大磁盘&lt;/strong>。&lt;/p>
&lt;p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。&lt;/p>
&lt;blockquote>
&lt;p>接下来，我们来看看索引的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。&lt;/p>
&lt;p>索引的实现是为每个文件创建一个「&lt;strong>索引数据块&lt;/strong>」，里面存放的是&lt;strong>指向文件数据块的指针列表&lt;/strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p>
&lt;p>另外，&lt;strong>文件头需要包含指向「索引数据块」的指针&lt;/strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。&lt;/p>
&lt;p>创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-1e6d2ef6d8782117779143843798b79e_1440w.jpg" alt="">&lt;/p>
&lt;p>索引的方式优点在于：&lt;/p>
&lt;ul>
&lt;li>文件的创建、增大、缩小很方便；&lt;/li>
&lt;li>不会有碎片的问题；&lt;/li>
&lt;li>支持顺序读写和随机读写；&lt;/li>
&lt;/ul>
&lt;p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p>
&lt;p>如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p>
&lt;p>先来看看链表 + 索引的组合，这种组合称为「&lt;strong>链式索引块&lt;/strong>」，它的实现方式是&lt;strong>在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-ede534663e1c19169eb40cbe01384da2_1440w.jpg" alt="">&lt;/p>
&lt;p>还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong>多级索引块&lt;/strong>」，实现方式是&lt;strong>通过一个索引块来存放多个索引数据块&lt;/strong>，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-fb7d558d7b1d2d48fa4544adbead57bc_1440w.jpg" alt="">&lt;/p>
&lt;h3 id="unix-文件的实现方式">Unix 文件的实现方式&lt;/h3>
&lt;p>我们先把前面提到的文件实现方式，做个比较：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-e01c7af752461c0794a10f383dbe465b_1440w.jpg" alt="">&lt;/p>
&lt;p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-0c16919bcad17d1391f162e0363229b7_1440w.jpg" alt="">&lt;/p>
&lt;p>它是根据文件的大小，存放的方式会有所变化：&lt;/p>
&lt;ul>
&lt;li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；&lt;/li>
&lt;li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；&lt;/li>
&lt;li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；&lt;/li>
&lt;li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；&lt;/li>
&lt;/ul>
&lt;p>那么，文件头（&lt;em>Inode&lt;/em>）就需要包含 13 个指针：&lt;/p>
&lt;ul>
&lt;li>10 个指向数据块的指针；&lt;/li>
&lt;li>第 11 个指向索引块的指针；&lt;/li>
&lt;li>第 12 个指向二级索引块的指针；&lt;/li>
&lt;li>第 13 个指向三级索引块的指针；&lt;/li>
&lt;/ul>
&lt;p>所以，这种方式能很灵活地支持小文件和大文件的存放：&lt;/p>
&lt;ul>
&lt;li>对于小文件使用直接查找的方式可减少索引数据块的开销；&lt;/li>
&lt;li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；&lt;/li>
&lt;/ul>
&lt;p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。&lt;/p>
&lt;p>为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。&lt;/p>
&lt;hr>
&lt;h3 id="空闲空间管理">空闲空间管理&lt;/h3>
&lt;p>针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：&lt;/p>
&lt;ul>
&lt;li>空闲表法&lt;/li>
&lt;li>空闲链表法&lt;/li>
&lt;li>位图法&lt;/li>
&lt;/ul>
&lt;h3 id="空闲表法">空闲表法&lt;/h3>
&lt;p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-1ec1e7e0b313a92e0028691ae97c9766_1440w.jpg" alt="">&lt;/p>
&lt;p>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。&lt;/p>
&lt;p>这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p>
&lt;h3 id="空闲链表法">空闲链表法&lt;/h3>
&lt;p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-a14c65a4ec2fbb470fba728b818a6d22_1440w.jpg" alt="">&lt;/p>
&lt;p>当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p>
&lt;p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p>
&lt;p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p>
&lt;h3 id="位图法">位图法&lt;/h3>
&lt;p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p>
&lt;p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">1111110011111110001110110111111100111 ...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p>
&lt;hr>
&lt;h3 id="文件系统的结构">文件系统的结构&lt;/h3>
&lt;p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。&lt;/p>
&lt;p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code>4 * 1024 * 8 = 2^15&lt;/code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code>2^15 * 4 * 1024 = 2^27&lt;/code> 个 byte，也就是 128M。&lt;/p>
&lt;p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p>
&lt;p>在 Linux 文件系统，把这个结构称为一个&lt;strong>块组&lt;/strong>，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p>
&lt;p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-d9e36f97b24b2a7f760a81d0b095c36d_1440w.jpg" alt="">&lt;/p>
&lt;p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p>
&lt;ul>
&lt;li>- &lt;em>超级块&lt;/em>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/li>
&lt;li>- &lt;em>块组描述符&lt;/em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/li>
&lt;li>- &lt;em>数据位图和 inode 位图&lt;/em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/li>
&lt;li> &lt;em>inode 列表&lt;/em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/li>
&lt;li>&lt;em>数据块&lt;/em>，包含文件的有用数据。&lt;/li>
&lt;/ul>
&lt;p>你可以会发现每个块组里有很多重复的信息，比如&lt;strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong>，这么做是有两个原因：&lt;/p>
&lt;ul>
&lt;li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。 -&lt;/li>
&lt;li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/li>
&lt;/ul>
&lt;p>不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。&lt;/p>
&lt;hr>
&lt;h3 id="目录的存储">目录的存储&lt;/h3>
&lt;p>在前面，我们知道了一个普通文件是如何存储的，但还有一个特殊的文件，经常用到的目录，它是如何保存的呢？&lt;/p>
&lt;p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 &lt;code>vim&lt;/code> 打开它，它也有 inode，inode 里面也是指向一些块。&lt;/p>
&lt;p>和普通文件不同的是，&lt;strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong>&lt;/p>
&lt;p>在目录文件的块中，最简单的保存格式就是&lt;strong>列表&lt;/strong>，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p>
&lt;p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-89f1e2f2d2a2cb232920d2df16a5f3f4_1440w.jpg" alt="">&lt;/p>
&lt;p>通常，第一项是「&lt;code>.&lt;/code>」，表示当前目录，第二项是「&lt;code>..&lt;/code>」，表示上一级目录，接下来就是一项一项的文件名和 inode。&lt;/p>
&lt;p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p>
&lt;p>于是，保存目录的格式改成&lt;strong>哈希表&lt;/strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p>
&lt;p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。&lt;/p>
&lt;p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。&lt;/p>
&lt;hr>
&lt;h3 id="软链接和硬链接">软链接和硬链接&lt;/h3>
&lt;p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过&lt;strong>硬链接（&lt;em>Hard Link&lt;/em>）&lt;/strong> 和&lt;strong>软链接（&lt;em>Symbolic Link&lt;/em>）&lt;/strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。&lt;/p>
&lt;ul>
&lt;li>硬链接: &lt;strong>多个dentry中的inode指向一个文件&lt;/strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong>硬链接是不可用于跨文件系统的&lt;/strong>。由于多个&lt;code>dentry&lt;/code>都是指向一个 inode，那么&lt;strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-7cf8cec396a66dca2dd1fcd6dadab537_1440w.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>软链接相当于重新创建一个文件，这个文件有&lt;strong>独立的 inode&lt;/strong>，但是这个&lt;strong>文件的内容是另外一个文件的路径&lt;/strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，&lt;/li>
&lt;li>所以&lt;strong>软链接是可以跨文件系统的&lt;/strong>，甚至&lt;strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-5606413e1b5d2c727399711d347617a2_1440w.jpg" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="文件-io">文件 I/O&lt;/h3>
&lt;p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有&lt;/p>
&lt;ul>
&lt;li>缓冲与非缓冲 I/O&lt;/li>
&lt;li>直接与非直接 I/O&lt;/li>
&lt;li>阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/li>
&lt;/ul>
&lt;p>接下来，分别对这些分类讨论讨论。&lt;/p>
&lt;h3 id="缓冲与非缓冲-io">缓冲与非缓冲 I/O&lt;/h3>
&lt;p>文件操作的标准库是可以实现数据的缓存，那么&lt;strong>根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>缓冲 I/O：利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。&lt;/li>
&lt;li>非缓冲 I/O：直接通过系统调用访问文件，不经过标准库缓存。&lt;/li>
&lt;/ul>
&lt;p>这里所说的「缓冲」特指标准库内部实现的缓冲。&lt;/p>
&lt;p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。&lt;/p>
&lt;h3 id="直接与非直接-io">直接与非直接 I/O&lt;/h3>
&lt;p>我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。&lt;/p>
&lt;p>那么，&lt;strong>根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。&lt;/li>
&lt;li>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。&lt;/li>
&lt;/ul>
&lt;p>如果你在使用文件操作类的系统调用函数时，指定了 &lt;code>O_DIRECT&lt;/code> 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。&lt;/p>
&lt;blockquote>
&lt;p>如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？&lt;/p>
&lt;/blockquote>
&lt;p>以下几种场景会触发内核缓存的数据写入磁盘：&lt;/p>
&lt;ul>
&lt;li>在调用 &lt;code>write&lt;/code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上； -&lt;/li>
&lt;li>用户主动调用 &lt;code>sync&lt;/code>，内核缓存会刷到磁盘上； - 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上； -&lt;/li>
&lt;li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；&lt;/li>
&lt;/ul>
&lt;h3 id="阻塞与非阻塞-io-vs-同步与异步-io">阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/h3>
&lt;p>为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。&lt;/p>
&lt;p>先来看看&lt;strong>阻塞 I/O&lt;/strong>，当用户程序执行 &lt;code>read&lt;/code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，&lt;code>read&lt;/code> 才会返回。&lt;/p>
&lt;p>注意，&lt;strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程&lt;/strong>。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-7f73fdcaca316aa0f12d77b6873785e5_1440w.jpg" alt="">&lt;/p>
&lt;p>知道了阻塞 I/O ，来看看&lt;strong>非阻塞 I/O&lt;/strong>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，&lt;code>read&lt;/code> 调用才可以获取到结果。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-51e052e2beecef41da3aed3ebc2b80bd_1440w.jpg" alt="">&lt;/p>
&lt;p>注意，&lt;strong>这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。&lt;/strong>&lt;/p>
&lt;p>举个例子，访问管道或 socket 时，如果设置了 &lt;code>O_NONBLOCK&lt;/code> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。&lt;/p>
&lt;p>应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。&lt;/p>
&lt;p>为了解决这种傻乎乎轮询方式，于是 &lt;strong>I/O 多路复用&lt;/strong>技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。&lt;/p>
&lt;p>这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。&lt;/p>
&lt;p>下图是使用 select I/O 多路复用过程。注意，&lt;code>read&lt;/code> 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个&lt;strong>同步的过程&lt;/strong>，需要等待：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-02cfbd8572026087fc9b8e946b4d98bf_1440w.jpg" alt="">&lt;/p>
&lt;p>实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用&lt;strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。&lt;/strong>&lt;/p>
&lt;p>而真正的&lt;strong>异步 I/O&lt;/strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。&lt;/p>
&lt;p>当我们发起 &lt;code>aio_read&lt;/code> 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-b01988dd44a5edbe596a280d1c266033_1440w.jpg" alt="">&lt;/p>
&lt;p>下面这张图，总结了以上几种 I/O 模型：&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-1e7c3779cdf820da751a4fb1c84a602c_1440w.jpg" alt="">&lt;/p>
&lt;p>在前面我们知道了，I/O 是分为两个过程的：&lt;/p>
&lt;ol>
&lt;li>数据准备的过程 ；&lt;/li>
&lt;li>数据从内核空间拷贝到用户进程缓冲区的过程；&lt;/li>
&lt;/ol>
&lt;p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。&lt;/p>
&lt;p>异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p>
&lt;blockquote>
&lt;p>用故事去理解这几种 I/O 模型&lt;/p>
&lt;/blockquote>
&lt;p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p>
&lt;ul>
&lt;li>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/li>
&lt;li>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/li>
&lt;/ul>
&lt;p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code>select&lt;/code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p>
&lt;p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p></description></item><item><title>Linux系统调用之Futex</title><link>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</guid><description>&lt;h1 id="linux系统调用之futex">Linux系统调用之Futex&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>Futex（Fast Userspace muTexes）的缩写，由Hubertus Franke, Matthew Kirkwood, Ingo Molnar and Rusty Russell共同设计完成，&lt;/li>
&lt;li>Futex是一种用户态和内核态混合的同步机制。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>同步的进程间通过mmap共享一段内存，futex变量就位于这段共享 的内存中且操作是原子的，&lt;/li>
&lt;li>当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，
3. 如果没有竞争发生，则只修改futex,而不 用再执行系统调用了。
4. 如果有竞争发生，则执行系统调用去完成相应的处理(wait 或者 wake up)。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>futex()&lt;/code> 函数：&lt;/p>
&lt;ol>
&lt;li>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;/li>
&lt;li>不加timeout参数，它会一直被阻塞，直到FUTEX_WAKE:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/futex.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/time.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">futex&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">timespec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cp">#define __NR_futex 240
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。
FUTEX_WAKE: 最多唤醒val个等待在uaddr上进程。&lt;/p>
&lt;p>可见FUTEX_WAIT和FUTEX_WAKE只是用来挂起或者唤醒进程，当然这部分工作也只能在内核态下完成。有些人尝试着直接使用futex系统调 用来实现进程同步，并寄希望获得futex的性能优势，这是有问题的。应该区分futex同步机制和futex系统调用。futex同步机制还包括用户态 下的操作，我们将在下节提到。&lt;/p>
&lt;h2 id="futex同步机制">Futex同步机制&lt;/h2>
&lt;p>所有的futex同步操作都应该从用户空间开始，首先创建一个futex同步变量，也就是位于共享内存的一个整型计数器。
当 进程尝试持有锁或者要进入互斥区的时候，对futex执行&amp;quot;down&amp;quot;操作，即原子性的给futex同步变量减1。如果同步变量变为0，则没有竞争发生， 进程照常执行。如果同步变量是个负数，则意味着有竞争发生，需要调用futex系统调用的futex_wait操作休眠当前进程。
当进程释放锁或 者要离开互斥区的时候，对futex进行&amp;quot;up&amp;quot;操作，即原子性的给futex同步变量加1。如果同步变量由0变成1，则没有竞争发生，进程照常执行。如 果加之前同步变量是负数，则意味着有竞争发生，需要调用futex系统调用的futex_wake操作唤醒一个或者多个等待进程。&lt;/p>
&lt;p>这里的原子性加减通常是用CAS(Compare and Swap)完成的，与平台相关。CAS的基本形式是：CAS(addr,old,new),当addr中存放的值等于old时，用new对其替换。在x86平台上有专门的一条指令来完成它: cmpxchg。&lt;/p>
&lt;p>可见: futex是从用户态开始，由用户态和核心态协调完成的。&lt;/p>
&lt;h2 id="进线程利用futex同步">进/线程利用futex同步&lt;/h2>
&lt;p>进程或者线程都可以利用futex来进行同步。
对于线程，情况比较简单，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量。
对 于进程，情况相对复杂，因为进程有独立的虚拟内存空间，只有通过mmap()让它们共享一段地址空间来使用futex变量。每个进程用来访问futex的 虚拟地址可以是不一样的，只要系统知道所有的这些虚拟地址都映射到同一个物理内存地址，并用物理内存地址来唯一标识futex变量。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.shuzhiduo.com/A/rV57P2rLdP/">linux内核级同步机制&amp;ndash;futex&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/farmerjohngit/myblog/issues/6">关于同步的一点思考-上 · Issue #6 · farmerjohngit/myblog · GitHub&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>MySQL InnoDB 存储原理</title><link>https://justice.bj.cn/post/30.architech/mysql/mysql_innodb_%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/30.architech/mysql/mysql_innodb_%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="mysql-innodb-存储原理">MySQL InnoDB 存储原理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>mysql InnoDB 存储引擎&lt;/li>
&lt;/ul>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>mysql InnoDB存储引擎的数据以目录文件形式存储在磁盘中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个db 都会在 /var/lib/mysql/ 目录里面创建一个以 db 为名的目录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个db目录下包含：&lt;/p>
&lt;ul>
&lt;li>db.opt：db选项，记录当前数据库db的默认字符集和字符校验规则；&lt;/li>
&lt;li>table1.frm：表table1结构文件，保存每个表的元数据信息的，主要包含表结构定义；&lt;/li>
&lt;li>table1.ibd：表table1数据文件，表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@xiaolin ~]#ls /var/lib/mysql/my_test
db.opt
table1.frm
table1.ibd
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="表空间文件结构">表空间文件结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>表数据文件(.ibd)又叫表空间文件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>表空间由&lt;/p>
&lt;ul>
&lt;li>
&lt;p>行（row）：&lt;/p>
&lt;ul>
&lt;li>innodb中表记录的每行数据存储为一行；&lt;/li>
&lt;li>行是innodb数据存储基本单元；&lt;/li>
&lt;li>一行记录除了 TEXT、BLOBs 类型的列，最大为 65535(64K) 字节;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>页（page）：&lt;/p>
&lt;ul>
&lt;li>页是innodb的读写单元，innodb每次读写都是一个完整的page；&lt;/li>
&lt;li>每个页可以包含多个row；&lt;/li>
&lt;li>每个页默认大小16KB；&lt;/li>
&lt;li>页之间通过双向链表组织起来，逻辑上连续，物理上可能不连续；&lt;/li>
&lt;li>页通过&lt;/li>
&lt;li>页分为：
&lt;ul>
&lt;li>数据页：包含row记录；&lt;/li>
&lt;li>undo 日志页：；&lt;/li>
&lt;li>溢出页&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>区(extent):&lt;/p>
&lt;ul>
&lt;li>当表中数据量大时，为某个索引分配空间不按照页为单位分配了，而是按照区（extent）为单位分配；&lt;/li>
&lt;li>每个区中包含一系列相邻的页，使用顺序 I/O 了；&lt;/li>
&lt;li>每个区的大小为 1MB；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>段（segment）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>多个区（extent）组成段；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>段分为：&lt;/p>
&lt;ul>
&lt;li>索引段：存放 B + 树的非叶子节点的区的集合；&lt;/li>
&lt;li>数据段：存放 B + 树的叶子节点的区的集合；&lt;/li>
&lt;li>回滚段：存放的是回滚数据的区的集合，之前讲&lt;a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离 (opens new window)&lt;/a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>这些段共同组成表空间文件；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-17-52-49-2024-01-18-17-52-39-image.png" alt="">&lt;/p>
&lt;h2 id="行存储结构">行存储结构&lt;/h2>
&lt;p>InnoDB 的表行存储提供有 4 种行格式：&lt;/p>
&lt;ul>
&lt;li>Redundant： MySQL 5.0 版本之前用的行格式，不是一种紧凑的行格式；&lt;/li>
&lt;li>Compact：一种紧凑的行格式，可以让一个数据页中可以存放更多的行记录，是MySQL 5.1 版本之后的默认行格式；&lt;/li>
&lt;li>Dynamic：&lt;/li>
&lt;li>Compresse：&lt;/li>
&lt;/ul>
&lt;h3 id="compact格式行结构">Compact格式行结构&lt;/h3>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/2024-01-18-17-59-20-image.png" alt="">&lt;/p>
&lt;h3 id="记录的额外信息">记录的额外信息&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>变长字段长度列表&lt;/p>
&lt;ul>
&lt;li>记录varchar, text, blob等变长列的字节长度；&lt;/li>
&lt;li>按照列的顺序&lt;strong>逆序存放&lt;/strong>；&lt;/li>
&lt;li>不需要保存值为 NULL 的变长字段的长度；&lt;/li>
&lt;li>逆序存放是为了从记录头信息开始，位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line，提高效率；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>NULL 值列表&lt;/p>
&lt;ul>
&lt;li>记录可能会存储 NULL列是否是NULL值；&lt;/li>
&lt;li>每个列对应一个二进制位（bit），1代表NULL，0为非NULL；&lt;/li>
&lt;li>NULL 值列表必须用整数个字节的位表示，小于9个NULL列，用1个字节，否则用多个字节；&lt;/li>
&lt;li>NULL 值列表也不是必须的，当所有字段都定义成 NOT NULL 时，不需要NULL值列表；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>记录头信息&lt;/p>
&lt;ul>
&lt;li>
&lt;p>记录头信息中包含的内容很多；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delete_mask：标识此条数据是否被删除，执行 detele 删除记录的时候，并不会真正的删除记录，只是将该条记录的 delete_mask 标记为 1；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>next_record：下一条记录的位置。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>record_type：表示当前记录的类型。&lt;/p>
&lt;ul>
&lt;li>0：表示普通记录；&lt;/li>
&lt;li>1：表示B+树非叶子节点记录；&lt;/li>
&lt;li>2：表示最小记录；&lt;/li>
&lt;li>3：表示最大记录；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="隐藏字段">隐藏字段&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>row_id：&lt;/p>
&lt;ul>
&lt;li>建表时未指定主键和唯一约束列，则innodb将自动添加row_id，否则没有row_id；&lt;/li>
&lt;li>row_id不是必需的，有的话占用 6 个字节;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>trx_id：事务id&lt;/p>
&lt;ul>
&lt;li>表示这条记录是由哪个事务生成的；&lt;/li>
&lt;li>trx_id必需，占用 6 个字节；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>roll_pointer：回滚指针&lt;/p>
&lt;ul>
&lt;li>记录上一个版本的指针；&lt;/li>
&lt;li>roll_pointer 是必需的，占用 7 个字节。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="行溢出">行溢出&lt;/h3>
&lt;ul>
&lt;li>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中；&lt;/li>
&lt;li>发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-20-56-18-2024-01-18-20-56-12-image.png" alt="">&lt;/p>
&lt;h2 id="数据页结构">数据页结构&lt;/h2>
&lt;p>数据页包括七个部分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>File Header(文件头)：记录页信息， File Header 中有两个指针，分别指向上一个数据页和下一个数据页；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Page Hader(页头)：页状态信息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最大最小记录：页中最大记录，最小行记录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>User Records：一系列数据行记录；&lt;/p>
&lt;ul>
&lt;li>记录按照「主键」顺序组成单向链表；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>FreeSpace: 页中还未被行记录使用的空闲空间；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Page Directory：页目录，记录的索引作用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FileTailer：校验页是否完整；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-06-44-2024-01-18-21-06-19-image.png" alt="">&lt;/p>
&lt;p>多个数据页通过FileHeader中的2个指针组成双向链表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-07-34-2024-01-18-21-07-27-image.png" alt="">&lt;/p>
&lt;h3 id="页目录">页目录&lt;/h3>
&lt;p>页目录创建的过程如下：&lt;/p>
&lt;ol>
&lt;li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；&lt;/li>
&lt;li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）&lt;/li>
&lt;li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），&lt;strong>每个槽相当于指针指向了不同组的最后一个记录&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-26-44-2024-01-18-21-26-39-image.png" alt="">&lt;/p>
&lt;h3 id="b树结构">B+树结构&lt;/h3>
&lt;p>聚簇索引&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-09-12-2024-01-18-21-09-07-image.png" alt="">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84">从数据页的角度看 B+ 树 | 小林coding&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>NVMe</title><link>https://justice.bj.cn/post/40.storage/nvme%E7%AE%80%E4%BB%8B/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/40.storage/nvme%E7%AE%80%E4%BB%8B/</guid><description>&lt;h1 id="nvme">NVMe&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>NVMe（Non-Volatile Memory Express）非易失性内存主机控制器接口规范，是一个主机控制器接口和存储协议，用于加速企业和客户端系统以及固态驱动器（SSD）之间的数据传输。它通过电脑的高速 PCIe 总线工作&lt;/p>
&lt;p>NVMe 自 Linux 内核 3.3 版本就支持了&lt;/p>
&lt;p>基于 SCSI 协议的 SAS 和 SATA&lt;strong>只能是单个队列&lt;/strong>而且每个队列的深度也比较低，分别是 254 和 32 的队列深度。而 NVMe 协议设计之初就考虑了该问题，它的最大队列数量可以是 64K（65535 个命令队列和 1 个管理队列），&lt;/p>
&lt;p>NVMe 协议可以最多有 64K 个队列，每个 CPU 或者核心都可以有一个队列，这样并发程度大大提升，性能也自然更高了&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/12/14-14-16-48-2020-12-14-14-16-42-image.png" alt="">&lt;/p></description></item><item><title>CUDA编程</title><link>https://justice.bj.cn/post/50.ml/cuda/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/50.ml/cuda/</guid><description>&lt;h1 id="cuda编程">CUDA编程&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>CUDA是NVIDIA于2006年发布的一个基于NVIDIA的GPU的通用并行计算平台和编程模型;&lt;/li>
&lt;li>CUDA可以利用GPUs的并行计算引擎来更加高效地解决复杂的计算难题;&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;ul>
&lt;li>CUDA是基于CPU+GPU的异构计算架构, 此时, GPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为为主机端（host），而GPU所在位置称为设备端（device）&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/20240415210806.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/20240415214127.png" alt="">&lt;/p>
&lt;h2 id="编程模型">编程模型&lt;/h2>
&lt;ul>
&lt;li>CUDA中有2个重要的概念host和device，host: 指代CPU及其内存，device指:GPU及其内存。&lt;/li>
&lt;li>CUDA程序中的host与device之间可以进行通信，进行数据拷贝;&lt;/li>
&lt;li>典型的CUDA程序的执行流程如下：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>分配host内存，并进行数据初始化；&lt;/li>
&lt;li>分配device内存，并从host将数据拷贝到device上；&lt;/li>
&lt;li>调用CUDA的核函数在device上完成指定的运算；&lt;/li>
&lt;li>将device上的运算结果拷贝到host上；&lt;/li>
&lt;li>释放device和host上分配的内存。&lt;/li>
&lt;/ol>
&lt;h3 id="函数限定符">函数限定符&lt;/h3>
&lt;p>CUDA中是通过函数类型限定词开区别host和device上的函数，主要的三个函数类型限定词如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>__global__&lt;/code>：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是&lt;code>void&lt;/code>，不支持可变参数参数，不能成为类成员函数。注意用&lt;code>__global__&lt;/code>定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。&lt;/li>
&lt;li>&lt;code>__device__&lt;/code>：在device上执行，单仅可以从device中调用，不可以和&lt;code>__global__&lt;/code>同时用。&lt;/li>
&lt;li>&lt;code>__host__&lt;/code>：在host上执行，仅可以从host上调用，一般省略不写，不可以和&lt;code>__global__&lt;/code>同时用，但可和&lt;code>__device__&lt;/code>，此时函数会在device和host都编译。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/20240416121938.png" alt="Kernel上的两层线程组织结构（2-dim）">&lt;/p>
&lt;h2 id="内存模型">内存模型&lt;/h2>
&lt;p>每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory）,可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/20240416122158.png" alt="CUDA内存模型">&lt;/p>
&lt;h2 id="实例">实例&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="c1">// CUDA向量加法实例
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 两个向量加法kernel，grid和block均为一维
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">__global__&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// 获取全局索引
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadIdx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">blockIdx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">blockDim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 步长
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">stride&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">blockDim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">gridDim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">stride&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">z&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">nBytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 申请host内存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 初始化数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">10.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">20.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 申请device内存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">d_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">d_y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">d_z&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">cudaMalloc&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">d_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaMalloc&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">d_y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaMalloc&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">d_z&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 将host数据拷贝到device
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cudaMemcpy&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">d_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cudaMemcpyHostToDevice&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaMemcpy&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">d_y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cudaMemcpyHostToDevice&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 定义kernel的执行配置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dim3&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">256&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">dim3&lt;/span> &lt;span class="n">gridSize&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">N&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 执行kernel
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">add&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">gridSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">blockSize&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">d_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">d_y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">d_z&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 将device得到的结果拷贝到host
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cudaMemcpy&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">d_z&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cudaMemcpyDeviceToHost&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 检查执行结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">maxError&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">maxError&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fmax&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maxError&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fabs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mf">30.0&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;最大误差: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">maxError&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 释放device内存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cudaFree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">d_x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaFree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">d_y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaFree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">d_z&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 释放host内存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="矩阵乘法实例">矩阵乘法实例&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="c1">// 获取矩阵A的(row, col)元素
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">__device__&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="nf">getElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Matrix&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 为矩阵A的(row, col)元素赋值
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">__device__&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Matrix&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 矩阵相乘kernel，2-D，每个线程计算一个元素
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">__global__&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">matMulKernel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Matrix&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Matrix&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Matrix&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">float&lt;/span> &lt;span class="n">Cvalue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadIdx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">blockIdx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">blockDim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">col&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadIdx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">blockIdx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">blockDim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">Cvalue&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">getElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">getElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">setElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Cvalue&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">Matrix&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 申请托管内存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cudaMallocManaged&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Matrix&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">cudaMallocManaged&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Matrix&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">cudaMallocManaged&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Matrix&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">nBytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">width&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaMallocManaged&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaMallocManaged&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">cudaMallocManaged&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nBytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 初始化数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">B&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">B&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">C&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">C&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">width&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">A&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">B&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">2.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 定义kernel的执行配置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dim3&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">dim3&lt;/span> &lt;span class="n">gridSize&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">width&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">blockSize&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 执行kernel
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">matMulKernel&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">gridSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">blockSize&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">C&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 同步device 保证结果能正确访问
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cudaDeviceSynchronize&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="c1">// 检查执行结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">maxError&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">width&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">maxError&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fmax&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maxError&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fabs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;最大误差: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">maxError&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/34587739">https://zhuanlan.zhihu.com/p/34587739&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>LLM-大语言模型相关</title><link>https://justice.bj.cn/post/50.ml/llm/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/50.ml/llm/</guid><description>&lt;h1 id="llm大语言模型相关">LLM:大语言模型相关&lt;/h1>
&lt;h2 id="准备">准备&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 安装anaconda&lt;/span>
$ winget install Anaconda.Anaconda3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="hf-mirror-hugging-faces镜像网站">hf-mirror: hugging-faces镜像网站&lt;/h3>
&lt;h3 id="hfd-大模型数据下载工具">hfd: 大模型数据下载工具&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 安装&lt;/span>
$ wget
&lt;span class="c1">## 用法&lt;/span>
$ hfd.sh jartine/llava-v1.5-7B-GGUF --include &lt;span class="s2">&amp;#34;llava-v1.5-7b-q4.llamafile&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="概念">概念&lt;/h2>
&lt;h3 id="gguf">GGUF:&lt;/h3>
&lt;ul>
&lt;li>gguf:&lt;/li>
&lt;/ul>
&lt;h3 id="onnx-开发神经网络交换格式">ONNX: 开发神经网络交换格式&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>onnx: Open Neural Network Exchange，是一种模型IR，用于在各种深度学习训练和推理框架转换的一个中间表示格式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用protobuf定义;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ONNX 模型结构：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ModelProto&lt;/p>
&lt;ul>
&lt;li>GraphProto
&lt;ul>
&lt;li>NodeProto&lt;/li>
&lt;li>ValueInfoProto&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="框架">框架&lt;/h2>
&lt;h3 id="rag">RAG:&lt;/h3>
&lt;h2 id="工具">工具&lt;/h2>
&lt;h3 id="llama-cli">llama-cli&lt;/h3>
&lt;h3 id="ollama-命令行运行llama工具">ollama: 命令行运行llama工具&lt;/h3>
&lt;ul>
&lt;li>支持平台: mac, linux, windows&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 创建模型配置文件&lt;/span>
$ cat &lt;span class="s2">&amp;#34;FROM d:\code\llm\&amp;lt;LLM_MODEL_GGUF&amp;gt;&amp;#34;&lt;/span> &amp;gt; modelfile.txt
&lt;span class="c1">## ollama导入模型&lt;/span>
$ ollama create &amp;lt;MODLE_NAME&amp;gt; -f modelfile.txt
&lt;span class="c1">## 查看ollama导入的模型&lt;/span>
$ ollama list
&lt;span class="c1">## 运行模型&lt;/span>
$ ollama run &amp;lt;MODLE_IMPORT_NAME&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="llamafile-单文件大模型运行工具">llamafile: 单文件大模型运行工具&lt;/h3>
&lt;ul>
&lt;li>支持平台: mac, linux, win&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 安装llamafile命令行命令&lt;/span>
$ wget -O /c/app/llamafile.exe https://github.com/Mozilla-Ocho/llamafile/releases/download/0.7/llamafile-0.7
&lt;span class="c1">## 启动 llama服务&lt;/span>
$ llamafile -m qwen1_5-14b-chat-q4_0.gguf
&lt;span class="c1">## 启动浏览器: http://127.0.0.1:8080&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="gpt4all">gpt4all&lt;/h3>
&lt;h3 id="lm-studio">lm-studio&lt;/h3>
&lt;h3 id="anythingllm">AnythingLLM&lt;/h3>
&lt;ul>
&lt;li>高效、可定制且开源的企业级文档聊天机器人解决方案;&lt;/li>
&lt;li>github: &lt;a href="https://github.com/Mintplex-Labs/anything-llm">https://github.com/Mintplex-Labs/anything-llm&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="应用">应用&lt;/h2>
&lt;h3 id="chat-文本对话">Chat: 文本对话&lt;/h3>
&lt;h3 id="语音识别">语音识别&lt;/h3>
&lt;h4 id="whispercpp">whisper.cpp&lt;/h4>
&lt;ul>
&lt;li>基于whispe.cpp语音对话模型;&lt;/li>
&lt;li>windows下wsl编译&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ git clone git@github.com:ggerganov/whisper.cpp.git
$ &lt;span class="nb">cd&lt;/span> whisper.cpp
&lt;span class="c1">## 编译talk-llama&lt;/span>
$ make talk-llama
&lt;span class="c1">## 下载ggml语音模型&lt;/span>
$ models/download-ggml-model.sh small
&lt;span class="c1">## 运行&lt;/span>
$ ./talk-llama -mw /mnt/c/code/llm/whisper-models/ggml-whisper-small.bin -ml /mnt/c/code/llm/lmstudio/Qwen/Qwen1.5-0.5B-Chat-GGUF/qwen1_5-7b-chat-q4_0.gguf -p &lt;span class="s2">&amp;#34;Jack&amp;#34;&lt;/span> -t &lt;span class="m">8&lt;/span> -l zh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="tts-文本转语音">TTS: 文本转语音&lt;/h3>
&lt;h3 id="图片生成">图片生成&lt;/h3>
&lt;h3 id="2d转3d">2d转3d&lt;/h3>
&lt;h3 id="知识系统">知识系统&lt;/h3>
&lt;h2 id="平台">平台&lt;/h2>
&lt;h3 id="nvidia">Nvidia&lt;/h3>
&lt;h4 id="cuda">CUDA&lt;/h4>
&lt;h3 id="amd">AMD&lt;/h3>
&lt;h3 id="zludahttpsgithubcomvosenzluda">&lt;a href="https://github.com/vosen/ZLUDA">ZLUDA&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>zluda: 是无修改直接在amd gpu上运行cuda程序的cuda兼容库;&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## download and install&lt;/span>
$ wget https://github.com/vosen/ZLUDA/releases/download/v3/zluda-3-windows.zip
&lt;span class="c1">## run with zlud&lt;/span>
$ &amp;lt;ZLUDA_DIRECTORY&amp;gt;&lt;span class="se">\z&lt;/span>luda.exe -- &amp;lt;APPLICATION&amp;gt; &amp;lt;APPLICATION_ARGUMENTS&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>olive&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 1. 创建虚拟环境&lt;/span>
$ conda create --name&lt;span class="o">=&lt;/span>llama2_opt &lt;span class="nv">python&lt;/span>&lt;span class="o">=&lt;/span>3.11.5
&lt;span class="c1">## 2. 激活虚拟环境&lt;/span>
$ conda active llama2_opt
&lt;span class="c1">## 下载olive源码&lt;/span>
$ git clone https://github.com/microsoft/Olive.git
&lt;span class="c1">## 安装依赖包&lt;/span>
$ pip install -r ./requirements.txt
&lt;span class="c1">## &lt;/span>
$ pip install -e .
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.deepin.org/zh/llamafile-a-must-have-tool/">https://www.deepin.org/zh/llamafile-a-must-have-tool/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cvmart.net/community/detail/6550">https://www.cvmart.net/community/detail/6550&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/686886176">https://zhuanlan.zhihu.com/p/686886176&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Tauri</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BA%93%E4%B9%8Btauri/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BA%93%E4%B9%8Btauri/</guid><description>&lt;h1 id="tauri">Tauri&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Tauri是一个类似electron的跨平台基于web的客户端框架。奥法队是非得失通过Tauri可以将web网站已本地客户端的方式在pc\mac上运行。所以一些web网站无法实现的功能比如读取存储本地文件，就可以通过Tauri上提供的api实现了。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2></description></item><item><title>whisper.cpp</title><link>https://justice.bj.cn/post/50.ml/whisper.cpp/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/50.ml/whisper.cpp/</guid><description>&lt;h1 id="whispercpp">whisper.cpp&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Zeus- Uber的分布式Spark Shuffle Service</title><link>https://justice.bj.cn/post/30.architech/spark/zeus-uber-remote-spark-shuffle-service/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/30.architech/spark/zeus-uber-remote-spark-shuffle-service/</guid><description>&lt;h1 id="zeus-uber的分布式spark-shuffle-service">Zeus: Uber的分布式Spark Shuffle Service&lt;/h1>
&lt;hr>
&lt;h2 id="特性">特性&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>垂直扩展&lt;/p>
&lt;ul>
&lt;li>
&lt;p>独立节点运行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>去中心化存储，节点无状态；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>解决网络延迟&lt;/p>
&lt;ul>
&lt;li>
&lt;p>降低服务响应等待时间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>流数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>性能优化&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-07-02-17-06-40-image.png" alt="">&lt;/p>
&lt;hr>
&lt;h2 id="优化点">优化点&lt;/h2>
&lt;h3 id="横向扩展">横向扩展&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>shuffle 服务独立，可在不同应用间共享；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>shuffle 节点无状态；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>shuffle 节点可根据需求横向扩展；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="分布式shuffle服务">分布式shuffle服务&lt;/h3>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-07-02-10-50-42-image.png" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="磁盘文件直接读写">磁盘文件直接读写&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>直接写入文件，无应用层的缓存；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>零拷贝&lt;/p>
&lt;/li>
&lt;li>
&lt;p>顺序读写，无随机磁盘IO；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="实现方面优化">实现方面优化&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Netty：高性能异步服务框架&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2个线程组：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>group1接收网络连接；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>group2读取数据；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>彼此不阻塞；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>二进制网络协议&lt;/p>
&lt;ul>
&lt;li>编码和压缩更有效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="客户端压缩">客户端压缩&lt;/h3>
&lt;ul>
&lt;li>shuffle client&lt;/li>
&lt;/ul></description></item><item><title>智能语音助手</title><link>https://justice.bj.cn/post/50.ml/%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/50.ml/%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B/</guid><description>&lt;h1 id="智能语音助手">智能语音助手&lt;/h1>
&lt;h2 id="功能">功能&lt;/h2>
&lt;ol>
&lt;li>实现中英文语音对话;&lt;/li>
&lt;/ol>
&lt;h2 id="架构">架构&lt;/h2>
&lt;h2 id="组件">组件&lt;/h2>
&lt;h3 id="语音转文本">语音转文本&lt;/h3>
&lt;ul>
&lt;li>whisper.cpp&lt;/li>
&lt;/ul>
&lt;h3 id="对话大模型">对话大模型&lt;/h3>
&lt;ul>
&lt;li>llama&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>下载大模型数据:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ export HF_ENDPOINT=https://hf-mirror.com
$ hfd.sh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="文本转语音输出">文本转语音输出&lt;/h3>
&lt;ul>
&lt;li>espeak&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## ubuntu 安装 &lt;/span>
$ sudo apt install espeak
&lt;span class="c1">## 下载数据文件&lt;/span>
$ wget https://gitee.com/xiaohe4966/espeak-data/blob/master/espeak-data.zip
&lt;span class="c1">## 查找espeak-data目录&lt;/span>
$ find /usr -name espeak-data
&lt;span class="c1">## 移动espeak-data到安装目录&lt;/span>
$ mv espeak-data /usr/lib/x86_64-linux-gnu/
&lt;span class="c1">## 使用espeak &lt;/span>
$ espeak -v zh &lt;span class="s2">&amp;#34;你好&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>audio-box: meta&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="http://awesome-zh.nocode.site/services/espeak.html">http://awesome-zh.nocode.site/services/espeak.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Zerotier</title><link>https://justice.bj.cn/post/70.tool/zerotier/</link><pubDate>Thu, 28 Mar 2024 20:55:30 +0800</pubDate><guid>https://justice.bj.cn/post/70.tool/zerotier/</guid><description>&lt;h1 id="zerotier">Zerotier&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>zerotier是一款智能可编程以太网交换软件，只需要经过简单的注册，安装和配置，即可建立VPN。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h3 id="小米mini-wifi安装zerotier">小米mini wifi安装zerotier&lt;/h3>
&lt;h3 id="架构">架构&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>家中小米路由器(mini-wifi)上安装zerotier路由器版;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>手机安装zerotier android版；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将这些设备都加入到一个zerotier 虚拟局域网中，以达到随时可相互访问的目的;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="准备工作">准备工作&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>登陆&lt;a href="https://www.zerotier.com/">zerotier官网&lt;/a>，注册账号，申请网络ID；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按小米路由官方提示开启小米mini-wifi的ssh登陆功能；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="操作">操作&lt;/h4>
&lt;ol>
&lt;li>ssh 到mini wifi中，进行如下操作：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 使用ssh登陆到mini-wifi中&lt;/span>
&lt;span class="o">[&lt;/span>your-pc&lt;span class="o">]&lt;/span>$ ssh root@192.168.xx.x
&lt;span class="c1">## 进入小米路由外接磁盘目录&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># cd /extdisks/sda1/xiaomi_router/&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># mkdir -p opt/zerotier/pkg opt/bin opt/conf&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># cd opt/zerotier/pkg&lt;/span>
&lt;span class="c1">## 下载zerotier-one 二进制程序&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># wget http://pkg.entware.net/binaries/mipsel/zerotier_1.1.14-4_mipselsf.ipk&lt;/span>
&lt;span class="c1"># tar xf zerotier_1.1.14-4_mipselsf.ipk&lt;/span>
&lt;span class="c1">## 启动zerotier守护进程&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># zerotier-one -D /extdisks/sda1/xiaomi_router/opt/zerotier/data&lt;/span>
&lt;span class="c1">## 加入zerotier网络&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># zerotier-cli -D/extdisks/sda1/xiaomi_router/opt/zerotier/data join &amp;lt;NETWORK_ID&amp;gt;&lt;/span>
&lt;span class="c1">## 查看状态&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># zerotier-cli -D/extdisks/sda1/xiaomi_router/opt/zerotier/data status&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>
&lt;p>上my.zerotier.com上“setting”-&amp;gt;&amp;ldquo;Advance&amp;quot;中增加路由规则，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Destination：内网网段，路由默认为: 192.168.31.0/24&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Via: zerotier分配给路由的ip&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>设置完成后，在手机上安装zerotier，加入网络后，可通过手机访问家中网络；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="nat模式访问内网设备">NAT模式访问内网设备&lt;/h4>
&lt;p>内网路由器安装zerotier并加入，外网设备(如手机)通过NAT模式访问内网其他设备&lt;/p>
&lt;p>路由器设置NAT路由转发规则如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">root@XiaoQiang:~# ZT_IF=zt0
root@XiaoQiang:~# iptables -I FORWARD -o $ZT_IF -j ACCEPT
root@XiaoQiang:~# iptables -I FORWARD -i $ZT_IF=zt0 -j ACCEPT
root@XiaoQiang:~# iptables -t nat -I POSTROUTING -o $ZT_IF -j MASQUERADE
root@XiaoQiang:~# iptables-save
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.zerotier.com/">https://www.zerotier.com/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/zerotier/ZeroTierOne">https://github.com/zerotier/ZeroTierOne&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.entware.net/binaries/mipsel/">https://pkg.entware.net/binaries/mipsel/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://post.smzdm.com/p/a5d09ln8/">小米路由3安装Zerotier_路由器_什么值得买&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>专题：动态规划</title><link>https://justice.bj.cn/post/leetcode/%E4%B8%93%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Thu, 28 Mar 2024 20:55:30 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/%E4%B8%93%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>&lt;h1 id="专题动态规划">专题：动态规划&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>动态规划问题的难点在于对问题进行合理划分，将大问题转变为小问题的组合，形成递推关系，通过归纳法将问题得到解决；&lt;/p>
&lt;p>动态规划最关键的地方在于对问题进行正确的抽象和建模，进而建立递推公式；&lt;/p>
&lt;h2 id="步骤">步骤&lt;/h2>
&lt;ul>
&lt;li>函数定义：定义问题目标函数，目标函数可通过子目标函数组合而成，子函数需要包含目标函数的所有情形且不能重叠；&lt;/li>
&lt;li>递推公式：定义最终函数 和 子目标函数之间的递推关系，通过将目标问题分解为规模更小的子问题组合来递推解决目标问题；&lt;/li>
&lt;li>初始条件：&lt;/li>
&lt;li>终止条件:&lt;/li>
&lt;/ul>
&lt;h2 id="相关题目">相关题目&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>题目&lt;/th>
&lt;th>难度&lt;/th>
&lt;th>关键思路&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="../../5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">5.最长回文子串&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../10.%E6%AD%A3%E5%88%99%E5%BC%8F%E5%8C%B9%E9%85%8D">10.正则式匹配&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">62.不同路径&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii">63.不同路径 II&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../403.%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3">403.青蛙过河&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../97.%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2">97.交错字符串&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="./115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.md" title="https://leetcode.cn/problems/distinct-subsequences/description/">115.不同的子序列&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139.单词拆分&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../887.%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD">887.鸡蛋掉落&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>鸡蛋掉落</title><link>https://justice.bj.cn/post/leetcode/887.%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/</link><pubDate>Thu, 07 Mar 2024 14:02:17 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/887.%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/</guid><description>&lt;h1 id="鸡蛋掉落httpsleetcodecnproblemssuper-egg-dropdescription-httpsleetcodecnproblemssuper-egg-dropdescription">&lt;a href="https://leetcode.cn/problems/super-egg-drop/description/" title="https://leetcode.cn/problems/super-egg-drop/description/">鸡蛋掉落&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Hard (30.83%)&lt;/td>
&lt;td>985&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/heap" title="https://leetcode.com/tag/heap">&lt;code>heap&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>Unknown&lt;/code>&lt;/p>
&lt;p>给你 &lt;code>k&lt;/code> 枚相同的鸡蛋，并可以使用一栋从第 &lt;code>1&lt;/code> 层到第 &lt;code>n&lt;/code> 层共有 &lt;code>n&lt;/code> 层楼的建筑。&lt;/p>
&lt;p>已知存在楼层 &lt;code>f&lt;/code> ，满足 &lt;code>0 &amp;lt;= f &amp;lt;= n&lt;/code> ，任何从 &lt;strong>高于&lt;/strong> &lt;code>f&lt;/code> 的楼层落下的鸡蛋都会碎，从 &lt;code>f&lt;/code> 楼层或比它低的楼层落下的鸡蛋都不会破。&lt;/p>
&lt;p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 &lt;code>x&lt;/code> 扔下（满足 &lt;code>1 &amp;lt;= x &amp;lt;= n&lt;/code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 &lt;strong>重复使用&lt;/strong> 这枚鸡蛋。&lt;/p>
&lt;p>请你计算并返回要确定 &lt;code>f&lt;/code> &lt;strong>确切的值&lt;/strong> 的 &lt;strong>最小操作次数&lt;/strong> 是多少？&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
如果它没碎，那么肯定能得出 f = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：k = 2, n = 6
输出：3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：k = 3, n = 14
输出：4
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= k &amp;lt;= 100&lt;/code>&lt;/li>
&lt;li>&lt;code>1 &amp;lt;= n &amp;lt;= 104&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode.cn/problems/super-egg-drop/comments/" title="https://leetcode.cn/problems/super-egg-drop/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode.cn/problems/super-egg-drop/solution/" title="https://leetcode.cn/problems/super-egg-drop/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;span class="lnt">81
&lt;/span>&lt;span class="lnt">82
&lt;/span>&lt;span class="lnt">83
&lt;/span>&lt;span class="lnt">84
&lt;/span>&lt;span class="lnt">85
&lt;/span>&lt;span class="lnt">86
&lt;/span>&lt;span class="lnt">87
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Solution&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// @lc code=start
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// ## 鸡蛋掉落
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// - 动态规划1(超时)
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 1. 设 dp[i][j] 表示总共有i个鸡蛋, 总共j层楼时, 确定目标楼层f的最小操作次数;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 2. 如果最开始选择在x楼(1&amp;lt;=x&amp;lt;=j)扔1个鸡蛋, 此时会有两种情况：
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 鸡蛋未破, 则目标楼层一定不在`[1,x)`中, 此时可继续用i个鸡蛋在`(x,n]`楼层中尝试.
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 后续为确定目标楼层的最小操作次数为: dp[i][j-x]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// b. 鸡蛋破裂, 则目标楼层一定不在`(x,j]`中, 此时可用剩下的i-1个鸡蛋在`[1,x)`楼层中继续尝试.
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 后续为确定目标楼层的最小操作次数为: dp[i-1][x-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 综合以上情况, 如果扔1枚鸡蛋在x楼后, 为保证一定能确定目标楼层, 后续最小操作次数为:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// max(dp[i][j-x], dp[i-1][x-1])
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 那么, 依次从`[1,j]`中选择开始楼层x扔鸡蛋, 选择总操作数最小的即为dp[i][j]:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// min(max(dp[i][j-x], dp[i-1][x-1]) + 1) ( 1 &amp;lt;= x &amp;lt;= j )
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 3. 综上可得递推关系:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// dp[i][j] = 1 + min(max(dp[i][j-k], dp[i-1][k-1])) ( 1 &amp;lt;= k &amp;lt;= j )
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 4. 初始条件: 当只有1个鸡蛋时, 需要从低到高逐层进行尝试, 最坏情况需要到最高一层n才能确定,
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 因此: dp[1][j] = j ( 1 &amp;lt;= j &amp;lt;= n )
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 5. 目标值: dp[k][n]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">i32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 初始条件
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">min&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unwrap_or&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// ## 鸡蛋掉落
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// - 动态规划2
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 1. 设 dp[i][j] 表示: 总共有i个鸡蛋, 扔鸡蛋j次, 最多可检测的楼层数;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 2. 扔1次鸡蛋后(不论扔在那个楼层), 有两种情况:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 鸡蛋未破, 剩余i个鸡蛋, 剩余操作次数j-1, 最多检测楼层数为: dp[i][j-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// b. 鸡蛋破了, 剩余i-1个鸡蛋, 剩余操作次数j-1, 最多可检测楼层数为: dp[i-1][j-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 那么, 最多可检测楼层总数:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// dp[i][j] = 1 + dp[i][j-1] + dp[i-1][j-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 3. 初始条件:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 鸡蛋个数i: 1 &amp;lt;= i &amp;lt;= k
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 总操作次数j最多为楼层数: 1 &amp;lt;= j &amp;lt;= n;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// b. 1个鸡蛋1次最多可检测楼层数为1: dp[1][1] = 1;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 4. 目标:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// i, j 由小到大, 当: i == k &amp;amp;&amp;amp; dp[i][j] &amp;gt;= n时, j的值
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">i32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// @lc code=end
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="cp">#[cfg(test)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">tests&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">super&lt;/span>::&lt;span class="o">*&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="cp">#[test]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">test&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://algo.itcharge.cn/Solutions/0800-0899/super-egg-drop/">0887. 鸡蛋掉落 | 算法通关手册（LeetCode）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item></channel></rss>