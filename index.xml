<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 24 Apr 2024 12:31:05 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Linux IO 之 文件系统的架构(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84/</guid><description>&lt;h1 id="linux-io-之-文件系统的架构转">Linux IO 之 文件系统的架构(转)&lt;/h1>
&lt;h3 id="vfs和文件系统总结">VFS和文件系统总结&lt;/h3>
&lt;p>一切都是文件： VFS&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/42fc84d8385cd6f0bf3c2573f2e58eea_1702x1054.png" alt="">&lt;/p>
&lt;p>文件系统的设计，类似抽象基类，面向对象的思想。&lt;/p>
&lt;p>虚函数都必须由底层派生出的实例实现，使用成员函数 file_operations。在linux里面的文件操作，底层都要实现file_operations，抽象出owner，write，open，release。所以，无论是字符块，还是文件系统的文件，最终操作就必须是file_operations。&lt;/p>
&lt;p>例如，实现一个字符设备驱动，就是去实现file_operations。VFS_read时就会调用字符设备的file_operations。&lt;/p>
&lt;hr>
&lt;p>块设备的两种访问方法:&lt;/p>
&lt;p>一是访问裸分区，&lt;/p>
&lt;p>二是访问文件系统。&lt;/p>
&lt;p>当直接访问裸分区，是通过fs/block_dev.c 中的 file_operations def_blk_fops，也有read,write,open，一切继承到file_operations。如果是访问文件系统，就会通过实现 {ext4}_file_operations 来对接VFS对文件的操作。&lt;/p>
&lt;p>块设备驱动就不需要知道file_operations，无论是裸设备，还是文件系统的file。他们实现的file_operations是把linux中的各种设备，hook进 VFS的方法。&lt;/p>
&lt;h3 id="文件最终如何转化成对磁盘的访问">文件最终如何转化成对磁盘的访问？&lt;/h3>
&lt;p>file_operation 跟pagecache 以及硬盘的关系？&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/1072c5381bd5ae4a96ebd0ec110a1a25_1686x1186.png" alt="">&lt;/p>
&lt;p>整个文件系统里，除了放文件本身的数据，还包括文件的管理数据，包括&lt;/p>
&lt;ul>
&lt;li>super block，保存在全局的 superblock结构中。&lt;/li>
&lt;li>inode，是文件的唯一特定标识，文件系统使用bitmap来标识，inode是否使用。&lt;/li>
&lt;li>block bitmap，来表示这些block是否占用，它在改变文件大小，创建删除等操作时，都会改变。&lt;/li>
&lt;li>inode table/diagram ： bitmap 只是表示inode和block是否被占用。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://box.kancloud.cn/f00f3c82d9785e742b49db1975721a00_1666x1202.png" alt="">&lt;/p>
&lt;h3 id="超级块目录inode">超级块、目录、inode&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>file_system_type： 文件系统的类型，mount/umount 的时候会用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>superblock：包含super_operations，其中包含如何分配/销毁一个inode。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>inode：包含 inode_operations 和 file_operations。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> file_operations里面记录这种类型的文件包含哪些操作。
inode_operations里面包含如何生成新的inode，根据文件名字找到inode，如何mkdir,unlink.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>dentry: 对应路径，目录在文件系统里面是一个特殊的文件，文件的内容是一个inode和文件的表格。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>file:&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://box.kancloud.cn/8d9afa6c6797f98151f5f2ef9835d096_796x509.png" alt="">&lt;/p>
&lt;ul>
&lt;li>inode表：包含文件的一些基本信息，大小，创建日期，属性。还有一些成员指向硬盘所在的位置。
申请slab区域，比如 ext4_inode_cache , ext3_inode_cache. 这些cache会创建单独的slab，这些slab和内存里的page一一对应。&lt;/li>
&lt;/ul>
&lt;p>ext2/ext4文件系统中存在间接映射表。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/aedf91b68e0ddc9140f5cca3a57f162b_1574x1116.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/d2504c197b79aecf377855f29a810ba1_1498x1112.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/8116806badcf819ebf297c067976978c_1596x1094.png" alt="">&lt;/p>
&lt;p>硬盘里的inode diagram里的数据结构，在内存中会通过slab分配器，组织成 xxx_inode_cache，出现在meminfo的可回收的内存。 inode表也会记录每一个inode 在硬盘中摆放的位置。&lt;/p>
&lt;h3 id="目录的组织">目录的组织&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/43f11c7e2cc0fcc45e7891c932f82895_1464x1074.png" alt="">&lt;/p>
&lt;p>目录(dentry)在硬盘里是一个特殊的文件，和之前的file结构体不同。目录在硬盘中对应一个inode，记录文件的名字和inode号。查找一个文件时，文件系统的 根inode和目录，根据根目录和根inode，找到根目录所在硬盘的位置。再去做字符串匹配，能够找到 /A/B/ 。inode表也会记录每一个inode 在硬盘中摆放的位置。&lt;/p>
&lt;h3 id="发现并读取usrbinxxx的全流程">发现并读取/usr/bin/xxx的全流程&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/44f2fbe905a636b07986d3b69f795351_1680x1066.png" alt="">&lt;/p>
&lt;p>如上图，当你在硬盘查找 /usr/bin/emacs文件时，从根的inode和dentry，根据/的inode表，找到/ 目录文件所在的硬盘中的位置，读硬盘/目录文件的内容，发现 usr 对应inode 2, bin 对应inode 3, share 对应inode4。再去查inode表，inode 2所在硬盘的位置，即/usr 目录文件所在硬盘的位置。读出内容包括 var 对应 inode 10, bin 对应inode 11, opt对应inode 12，。&lt;/p>
&lt;p>这个过程会查找很多inode和 dentry，这些都会通过 icache 和dcache缓存。&lt;/p>
&lt;h2 id="符号链接-与-硬链接">符号链接 与 硬链接&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/b52f2fdfec772ded1282a69aa9e56b53_1216x794.png" alt="">&lt;/p>
&lt;p>文件名是特殊目录文件的内容，比如 A目录下有b\c\d，其实就是 A这个目录文件，里面对应目录b,c,d和对应inode的表。&lt;/p>
&lt;p>硬链接：在硬盘中是同一个inode存在，在目录文件中多了一个目录和inode对应。&lt;/p>
&lt;p>符号链接：是linux中是真实存在的实体文件，文件内容指向 其他文件。符号链接和文件是不同的inode。&lt;/p>
&lt;ol>
&lt;li>硬链接不能跨本地文件系统&lt;/li>
&lt;li>硬链接不能针对目录&lt;/li>
&lt;li>针对目录的软链接，用rm -fr 删除不了目录里的内容&lt;/li>
&lt;li>针对目录的软链接，&amp;ldquo;cd ..&amp;ldquo;进的是软链接所在目录的上级目录&lt;/li>
&lt;li>可以对文件执行unlink或rm，但是不能对目录执行unlink&lt;/li>
&lt;/ol>
&lt;h2 id="文件系统中的icache-和-dcache">文件系统中的icache 和 dcache&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/4200715ec3487a8ffb56d2281824275b_1204x806.png" alt="">&lt;/p>
&lt;p>文件系统在实现时，在vfs这一层的 inode cache 和 dentry cache，不管硬盘的系统，跨所有文件系统的通用信息。&lt;/p>
&lt;p>针对这些cache，这些可以回收的slab，linux提供了专门的slab shrink- 收缩函数。
最后所有可回收的内存，都必须通过&lt;code>LRU算法&lt;/code>去回收。
有些自己申请的 reclaim的内存，由于没有写 shrink函数，所以就无法进行内存的回收。&lt;/p>
&lt;h2 id="文件读写如何通过file_operation-和pagecache的关系">文件读写如何通过file_operation 和pagecache的关系，&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/71ce1fb31cdeed119f972c8b1771972c_1524x1100.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/6ed93b05cf6600220d744a0dcae115f9_1126x724.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/bdbb3ff0a3278c93493379a0f6076fc8_1202x730.png" alt="">&lt;/p>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Linux文件系统基础知识(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="linux文件系统基础知识转">Linux文件系统基础知识(转)&lt;/h1>
&lt;h3 id="文件系统的基本组成">文件系统的基本组成&lt;/h3>
&lt;p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。&lt;/p>
&lt;p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。&lt;/p>
&lt;p>Linux 最经典的一句话是：「&lt;strong>一切皆文件&lt;/strong>」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。&lt;/p>
&lt;p>Linux 文件系统会为每个文件分配两个数据结构：&lt;strong>索引节点（&lt;em>index node&lt;/em>）和目录项（&lt;em>directory entry&lt;/em>）&lt;/strong>，它们主要用来记录文件的元信息和目录层次结构。&lt;/p>
&lt;ul>
&lt;li>索引节点，也就是 &lt;em>inode&lt;/em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、&lt;strong>数据在磁盘的位置&lt;/strong>等等。索引节点是文件的&lt;strong>唯一&lt;/strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以&lt;strong>索引节点同样占用磁盘空间&lt;/strong>。&lt;/li>
&lt;li>目录项，也就是 &lt;em>dentry&lt;/em>，用来记录文件的名字、&lt;strong>索引节点指针&lt;/strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，&lt;strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。&lt;/p>
&lt;p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。&lt;/p>
&lt;blockquote>
&lt;p>目录项和目录是一个东西吗？&lt;/p>
&lt;/blockquote>
&lt;p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。&lt;/p>
&lt;p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。&lt;/p>
&lt;p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。&lt;/p>
&lt;blockquote>
&lt;p>那文件数据是如何存储在磁盘的呢？&lt;/p>
&lt;/blockquote>
&lt;p>磁盘读写的最小单位是&lt;strong>扇区&lt;/strong>，扇区的大小只有 &lt;code>512B&lt;/code> 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。&lt;/p>
&lt;p>所以，文件系统把多个扇区组成了一个&lt;strong>逻辑块&lt;/strong>，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 &lt;code>4KB&lt;/code>，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。&lt;/p>
&lt;p>以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-9d77e25913894df26b0374ceae25c605_1440w.jpg" alt="">&lt;/p>
&lt;p>索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。&lt;/p>
&lt;p>另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。&lt;/p>
&lt;p>- &lt;em>超级块&lt;/em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。&lt;/p>
&lt;p>- &lt;em>索引节点区&lt;/em>，用来存储索引节点； - &lt;em>数据块区&lt;/em>，用来存储文件或目录数据；&lt;/p>
&lt;p>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：&lt;/p>
&lt;ul>
&lt;li>超级块：当文件系统挂载时进入内存；&lt;/li>
&lt;li>索引节点区：当文件被访问时进入内存；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="虚拟文件系统">虚拟文件系统&lt;/h3>
&lt;p>文件系统的种类众多，而操作系统希望&lt;strong>对用户提供一个统一的接口&lt;/strong>，于是在用户层与文件系统层引入了中间层，这个中间层就称为&lt;strong>虚拟文件系统（&lt;em>Virtual File System，VFS&lt;/em>）。&lt;/strong>&lt;/p>
&lt;p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。&lt;/p>
&lt;p>在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-b92499b17ed11bc279689ecdb6efb4b6_1440w.jpg" alt="">&lt;/p>
&lt;p>Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：&lt;/p>
&lt;ul>
&lt;li>&lt;em>磁盘文件系统&lt;/em>，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。&lt;/li>
&lt;li>&lt;em>内存文件系统&lt;/em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 &lt;code>/proc&lt;/code> 和 &lt;code>/sys&lt;/code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。&lt;/li>
&lt;li>&lt;em>网络文件系统&lt;/em>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。&lt;/li>
&lt;/ul>
&lt;p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。&lt;/p>
&lt;hr>
&lt;h3 id="文件的使用">文件的使用&lt;/h3>
&lt;p>我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-bb6dc369fbf16afbdb088c6c7c26d9cc_1440w.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">打开文件&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,...);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">写数据&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">关闭文件&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面简单的代码是读取一个文件的过程：&lt;/p>
&lt;ul>
&lt;li>首先用 &lt;code>open&lt;/code> 系统调用打开文件，&lt;code>open&lt;/code> 的参数中包含文件的路径名和文件名。&lt;/li>
&lt;li>使用 &lt;code>write&lt;/code> 写数据，其中 &lt;code>write&lt;/code> 使用 &lt;code>open&lt;/code> 所返回的&lt;strong>文件描述符&lt;/strong>，并不使用文件名作为参数。&lt;/li>
&lt;li>使用完文件后，要用 &lt;code>close&lt;/code> 系统调用关闭文件，避免资源的泄露。&lt;/li>
&lt;/ul>
&lt;p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong>文件描述符&lt;/strong>」，所以说文件描述符是打开文件的标识。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-4d1f24d7102933f32a560a1cbdfce6da_1440w.jpg" alt="">&lt;/p>
&lt;p>操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p>
&lt;ul>
&lt;li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的； -&lt;/li>
&lt;li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目； -&lt;/li>
&lt;li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取； -&lt;/li>
&lt;li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/li>
&lt;/ul>
&lt;p>在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。&lt;/p>
&lt;p>所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。&lt;/p>
&lt;p>我们来分别看一下，读文件和写文件的过程：&lt;/p>
&lt;ul>
&lt;li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。&lt;/li>
&lt;li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。&lt;/li>
&lt;/ul>
&lt;p>所以说，&lt;strong>文件系统的基本操作单位是数据块&lt;/strong>。&lt;/p>
&lt;hr>
&lt;h3 id="文件的存储">文件的存储&lt;/h3>
&lt;p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p>
&lt;ul>
&lt;li>连续空间存放方式&lt;/li>
&lt;li>非连续空间存放方式&lt;/li>
&lt;/ul>
&lt;p>其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。&lt;/p>
&lt;p>不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。&lt;/p>
&lt;h3 id="连续空间存放方式">连续空间存放方式&lt;/h3>
&lt;p>连续空间存放方式顾名思义，&lt;strong>文件存放在磁盘「连续的」物理空间中&lt;/strong>。这种模式下，文件的数据都是紧密相连，&lt;strong>读写效率很高&lt;/strong>，因为一次磁盘寻道就可以读出整个文件。&lt;/p>
&lt;p>使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p>
&lt;p>所以，&lt;strong>文件头里需要指定「起始块的位置」和「长度」&lt;/strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p>
&lt;p>注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-7fc9cbf9c253d0ee84af8f61c605d50f_1440w.jpg" alt="">&lt;/p>
&lt;p>连续空间存放的方式虽然读写效率高，&lt;strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong>&lt;/p>
&lt;p>如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-5e0b69486a4e42554941c93a44d538e0_1440w.jpg" alt="">&lt;/p>
&lt;p>另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。&lt;/p>
&lt;p>那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。&lt;/p>
&lt;h3 id="非连续空间存放方式">非连续空间存放方式&lt;/h3>
&lt;p>非连续空间存放方式分为「链表方式」和「索引方式」。&lt;/p>
&lt;blockquote>
&lt;p>我们先来看看链表的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式存放是&lt;strong>离散的，不用连续的&lt;/strong>，于是就可以&lt;strong>消除磁盘碎片&lt;/strong>，可大大提高磁盘空间的利用率，同时&lt;strong>文件的长度可以动态扩展&lt;/strong>。根据实现的方式的不同，链表可分为「&lt;strong>隐式链表&lt;/strong>」和「&lt;strong>显式链接&lt;/strong>」两种形式。&lt;/p>
&lt;p>文件要以「&lt;strong>隐式链表&lt;/strong>」的方式存放的话，&lt;strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong>，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-b3d581a3d561f3386a497d5622180c81_1440w.jpg" alt="">&lt;/p>
&lt;p>隐式链表的存放方式的&lt;strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong>。隐式链接分配的&lt;strong>稳定性较差&lt;/strong>，系统在运行过程中由于软件或者硬件错误&lt;strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong>&lt;/p>
&lt;p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong>显式链接&lt;/strong>」，它指&lt;strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong>，该表在整个磁盘仅设置一张，&lt;strong>每个表项中存放链接指针，指向下一个数据块号&lt;/strong>。&lt;/p>
&lt;p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为&lt;strong>文件分配表（&lt;em>File Allocation Table，FAT&lt;/em>）&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-848b55299135f1775cb9fa5e6f9f9272_1440w.jpg" alt="">&lt;/p>
&lt;p>由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong>提高了检索速度&lt;/strong>，而且&lt;strong>大大减少了访问磁盘的次数&lt;/strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是&lt;strong>不适用于大磁盘&lt;/strong>。&lt;/p>
&lt;p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。&lt;/p>
&lt;blockquote>
&lt;p>接下来，我们来看看索引的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。&lt;/p>
&lt;p>索引的实现是为每个文件创建一个「&lt;strong>索引数据块&lt;/strong>」，里面存放的是&lt;strong>指向文件数据块的指针列表&lt;/strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p>
&lt;p>另外，&lt;strong>文件头需要包含指向「索引数据块」的指针&lt;/strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。&lt;/p>
&lt;p>创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-1e6d2ef6d8782117779143843798b79e_1440w.jpg" alt="">&lt;/p>
&lt;p>索引的方式优点在于：&lt;/p>
&lt;ul>
&lt;li>文件的创建、增大、缩小很方便；&lt;/li>
&lt;li>不会有碎片的问题；&lt;/li>
&lt;li>支持顺序读写和随机读写；&lt;/li>
&lt;/ul>
&lt;p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p>
&lt;p>如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p>
&lt;p>先来看看链表 + 索引的组合，这种组合称为「&lt;strong>链式索引块&lt;/strong>」，它的实现方式是&lt;strong>在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-ede534663e1c19169eb40cbe01384da2_1440w.jpg" alt="">&lt;/p>
&lt;p>还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong>多级索引块&lt;/strong>」，实现方式是&lt;strong>通过一个索引块来存放多个索引数据块&lt;/strong>，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-fb7d558d7b1d2d48fa4544adbead57bc_1440w.jpg" alt="">&lt;/p>
&lt;h3 id="unix-文件的实现方式">Unix 文件的实现方式&lt;/h3>
&lt;p>我们先把前面提到的文件实现方式，做个比较：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-e01c7af752461c0794a10f383dbe465b_1440w.jpg" alt="">&lt;/p>
&lt;p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-0c16919bcad17d1391f162e0363229b7_1440w.jpg" alt="">&lt;/p>
&lt;p>它是根据文件的大小，存放的方式会有所变化：&lt;/p>
&lt;ul>
&lt;li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；&lt;/li>
&lt;li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；&lt;/li>
&lt;li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；&lt;/li>
&lt;li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；&lt;/li>
&lt;/ul>
&lt;p>那么，文件头（&lt;em>Inode&lt;/em>）就需要包含 13 个指针：&lt;/p>
&lt;ul>
&lt;li>10 个指向数据块的指针；&lt;/li>
&lt;li>第 11 个指向索引块的指针；&lt;/li>
&lt;li>第 12 个指向二级索引块的指针；&lt;/li>
&lt;li>第 13 个指向三级索引块的指针；&lt;/li>
&lt;/ul>
&lt;p>所以，这种方式能很灵活地支持小文件和大文件的存放：&lt;/p>
&lt;ul>
&lt;li>对于小文件使用直接查找的方式可减少索引数据块的开销；&lt;/li>
&lt;li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；&lt;/li>
&lt;/ul>
&lt;p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。&lt;/p>
&lt;p>为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。&lt;/p>
&lt;hr>
&lt;h3 id="空闲空间管理">空闲空间管理&lt;/h3>
&lt;p>针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：&lt;/p>
&lt;ul>
&lt;li>空闲表法&lt;/li>
&lt;li>空闲链表法&lt;/li>
&lt;li>位图法&lt;/li>
&lt;/ul>
&lt;h3 id="空闲表法">空闲表法&lt;/h3>
&lt;p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-1ec1e7e0b313a92e0028691ae97c9766_1440w.jpg" alt="">&lt;/p>
&lt;p>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。&lt;/p>
&lt;p>这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p>
&lt;h3 id="空闲链表法">空闲链表法&lt;/h3>
&lt;p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-a14c65a4ec2fbb470fba728b818a6d22_1440w.jpg" alt="">&lt;/p>
&lt;p>当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p>
&lt;p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p>
&lt;p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p>
&lt;h3 id="位图法">位图法&lt;/h3>
&lt;p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p>
&lt;p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">1111110011111110001110110111111100111 ...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p>
&lt;hr>
&lt;h3 id="文件系统的结构">文件系统的结构&lt;/h3>
&lt;p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。&lt;/p>
&lt;p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code>4 * 1024 * 8 = 2^15&lt;/code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code>2^15 * 4 * 1024 = 2^27&lt;/code> 个 byte，也就是 128M。&lt;/p>
&lt;p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p>
&lt;p>在 Linux 文件系统，把这个结构称为一个&lt;strong>块组&lt;/strong>，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p>
&lt;p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-d9e36f97b24b2a7f760a81d0b095c36d_1440w.jpg" alt="">&lt;/p>
&lt;p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p>
&lt;ul>
&lt;li>- &lt;em>超级块&lt;/em>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/li>
&lt;li>- &lt;em>块组描述符&lt;/em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/li>
&lt;li>- &lt;em>数据位图和 inode 位图&lt;/em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/li>
&lt;li> &lt;em>inode 列表&lt;/em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/li>
&lt;li>&lt;em>数据块&lt;/em>，包含文件的有用数据。&lt;/li>
&lt;/ul>
&lt;p>你可以会发现每个块组里有很多重复的信息，比如&lt;strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong>，这么做是有两个原因：&lt;/p>
&lt;ul>
&lt;li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。 -&lt;/li>
&lt;li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/li>
&lt;/ul>
&lt;p>不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。&lt;/p>
&lt;hr>
&lt;h3 id="目录的存储">目录的存储&lt;/h3>
&lt;p>在前面，我们知道了一个普通文件是如何存储的，但还有一个特殊的文件，经常用到的目录，它是如何保存的呢？&lt;/p>
&lt;p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 &lt;code>vim&lt;/code> 打开它，它也有 inode，inode 里面也是指向一些块。&lt;/p>
&lt;p>和普通文件不同的是，&lt;strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong>&lt;/p>
&lt;p>在目录文件的块中，最简单的保存格式就是&lt;strong>列表&lt;/strong>，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p>
&lt;p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-89f1e2f2d2a2cb232920d2df16a5f3f4_1440w.jpg" alt="">&lt;/p>
&lt;p>通常，第一项是「&lt;code>.&lt;/code>」，表示当前目录，第二项是「&lt;code>..&lt;/code>」，表示上一级目录，接下来就是一项一项的文件名和 inode。&lt;/p>
&lt;p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p>
&lt;p>于是，保存目录的格式改成&lt;strong>哈希表&lt;/strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p>
&lt;p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。&lt;/p>
&lt;p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。&lt;/p>
&lt;hr>
&lt;h3 id="软链接和硬链接">软链接和硬链接&lt;/h3>
&lt;p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过&lt;strong>硬链接（&lt;em>Hard Link&lt;/em>）&lt;/strong> 和&lt;strong>软链接（&lt;em>Symbolic Link&lt;/em>）&lt;/strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。&lt;/p>
&lt;ul>
&lt;li>硬链接: &lt;strong>多个dentry中的inode指向一个文件&lt;/strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong>硬链接是不可用于跨文件系统的&lt;/strong>。由于多个&lt;code>dentry&lt;/code>都是指向一个 inode，那么&lt;strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-7cf8cec396a66dca2dd1fcd6dadab537_1440w.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>软链接相当于重新创建一个文件，这个文件有&lt;strong>独立的 inode&lt;/strong>，但是这个&lt;strong>文件的内容是另外一个文件的路径&lt;/strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，&lt;/li>
&lt;li>所以&lt;strong>软链接是可以跨文件系统的&lt;/strong>，甚至&lt;strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-5606413e1b5d2c727399711d347617a2_1440w.jpg" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="文件-io">文件 I/O&lt;/h3>
&lt;p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有&lt;/p>
&lt;ul>
&lt;li>缓冲与非缓冲 I/O&lt;/li>
&lt;li>直接与非直接 I/O&lt;/li>
&lt;li>阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/li>
&lt;/ul>
&lt;p>接下来，分别对这些分类讨论讨论。&lt;/p>
&lt;h3 id="缓冲与非缓冲-io">缓冲与非缓冲 I/O&lt;/h3>
&lt;p>文件操作的标准库是可以实现数据的缓存，那么&lt;strong>根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>缓冲 I/O：利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。&lt;/li>
&lt;li>非缓冲 I/O：直接通过系统调用访问文件，不经过标准库缓存。&lt;/li>
&lt;/ul>
&lt;p>这里所说的「缓冲」特指标准库内部实现的缓冲。&lt;/p>
&lt;p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。&lt;/p>
&lt;h3 id="直接与非直接-io">直接与非直接 I/O&lt;/h3>
&lt;p>我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。&lt;/p>
&lt;p>那么，&lt;strong>根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。&lt;/li>
&lt;li>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。&lt;/li>
&lt;/ul>
&lt;p>如果你在使用文件操作类的系统调用函数时，指定了 &lt;code>O_DIRECT&lt;/code> 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。&lt;/p>
&lt;blockquote>
&lt;p>如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？&lt;/p>
&lt;/blockquote>
&lt;p>以下几种场景会触发内核缓存的数据写入磁盘：&lt;/p>
&lt;ul>
&lt;li>在调用 &lt;code>write&lt;/code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上； -&lt;/li>
&lt;li>用户主动调用 &lt;code>sync&lt;/code>，内核缓存会刷到磁盘上； - 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上； -&lt;/li>
&lt;li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；&lt;/li>
&lt;/ul>
&lt;h3 id="阻塞与非阻塞-io-vs-同步与异步-io">阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/h3>
&lt;p>为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。&lt;/p>
&lt;p>先来看看&lt;strong>阻塞 I/O&lt;/strong>，当用户程序执行 &lt;code>read&lt;/code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，&lt;code>read&lt;/code> 才会返回。&lt;/p>
&lt;p>注意，&lt;strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程&lt;/strong>。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-7f73fdcaca316aa0f12d77b6873785e5_1440w.jpg" alt="">&lt;/p>
&lt;p>知道了阻塞 I/O ，来看看&lt;strong>非阻塞 I/O&lt;/strong>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，&lt;code>read&lt;/code> 调用才可以获取到结果。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-51e052e2beecef41da3aed3ebc2b80bd_1440w.jpg" alt="">&lt;/p>
&lt;p>注意，&lt;strong>这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。&lt;/strong>&lt;/p>
&lt;p>举个例子，访问管道或 socket 时，如果设置了 &lt;code>O_NONBLOCK&lt;/code> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。&lt;/p>
&lt;p>应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。&lt;/p>
&lt;p>为了解决这种傻乎乎轮询方式，于是 &lt;strong>I/O 多路复用&lt;/strong>技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。&lt;/p>
&lt;p>这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。&lt;/p>
&lt;p>下图是使用 select I/O 多路复用过程。注意，&lt;code>read&lt;/code> 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个&lt;strong>同步的过程&lt;/strong>，需要等待：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-02cfbd8572026087fc9b8e946b4d98bf_1440w.jpg" alt="">&lt;/p>
&lt;p>实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用&lt;strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。&lt;/strong>&lt;/p>
&lt;p>而真正的&lt;strong>异步 I/O&lt;/strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。&lt;/p>
&lt;p>当我们发起 &lt;code>aio_read&lt;/code> 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-b01988dd44a5edbe596a280d1c266033_1440w.jpg" alt="">&lt;/p>
&lt;p>下面这张图，总结了以上几种 I/O 模型：&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-1e7c3779cdf820da751a4fb1c84a602c_1440w.jpg" alt="">&lt;/p>
&lt;p>在前面我们知道了，I/O 是分为两个过程的：&lt;/p>
&lt;ol>
&lt;li>数据准备的过程 ；&lt;/li>
&lt;li>数据从内核空间拷贝到用户进程缓冲区的过程；&lt;/li>
&lt;/ol>
&lt;p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。&lt;/p>
&lt;p>异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p>
&lt;blockquote>
&lt;p>用故事去理解这几种 I/O 模型&lt;/p>
&lt;/blockquote>
&lt;p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p>
&lt;ul>
&lt;li>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/li>
&lt;li>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/li>
&lt;/ul>
&lt;p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code>select&lt;/code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p>
&lt;p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p></description></item><item><title>Linux系统调用之Futex</title><link>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</guid><description>&lt;h1 id="linux系统调用之futex">Linux系统调用之Futex&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>Futex（Fast Userspace muTexes）的缩写，由Hubertus Franke, Matthew Kirkwood, Ingo Molnar and Rusty Russell共同设计完成，&lt;/li>
&lt;li>Futex是一种用户态和内核态混合的同步机制。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>同步的进程间通过mmap共享一段内存，futex变量就位于这段共享 的内存中且操作是原子的，&lt;/li>
&lt;li>当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，
3. 如果没有竞争发生，则只修改futex,而不 用再执行系统调用了。
4. 如果有竞争发生，则执行系统调用去完成相应的处理(wait 或者 wake up)。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>futex()&lt;/code> 函数：&lt;/p>
&lt;ol>
&lt;li>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;/li>
&lt;li>不加timeout参数，它会一直被阻塞，直到FUTEX_WAKE:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/futex.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/time.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">futex&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">timespec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cp">#define __NR_futex 240
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。
FUTEX_WAKE: 最多唤醒val个等待在uaddr上进程。&lt;/p>
&lt;p>可见FUTEX_WAIT和FUTEX_WAKE只是用来挂起或者唤醒进程，当然这部分工作也只能在内核态下完成。有些人尝试着直接使用futex系统调 用来实现进程同步，并寄希望获得futex的性能优势，这是有问题的。应该区分futex同步机制和futex系统调用。futex同步机制还包括用户态 下的操作，我们将在下节提到。&lt;/p>
&lt;h2 id="futex同步机制">Futex同步机制&lt;/h2>
&lt;p>所有的futex同步操作都应该从用户空间开始，首先创建一个futex同步变量，也就是位于共享内存的一个整型计数器。
当 进程尝试持有锁或者要进入互斥区的时候，对futex执行&amp;quot;down&amp;quot;操作，即原子性的给futex同步变量减1。如果同步变量变为0，则没有竞争发生， 进程照常执行。如果同步变量是个负数，则意味着有竞争发生，需要调用futex系统调用的futex_wait操作休眠当前进程。
当进程释放锁或 者要离开互斥区的时候，对futex进行&amp;quot;up&amp;quot;操作，即原子性的给futex同步变量加1。如果同步变量由0变成1，则没有竞争发生，进程照常执行。如 果加之前同步变量是负数，则意味着有竞争发生，需要调用futex系统调用的futex_wake操作唤醒一个或者多个等待进程。&lt;/p>
&lt;p>这里的原子性加减通常是用CAS(Compare and Swap)完成的，与平台相关。CAS的基本形式是：CAS(addr,old,new),当addr中存放的值等于old时，用new对其替换。在x86平台上有专门的一条指令来完成它: cmpxchg。&lt;/p>
&lt;p>可见: futex是从用户态开始，由用户态和核心态协调完成的。&lt;/p>
&lt;h2 id="进线程利用futex同步">进/线程利用futex同步&lt;/h2>
&lt;p>进程或者线程都可以利用futex来进行同步。
对于线程，情况比较简单，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量。
对 于进程，情况相对复杂，因为进程有独立的虚拟内存空间，只有通过mmap()让它们共享一段地址空间来使用futex变量。每个进程用来访问futex的 虚拟地址可以是不一样的，只要系统知道所有的这些虚拟地址都映射到同一个物理内存地址，并用物理内存地址来唯一标识futex变量。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.shuzhiduo.com/A/rV57P2rLdP/">linux内核级同步机制&amp;ndash;futex&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/farmerjohngit/myblog/issues/6">关于同步的一点思考-上 · Issue #6 · farmerjohngit/myblog · GitHub&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>MySQL InnoDB 存储原理</title><link>https://justice.bj.cn/post/30.architech/mysql/mysql_innodb_%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/30.architech/mysql/mysql_innodb_%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="mysql-innodb-存储原理">MySQL InnoDB 存储原理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>mysql InnoDB 存储引擎&lt;/li>
&lt;/ul>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>mysql InnoDB存储引擎的数据以目录文件形式存储在磁盘中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个db 都会在 /var/lib/mysql/ 目录里面创建一个以 db 为名的目录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个db目录下包含：&lt;/p>
&lt;ul>
&lt;li>db.opt：db选项，记录当前数据库db的默认字符集和字符校验规则；&lt;/li>
&lt;li>table1.frm：表table1结构文件，保存每个表的元数据信息的，主要包含表结构定义；&lt;/li>
&lt;li>table1.ibd：表table1数据文件，表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@xiaolin ~]#ls /var/lib/mysql/my_test
db.opt
table1.frm
table1.ibd
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="表空间文件结构">表空间文件结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>表数据文件(.ibd)又叫表空间文件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>表空间由&lt;/p>
&lt;ul>
&lt;li>
&lt;p>行（row）：&lt;/p>
&lt;ul>
&lt;li>innodb中表记录的每行数据存储为一行；&lt;/li>
&lt;li>行是innodb数据存储基本单元；&lt;/li>
&lt;li>一行记录除了 TEXT、BLOBs 类型的列，最大为 65535(64K) 字节;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>页（page）：&lt;/p>
&lt;ul>
&lt;li>页是innodb的读写单元，innodb每次读写都是一个完整的page；&lt;/li>
&lt;li>每个页可以包含多个row；&lt;/li>
&lt;li>每个页默认大小16KB；&lt;/li>
&lt;li>页之间通过双向链表组织起来，逻辑上连续，物理上可能不连续；&lt;/li>
&lt;li>页通过&lt;/li>
&lt;li>页分为：
&lt;ul>
&lt;li>数据页：包含row记录；&lt;/li>
&lt;li>undo 日志页：；&lt;/li>
&lt;li>溢出页&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>区(extent):&lt;/p>
&lt;ul>
&lt;li>当表中数据量大时，为某个索引分配空间不按照页为单位分配了，而是按照区（extent）为单位分配；&lt;/li>
&lt;li>每个区中包含一系列相邻的页，使用顺序 I/O 了；&lt;/li>
&lt;li>每个区的大小为 1MB；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>段（segment）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>多个区（extent）组成段；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>段分为：&lt;/p>
&lt;ul>
&lt;li>索引段：存放 B + 树的非叶子节点的区的集合；&lt;/li>
&lt;li>数据段：存放 B + 树的叶子节点的区的集合；&lt;/li>
&lt;li>回滚段：存放的是回滚数据的区的集合，之前讲&lt;a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离 (opens new window)&lt;/a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>这些段共同组成表空间文件；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-17-52-49-2024-01-18-17-52-39-image.png" alt="">&lt;/p>
&lt;h2 id="行存储结构">行存储结构&lt;/h2>
&lt;p>InnoDB 的表行存储提供有 4 种行格式：&lt;/p>
&lt;ul>
&lt;li>Redundant： MySQL 5.0 版本之前用的行格式，不是一种紧凑的行格式；&lt;/li>
&lt;li>Compact：一种紧凑的行格式，可以让一个数据页中可以存放更多的行记录，是MySQL 5.1 版本之后的默认行格式；&lt;/li>
&lt;li>Dynamic：&lt;/li>
&lt;li>Compresse：&lt;/li>
&lt;/ul>
&lt;h3 id="compact格式行结构">Compact格式行结构&lt;/h3>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/2024-01-18-17-59-20-image.png" alt="">&lt;/p>
&lt;h3 id="记录的额外信息">记录的额外信息&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>变长字段长度列表&lt;/p>
&lt;ul>
&lt;li>记录varchar, text, blob等变长列的字节长度；&lt;/li>
&lt;li>按照列的顺序&lt;strong>逆序存放&lt;/strong>；&lt;/li>
&lt;li>不需要保存值为 NULL 的变长字段的长度；&lt;/li>
&lt;li>逆序存放是为了从记录头信息开始，位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line，提高效率；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>NULL 值列表&lt;/p>
&lt;ul>
&lt;li>记录可能会存储 NULL列是否是NULL值；&lt;/li>
&lt;li>每个列对应一个二进制位（bit），1代表NULL，0为非NULL；&lt;/li>
&lt;li>NULL 值列表必须用整数个字节的位表示，小于9个NULL列，用1个字节，否则用多个字节；&lt;/li>
&lt;li>NULL 值列表也不是必须的，当所有字段都定义成 NOT NULL 时，不需要NULL值列表；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>记录头信息&lt;/p>
&lt;ul>
&lt;li>
&lt;p>记录头信息中包含的内容很多；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delete_mask：标识此条数据是否被删除，执行 detele 删除记录的时候，并不会真正的删除记录，只是将该条记录的 delete_mask 标记为 1；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>next_record：下一条记录的位置。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>record_type：表示当前记录的类型。&lt;/p>
&lt;ul>
&lt;li>0：表示普通记录；&lt;/li>
&lt;li>1：表示B+树非叶子节点记录；&lt;/li>
&lt;li>2：表示最小记录；&lt;/li>
&lt;li>3：表示最大记录；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="隐藏字段">隐藏字段&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>row_id：&lt;/p>
&lt;ul>
&lt;li>建表时未指定主键和唯一约束列，则innodb将自动添加row_id，否则没有row_id；&lt;/li>
&lt;li>row_id不是必需的，有的话占用 6 个字节;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>trx_id：事务id&lt;/p>
&lt;ul>
&lt;li>表示这条记录是由哪个事务生成的；&lt;/li>
&lt;li>trx_id必需，占用 6 个字节；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>roll_pointer：回滚指针&lt;/p>
&lt;ul>
&lt;li>记录上一个版本的指针；&lt;/li>
&lt;li>roll_pointer 是必需的，占用 7 个字节。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="行溢出">行溢出&lt;/h3>
&lt;ul>
&lt;li>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中；&lt;/li>
&lt;li>发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-20-56-18-2024-01-18-20-56-12-image.png" alt="">&lt;/p>
&lt;h2 id="数据页结构">数据页结构&lt;/h2>
&lt;p>数据页包括七个部分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>File Header(文件头)：记录页信息， File Header 中有两个指针，分别指向上一个数据页和下一个数据页；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Page Hader(页头)：页状态信息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最大最小记录：页中最大记录，最小行记录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>User Records：一系列数据行记录；&lt;/p>
&lt;ul>
&lt;li>记录按照「主键」顺序组成单向链表；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>FreeSpace: 页中还未被行记录使用的空闲空间；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Page Directory：页目录，记录的索引作用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FileTailer：校验页是否完整；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-06-44-2024-01-18-21-06-19-image.png" alt="">&lt;/p>
&lt;p>多个数据页通过FileHeader中的2个指针组成双向链表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-07-34-2024-01-18-21-07-27-image.png" alt="">&lt;/p>
&lt;h3 id="页目录">页目录&lt;/h3>
&lt;p>页目录创建的过程如下：&lt;/p>
&lt;ol>
&lt;li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；&lt;/li>
&lt;li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）&lt;/li>
&lt;li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），&lt;strong>每个槽相当于指针指向了不同组的最后一个记录&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-26-44-2024-01-18-21-26-39-image.png" alt="">&lt;/p>
&lt;h3 id="b树结构">B+树结构&lt;/h3>
&lt;p>聚簇索引&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/18-21-09-12-2024-01-18-21-09-07-image.png" alt="">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84">从数据页的角度看 B+ 树 | 小林coding&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>NVMe</title><link>https://justice.bj.cn/post/40.storage/nvme%E7%AE%80%E4%BB%8B/</link><pubDate>Wed, 24 Apr 2024 12:31:05 +0800</pubDate><guid>https://justice.bj.cn/post/40.storage/nvme%E7%AE%80%E4%BB%8B/</guid><description>&lt;h1 id="nvme">NVMe&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>NVMe（Non-Volatile Memory Express）非易失性内存主机控制器接口规范，是一个主机控制器接口和存储协议，用于加速企业和客户端系统以及固态驱动器（SSD）之间的数据传输。它通过电脑的高速 PCIe 总线工作&lt;/p>
&lt;p>NVMe 自 Linux 内核 3.3 版本就支持了&lt;/p>
&lt;p>基于 SCSI 协议的 SAS 和 SATA&lt;strong>只能是单个队列&lt;/strong>而且每个队列的深度也比较低，分别是 254 和 32 的队列深度。而 NVMe 协议设计之初就考虑了该问题，它的最大队列数量可以是 64K（65535 个命令队列和 1 个管理队列），&lt;/p>
&lt;p>NVMe 协议可以最多有 64K 个队列，每个 CPU 或者核心都可以有一个队列，这样并发程度大大提升，性能也自然更高了&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/12/14-14-16-48-2020-12-14-14-16-42-image.png" alt="">&lt;/p></description></item><item><title>Tauri</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BA%93%E4%B9%8Btauri/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BA%93%E4%B9%8Btauri/</guid><description>&lt;h1 id="tauri">Tauri&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Tauri是一个类似electron的跨平台基于web的客户端框架。奥法队是非得失通过Tauri可以将web网站已本地客户端的方式在pc\mac上运行。所以一些web网站无法实现的功能比如读取存储本地文件，就可以通过Tauri上提供的api实现了。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2></description></item><item><title>Zeus- Uber的分布式Spark Shuffle Service</title><link>https://justice.bj.cn/post/30.architech/spark/zeus-uber-remote-spark-shuffle-service/</link><pubDate>Tue, 16 Apr 2024 17:06:35 +0800</pubDate><guid>https://justice.bj.cn/post/30.architech/spark/zeus-uber-remote-spark-shuffle-service/</guid><description>&lt;h1 id="zeus-uber的分布式spark-shuffle-service">Zeus: Uber的分布式Spark Shuffle Service&lt;/h1>
&lt;hr>
&lt;h2 id="特性">特性&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>垂直扩展&lt;/p>
&lt;ul>
&lt;li>
&lt;p>独立节点运行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>去中心化存储，节点无状态；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>解决网络延迟&lt;/p>
&lt;ul>
&lt;li>
&lt;p>降低服务响应等待时间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>流数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>性能优化&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-07-02-17-06-40-image.png" alt="">&lt;/p>
&lt;hr>
&lt;h2 id="优化点">优化点&lt;/h2>
&lt;h3 id="横向扩展">横向扩展&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>shuffle 服务独立，可在不同应用间共享；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>shuffle 节点无状态；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>shuffle 节点可根据需求横向扩展；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="分布式shuffle服务">分布式shuffle服务&lt;/h3>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/Documents/gitnote/img/2020-07-02-10-50-42-image.png" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="磁盘文件直接读写">磁盘文件直接读写&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>直接写入文件，无应用层的缓存；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>零拷贝&lt;/p>
&lt;/li>
&lt;li>
&lt;p>顺序读写，无随机磁盘IO；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="实现方面优化">实现方面优化&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Netty：高性能异步服务框架&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2个线程组：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>group1接收网络连接；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>group2读取数据；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>彼此不阻塞；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>二进制网络协议&lt;/p>
&lt;ul>
&lt;li>编码和压缩更有效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="客户端压缩">客户端压缩&lt;/h3>
&lt;ul>
&lt;li>shuffle client&lt;/li>
&lt;/ul></description></item><item><title>Zerotier</title><link>https://justice.bj.cn/post/70.tool/zerotier/</link><pubDate>Thu, 28 Mar 2024 20:55:30 +0800</pubDate><guid>https://justice.bj.cn/post/70.tool/zerotier/</guid><description>&lt;h1 id="zerotier">Zerotier&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>zerotier是一款智能可编程以太网交换软件，只需要经过简单的注册，安装和配置，即可建立VPN。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h3 id="小米mini-wifi安装zerotier">小米mini wifi安装zerotier&lt;/h3>
&lt;h3 id="架构">架构&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>家中小米路由器(mini-wifi)上安装zerotier路由器版;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>手机安装zerotier android版；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将这些设备都加入到一个zerotier 虚拟局域网中，以达到随时可相互访问的目的;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="准备工作">准备工作&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>登陆&lt;a href="https://www.zerotier.com/">zerotier官网&lt;/a>，注册账号，申请网络ID；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按小米路由官方提示开启小米mini-wifi的ssh登陆功能；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="操作">操作&lt;/h4>
&lt;ol>
&lt;li>ssh 到mini wifi中，进行如下操作：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 使用ssh登陆到mini-wifi中&lt;/span>
&lt;span class="o">[&lt;/span>your-pc&lt;span class="o">]&lt;/span>$ ssh root@192.168.xx.x
&lt;span class="c1">## 进入小米路由外接磁盘目录&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># cd /extdisks/sda1/xiaomi_router/&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># mkdir -p opt/zerotier/pkg opt/bin opt/conf&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># cd opt/zerotier/pkg&lt;/span>
&lt;span class="c1">## 下载zerotier-one 二进制程序&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># wget http://pkg.entware.net/binaries/mipsel/zerotier_1.1.14-4_mipselsf.ipk&lt;/span>
&lt;span class="c1"># tar xf zerotier_1.1.14-4_mipselsf.ipk&lt;/span>
&lt;span class="c1">## 启动zerotier守护进程&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># zerotier-one -D /extdisks/sda1/xiaomi_router/opt/zerotier/data&lt;/span>
&lt;span class="c1">## 加入zerotier网络&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># zerotier-cli -D/extdisks/sda1/xiaomi_router/opt/zerotier/data join &amp;lt;NETWORK_ID&amp;gt;&lt;/span>
&lt;span class="c1">## 查看状态&lt;/span>
&lt;span class="o">[&lt;/span>root&lt;span class="o">]&lt;/span>&lt;span class="c1"># zerotier-cli -D/extdisks/sda1/xiaomi_router/opt/zerotier/data status&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>
&lt;p>上my.zerotier.com上“setting”-&amp;gt;&amp;ldquo;Advance&amp;quot;中增加路由规则，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Destination：内网网段，路由默认为: 192.168.31.0/24&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Via: zerotier分配给路由的ip&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>设置完成后，在手机上安装zerotier，加入网络后，可通过手机访问家中网络；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="nat模式访问内网设备">NAT模式访问内网设备&lt;/h4>
&lt;p>内网路由器安装zerotier并加入，外网设备(如手机)通过NAT模式访问内网其他设备&lt;/p>
&lt;p>路由器设置NAT路由转发规则如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">root@XiaoQiang:~# ZT_IF=zt0
root@XiaoQiang:~# iptables -I FORWARD -o $ZT_IF -j ACCEPT
root@XiaoQiang:~# iptables -I FORWARD -i $ZT_IF=zt0 -j ACCEPT
root@XiaoQiang:~# iptables -t nat -I POSTROUTING -o $ZT_IF -j MASQUERADE
root@XiaoQiang:~# iptables-save
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.zerotier.com/">https://www.zerotier.com/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/zerotier/ZeroTierOne">https://github.com/zerotier/ZeroTierOne&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.entware.net/binaries/mipsel/">https://pkg.entware.net/binaries/mipsel/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://post.smzdm.com/p/a5d09ln8/">小米路由3安装Zerotier_路由器_什么值得买&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>专题：动态规划</title><link>https://justice.bj.cn/post/leetcode/%E4%B8%93%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Thu, 28 Mar 2024 20:55:30 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/%E4%B8%93%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>&lt;h1 id="专题动态规划">专题：动态规划&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>动态规划问题的难点在于对问题进行合理划分，将大问题转变为小问题的组合，形成递推关系，通过归纳法将问题得到解决；&lt;/p>
&lt;p>动态规划最关键的地方在于对问题进行正确的抽象和建模，进而建立递推公式；&lt;/p>
&lt;h2 id="步骤">步骤&lt;/h2>
&lt;ul>
&lt;li>函数定义：定义问题目标函数，目标函数可通过子目标函数组合而成，子函数需要包含目标函数的所有情形且不能重叠；&lt;/li>
&lt;li>递推公式：定义最终函数 和 子目标函数之间的递推关系，通过将目标问题分解为规模更小的子问题组合来递推解决目标问题；&lt;/li>
&lt;li>初始条件：&lt;/li>
&lt;li>终止条件:&lt;/li>
&lt;/ul>
&lt;h2 id="相关题目">相关题目&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>题目&lt;/th>
&lt;th>难度&lt;/th>
&lt;th>关键思路&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="../../5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">5.最长回文子串&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../10.%E6%AD%A3%E5%88%99%E5%BC%8F%E5%8C%B9%E9%85%8D">10.正则式匹配&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">62.不同路径&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii">63.不同路径 II&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../403.%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3">403.青蛙过河&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../97.%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2">97.交错字符串&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="./115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.md" title="https://leetcode.cn/problems/distinct-subsequences/description/">115.不同的子序列&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139.单词拆分&lt;/a>&lt;/td>
&lt;td>**&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../887.%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD">887.鸡蛋掉落&lt;/a>&lt;/td>
&lt;td>***&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>鸡蛋掉落</title><link>https://justice.bj.cn/post/leetcode/887.%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/</link><pubDate>Thu, 07 Mar 2024 14:02:17 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/887.%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/</guid><description>&lt;h1 id="鸡蛋掉落httpsleetcodecnproblemssuper-egg-dropdescription-httpsleetcodecnproblemssuper-egg-dropdescription">&lt;a href="https://leetcode.cn/problems/super-egg-drop/description/" title="https://leetcode.cn/problems/super-egg-drop/description/">鸡蛋掉落&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Hard (30.83%)&lt;/td>
&lt;td>985&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/heap" title="https://leetcode.com/tag/heap">&lt;code>heap&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>Unknown&lt;/code>&lt;/p>
&lt;p>给你 &lt;code>k&lt;/code> 枚相同的鸡蛋，并可以使用一栋从第 &lt;code>1&lt;/code> 层到第 &lt;code>n&lt;/code> 层共有 &lt;code>n&lt;/code> 层楼的建筑。&lt;/p>
&lt;p>已知存在楼层 &lt;code>f&lt;/code> ，满足 &lt;code>0 &amp;lt;= f &amp;lt;= n&lt;/code> ，任何从 &lt;strong>高于&lt;/strong> &lt;code>f&lt;/code> 的楼层落下的鸡蛋都会碎，从 &lt;code>f&lt;/code> 楼层或比它低的楼层落下的鸡蛋都不会破。&lt;/p>
&lt;p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 &lt;code>x&lt;/code> 扔下（满足 &lt;code>1 &amp;lt;= x &amp;lt;= n&lt;/code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 &lt;strong>重复使用&lt;/strong> 这枚鸡蛋。&lt;/p>
&lt;p>请你计算并返回要确定 &lt;code>f&lt;/code> &lt;strong>确切的值&lt;/strong> 的 &lt;strong>最小操作次数&lt;/strong> 是多少？&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
如果它没碎，那么肯定能得出 f = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：k = 2, n = 6
输出：3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：k = 3, n = 14
输出：4
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= k &amp;lt;= 100&lt;/code>&lt;/li>
&lt;li>&lt;code>1 &amp;lt;= n &amp;lt;= 104&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode.cn/problems/super-egg-drop/comments/" title="https://leetcode.cn/problems/super-egg-drop/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode.cn/problems/super-egg-drop/solution/" title="https://leetcode.cn/problems/super-egg-drop/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;span class="lnt">81
&lt;/span>&lt;span class="lnt">82
&lt;/span>&lt;span class="lnt">83
&lt;/span>&lt;span class="lnt">84
&lt;/span>&lt;span class="lnt">85
&lt;/span>&lt;span class="lnt">86
&lt;/span>&lt;span class="lnt">87
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Solution&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// @lc code=start
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// ## 鸡蛋掉落
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// - 动态规划1(超时)
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 1. 设 dp[i][j] 表示总共有i个鸡蛋, 总共j层楼时, 确定目标楼层f的最小操作次数;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 2. 如果最开始选择在x楼(1&amp;lt;=x&amp;lt;=j)扔1个鸡蛋, 此时会有两种情况：
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 鸡蛋未破, 则目标楼层一定不在`[1,x)`中, 此时可继续用i个鸡蛋在`(x,n]`楼层中尝试.
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 后续为确定目标楼层的最小操作次数为: dp[i][j-x]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// b. 鸡蛋破裂, 则目标楼层一定不在`(x,j]`中, 此时可用剩下的i-1个鸡蛋在`[1,x)`楼层中继续尝试.
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 后续为确定目标楼层的最小操作次数为: dp[i-1][x-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 综合以上情况, 如果扔1枚鸡蛋在x楼后, 为保证一定能确定目标楼层, 后续最小操作次数为:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// max(dp[i][j-x], dp[i-1][x-1])
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 那么, 依次从`[1,j]`中选择开始楼层x扔鸡蛋, 选择总操作数最小的即为dp[i][j]:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// min(max(dp[i][j-x], dp[i-1][x-1]) + 1) ( 1 &amp;lt;= x &amp;lt;= j )
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 3. 综上可得递推关系:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// dp[i][j] = 1 + min(max(dp[i][j-k], dp[i-1][k-1])) ( 1 &amp;lt;= k &amp;lt;= j )
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 4. 初始条件: 当只有1个鸡蛋时, 需要从低到高逐层进行尝试, 最坏情况需要到最高一层n才能确定,
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 因此: dp[1][j] = j ( 1 &amp;lt;= j &amp;lt;= n )
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 5. 目标值: dp[k][n]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">i32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 初始条件
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">min&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unwrap_or&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// ## 鸡蛋掉落
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// - 动态规划2
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 1. 设 dp[i][j] 表示: 总共有i个鸡蛋, 扔鸡蛋j次, 最多可检测的楼层数;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 2. 扔1次鸡蛋后(不论扔在那个楼层), 有两种情况:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 鸡蛋未破, 剩余i个鸡蛋, 剩余操作次数j-1, 最多检测楼层数为: dp[i][j-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// b. 鸡蛋破了, 剩余i-1个鸡蛋, 剩余操作次数j-1, 最多可检测楼层数为: dp[i-1][j-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 那么, 最多可检测楼层总数:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// dp[i][j] = 1 + dp[i][j-1] + dp[i-1][j-1]
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 3. 初始条件:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 鸡蛋个数i: 1 &amp;lt;= i &amp;lt;= k
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// a. 总操作次数j最多为楼层数: 1 &amp;lt;= j &amp;lt;= n;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// b. 1个鸡蛋1次最多可检测楼层数为1: dp[1][1] = 1;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 4. 目标:
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// i, j 由小到大, 当: i == k &amp;amp;&amp;amp; dp[i][j] &amp;gt;= n时, j的值
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">i32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// @lc code=end
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="cp">#[cfg(test)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">tests&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">super&lt;/span>::&lt;span class="o">*&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="cp">#[test]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">test&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">assert_eq&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">super_egg_drop1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://algo.itcharge.cn/Solutions/0800-0899/super-egg-drop/">0887. 鸡蛋掉落 | 算法通关手册（LeetCode）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>CPU异常</title><link>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/05-cpu-exceptions/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/writing-an-os-in-rust/05-cpu-exceptions/</guid><description>&lt;h1 id="cpu异常">CPU异常&lt;/h1>
&lt;blockquote>
&lt;p>原文：&lt;a href="https://os.phil-opp.com/cpu-exceptions/">https://os.phil-opp.com/cpu-exceptions/&lt;/a>&lt;/p>
&lt;p>原作者：@phil-opp&lt;/p>
&lt;p>译者：&lt;a href="https://github.com/niguangye">倪广野&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>触发CPU异常的情况多种多样，例如：访问非法内存地址或执行非法指令（除以零）等。为了应对CPU异常，我们需要建立中断描述符表（interrupt descriptor table)，它列举了不同异常所对应的处理函数(handler functions)。在博文的最后，我们的内核（kernel)可以捕获断点异常（&lt;a href="https://wiki.osdev.org/Exceptions#Breakpoint">breakpoint exceptions&lt;/a>）并且恢复CPU的正常运行。&lt;/p>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>异常的发生标志着当前正在执行的指令出现了问题。例如：指令试图除以0的时候，CPU会抛出一个异常。当异常发生，CPU会中断（interrupt）它当前的流程，并立即调用该类型异常对应的处理函数。&lt;/p>
&lt;p>在x86体系结构中，有大约20种不同的CPU 异常类型。常见的如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>缺页错误（Page Fault）&lt;/strong>：缺页错误发生在非法的内存访问操作中。例如：当前指令试图访问没有映射的内存页或试图写入只读的内存页。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>非法操作码（Invalid Opcode）&lt;/strong>：非法操作码发生在当前指令不正确的情况下。例如：试图在不支持 &lt;a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE 指令集&lt;/a> 的老旧CPU上使用该指令集。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>通用保护错误（General Protection Fault）&lt;/strong>：这是一个触发原因相对宽泛的异常。试图在用户态程序中执行特权指令或试图写入配置寄存器的保留位等非法访问操作均会触发该异常。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>双重异常（Double Fault）&lt;/strong>：异常发生后，CPU会调用对应的异常处理函数。在调用过程中如果发生另一个异常，CPU会触发双重异常。双重异常也会在找不到对应的异常处理函数的情况下发生。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>三重异常（Triple Fault）&lt;/strong>：如果异常发生在CPU调用双重异常处理函数的过程中，这会导致严重的三重异常。我们不能捕获或者处理三重异常。大多数处理器会选择复位并重启操作系统。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>你可以在&lt;a href="https://wiki.osdev.org/Exceptions">这里&lt;/a>找到所有的CPU异常列表。&lt;/p>
&lt;h3 id="中断描述符表interrupt-descriptor-table">中断描述符表（interrupt descriptor table)&lt;/h3>
&lt;p>为了捕获并处理CPU异常，我们需要建立所谓的中断描述符表（interrupt descriptor table，IDT)。在IDT中，我们可以为每种异常指定一个处理函数。硬件会直接使用这张表，所以我们需要遵循提前约定好的格式。IDT的每一项（entry）必须是16字节的结构：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Type&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>u16&lt;/td>
&lt;td>函数指针 [0:15]&lt;/td>
&lt;td>处理函数（handler function)指针的低16位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u16&lt;/td>
&lt;td>GDT 选择子&lt;/td>
&lt;td>&lt;a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">global descriptor table&lt;/a> 代码段的选择子&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u16&lt;/td>
&lt;td>选项参数&lt;/td>
&lt;td>参见下文&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u16&lt;/td>
&lt;td>函数指针 [16:31]&lt;/td>
&lt;td>处理函数（handler function)指针的中间16位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u32&lt;/td>
&lt;td>函数指针 [32:63]&lt;/td>
&lt;td>处理函数（handler function)指针剩下的32位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>u32&lt;/td>
&lt;td>保留位&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>选项参数必须是下面的结构：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bits&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0-2&lt;/td>
&lt;td>中断栈表索引&lt;/td>
&lt;td>0: 不切换栈, 1-7:当处理函数被调用时，切换到中断栈表（Interrupt Stack Table）的第n个栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3-7&lt;/td>
&lt;td>保留位&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>0: 中断门, 1: 陷阱门&lt;/td>
&lt;td>如果这个bit被设置为0，处理函数被调用的时候，中断会被禁用。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9-11&lt;/td>
&lt;td>必须为1&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12&lt;/td>
&lt;td>必须为0&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13‑14&lt;/td>
&lt;td>特权等级描述符 (DPL)&lt;/td>
&lt;td>允许调用该处理函数的最小特权等级。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>15&lt;/td>
&lt;td>Present&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>每个异常都拥有提前约定好的IDT索引。例如：非法操作码的表索引是6，而缺页错误的的表索引是14。因此，硬件可以找到每种异常对应的中断描述符表的条目（interrupt descriptor table entry, IDT entry)。&lt;a href="https://wiki.osdev.org/Exceptions">OSDev wiki&lt;/a>页面的Exception Table的“Vector nr.”列展示了所有异常的IDT索引。&lt;/p>
&lt;p>当异常发生时，CPU大致遵循下面的流程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将一些寄存器的内容压入栈中，包括当前指令的指针和&lt;a href="http://en.wikipedia.org/wiki/FLAGS_register">RFLAGS&lt;/a>寄存器的内容（我们会在文章的后续部分用到这些值）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读取中断描述符表（IDT）中对应的条目。例如：缺页错误发生时，CPU会读取IDT的第十四个条目。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查这个条目是否存在，如果没有则升级为双重错误（double fault)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果条目是一个中断门（第40个bit没有被设置为1），则禁用硬件中断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>装载指定的GDT 选择子到CS段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>跳转到指定的处理函数。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>现在不要担心第四、五步，我们会在未来的文章中研究GDT和硬件中断。&lt;/p>
&lt;h2 id="一个idt类型an-idt-type">一个IDT类型（An IDT Type)&lt;/h2>
&lt;p>我们选择使用&lt;code>x86_64&lt;/code> crate中的 &lt;code>InterruptDescriptorTable&lt;/code> 结构体，而不是创建自己的 IDT 类型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="cp">#[repr(C)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">InterruptDescriptorTable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">divide_by_zero&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">debug&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">non_maskable_interrupt&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="n">point&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">overflow&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bound_range_exceeded&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">invalid_opcode&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">device_not_available&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">double_fault&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFuncWithErrCode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">invalid_tss&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFuncWithErrCode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">segment_not_present&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFuncWithErrCode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">stack_segment_fault&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFuncWithErrCode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">general_protection_fault&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFuncWithErrCode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">page_fault&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">PageFaultHandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x87_floating_point&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">alignment_check&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFuncWithErrCode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">machine_check&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">simd_floating_point&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">virtualization&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFunc&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">security_exception&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HandlerFuncWithErrCode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// some fields omitted
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>InterruptDescriptorTable&lt;/code>结构体的字段都是&lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/struct.Entry.html">&lt;code>idt::Entry&lt;/code>&lt;/a>类型，这种类型是一种代表&lt;code>IDT&lt;/code>条目字段的结构体（见上面的示例）。类型参数&lt;code>F&lt;/code>定义了预期的处理函数类型。我们可以发现上面的条目字段需要 &lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/type.HandlerFunc.html">&lt;code>HandlerFunc &lt;/code>&lt;/a> 或 &lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/type.HandlerFuncWithErrCode.html">&lt;code>HandlerFuncWithErrCode &lt;/code>&lt;/a> 参数。缺页错误甚至拥有它独有的处理函数类型：&lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/type.PageFaultHandlerFunc.html">&lt;code>PageFaultHandlerFunc &lt;/code>&lt;/a> 。&lt;/p>
&lt;p>首先，我们探讨一下 &lt;code>HandlerFunc&lt;/code> 类型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">type&lt;/span> &lt;span class="nc">HandlerFunc&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">extern&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;x86-interrupt&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptStackFrame&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>HandlerFunc &lt;/code> 是 &lt;code>extern &amp;quot;x86-interrupt&amp;quot; fn&lt;/code> 的类型别名。&lt;code>extern&lt;/code> 关键字定义了一个外部调用约定（ &lt;a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">foreign calling convention&lt;/a> ），它经常被用于链接C语言代码（&lt;code>extern &amp;quot;C&amp;quot; fn&lt;/code>）。那么，&lt;code>x86-interrupt&lt;/code>调用约定是什么呢?&lt;/p>
&lt;h2 id="中断调用约定-the-interrupt-calling-convention">中断调用约定（ The Interrupt Calling Convention）&lt;/h2>
&lt;p>CPU异常与函数调用非常相似：CPU跳转到调用函数的第一条指令并执行它。然后，CPU跳转到返回地址并继续执行函数的调用者函数（&lt;code>parent function&lt;/code>)。&lt;/p>
&lt;p>然而，异常和函数调用有一个重要的区别：函数调用是被编译器生成的 &lt;code>call&lt;/code> 指令主动发起，而&lt;/p>
&lt;p>异常可以发生在所有指令的执行过程中。为了理解这个区别的重要性，我们需要更进一步地研究函数调用。&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Calling_convention">调用约定 Calling conventions&lt;/a> 明确规定了函数调用的细节。例如，它规定了函数参数的位置（ 寄存器还是函数栈）和结果的返回方式。在x86_64 Linux体系中，C语言函数调用适用下面的规则（在&lt;a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">System V ABI&lt;/a>中规定）：&lt;/p>
&lt;ul>
&lt;li>前六个整数参数会被放在寄存器中传递：&lt;code>rdi&lt;/code>, &lt;code>rsi&lt;/code>, &lt;code>rdx&lt;/code>, &lt;code>rcx&lt;/code>, &lt;code>r8&lt;/code>, &lt;code>r9&lt;/code>&lt;/li>
&lt;li>剩下的参数被放在栈中传递&lt;/li>
&lt;li>结果被放在 &lt;code>rax&lt;/code> 和 &lt;code>rdx&lt;/code> 中返回&lt;/li>
&lt;/ul>
&lt;p>Rust 没有遵顼C ABI （事实上，Rust甚至没有规定的ABI），所以这些规则仅仅适用于声明了 &lt;code>extern &amp;quot;C&amp;quot; fn&lt;/code> 的函数。&lt;/p>
&lt;h3 id="preserved-and-scratch-寄存器">Preserved and Scratch 寄存器&lt;/h3>
&lt;p>调用约定（ &lt;code>calling convention&lt;/code>）将寄存器分为两个部分： &lt;em>preserved&lt;/em> 和 &lt;em>scratch&lt;/em> 寄存器。&lt;/p>
&lt;p>在函数调用的过程中，&lt;em>preserved&lt;/em>寄存器的值必须保持不变。所以，被调用的函数（&lt;code>callee&lt;/code>）必须保证会在返回以前会主动复原这些寄存器的原始值，才可以修改这些寄存器的值。因此，这些寄存器被称为被&lt;strong>调用者保存寄存器&lt;/strong>（&lt;em>callee-saved&lt;/em>，译者注：也就是AKA非易失性寄存器）。通行的模式是在函数的开始保存这些寄存器的值到函数栈中，并在函数马上返回的时候复原他们。&lt;/p>
&lt;p>相比之下，被调用的函数（&lt;code>callee&lt;/code>）可以无约束地修改 &lt;em>scratch&lt;/em>寄存器。如果调用者函数希望在函数调用的过程中保留 &lt;em>scratch&lt;/em>寄存器的值，它需要在调用函数之前备份和复原 &lt;em>scratch&lt;/em>寄存器的值（例如将这些值压入栈中）。所以，这些寄存器被称为&lt;strong>调用者寄存器&lt;/strong>（&lt;em>caller-saved&lt;/em>，译者注：也就是AKA易失性寄存器）。&lt;/p>
&lt;p>在x86_64架构中，C语言调用约定明确规定了下面的 preserved and scratch 寄存器：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>preserved 寄存器&lt;/th>
&lt;th>scratch 寄存器&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>rbp&lt;/code>, &lt;code>rbx&lt;/code>, &lt;code>rsp&lt;/code>, &lt;code>r12&lt;/code>, &lt;code>r13&lt;/code>, &lt;code>r14&lt;/code>, &lt;code>r15&lt;/code>&lt;/td>
&lt;td>&lt;code>rax&lt;/code>, &lt;code>rcx&lt;/code>, &lt;code>rdx&lt;/code>, &lt;code>rsi&lt;/code>, &lt;code>rdi&lt;/code>, &lt;code>r8&lt;/code>, &lt;code>r9&lt;/code>, &lt;code>r10&lt;/code>, &lt;code>r11&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;em>callee-saved&lt;/em>&lt;/td>
&lt;td>&lt;em>caller-saved&lt;/em>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>编译器遵顼这些规定生成二进制字节码。例如：绝大多数函数地字节码开始于&lt;code>push rbp&lt;/code>指令，这个指令会备份&lt;code>rbp&lt;/code>寄存器地值到函数栈中（因为这是一个&lt;code>callee-saved&lt;/code>寄存器）。&lt;/p>
&lt;h3 id="保存所有寄存器">保存所有寄存器&lt;/h3>
&lt;p>与函数调用形成鲜明对比的是，异常可以发生在所有指令的执行过程中。大多数情况下，我们甚至不能识别出编译器生成的代码是否会引起异常。例如，编译器不能预见到一个指令是否会引起栈溢出或缺页错误。&lt;/p>
&lt;p>既然不能预见到异常的发生时机，我们自然也无法做到提前备份任何寄存器的值。这意味着我们不能使用依赖于 &lt;code>caller-saved&lt;/code> 寄存器的调用约定去处理异常。然而，我们需要一个会保存所有寄存器值的调用约定。&lt;code>x86-interrupt&lt;/code>调用约定恰恰能够保证所有寄存器会在函数调用结束以前复原到原始值。&lt;/p>
&lt;p>这并不意味着所有寄存器的值会在函数开始时被保存到函数栈中。相反，编译器（生成的代码）只会备份被函数覆盖的寄存器的值。在这种方式下，较短的函数编译生成的二进制字节码会非常高效，也就是只使用尽可能少的寄存器。&lt;/p>
&lt;h3 id="中断栈帧-the-interrupt-stack-frame">中断栈帧（ The Interrupt Stack Frame）&lt;/h3>
&lt;p>在寻常的函数调用（&lt;code>call&lt;/code>指令执行）中，CPU跳转到相应的函数之前会将返回地址压入到函数栈中。在函数返回（&lt;code>ret&lt;/code>指令执行）的时候，CPU会弹出并跳转到这个返回地址。所以，寻常的函数调用栈帧会如下图所示：&lt;/p>
&lt;p>&lt;img src="https://markdown-ngy.oss-cn-beijing.aliyuncs.com/function-stack-frame.svg" alt="function-stack-frame">&lt;/p>
&lt;p>然而，异常和中断处理函数并不能将返回地址压入到函数栈中，因为中断处理函数往往运行在不同的上下文（栈指针，CPU flags等）中。相反，在异常发生的时候，CPU会执行以下步骤：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>对齐栈指针&lt;/strong>：中断可以发生在任何指令的执行过程中，栈指针自然也可能是任何值。然而，一些CPU指令集（e.g. 一些 SSE指令集）需要栈指针在16字节边界上对齐，因此CPU会在中断之后靠右对齐栈指针。&lt;/li>
&lt;li>&lt;strong>切换栈（在某种情况下）&lt;/strong>：CPU特权等级发生改变的时候，栈会被切换，例如CPU 异常发生在用户态程序的时候。用所谓的中断栈表（ &lt;em>Interrupt Stack Table&lt;/em> , 下篇文章解释 ）配置特定中断的栈切换也是可行的。&lt;/li>
&lt;li>&lt;strong>压入原来的栈指针&lt;/strong>：在中断发生的时候（对齐栈指针发生之前），CPU将栈指针（&lt;code>rsp&lt;/code>）和栈段（&lt;code>ss&lt;/code>)寄存器压入栈中。如此一来，中断处理函数返回时就可以复原栈指针的原始值。&lt;/li>
&lt;li>&lt;strong>压入并更新&lt;code>RFLAGS&lt;/code>寄存器&lt;/strong>：&lt;a href="https://en.wikipedia.org/wiki/FLAGS_register">&lt;code>RFLAGS&lt;/code>&lt;/a>寄存器保存了多种控制和状态位。进入中断函数时，CPU修改一些位并压入旧的值。&lt;/li>
&lt;li>&lt;strong>压入指令指针&lt;/strong>：跳转到中断处理函数之前，CPU压入指令指针（&lt;code>rip&lt;/code>）和代码段（&lt;code>cs&lt;/code>)。这类似于寻常的函数调用压入返回地址的过程。&lt;/li>
&lt;li>&lt;strong>压入错误码（对于部分异常）&lt;/strong>：对于缺页错误等特定的异常，CPU会压入解释异常原因的错误码。&lt;/li>
&lt;li>&lt;strong>调用中断处理函数&lt;/strong>：CPU从IDT对应的字段中读取中断处理函数的地址和段描述符。然后通过加载这些值到&lt;code>rip&lt;/code>和&lt;code>cs&lt;/code>寄存器中，调用中断处理函数。&lt;/li>
&lt;/ol>
&lt;p>所以，中断调用栈帧会如下图所示：&lt;/p>
&lt;p>&lt;img src="https://markdown-ngy.oss-cn-beijing.aliyuncs.com/exception-stack-frame.svg" alt="exception-stack-frame">&lt;/p>
&lt;p>在Rust的&lt;code>x86_64&lt;/code>库中，中断调用栈帧被抽象为&lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/struct.InterruptStackFrame.html">&lt;code>InterruptStackFrame&lt;/code>&lt;/a>结构体。它会被作为&lt;code>&amp;amp;mut&lt;/code>传递给中断处理函数，并被用来获取更多的关于异常原因的信息。由于只有小部分异常会压入错误码，所以&lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/struct.InterruptStackFrame.html">&lt;code>InterruptStackFrame&lt;/code>&lt;/a>并没有设置&lt;code>error_code&lt;/code>字段。这些异常会另外使用&lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/type.HandlerFuncWithErrCode.html">&lt;code>HandlerFuncWithErrCode&lt;/code>&lt;/a>函数来处理，这个函数有一个&lt;code>error_code&lt;/code>参数用来保存错误码。&lt;/p>
&lt;h3 id="幕后工作">幕后工作&lt;/h3>
&lt;p>&lt;code>x86-interrupt&lt;/code>调用约定作为一个优秀的抽象，它几乎隐藏了异常处理过程中所有繁杂的细节。然而，理解幕布后的工作在某些时候是有益的。下面简要概述了&lt;code>x86-interrupt&lt;/code>调用约定所处理的事情：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>抽取参数&lt;/strong>：大多数调用约定希望参数被放在寄存器中传递。这对于异常处理函数是不可能的，因为我们不能在保存寄存器的值之前覆盖这些寄存器。然而，&lt;code>x86-interrupt&lt;/code>调用约定明白这些参数早就被放在栈的某个位置上了。&lt;/li>
&lt;li>&lt;strong>使用&lt;code>iretq&lt;/code>返回&lt;/strong>：既然中断栈帧和寻常函数调用的栈帧是不同的，我们不能使用&lt;code>ret&lt;/code>指令从中断处理函数中返回。但是可以使用&lt;code>iretq&lt;/code>指令。&lt;/li>
&lt;li>&lt;strong>处理错误码&lt;/strong>：部分特定异常压入的错误码是事情变得更加复杂。它改变了栈对齐（见对齐栈部分）并且需要在返回之前从栈中弹出。&lt;code>x86-interrupt&lt;/code>调用约定处理了所有难题。但是，它无法获得每种异常对应的处理函数，所以，它需要从函数的参数中推断这些信息。这意味着，程序员有责任使用正确的函数类型处理每种异常。幸运的是，&lt;code>x86_64&lt;/code>库的&lt;code>InterruptDescriptorTable&lt;/code>可以确保这一过程不会出错。&lt;/li>
&lt;li>&lt;strong>对齐栈&lt;/strong>：一些指令集（尤其是SSE指令集）使用16字节的栈对齐。在异常发生的时候，CPU会确保栈对齐。但是在压入错误码后，栈对齐会再次被破坏。&lt;code>x86-interrupt&lt;/code>调用约定会通过再次对齐栈解决这个问题。&lt;/li>
&lt;/ul>
&lt;p>如果你对更多的细节感兴趣：我们也有一系列文章解释了如何使用 &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md">naked functions&lt;/a>处理异常。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>现在我们理解了这些理论，是时候在我们的内核中实现CPU异常处理了。我们首先在&lt;code>src/interrupts.rs&lt;/code>中创建一个新的interrupts 模块，其中&lt;code>init_idt&lt;/code>函数创建了一个新的&lt;code>InterruptDescriptorTable&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// in src/lib.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">interrupts&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// in src/interrupts.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x86_64&lt;/span>::&lt;span class="n">structures&lt;/span>::&lt;span class="n">idt&lt;/span>::&lt;span class="n">InterruptDescriptorTable&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">init_idt&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptDescriptorTable&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们可以增加更多的处理函数。我们首先创建断点异常（&lt;a href="https://wiki.osdev.org/Exceptions#Breakpoint">breakpoint exception&lt;/a>）的处理函数。断点异常是一个绝佳的测试处理异常过程的示例。它唯一的用途是在断点指令&lt;code>int3&lt;/code>执行的时候暂停整个程序。&lt;/p>
&lt;p>断点异常通常被用于调试程序（debugger）：当用户设置了断点，调试程序会使用&lt;code>int3&lt;/code>指令覆盖对应位置的指令，当CPU执行到这一位置的时候会抛出断点异常。当用户希望继续执行程序时，调试程序将&lt;code>int3&lt;/code>指令替换回原来的指令并继续执行。可以从 &lt;a href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints">&amp;quot;&lt;em>How debuggers work&lt;/em>&amp;quot;&lt;/a> 系列获取更多的细节。&lt;/p>
&lt;p>我们无需覆盖任何指令。因为我们只希望程序在异常指令执行的时候打印一条消息，然后继续执行。让我们创建一个简单的断点异常处理函数（breakpoint_handler）并添加到IDT：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// in src/interrupts.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x86_64&lt;/span>::&lt;span class="n">structures&lt;/span>::&lt;span class="n">idt&lt;/span>::&lt;span class="p">{&lt;/span>&lt;span class="n">InterruptDescriptorTable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptStackFrame&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">crate&lt;/span>::&lt;span class="n">println&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">init_idt&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptDescriptorTable&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_handler_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="n">point_handler&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">extern&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;x86-interrupt&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">breakpoint_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">stack_frame&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptStackFrame&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;EXCEPTION: BREAKPOINT\n{:#?}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">stack_frame&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>处理函数只输出了一条消息并美观的打印了中断栈帧。&lt;/p>
&lt;p>当我们试图编译程序的时候，错误出现了：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="n">error&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">E0658&lt;/span>&lt;span class="p">]&lt;/span>: &lt;span class="nc">x86&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">interrupt&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ABI&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">is&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">experimental&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">subject&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">change&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">see&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">issue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mi">40180&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>-&amp;gt; &lt;span class="nc">src&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">main&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">rs&lt;/span>:&lt;span class="mi">53&lt;/span>:&lt;span class="mi">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="mi">53&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">extern&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;x86-interrupt&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">breakpoint_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stack_frame&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptStackFrame&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="mi">54&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;EXCEPTION: BREAKPOINT\n{:#?}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">stack_frame&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="mi">55&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">help&lt;/span>: &lt;span class="nc">add&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="cp">#![feature(abi_x86_interrupt)]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">the&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">crate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">attributes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">enable&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个错误是因为 &lt;code>x86-interrupt&lt;/code> 中断调用约定仍然不稳定。我们需要明确地在&lt;code>lib.rs&lt;/code>顶部增加&lt;code>#![feature(abi_x86_interrupt)]&lt;/code>去激活它。&lt;/p>
&lt;h3 id="加载idt">加载IDT&lt;/h3>
&lt;p>为了让CPU使用我们新的中断描述符表，我们需要使用 &lt;a href="https://www.felixcloutier.com/x86/lgdt:lidt">&lt;code>lidt&lt;/code>&lt;/a> 指令去加载它。&lt;code>x86_64&lt;/code> 库的&lt;code>InterruptDescriptorTable&lt;/code> 结构体提供了一个 &lt;code>load&lt;/code> 方法去实现这个操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// in src/interrupts.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">init_idt&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptDescriptorTable&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_handler_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="n">point_handler&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当我们试图编译程序的时候，下面的错误出现了：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="n">error&lt;/span>: &lt;span class="err">`&lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">does&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">live&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">enough&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>-&amp;gt; &lt;span class="nc">src&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">interrupts&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">mod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">rs&lt;/span>:&lt;span class="mi">43&lt;/span>:&lt;span class="mi">5&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="mi">43&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">^^^&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">does&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">live&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">enough&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="mi">44&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">borrowed&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">only&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">until&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">here&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">note&lt;/span>: &lt;span class="nc">borrowed&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">must&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">be&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">valid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">the&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lifetime&lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>load&lt;/code> 方法期望一个 &lt;code>&amp;amp;'static self&lt;/code>，以确保 &lt;code>idt&lt;/code> 引用在整个程序生命周期中可用。因为CPU会在每个异常发生的时候访问这张表，直到我们加载了其它的&lt;code>InterruptDescriptorTable&lt;/code>对象。所以，使用比 &lt;code>'static&lt;/code> 短的生命周期会导致 use-after-free bug。&lt;/p>
&lt;p>事实上，情况很明白。我们的 &lt;code>idt&lt;/code> 在栈上创建，所以它只在 &lt;code>init&lt;/code> 函数的生命周期中有效。一旦这个栈内存被其它函数重用，CPU会把随机的栈内存当作IDT。幸运的是， &lt;code>InterruptDescriptorTable::load&lt;/code> 在函数定义中明确要求了必要的生命周期条件（译者注：也就是必须使用 &lt;code>'static&lt;/code> 生命周期）。所以，Rust 编译器可以在编译期就阻止这个潜在的 bug 。&lt;/p>
&lt;p>为了解决这个问题，我们需要保存我们的 &lt;code>idt&lt;/code> 对象到拥有 &lt;code>'static&lt;/code> 生命周期的地方。我们可以使用 &lt;code>Box&lt;/code> 把 IDT 分配到堆上，并转换为 &lt;code>'static&lt;/code> 引用，但是我们是在开发操作系统内核，所以并不会有堆这个概念。&lt;/p>
&lt;p>作为代替，我们可以把 IDT 保存为 常量（&lt;code>static&lt;/code>）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">static IDT: InterruptDescriptorTable = InterruptDescriptorTable::new();
pub fn init_idt() {
IDT.breakpoint.set_handler_fn(breakpoint_handler);
IDT.load();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是，这有一个问题：常量是不可变的，所以我们不能修改来自 &lt;code>init&lt;/code> 函数的IDT中的断点条目。我们可以使用 &lt;a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable">&lt;code>static mut&lt;/code>&lt;/a> 解决这个问题：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">IDT&lt;/span>: &lt;span class="nc">InterruptDescriptorTable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptDescriptorTable&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">init_idt&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">unsafe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">IDT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_handler_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">break&lt;/span>&lt;span class="n">point_handler&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">IDT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这种变体不会出现编译错误，但是并不符合优雅的编程风格。 &lt;code>static mut&lt;/code> 非常容易造成数据竞争，所以在每一次访问中都需要使用 &lt;a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#unsafe-superpowers">&lt;code>unsafe&lt;/code>&lt;/a> 代码块。&lt;/p>
&lt;h4 id="懒加载常量">懒加载常量&lt;/h4>
&lt;p>&lt;code>lazy_static&lt;/code> 宏的存在令人庆幸。它可以让常量在被第一次使用的时候被初始化，而不是在编译期。因此，我们可以在初始化代码块中做几乎所有的事情，甚至读取常量在运行时的值。&lt;/p>
&lt;p>我们已经在 &lt;a href="https://os.phil-opp.com/vga-text-mode/#lazy-statics">created an abstraction for the VGA text buffer&lt;/a> 引用了 &lt;code>lazy_static&lt;/code> 库。所以我们可以直接使用 &lt;code>lazy_static!&lt;/code> 宏去创建静态的IDT：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// in src/interrupts.rs
use lazy_static::lazy_static;
lazy_static! {
static ref IDT: InterruptDescriptorTable = {
let mut idt = InterruptDescriptorTable::new();
idt.breakpoint.set_handler_fn(breakpoint_handler);
idt
};
}
pub fn init_idt() {
IDT.load();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这种方法不需要 &lt;a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#unsafe-superpowers">&lt;code>unsafe&lt;/code>&lt;/a> 代码块，因为 &lt;code>lazy_static!&lt;/code> 宏在底层使用了 &lt;a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#unsafe-superpowers">&lt;code>unsafe&lt;/code>&lt;/a> 代码块，但是抽象出了一个安全接口。&lt;/p>
&lt;h3 id="运行">运行&lt;/h3>
&lt;p>让内核种的异常处理工作的最后一步是在 &lt;code>main.rs&lt;/code> 中调用 &lt;code>init_idt&lt;/code> 函数。在 &lt;code>lib.rs&lt;/code> 中抽象一个总体的 &lt;code>init&lt;/code> 函数而不是直接调用:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// in src/lib.rs
pub fn init() {
interrupts::init_idt();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数用来放置可以被 &lt;code>main.rs&lt;/code> , &lt;code>lib.rs&lt;/code>中的 &lt;code>_start&lt;/code> 函数和集成测试所共享的初始化代码。&lt;/p>
&lt;p>在 &lt;code>main.rs&lt;/code> 中的 &lt;code>_start&lt;/code> 函数中调用 &lt;code>init&lt;/code> 函数，并触发一个断点异常。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// in src/main.rs
#[no_mangle]
pub extern &amp;#34;C&amp;#34; fn _start() -&amp;gt; ! {
println!(&amp;#34;Hello World{}&amp;#34;, &amp;#34;!&amp;#34;);
blog_os::init(); // new
// invoke a breakpoint exception
x86_64::instructions::interrupts::int3(); // new
// as before
#[cfg(test)]
test_main();
println!(&amp;#34;It did not crash!&amp;#34;);
loop {}
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用 &lt;code>cargo run&lt;/code> 命令在QEMU中运行程序：&lt;/p>
&lt;p>&lt;img src="https://markdown-ngy.oss-cn-beijing.aliyuncs.com/qemu-breakpoint-exception.png" alt="qemu-breakpoint-exception">&lt;/p>
&lt;p>CPU成功调用了断点异常处理函数，并打印了一些消息，然后返回 &lt;code>_start&lt;/code> 函数继续打印了 &lt;code>It did not crash!&lt;/code> 消息。&lt;/p>
&lt;p>可以发现，中断栈帧显示了中断发生时的指令和栈指针地址。这有助于调试不该发生的异常。&lt;/p>
&lt;h3 id="增加test">增加Test&lt;/h3>
&lt;p>增加一个确认上文中CPU继续工作的测试。首先，让 &lt;code>lib.rs&lt;/code> 的 &lt;code>_start&lt;/code> 函数同样调用 &lt;code>init&lt;/code> 函数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// in src/lib.rs
/// Entry point for `cargo test`
#[cfg(test)]
#[no_mangle]
pub extern &amp;#34;C&amp;#34; fn _start() -&amp;gt; ! {
init(); // new
test_main();
loop {}
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>既然 &lt;code>lib.rs&lt;/code> 中的测试完全独立于 &lt;code>main.rs&lt;/code> ，必须使用命令 &lt;code>cargo test --lib&lt;/code> 来指定运行 &lt;code>lib.rs&lt;/code> 中的 &lt;code>_start&lt;/code> 函数。在&lt;code>lib.rs&lt;/code> 中的测试运行以前，我们需要调用 &lt;code>init&lt;/code> 函数去建立IDT。&lt;/p>
&lt;p>现在，创建一个 &lt;code>test_breakpoint_exception&lt;/code> 测试：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// in src/interrupts.rs
#[test_case]
fn test_breakpoint_exception() {
// invoke a breakpoint exception
x86_64::instructions::interrupts::int3();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个测试调用了 &lt;code>x86_64&lt;/code> 库的 &lt;code>int3&lt;/code> 函数去触发断点异常。通过检查异常处理后程序继续执行，可以验证断点异常处理函数正常工作。&lt;/p>
&lt;p>使用 &lt;code>cargo test&lt;/code> （所有测试）或 &lt;code>cargo test --lib&lt;/code>（只限于 &lt;code>lib.rs&lt;/code> 和它的子模块中的测试）命令运行新的测试，应当可以看见：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">blog_os::interrupts::test_breakpoint_exception... [ok]
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="过于抽象-too-much-magic">过于抽象?（ Too much Magic?）&lt;/h2>
&lt;p>&lt;code>x86-interrupt&lt;/code> 调用约定和 &lt;a href="https://docs.rs/x86_64/0.12.1/x86_64/structures/idt/struct.InterruptDescriptorTable.html">&lt;code>InterruptDescriptorTable&lt;/code>&lt;/a> 让异常处理流程变得相当简单愉快。如果你觉得太过抽象或有兴趣学习异常处理更硬核的细节，&lt;a href="https://os.phil-opp.com/first-edition/extra/naked-exceptions/">“Handling Exceptions with Naked Functions”&lt;/a> 系列会告诉你如何在不使用 &lt;code>x86-interrupt&lt;/code> 调用约定的情况下处理异常并建立自己的IDT类型。在 &lt;code>x86-interrupt&lt;/code> 调用约定和 &lt;code>x86_64&lt;/code> 库问世以前，这个系列可以说是最主流的异常处理主体相关的博客。不得不提的是，这些文章基于第一版本的 &lt;a href="https://os.phil-opp.com/first-edition/">Writing an OS in Rust &lt;/a>，所以可能会有些过时。&lt;/p>
&lt;h2 id="接下来">接下来?&lt;/h2>
&lt;p>我们成功地触发了第一个异常并从中返回！下一步是确保可以捕获所有异常，因为未被捕获地异常会引发严重的 &lt;a href="https://wiki.osdev.org/Triple_Fault">triple fault&lt;/a> ，继而导致系统复位。下一篇文章解释了如何通过捕获 &lt;a href="https://wiki.osdev.org/Double_Fault#Double_Fault">双重异常 double faults&lt;/a> 来避免这些问题。&lt;/p></description></item><item><title>Go Channel</title><link>https://justice.bj.cn/post/14.language/golang/golang-channel/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang-channel/</guid><description>&lt;h1 id="go-channel">Go Channel&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>channel&lt;/code>是first-class的，可以被存储到变量中，可以作为参数传递给函数，也可以作为函数的返回值返回;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>channel分为：有缓存channel和无缓冲channel两种；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>close：如果 Channel 是一个空指针或者已经被关闭时，Go 语言运行时都会直接崩溃并抛出异常;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从一个&lt;code>nil&lt;/code> channel中接收数据会一直被block;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从一个被closed的channel中接收数据会立即返回；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/01/26-12-35-27-2021-01-26-12-35-23-image.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Hchan&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">uintgo&lt;/span> &lt;span class="n">qcount&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 队列q中的总数据数量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">uintgo&lt;/span> &lt;span class="n">dataqsiz&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 环形队列q的数据大小
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">uint16&lt;/span> &lt;span class="n">elemsize&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//队列的当前使用量
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kt">bool&lt;/span> &lt;span class="n">closed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">uint8&lt;/span> &lt;span class="n">elemalign&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">Alg&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">elemalg&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// interface for element type
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">uintgo&lt;/span> &lt;span class="n">sendx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 发送index
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">uintgo&lt;/span> &lt;span class="n">recvx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 接收index
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">WaitQ&lt;/span> &lt;span class="n">recvq&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 因recv而阻塞的等待队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">WaitQ&lt;/span> &lt;span class="n">sendq&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 因send而阻塞的等待队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Lock&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>带缓冲区的chan，则缓冲区数据实际上是紧接着Hchan结构体中分配的&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">Hchan&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">hint&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">elem&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">WaitQ&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">SudoG&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">SudoG&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">last&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">SudoG&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">G&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// g and selgen constitute
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">uint32&lt;/span> &lt;span class="n">selgen&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// a weak pointer to g
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">SudoG&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">link&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">int64&lt;/span> &lt;span class="n">releasetime&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">byte&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">elem&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// data element
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="读写channel操作">读写channel操作&lt;/h2>
&lt;p>写channel操作，在底层运行时库中对应的是一个runtime.chansend函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//c &amp;lt;- v
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="n">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="n">chansend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ChanType&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Hchan&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">byte&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ep&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">pres&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">pc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="select的实现">select的实现&lt;/h2>
&lt;p>select-case中的chan操作编译成了if-else。比如：&lt;/p>
&lt;p>每个select都对应一个Select结构体&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="o">...&lt;/span>&lt;span class="nx">foo&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="o">...&lt;/span>&lt;span class="nx">bar&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 编译如下：
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nf">selectnbrecv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>&lt;span class="nx">foo&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>&lt;span class="nx">bar&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>select和case关键字使用了下面的结构体：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">struct&lt;/span> &lt;span class="nx">Scase&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nx">SudoG&lt;/span> &lt;span class="nx">sg&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// must be first member (cast to Scase)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Hchan&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// chan
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">byte&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nx">pc&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// return pc
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">uint16&lt;/span> &lt;span class="nx">kind&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">uint16&lt;/span> &lt;span class="nx">so&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// vararg of selected bool
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nx">receivedp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// pointer to received bool (recv2)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="kd">struct&lt;/span> &lt;span class="nx">Select&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">uint16&lt;/span> &lt;span class="nx">tcase&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 总的scase[]数量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">uint16&lt;/span> &lt;span class="nx">ncase&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 当前填充了的scase[]数量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">uint16&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nx">pollorder&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// case的poll次序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Hchan&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="nx">lockorder&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// channel的锁住的次序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Scase&lt;/span> &lt;span class="nx">scase&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// 每个case会在结构体里有一个Scase，顺序是按出现的次序
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.bookstack.cn/read/go-internals/zh-07.1.md">高级数据结构的实现 - channel - 《深入解析Go》 - 书栈网 · BookStack&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Golang之syscall</title><link>https://justice.bj.cn/post/14.language/golang/golang%E4%B9%8Bsyscall/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E4%B9%8Bsyscall/</guid><description>&lt;h1 id="golang之syscall">Golang之syscall&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ User Mode ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
│
│ Application syscall library
program /src/syscall │
│
│
│ ┌───────────────────┐ ┌──────────────────────┐
│ │ ┌────────────▶│Faccessat { │ │
│ │ │ │ │ │
│ │ │ │ runtime·Syscall6 { │ │
│ │... │ │ │ │
│syscall.Access( │ │ │ ... │ │
│ │ path, mode)───┼────────┘ │ SYSCALL ──────────┼────────────────┐
│... ◀──────────┼──────┐ │ ... ◀──────────┼──────────┼─────┼────────┐
│ │ │ └───────────────┼─── return; │ │ │
│ │ │ } │ │ │ │
│ │ │ │} │ │ │
└───────────────────┘ └──────────────────────┘ │ │ │
│ │ │
─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘ │ ▲
│ │
switch to kernel mode │
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ Kernel Mode ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ▼ │
│ │ │
│ System call Trap handler │ │
service routine │ │ │
│ ┌──────────────────┐ ┌───────────────────────┐ │ │
│sys_faccessat() ◀─┼───────────┐ │system call: ◀───────┼────────┼─────┘ │
│ │{ │ │ │ │ │
│ │ │ │ │ │ │
│ │ │ │ │ ... │ │
│ │ │ │ │ │ │
│ │ ... │ └───────────┼───call sys_call_table │ switch to user mode
│ │ │ │ │ │
│ │ │ ┌───────────┼─▶ ... │ │
│ return error; ──┼───────────┘ │ │ │ │
│ │} │ │ ───────────────────┼───────────▶───────────┘
└──────────────────┘ └───────────────────────┘ │
│
─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">/syscall/syscall_linux.go
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以把系统调用分为三类:&lt;/p>
&lt;ol>
&lt;li>阻塞系统调用&lt;/li>
&lt;li>非阻塞系统调用&lt;/li>
&lt;li>&lt;code>wrapped&lt;/code> 系统调用&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//sys Madvise(b []byte, advice int) (err error)
&lt;/span>&lt;span class="c1">//sysnb EpollCreate(size int) (fd int, err error)
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">//mksyscall.pl 脚本 将上面的定义生成如下
&lt;/span>&lt;span class="c1">//sys
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">Madvise&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">advice&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">_p0&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">_p0&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">_p0&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">_zero&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">e1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">Syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">SYS_MADVISE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p0&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">)),&lt;/span> &lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">advice&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">e1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">errnoErr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//sysnb
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">EpollCreate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">size&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fd&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">r0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">e1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">RawSyscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">SYS_EPOLL_CREATE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">size&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">fd&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">r0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">e1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">errnoErr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//wrapped
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">Rename&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">oldpath&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">newpath&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">Renameat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_AT_FDCWD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">oldpath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_AT_FDCWD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">newpath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>入口：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">Syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">trap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a3&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r2&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Errno&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">Syscall6&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">trap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a6&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r2&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Errno&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">RawSyscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">trap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a3&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r2&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Errno&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">RawSyscall6&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">trap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a6&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r2&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Errno&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些函数的实现都是汇编，按照 linux 的 syscall 调用规范，我们只要在汇编中把参数依次传入寄存器，并调用 SYSCALL 指令即可进入内核处理逻辑，系统调用执行完毕之后，返回值放在 RAX 中:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>RDI&lt;/th>
&lt;th>RSI&lt;/th>
&lt;th>RDX&lt;/th>
&lt;th>R10&lt;/th>
&lt;th>R8&lt;/th>
&lt;th>R9&lt;/th>
&lt;th>RAX&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>参数一&lt;/td>
&lt;td>参数二&lt;/td>
&lt;td>参数三&lt;/td>
&lt;td>参数四&lt;/td>
&lt;td>参数五&lt;/td>
&lt;td>参数六&lt;/td>
&lt;td>系统调用编号/返回值&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Syscall 和 Syscall6 的区别只有传入参数不一样&lt;/p>
&lt;p>Syscall 和 Syscall6在进入和退出Syscall时，分别调用了&lt;code>runtime·entersyscall(SB)&lt;/code>和&lt;code>runtime·exitsyscall(SB)&lt;/code>;&lt;/p>
&lt;p>RawSyscall 和 RawSyscall6 在进入和退出Syscall 时候没有调用；&lt;/p>
&lt;h4 id="新版本抢占式调度中的-rawsyscall-和-syscall">新版本抢占式调度中的 RawSyscall 和 Syscall&lt;/h4>
&lt;p>由于 &lt;code>RawSyscall&lt;/code> 相较于 &lt;code>Syscall&lt;/code> 缺少了 &lt;code>runtime·entersyscall(SB)&lt;/code> 以及 &lt;code>runtime·exitsyscall(SB)&lt;/code> 的调用，当 &lt;code>g&lt;/code> 执行的是阻塞性质的系统调用的时候，当前 &lt;code>g&lt;/code> 会维持 &lt;code>running&lt;/code> 状态，runtime 系统监控在进行全局调度的时候一旦发现运行超过 10ms 的 &lt;code>g&lt;/code> 就会执行抢占操作（1.14.3 版本, linux_amd64 下为例），通过发送信号量给 &lt;code>g&lt;/code> 对应的线程，而由于线程在初始化的时候进行了信号量的监听以及设置了相应的 &lt;code>sa_flags&lt;/code> 参数，虽然包含诸如&lt;code>SA_RESTART&lt;/code>参数会让系统调用在信号中断后自动恢复，但是不是对所有系统调用都会有效，这将会导致在收到信号量的时候对正在阻塞的系统调用产生中断，&lt;/p>
&lt;p>提供给用户使用的系统调用，基本都会通知 runtime，以 entersyscall，exitsyscall 的形式来告诉 runtime，在这个 syscall 阻塞的时候，由 runtime 判断是否把 P 腾出来给其它的 M 用。解绑定指的是把 M 和 P 之间解绑，如果绑定被解除，在 syscall 返回时，这个 g 会被放入执行队列 runq 中。&lt;/p>
&lt;p>同时 runtime 又保留了自己的特权，在执行自己的逻辑的时候，我的 P 不会被调走，这样保证了在 Go 自己“底层”使用的这些 syscall 返回之后都能被立刻处理。&lt;/p>
&lt;p>所以同样是 epollwait，runtime 用的是不能被别人打断的，你用的 syscall.EpollWait 那显然是没有这种特权的。&lt;/p>
&lt;h2 id="vsdo">vsdo&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://github.com/cch123/golang-notes/blob/master/syscall.md">https://github.com/cch123/golang-notes/blob/master/syscall.md&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://blog.itpub.net/69908606/viewspace-2642153/">曹春晖：谈一谈 Go 和 Syscall_ITPUB博客&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Golang内存对齐</title><link>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid><description>&lt;h1 id="golang内存对齐">Golang内存对齐&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>CPU 始终以字长访问内存，&lt;/li>
&lt;/ul>
&lt;h2 id="对齐保证align-guarantee">对齐保证(align guarantee)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>结构体的成员变量，第一个成员变量的偏移量为 0。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>往后的每个成员变量的对齐值必须为&lt;strong>编译器默认对齐长度&lt;/strong>（&lt;code>#pragma pack(n)&lt;/code>）或&lt;strong>当前成员变量类型的长度&lt;/strong>（&lt;code>unsafe.Sizeof&lt;/code>），取&lt;strong>最小值作为当前类型的对齐值&lt;/strong>。其偏移量必须为对齐值的整数倍&lt;/p>
&lt;/li>
&lt;li>
&lt;p>结构体本身，对齐值必须为&lt;strong>编译器默认对齐长度&lt;/strong>（&lt;code>#pragma pack(n)&lt;/code>）或&lt;strong>结构体的所有成员变量类型中的最大长度&lt;/strong>，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>取&lt;strong>最大数的最小整数倍&lt;/strong>作为对齐值；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>结合以上两点，可得知若&lt;strong>编译器默认对齐长度&lt;/strong>（&lt;code>#pragma pack(n)&lt;/code>）超过结构体内成员变量的类型最大长度时，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默认对齐长度是没有任何意义的；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://geektutu.com/post/hpg-struct-alignment.html">https://geektutu.com/post/hpg-struct-alignment.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/go-memory-align">1.5 在 Go 中恰到好处的内存对齐 - 跟煎鱼学 Go&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://blog.newbmiao.com/2020/02/10/dig101-golang-struct-memory-align.html">http://blog.newbmiao.com/2020/02/10/dig101-golang-struct-memory-align.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Golang内存管理</title><link>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Thu, 07 Mar 2024 11:58:54 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="golang内存管理">Golang内存管理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Golang内存管理采用类似&lt;code>tcmalloc&lt;/code>的分级分配算法，主要由&lt;code>MHeap&lt;/code>、&lt;code>MCentral&lt;/code>、&lt;code>MCache&lt;/code> 3 级组成。&lt;/p>
&lt;p>按分配对象的大小不同，选择相应的区域进行分配。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/12/28-10-17-33-2021-12-28-10-17-27-image.png" alt="">&lt;/p>
&lt;h2 id="内存布局">内存布局&lt;/h2>
&lt;p>golang程序启动时，会根据OS类型向OS申请一大块连续虚拟内存空间如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-49-34-2020-05-04-09-32-44-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>arena&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>由连续的page(8KB)组成，用于具体的对象分配；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>spans&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>存放了&lt;code>mspan&lt;/code>的指针(8Byte)，表示arena区中的某一页(page)属于哪个&lt;code>mspan&lt;/code>，用于管理arena；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bitmap&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用于标记&lt;code>arena&lt;/code>(即heap)中的对象, 每个对象使用两个bit进行标记，分别表示gc状态和是否分配；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>高地址部分指向arena区域的低地址部分，地址是由高地址向低地址增长的；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-49-42-2020-05-04-09-36-04-image.png" alt="">&lt;/p>
&lt;h2 id="基本数据结构">基本数据结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MHeap&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>代表了golang的整个堆内存;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局唯一的;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大对象(&amp;gt;32KB)直接在MHeap中分配；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mheap 包含free，large两个域：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>free: free包含一个256单元的数组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>large:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>给MCentral和MCache等下层提供空间；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-49-48-2020-05-04-09-39-31-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MCentral&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>集中管理不同类型（67种）的MSpan，对应TCMalloc中的CentralCache；&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>每个mcentral包含两个mspan列表:
&lt;ul>
&lt;li>noempty: 表示已被mcache的mspan list；&lt;/li>
&lt;li>empty: 表示未被使用(empty)的mspan 链表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当某个goroutine中的mcache内存不够时，就会从mcentral的empty链表中分配对应的mspan。&lt;/li>
&lt;li>如果mcentral内存不够，就会从MHeap中分配；&lt;/li>
&lt;li>mcentral中有锁，以为多个goroutine分配提供互斥；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-49-08-2020-05-04-09-38-29-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MCache&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是各个goroutine自有的局部内存;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>向&lt;code>mcentral&lt;/code>申请得到的;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>小对象(&amp;lt;=32KB)的分配直接在goroutine内部进行，不用加锁，提高分配速度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mcache 内存不够时，会向mcentral重新申请；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-49-13-2020-05-04-09-38-54-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MSpan&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>内存管理基本单元，由一片连续的8KB页组成的双向链表，进行内存对象的数据分配;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为满足不同大小对象分配的需要，减少内存碎片，同时兼顾内存利用率，golang将span分层不同的大小类型（总共67种）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对象分配内存时，根据对象大小，选择最合适的mspan进行分配。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-13-49-19-2020-05-04-09-37-59-image.png" alt="">&lt;/p>
&lt;h2 id="内存分配">内存分配&lt;/h2>
&lt;p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：&lt;/p>
&lt;ul>
&lt;li>Tiny对象： (0, 16B]，使用mcache的tiny分配器分配，多个tiny对象可组合在一个mspan中&lt;/li>
&lt;li>Small对象：(16B, 32KB ]，在mcache中选择相应规格大小的mspan进行分配；&lt;/li>
&lt;li>大对象：&amp;gt;32KB, 直接从MHeap中分配；&lt;/li>
&lt;/ul>
&lt;p>golang变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。&lt;/p>
&lt;p>通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小。&lt;/p>
&lt;p>分配顺序：&lt;/p>
&lt;ul>
&lt;li>首先通过计算使用的大小规格&lt;/li>
&lt;li>然后&lt;code>mcache&lt;/code>中对应大小规格的块分配。&lt;/li>
&lt;li>如果&lt;code>mcache&lt;/code> free 链表不够分配&lt;/li>
&lt;li>如果&lt;code>mcentral&lt;/code>中没有可用的块，则向&lt;code>mheap&lt;/code>申请，并根据算法找到最合适的&lt;code>mspan&lt;/code>。&lt;/li>
&lt;li>如果申请到的&lt;code>mspan&lt;/code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。&lt;/li>
&lt;li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。&lt;/li>
&lt;/ul>
&lt;h2 id="gc流程">GC流程&lt;/h2>
&lt;h3 id="gc时机">GC时机&lt;/h3>
&lt;p>golang gc的触发是由gcpercent变量控制的，当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。&lt;/p>
&lt;p>比如，gcpercent=100，当前使用了4M的内存，那么当内存分配到达8M时就会再次gc。&lt;/p>
&lt;p>如果回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。&lt;/p>
&lt;p>也就是说，并不是内存分配越多，垃圾回收频率越高，这个算法使得垃圾回收的频率比较稳定，适合应用的场景。&lt;/p>
&lt;p>gcpercent的值是通过环境变量GOGC获取的，如果不设置这个环境变量，默认值是100。&lt;/p>
&lt;p>如果将它设置成off，则是关闭垃圾回收。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/27807169">https://zhuanlan.zhihu.com/p/27807169&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/2904efc7f1a8">图解Golang的内存分配&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/29216091">https://zhuanlan.zhihu.com/p/29216091&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/76802887">https://zhuanlan.zhihu.com/p/76802887&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yq.aliyun.com/articles/652551">&lt;strong>简单易懂的 Go 内存分配原理解读&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5c888a79e51d456ed11955a8">https://juejin.im/post/5c888a79e51d456ed11955a8&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/225190602">白话Go语言内存管理三部曲（一）内存分配原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000022499402">go怎样做stw&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw">https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item></channel></rss>