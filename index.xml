<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 29 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about.html</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages.html</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences.html</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage.html</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank.html</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Tiglab Raft</title><link>https://justice.bj.cn/post/31.distribute/chubao-raft.html</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/31.distribute/chubao-raft.html</guid><description>&lt;h1 id="tiglab-raft">Tiglab Raft&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Tiglab Raft 是 chubaofs 项目使用的 golang multigroup-raft 库，是在 etcd raft 库上进行了重构和优化。&lt;/p>
&lt;p>向较于 etcd-raft，tiglab-raft 有以下不同改进：&lt;/p>
&lt;ul>
&lt;li>multi-raft：支持多组 raft；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="状态机">状态机&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph TB
F(Follower)
C(Candidate)
L(Leader)
E(ElectionAck)
S((START)) --&amp;gt; F
F --timeout--&amp;gt; C
C --timeout/vote req--&amp;gt; C
C --electAck/append/hb/minor votes--&amp;gt; F
C -- quorum:lease_off --&amp;gt; L
C -- quorum:lease_on --&amp;gt; E
L -- lease offline --&amp;gt; F
E -- vote req --&amp;gt; E
E --electAck/append/hb--&amp;gt; F
E --quorum--&amp;gt; L
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="选举">选举&lt;/h2>
&lt;h3 id="选举发生条件">选举发生条件&lt;/h3>
&lt;ul>
&lt;li>&lt;code>Follower&lt;/code>或&lt;code>Candidate&lt;/code>节点&lt;code>选举计时器&lt;/code>超时（lease off） 或收到 Leader 的 Lease TimeOut 消息（lease on）；&lt;/li>
&lt;li>ElectionAck 状态时，选举计时器超时；&lt;/li>
&lt;li>外界选举信号；&lt;/li>
&lt;/ul>
&lt;h3 id="选举过程">选举过程&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>当选举条件达到时，raft 状态机会产生一个&lt;code>LocalMsgHup&lt;/code>消息中断当前任期，发起选举；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非 Leader 节点收到 LocalMsgHup 消息，如果可以提升为 Leader，且 raft 中没有待处理的配置变更日志，则举行选举(campaign)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>发起节点先将自己变成候选人(Candidate);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断得票数。如果达到法定票数(大于总数一半)&lt;/p>
&lt;ul>
&lt;li>启用 Lease，则直接当选为领导人(Leader)，选举结束;&lt;/li>
&lt;li>未启用 Lease，则进入选举确认(ElectionAck)状态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>否则，如果未达到法定票数，则给各个复制节点发送&lt;code>ReqMsgVote&lt;/code>拉票消息，强制各节点投票；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>拉票消息，投反对票，并回复 RespMsgVote 消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>拉票消息后，&lt;/p>
&lt;ul>
&lt;li>如果满足投票条件(条件：未设置 lease，或没有 leader 节点 并且 未投票给其他节点 且 日志为最新)，投赞成票，回复 RespMsgVote 消息给拉票节点；&lt;/li>
&lt;li>否则，投反对票；回复 RespMsgVote 消息给拉票节点；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Leader&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>消息，投反对票，回复&lt;code>RespMsgVote&lt;/code>消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ElectionAck&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>消息，投反对票；回复 RespMsgVote 消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code> 收到 &lt;code>RespMsgVote&lt;/code>投票消息后，统计有效票数：&lt;/p>
&lt;ul>
&lt;li>如果赞成票达多数
&lt;ul>
&lt;li>如果未启用 lease，则成为 Leader；&lt;/li>
&lt;li>否则，进入 ElectionAck 状态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果反对票达多数，则成为&lt;code>Follower&lt;/code>；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>给拉票候选人投赞成票条件：&lt;/p>
&lt;ul>
&lt;li>无 leader（或未启用 lease）;&lt;/li>
&lt;li>未给其他节点投过票；&lt;/li>
&lt;li>该候选人的 term 和 index 均为最新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="选举确认electionack">选举确认（ElectionAck）&lt;/h3>
&lt;p>如果启用 Lease，节点获得多数票后，不会直接当选，需先进入 ElectionAck 状态，对选举进行确认；&lt;/p>
&lt;p>在 ElectionAck 状态，ElectionAck 节点将向其他节点发送选举确认请求消息(ReqMsgElectAck)，待其他节点回复确认消息(RespMsgElectAck)后，统计确认票数，如果确认票数达到法定票数，才当选为领导人(Leader)。&lt;/p>
&lt;ul>
&lt;li>Follower 节点收到 ReqMsgElectAck 消息，将重置选举计数器，并将发送节点设为 Leader 后，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>Candidate 节点收到 ReqMsgElectAck 消息，将自己转变成 Follower，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>其他 ElectAck 节点收到 ReqMsgElectAck 消息，同样将自己转变成 Follower，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>ElectAck 节点收到 RespMsgElectAck 消息后，记录确认消息(ack)数。如果确认消息数大于等于法定当选票数，则当选为 Leader。并立即广播 append；&lt;/li>
&lt;/ul>
&lt;h2 id="消息驱动流程">消息驱动流程&lt;/h2>
&lt;h4 id="任何节点收到消息">任何节点收到消息：&lt;/h4>
&lt;ul>
&lt;li>如果是 LocalMsgHup 消息：
&lt;ul>
&lt;li>如果是非 Leader，且有副本节点，
&lt;ul>
&lt;li>如果包含配置变更消息且 comitted &amp;gt; applied, 则忽略；&lt;/li>
&lt;li>否则，举行选举；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果是 Leader 节点，则忽略；&lt;/li>
&lt;li>返回；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>否则，判断消息任期(Term):
&lt;ul>
&lt;li>如果 Term==0， 忽略；&lt;/li>
&lt;li>如果消息任期(m.Term) &amp;gt; 节点任期(r.term), 则继续判断
&lt;ul>
&lt;li>如果为请求投票消息(ReqMsgVote)，判断 lease：
&lt;ul>
&lt;li>如果是 Follower 节点，且启用了 lease，且消息不是来自旧 Leader 节点，则给旧 Leader 回复 LeaseMsgOffline 消息，通知旧 Leader Lease 下线；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变成 Follower。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果消息里任期小于节点任期(m.Term&amp;lt;r.term)，则忽略；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>转入不同角色状态处理；&lt;/li>
&lt;/ul>
&lt;h4 id="角色状态消息处理">角色状态消息处理&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>Follower&lt;/p>
&lt;ul>
&lt;li>LocalPropMsg：
&lt;ul>
&lt;li>如果没有 Leader，则不处理（报警提示）；&lt;/li>
&lt;li>如果有 Leader，转发 Leader 处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgAppend：
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;li>执行 append 操作：
&lt;ul>
&lt;li>如果消息 index 小于本节点 committed，则回复 RespMsgAppend 本节点 committe index；&lt;/li>
&lt;li>否则，尝试 append
&lt;ul>
&lt;li>如果 append 成功，则回复 RespMsgAppend（index = lastIndex）；&lt;/li>
&lt;li>否则，回复 RespMsgAppend，Reject=true；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgHeartBeat：
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqCheckQuorum:
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;li>回应发送者 RespCheckQuorum 消息；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgVote:
&lt;ul>
&lt;li>如果满足投票条件，则重置选举计数器，并回复发送者 RespMsgVote（赞成票，Reject=false）；&lt;/li>
&lt;li>否则回复发送者 RespMsgVote（反对票，Reject=true）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LeaseMsgTimeout
&lt;ul>
&lt;li>如果消息来自 Leader，则重置选举计数器，并发送 LocalMsgHup 消息;&lt;/li>
&lt;li>否则忽略；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Candidate&lt;/p>
&lt;ul>
&lt;li>LocalMsgProp:
&lt;ul>
&lt;li>忽略&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgAppend：
&lt;ul>
&lt;li>先转变为 Follower；&lt;/li>
&lt;li>再执行 append:&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgHeartBeat：
&lt;ul>
&lt;li>转变为 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgElectAck
&lt;ul>
&lt;li>先转变为 Follower；&lt;/li>
&lt;li>回复发送者 RespMsgElectAck 消息(Reject=false)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgVote：
&lt;ul>
&lt;li>回复发送者 RespMsgVote 消息, 投反对票(Reject=true)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RespMsgVote:
&lt;ul>
&lt;li>统计收到的赞成票数；&lt;/li>
&lt;li>如果赞成票已达多数：
&lt;ul>
&lt;li>如果启用 LeaseCheck，则转变为 ElectionAck 状态；&lt;/li>
&lt;li>否则未启用 LeaseCheck，则当选为 Leader，并广播 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果反对票已达多数，则变成 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Leader&lt;/p>
&lt;ul>
&lt;li>LocalMsgProp:
&lt;ul>
&lt;li>空消息或没有副本节点，则忽略该消息；&lt;/li>
&lt;li>否则，检查是否有配置变更消息；&lt;/li>
&lt;li>append；&lt;/li>
&lt;li>向副本节点广播 append。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgVote:
&lt;ul>
&lt;li>向发送者回复 RespMsgVote，投反对票(Reject=true);&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RespMsgAppend:
&lt;ul>
&lt;li>更新复制信道(pr)状态；&lt;/li>
&lt;li>如果 Reject, 则 pr 可能要回退，并转变到探测状态，在发送 append&lt;/li>
&lt;li>否则，更新信道状态，并尝试 commit：
&lt;ul>
&lt;li>如果 commit 成功，则广播 append；&lt;/li>
&lt;li>如果信道暂停过，则发送 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RespMsgHeartBeat:
&lt;ul>
&lt;li>
&lt;h2 id="更新信道状态">更新信道状态；&lt;/h2>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LeaseMsgOffline:
&lt;ul>
&lt;li>给所有副本节点发送 LeaseMsgTimeOut 消息；&lt;/li>
&lt;li>转变为 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RespMsgSnapShot:
&lt;ul>
&lt;li>如果信道状态不是 replicaStateSnapshot, 则忽略；&lt;/li>
&lt;li>如果消息被拒绝，则快照失败，信道转入探测状态；&lt;/li>
&lt;li>否则，更新信道并继续探测；&lt;/li>
&lt;li>信道暂停；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RespCheckQuorum:
&lt;ul>
&lt;li>接收 Ack；&lt;/li>
&lt;li>如果收到确认节点数+1(本节点)，则 readOnly-&amp;gt;advance;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ElectionAck&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LocalMsgProp:&lt;/p>
&lt;ul>
&lt;li>忽略&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgAppend:&lt;/p>
&lt;ul>
&lt;li>转变为 Follower；&lt;/li>
&lt;li>执行 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgHeartBeat:&lt;/p>
&lt;ul>
&lt;li>变成 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgElectAck:&lt;/p>
&lt;ul>
&lt;li>变成 Follower；&lt;/li>
&lt;li>回复 ResqMsgElectAck;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgVote:&lt;/p>
&lt;ul>
&lt;li>回复 RespMsgVote，投反对票(Reject=true)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespCheckQuorum:&lt;/p>
&lt;ul>
&lt;li>recvAck&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgElectAck:&lt;/p>
&lt;ul>
&lt;li>统计 ack 数；&lt;/li>
&lt;li>如果确认数&amp;gt;=法定票数，则成为 Leader，并广播 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="计时器tick">计时器(Tick)&lt;/h3>
&lt;p>计时器和消息一起用于驱动 raft 状态机的状态变更，主要包括三种种计时器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>心跳计数器(tickHeartBeat)：用于 Leader 向 Follower 发送存活信号。&lt;/p>
&lt;p>用于 Leader 节点，其频率&amp;raquo;选举计时器，约为选举计数器频率的 10 倍,用于 Leader 和 Follower 节点间确认信道状态。流程如下：&lt;/p>
&lt;ul>
&lt;li>心跳计数器+1，选举计数器+1；&lt;/li>
&lt;li>如果选举计数器到达阈值：
&lt;ul>
&lt;li>重置选举计数器为 0；&lt;/li>
&lt;li>如果启用 lease 且 lease 失效，则 Leader 状态转变为 Follower 状态；
&lt;ul>
&lt;li>如果是非 Leader 节点，忽略；&lt;/li>
&lt;li>如果心跳计数器到达阈值：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重置心跳计数器为 0；&lt;/li>
&lt;li>检查所有副本状态，如果不是快照状态，则副本继续；&lt;/li>
&lt;li>广播 ReadOnly；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>选举计时器(tickElection)：&lt;/p>
&lt;p>用于 Follower 和 Candidate 节点，用来计算一个任期是超时时间，如果一个任期内选举计时器超时，则将触发重新选举操作，流程如下：&lt;/p>
&lt;ul>
&lt;li>如果节点无法；&lt;/li>
&lt;li>选举计数器+1；&lt;/li>
&lt;li>判断是否超时：
&lt;ul>
&lt;li>如果超时，则重重置选举计数器为 0；状态机输入 LocalMsgHup 消息，中断当前任期；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>当选确认计数器(tickElectAck)：&lt;/p>
&lt;p>当选确认计数器主要用作当选确认状态节点中，流程如下：&lt;/p>
&lt;ul>
&lt;li>选举计数器+1；&lt;/li>
&lt;li>如果选举计数器超时，则：
&lt;ul>
&lt;li>重置选举计数器为 0；&lt;/li>
&lt;li>状态机输入 LocalMsgHup 消息，中断当前任期；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/47117804">线性一致性和 Raft&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/35697913">Raft 的 PreVote 实现机制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/50455478">Etcd 之 Lease read&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5af066f1f265da0b715634b9">Raft 协议精解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI3NDIxNTQyOQ==&amp;amp;mid=2247484499&amp;amp;idx=1&amp;amp;sn=79acb9b4b2f8baa3296f2288c4a0a45b&amp;amp;scene=0#wechat_redirect">TiKV 源码解析系列 - Lease Read&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/solotzg/article/details/80669924">Raft TLA+形式化验证&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>堆排序</title><link>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F.html</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F.html</guid><description>&lt;h1 id="堆排序">堆排序&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>堆排序是借助于堆这个数据结构来实现排序的一种算法。&lt;/p>
&lt;h3 id="堆heap的性质">堆(heap)的性质&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>堆&lt;/strong>是一个&lt;strong>完全二叉树&lt;/strong>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的每个非叶子结点值均大于(大顶堆)/小于(小顶堆)其左右子节点值；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的&lt;strong>根节点&lt;/strong>为所有节点中的最大值(大顶堆)/最小值(小顶堆)；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/05/22-20-35-03-2021-05-22-20-34-57-image.png" alt="">&lt;/p>
&lt;h2 id="堆排序-1">堆排序&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>堆排序利用堆节点的性质 2，每次从堆中排出堆顶元素，从而最终得到有序的序列；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于堆是一个完全二叉树，所以可以用数组来组织；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于完全二叉树性质，数组中根节点索引($i_o$)和其左右子节点($i_l,i_r$)满足如下关系：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>$$
i_l = 2 * i_o + 1 \&lt;br>
i_r = 2 * i_o + 2
$$&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp" alt="">&lt;/p>
&lt;h2 id="复杂性分析">复杂性分析&lt;/h2>
&lt;h3 id="时间复杂度">时间复杂度&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Avg: $O(nlogn)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Max: $O(n^2)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Min: $O(n)$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="空间复杂度">空间复杂度&lt;/h3>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">heap_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span class="s1"> 堆调整, 将nums数组从start开始,长度为length的数组调整为堆
&lt;/span>&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span>
&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">#初始化堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1"># 循环取出堆顶元素, 放到数组尾部, 并调整堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>红黑树</title><link>https://justice.bj.cn/post/12.data_struct/tree/rb-tree.html</link><pubDate>Fri, 10 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/rb-tree.html</guid><description>&lt;h1 id="红黑树rb-tree">红黑树(RB-Tree)&lt;/h1>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>红黑树是一种二叉平衡树。&lt;/p>
&lt;h2 id="性质">性质&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个节点要么是黑色，要么是红色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Root 节点是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个叶子节点（NIL）是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个红色结点的两个子结点一定都是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="旋转">旋转&lt;/h2>
&lt;ul>
&lt;li>右旋&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-07-rbtree-right-rotate.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>左旋&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-29-rbtree-left-rotate.webp" alt="loading-ag-18088">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/63272157">https://zhuanlan.zhihu.com/p/63272157&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/92761639">https://zhuanlan.zhihu.com/p/92761639&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>LSMTree日志结构合并树</title><link>https://justice.bj.cn/post/12.data_struct/tree/lsm-tree.html</link><pubDate>Thu, 09 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/lsm-tree.html</guid><description>&lt;h1 id="日志结构合并树lsm-tree">日志结构合并树(LSM-Tree)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>LSM-Tree&lt;/code>全称Log Structured Merge Tree，是Google在2006年开源其BigTable中引入的一种数据结构。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种分层，有序，面向磁盘的数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其核心思想是充分了利用了磁盘批量的顺序写要远比随机写性能高出很多的特性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LSM-Tree大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于写多读少的场景;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sstable">SSTable&lt;/h2>
&lt;p>LSM-Tree核心的数据结构是SSTable，全称是Sorted String Table；&lt;/p>
&lt;p>SSTable是一种拥有持久化，有序且不可变的的键值存储结构，它的key和value都是任意的字节数组，并且了提供了按指定key查找和指定范围的key区间迭代遍历的功能。SSTable内部包含了一系列可配置大小的Block块，典型的大小是64KB，关于这些Block块的index存储在SSTable的尾部，&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-12-38-2021-09-04-10-12-33-image.png" alt="">&lt;/p>
&lt;h2 id="整体结构">整体结构&lt;/h2>
&lt;p>LSM-Tree里，SSTable有一份在内存里面，其他的多级在磁盘上，如下图是一份完整的LSM-Tree图示&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-08-25-2021-09-04-10-08-20-image.png" alt="">&lt;/p>
&lt;h2 id="写流程">写流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>当收到一个写请求时，会先把该条数据记录在WAL Log里面，用作故障恢复；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当写完WAL Log后，会把该条数据写入内存的SSTable里面（删除是墓碑标记，更新是新记录一条的数据），也称Memtable。注意为了维持有序性在内存里面可以采用红黑树或者跳跃表相关的数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当Memtable超过一定的大小后，会在内存里面冻结，变成不可变的Memtable，同时为了不阻塞写操作需要新生成一个Memtable继续提供服务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把内存里面不可变的Memtable给dump到到硬盘上的SSTable层中，此步骤也称为Minor Compaction，这里需要注意在L0层的SSTable是没有进行合并的，所以这里的key range在多个SSTable中可能会出现重叠，在层数大于0层之后的SSTable，不存在重叠key；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当每层的磁盘上的SSTable的体积超过一定的大小或者个数，也会周期的进行合并。此步骤也称为Major Compaction，这个阶段会真正 的清除掉被标记删除掉的数据以及多版本数据的合并，避免浪费空间，注意由于SSTable都是有序的，我们可以直接采用merge sort进行高效合并。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="读流程">读流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>当收到一个读请求的时候，会直接先在内存里面查询，如果查询到就返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果没有查询到就会依次下沉，知道把所有的Level层查询一遍得到最终结果。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="优化">优化&lt;/h2>
&lt;h3 id="压缩">压缩&lt;/h3>
&lt;p>SSTable 是可以启用压缩功能的，并且这种压缩不是将整个 SSTable 一起压缩，而是根据 locality 将数据分组，每个组分别压缩，这样的好处当读取数据的时候，我们不需要解压缩整个文件而是解压缩部分 Group 就可以读取。&lt;/p>
&lt;h3 id="缓存">缓存&lt;/h3>
&lt;p>因为SSTable在写入磁盘后，除了Compaction之外，是不会变化的，所以我可以将Scan的Block进行缓存，从而提高检索的效率&lt;/p>
&lt;h2 id="索引bloom-filters">索引，Bloom filters&lt;/h2>
&lt;p>正常情况下，一个读操作是需要读取所有的 SSTable 将结果合并后返回的，但是对于某些 key 而言，有些 SSTable 是根本不包含对应数据的，因此，我们可以对每一个 SSTable 添加 Bloom Filter，因为布隆过滤器在判断一个SSTable不存在某个key的时候，那么就一定不会存在，利用这个特性可以减少不必要的磁盘扫描。&lt;/p>
&lt;h3 id="合并">合并&lt;/h3>
&lt;p>这个在前面的写入流程中已经介绍过，通过定期合并瘦身， 可以有效的清除无效数据，缩短读取路径，提高磁盘利用空间。但Compaction操作是非常消耗CPU和磁盘IO的，尤其是在业务高峰期，如果发生了Major Compaction，则会降低整个系统的吞吐量，这也是一些NoSQL数据库，比如Hbase里面常常会禁用Major Compaction，并在凌晨业务低峰期进行合并的原因。&lt;/p>
&lt;h2 id="lsm-tree-vs-btree">LSM-Tree vs B+Tree&lt;/h2>
&lt;p>传统关系型数据采用的底层数据结构是B+树，那么同样是面向磁盘存储的数据结构LSM-Tree相比B+树有什么异同之处呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LSM-Tree的设计思路是，将数据拆分为几百M大小的Segments，并是顺序写入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>B+Tree则是将数据拆分为固定大小的Block或Page, 一般是4KB大小，和磁盘一个扇区的大小对应，Page是读写的最小单位。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在数据的更新和删除方面，B+Tree可以做到原地更新和删除，这种方式对数据库事务支持更加友好，因为一个key只会出现一个Page页里面，但由于LSM-Tree只能追加写，并且在L0层key的rang会重叠，所以对事务支持较弱，只能在Segment Compaction的时候进行真正地更新和删除。&lt;/p>
&lt;p>因此LSM-Tree的优点是支持高吞吐的写（可认为是O（1）），这个特点在分布式系统上更为看重，当然针对读取普通的LSM-Tree结构，读取是O（N）的复杂度，在使用索引或者缓存优化后的也可以达到O（logN）的复杂度。&lt;/p>
&lt;p>而B+tree的优点是支持高效的读（稳定的OlogN），但是在大规模的写请求下（复杂度O(LogN)），效率会变得比较低，因为随着insert的操作，为了维护B+树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。&lt;/p>
&lt;p>还有一点需要提到的是基于LSM-Tree分层存储能够做到写的高吞吐，带来的副作用是整个系统必须频繁的进行compaction，写入量越大，Compaction的过程越频繁。而compaction是一个compare &amp;amp; merge的过程，非常消耗CPU和存储IO，在高吞吐的写入情形下，大量的compaction操作占用大量系统资源，必然带来整个系统性能断崖式下跌，对应用系统产生巨大影响，当然我们可以禁用自动Major Compaction，在每天系统低峰期定期触发合并，来避免这个问题。&lt;/p>
&lt;p>阿里为了优化这个问题，在X-DB引入了异构硬件设备FPGA来代替CPU完成compaction操作，使系统整体性能维持在高水位并避免抖动，是存储引擎得以服务业务苛刻要求的关键。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/developer/article/1441835">深入理解什么是LSM-Tree - 云+社区 - 腾讯云&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>B树</title><link>https://justice.bj.cn/post/12.data_struct/tree/b-tree.html</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/b-tree.html</guid><description>&lt;h1 id="b-tree">B-Tree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>B 树又叫平衡多路查找树。主要应用于数据库，文件等&lt;/p>
&lt;p>一棵 m 阶的 B 树 (m 叉树)的特性如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>树中每个结点最多含有 m 个孩子（m&amp;gt;=2）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中 ceil(x)是一个取上限的函数）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为 null)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个非终端结点中包含有 n 个关键字信息： (P1，K1，P2，K2，P3，&amp;hellip;&amp;hellip;，Kn，Pn+1)。其中：
       a)   Ki (i=1&amp;hellip;n)为关键字，且关键字按顺序升序排序 K(i-1)&amp;lt; Ki。 
       b)   Pi 为指向子树根的接点，且指针 P(i)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。 
       c)   关键字的个数 n 必须满足： [ceil(m / 2)-1]&amp;lt;= n &amp;lt;= m-1。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-56-17-2020-04-21-13-16-05-image.png" alt="">&lt;/p>
&lt;p>来模拟下查找文件 29 的过程：&lt;/p>
&lt;p>(1) 根据根结点指针找到文件目录的根磁盘块 1，将其中的信息导入内存。【磁盘 IO 操作 1 次】&lt;/p>
&lt;p>(2) 此时内存中有两个文件名 17，35 和三个存储其他磁盘页面地址的数据。根据算法我们发现 17&amp;lt;29&amp;lt;35，因此我们找到指针 p2。&lt;/p>
&lt;p>(3) 根据 p2 指针，我们定位到磁盘块 3，并将其中的信息导入内存。【磁盘 IO 操作 2 次】&lt;/p>
&lt;p>(4) 此时内存中有两个文件名 26，30 和三个存储其他磁盘页面地址的数据。根据算法我们发现 26&amp;lt;29&amp;lt;30，因此我们找到指针 p2。&lt;/p>
&lt;p>(5) 根据 p2 指针，我们定位到磁盘块 8，并将其中的信息导入内存。【磁盘 IO 操作 3 次】&lt;/p>
&lt;p>(6) 此时内存中有两个文件名 28，29。根据算法我们查找到文件 29，并定位了该文件内存的磁盘地址。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md">The-Art-Of-Programming-By-July/03.02.md at master · julycoding/The-Art-Of-Programming-By-July · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>MassTree</title><link>https://justice.bj.cn/post/12.data_struct/tree/masstree.html</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/masstree.html</guid><description>&lt;h1 id="masstree">MassTree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>masstree 来源于 2012 年发表的论文(&lt;a href="https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf">Cache craftiness for fast multicore key-value storage&lt;/a>)，&lt;strong>可以理解为 B+ Tree 和 Radix Tree 的混合体&lt;/strong>，即将键切分成多个部分，每个部分为一个节点；每个节点内部又是一个 B+ Tree，兼顾空间和性能。&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>Masstree 将变长键划分成多个固长部分，每个固长部分可以通过 int 类型表示，而不是 char 类型。由于处理器处理 int 类型比较操作的速度远远快于 char 数组的比较，因此 Masstree 通过 int 类型的比较进一步加速了查找过程。固定长度可以设置为 CPU 缓存行长度，以增加 CPU 缓存效率。&lt;/li>
&lt;li>每个节点是一个 B+ Tree，因此 CPU 在查询的时候可以将节点所代表的 B+ Tree 加载到 CPU 缓存中，以增加 CPU 缓存命中率。&lt;/li>
&lt;li>其并发控制用到了 Read-Copy-Update(RCU)。读不因任何数据更新而阻塞，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据。因此读不会造成 CPU 缓存无效。&lt;/li>
&lt;/ul>
&lt;h2 id="结构">结构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-10-57-34-image-20190528102500578-9312132.png" alt="image-20190528102500578">&lt;/p>
&lt;h2 id="mass-tree-算法">&lt;strong>Mass Tree 算法&lt;/strong>&lt;/h2>
&lt;h2 id="并发策略">&lt;strong>并发策略&lt;/strong>&lt;/h2>
&lt;p>Mass Tree 的并发策略和 OLFIT Tree 是相似的：&lt;/p>
&lt;ol>
&lt;li>fine-grained locking，即节点锁，解决 write-write 竞争，同一时刻只有一个线程可以对当前节点进行写操作&lt;/li>
&lt;li>optimistic concurrency control，即节点  &lt;code>version&lt;/code> (uint32_t)，解决 read-write 竞争，读开始前和读结束后都需要获取当前节点的最新 version，来判断在读过程中当前节点是否发生了写操作（插入或分裂），同时对节点的写操作都需要先修改 version，在插入 key 之前需要设置  &lt;code>inserting&lt;/code>  标记，插入完成之后将 insert 的 vinsert + 1；在分裂之前需要设置  &lt;code>splitting&lt;/code>  标记，分裂完成之后将 split 的 vsplit + 1。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-00-01-2020-11-14-10-59-56-image.png" alt="">&lt;/p>
&lt;p>和  &lt;code>permutation&lt;/code>  一样，&lt;code>version&lt;/code>  也被划分成了多个域，除了带有 insert 和 split 信息之外，还包含一个 lock bit，用于加锁；一个 root bit，用于指示否是根节点；一个 border bit，用于指示是否是 border node；一位 deleted 位，用于指示这个节点是否被标记为删除。&lt;/p>
&lt;h2 id="下降流程">&lt;strong>下降流程&lt;/strong>&lt;/h2>
&lt;p>对于每次插入，获取，删除操作，都需要从 root（可能是整棵树的根节点，也可能是某棵子树的根节点） 下降到对应的叶节点（border node）。&lt;/p>
&lt;p>首先，在开始读取节点之前，必须获得节点的 stable version（图中橙色方块），即  &lt;code>version&lt;/code>  中的  &lt;code>inserting&lt;/code>  和  &lt;code>splitting&lt;/code>  位都为 0。&lt;/p>
&lt;p>其次，在下降之前，需要获取最新的 root，因为在开始下降前，根节点可能分裂了，导致其发生了改变（图中蓝色方块）。&lt;/p>
&lt;p>最后，如果当前节点已经是叶节点，那么可以返回，否则需要进行下降，读取内部结点根据  &lt;code>key[x, x+8)&lt;/code>(8 字节) 获得下降节点之后，分为 3 种情况处理：&lt;/p>
&lt;ol>
&lt;li>case 1 那行伪代码可以这样用 C 语言表示：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">before&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node_get_stable_version&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// read node here
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node_get_version&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// no need to be stable, just latest version
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">before&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">LOCK_BIT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">before&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1">// neither insert nor split happened
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>节点在我们读取期间没有发生任何变化，我们可以安全地进行下降；&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>节点发生了变化，而且是分裂，那么我们需要从根节点重新进行下降（内部节点没有相互连接起来，所以不能像 Blink Tree 那样获取右节点）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点发生了变化，但只是插入，只需要重新对当前节点进行下降&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>注意第二个黄色方块，这一行非常关键，如果你细看下的话，它似乎可以挪到 case 1 的 if 语句里面，但实际上不能这样做。因为如果当前节点的孩子节点发生了分裂，但是还没来得及将新节点插入到当前节点，对调这两行代码，可能会导致下降到错误的节点。&lt;/p>
&lt;/blockquote>
&lt;h2 id="插入流程">&lt;strong>插入流程&lt;/strong>&lt;/h2>
&lt;p>作者只给出了读取伪代码，这里给出插入伪代码。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-02-06-2020-11-14-11-01-59-image.png" alt="">&lt;/p>
&lt;p>当我们通过  &lt;code>findborder&lt;/code>  下降到叶节点后，需要对其加锁（图中蓝色方块），但是此时并不能直接将 key 进行插入，当两个写线程同时下降到同一个叶节点时，只有一个线程可以进行写入，所以加锁后需要查看在加锁前是否有其他线程对这个节点进行了写入，如果有的话需要查看是否需要右移，这里的逻辑和 Blink Tree 是一样的。&lt;/p>
&lt;p>当我们成功加锁并且定位到正确的叶节点之后，可以进行写入，结果有 4 种：&lt;/p>
&lt;ol>
&lt;li>插入 key 成功或 key 已经存在；&lt;/li>
&lt;li>需要下降到下一层，同时需要增加索引的偏移；&lt;/li>
&lt;li>存在索引冲突，比如 &amp;ldquo;12345678AA&amp;rdquo; 和 &amp;ldquo;12345678BB&amp;rdquo;，此时需要创建一棵子树，存放 &amp;ldquo;AA&amp;rdquo; 和 &amp;ldquo;BB&amp;rdquo;，同时需要把原来存放 &amp;ldquo;AA&amp;rdquo; 的地方替换成这棵子树的根节点&lt;/li>
&lt;li>节点已满，需要分裂之后再次插入（见下一小节）&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>橙色方块在下面删除流程中介绍&lt;/p>
&lt;/blockquote>
&lt;h2 id="实现">实现&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/UncP/aili">UncP/aili&lt;/a>，没有实现删除操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/rmind/masstree">https://github.com/rmind/masstree&lt;/a>，采用了激进生成子树的策略，缺点就是 cache locality 在有些情况下不好。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>论文作者的实现：&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/kohler/masstree-beta">https://github.com/kohler/masstree-beta&lt;/a>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="总结">&lt;strong>总结&lt;/strong>&lt;/h2>
&lt;ol>
&lt;li>Trie 和 B+ 两种索引树的结合，使得在下降过程中的重试不需要从整棵树的根节点开始，同时加快拥有相同前缀的 key 的处理速度&lt;/li>
&lt;li>具体的内部结点与外部节点的结构&lt;/li>
&lt;li>fine-grained locking 写以及 lock-free 读&lt;/li>
&lt;li>比较具体的节点删除机制&lt;/li>
&lt;li>较小的节点减少了线程的竞争&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>需要指出的是这个算法不支持性能线性扩展，不过这并不是问题。&lt;/p>
&lt;/blockquote>
&lt;p>这个算法实现起来很有&lt;strong>挑战性&lt;/strong>，个人认为主要有两个方面，第一个是对于&lt;strong>树结构的把握&lt;/strong>，Mass Tree 是 Trie 和 B+ 树的结合。第二个是对于&lt;strong>并发下可见性的理解&lt;/strong>，”先改哪个域后改哪个域“，”谁先可见谁后可见“，”谁何时可见“，“在哪加以及加不加 memory barrier”等等这样的问题需要花很多时间考虑，而且出现 bug 非常难调试。&lt;/p>
&lt;p>Mass Tree 性能比我预想中要好很多，对于均匀分布的 10 字节 key 随机插入，数据量 1000 万，在我的机器上 4 个线程可以到 500 万以上的 tps；对于分布集中的测试数据，可以到 1000 万以上。其实&lt;strong>对于内存索引来说，cache miss 对性能造成的影响有时候是远远大于线程竞争的&lt;/strong>，所以尽管数据分布非常集中（线程竞争更多），仍然可以获得更高的性能。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf">https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kohler/masstree-beta">https://github.com/kohler/masstree-beta&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/52624601">https://zhuanlan.zhihu.com/p/52624601&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>MerkleTree</title><link>https://justice.bj.cn/post/12.data_struct/tree/merkle-tree.html</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/merkle-tree.html</guid><description>&lt;h1 id="merkle-tree">Merkle Tree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Merkle Tree 是一种 Hash Tree，由 Ralph Merkle 在 1979 年发明。&lt;/p>
&lt;p>Merkle Tree 的每个非叶节点通过其子节点的标记或者值（子节点为叶节点）的哈希值来进行标注，为大型的数据结构提供了高效安全的验证手段。&lt;/p>
&lt;p>Merkle Tree 可以理解为哈希列表和哈希链表的泛化产物。&lt;/p>
&lt;h2 id="结构">结构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/05-20-37-06-2020-12-05-20-34-44-image.png" alt="">&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>MT 是一种树，大多数是二叉树，也可以多叉树；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Merkle Tree 的叶子节点的 value 是数据集合的单元数据或者单元数据 HASH。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非叶子节点的 value 是根据它下面所有的叶子节点值，然后按照 Hash 算法计算而得出的；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>数字签名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>P2P 网络&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可信计算&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPFS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BitCoin/Ethereum&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/fengzhiwu/p/5524324.html">Merkle Tree 学习&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Radix Tree</title><link>https://justice.bj.cn/post/12.data_struct/tree/radixtree.html</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/radixtree.html</guid><description>&lt;h1 id="基数树radix-tree">基数树(Radix Tree)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Radix tree(也被称为 radix trie，或者 compact prefix tree)是一种空间优化的前缀树(prefix tree)数据结构。&lt;/p>
&lt;p>针对这对这样的稀疏长整型数据查找，能高速且节省空间地完成映射&lt;/p>
&lt;img title="" src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-32-55-2021-09-04-10-32-52-image.png" alt="" data-align="left">
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>IP 路由；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>倒排索引；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IDR（ID Radix）机制；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Linux 基数树（radix tree），内存管理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Redis Radix tree；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://ivanzz1001.github.io/records/post/data-structure/2018/11/18/ds-radix-tree" title="数据结构之Radix Tree">数据结构之 Radix Tree&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://sourcelink.top/2019/09/26/linux-kernel-radix-tree-analysis/">详解 Linux 内核 Radix 树算法的实现 - 黎棉麒的独立博客&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/developer/article/1597128">图解 Redis 中的 Radix 树 - 云+社区 - 腾讯云&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item></channel></rss>