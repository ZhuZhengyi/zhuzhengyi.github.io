<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 14 Jun 2022 19:20:14 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Flink消息消费流程</title><link>https://justice.bj.cn/post/30.architech/flink/flink-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 14 Jun 2022 19:20:14 +0800</pubDate><guid>https://justice.bj.cn/post/30.architech/flink/flink-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E6%B5%81%E7%A8%8B/</guid><description>&lt;h1 id="flink消息消费流程">Flink消息消费流程&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>准备一个ResultPartition；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通知JobMaster；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JobMaster通知下游节点；如果下游节点尚未部署，则部署之；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下游节点向上游请求数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开始传输数据&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/03-21-34-50-2022-01-03-21-34-42-image.png" alt="">&lt;/p>
&lt;h3 id="数据跨-task-传输">数据跨 task 传输&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>数据在本operator处理完后，交给RecordWriter。每条记录都要选择一个下游节点，所以要经过ChannelSelector。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个channel都有一个serializer（我认为这应该是为了避免多线程写的麻烦），把这条Record序列化为ByteBuffer&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来数据被写入ResultPartition下的各个subPartition里，此时该数据已经存入DirectBuffer（MemorySegment）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单独的线程控制数据的flush速度，一旦触发flush，则通过Netty的nio通道向对端写入&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对端的netty client接收到数据，decode出来，把数据拷贝到buffer里，然后通知InputChannel&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有可用的数据时，下游算子从阻塞醒来，从InputChannel取出buffer，再解序列化成record，交给算子执行用户代码&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/03-21-39-06-2022-01-03-21-39-02-image.png" alt="">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://blog.csdn.net/jsjsjs1789/article/details/106526982">一文搞定 Flink 消费消息的全流程_shengjk1的博客-CSDN博客_flink阻塞消费&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>区块链-POS共识机制</title><link>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE-pos%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</link><pubDate>Tue, 14 Jun 2022 19:20:14 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE-pos%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</guid><description>&lt;h1 id="区块链-pos共识机制">区块链-POS共识机制&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>PoS(Proof of Stake，权益证明), 最早由点点币的创始人Sunny King提出，目的是为了解决使用PoW挖矿出现大量资源浪费的问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在基于PoS共识的区块链网络中，节点不再通过算力竞争记账权，获得记账权的概率取决于其拥有的权益多少；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>“权益”（Stake）可以是节点持有的通证数量，也可以是关于通证数量的一个函数；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="实现原理">实现原理&lt;/h4>
&lt;p>我们知道PoW挖矿的基本逻辑和步骤，即找到一个nonce值，使得新区块头的哈希值小于某个指定的值，即区块头结构中的“难度目标”&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Hash (block_header) &amp;lt; Target
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从公式中我们可以看到，PoW下所有矿工的目标值是一样的，只要计算结果哈希小于目标值即可，简化来看就是前导0的个数。&lt;/p>
&lt;p>而在PoS系统中，这个公式变更为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Hash (block_header) &amp;lt; Target * CoinAge
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>变量叫做CoinAge，也就是币龄，这里就有意思了。&lt;/p>
&lt;p>这个变量为会造成每个矿工看到的目标值不一样，如果你的币龄越大，也就意味着你的获得答案越容易。这里的Target与PoW一致，与全网难度成反比，用来控制出块速度的。&lt;/p>
&lt;p>例如当前全网的目标是4369，A矿工的输入的币龄是15，那么A矿工的目标值为65535，换算成十六进制就是0xFFFF，完整的哈希长度假设是8位，也就是0x0000FFFF。&lt;/p>
&lt;p>而B矿工比较有钱，他输入的币龄是240，那么B矿工的目标值就是0x000FFFFF。你如果仔细观察肯定会发现，相比A矿工的目标值，B直接少了一个零。即如下：&lt;/p>
&lt;p>A 矿工 Hash( block_header ) &amp;lt; 0x0000FFFF&lt;br>
B 矿工 Hash( block_header ) &amp;lt; 0x000FFFFF&lt;/p>
&lt;p>所以B矿工获得记账权的概率肯定要比A高。&lt;/p>
&lt;h4 id="pos的相关问题">PoS的相关问题&lt;/h4>
&lt;h3 id="无利害攻击">无利害攻击&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>任何节点都可以挖矿，导致链容易出现分叉；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以太坊Casper共识应用了“执剑人”（Slashers，又译“剑手”）机制，在共识机制中引入惩罚措施，解决以往PoS共识的公共地悲剧；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="长程攻击">长程攻击&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>“长程攻击”是PoS共识中威胁最大的攻击形式；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当一个节点收回了他的抵押金时，虽然它不再拥有验证以后的区块的权利，但是仍然可以对收回抵押之前的区块进行回滚，并且由于它不再会受到没收押金惩罚，因此攻击者能够通过贿赂这些节点，收集足够的“幽灵”抵押金（这些抵押金已经被收回了），重新构造一条足够长的攻击链，尝试替换这些节点在作为验证者期间曾经验证过的区块；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一种解决策略是&lt;strong>移动检查点&lt;/strong>。即每隔一定的区块间隔设置检查点，只有检查点之后的区块可能会被重组。检查点的间隔一般少于要求的最短抵押金抵押时间，从而保证有充足可能性的区块都是由还有缴纳了抵押金的节点验证的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一种解决策略是&lt;strong>上下文感知交易&lt;/strong>（Context-Aware transactions）。在构造一笔交易时，在交易中记录前一个或前几个区块的哈希值，这样就能将一笔交易和特定的区块分支联系起来，在分叉链上伪造交易就变得困难；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.jianshu.com/p/aa61fb4c1e3c">共识机制-POS(权益证明)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://medium.com/centrality/%E4%BA%86%E8%A7%A3%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6-%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E-pow-%E8%BF%98%E6%98%AF%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E-pos-94a0e0530624">了解共识机制：工作证明（POW）还是权益证明（POS）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://medium.com/@tokenroll/pos%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%BC%95%E5%8D%B7%E4%B9%8B%E4%BA%94-483c4639e0f8">PoS共识机制及设计哲学&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>区块链中的攻击</title><link>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E6%94%BB%E5%87%BB/</link><pubDate>Tue, 14 Jun 2022 19:20:14 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E6%94%BB%E5%87%BB/</guid><description>&lt;h1 id="区块链中的攻击">区块链中的攻击&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="1-双花攻击">1. 双花攻击&lt;/h2>
&lt;h3 id="问题">问题&lt;/h3>
&lt;ul>
&lt;li>双花问题是在点对点数字现金系统中，支付方将同一笔资金同时支付给两位收款方，由于收款方无法验证自己收到的资金是否还曾经付给他人，因此支付方使用一笔资金；&lt;/li>
&lt;/ul>
&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>中心化方式：监督者+盲签名；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非中心化方式：比特币挖矿&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="2-粉尘攻击">2. 粉尘攻击&lt;/h2>
&lt;h3 id="问题-1">问题&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>粉尘就是很小部分的交易或金额，通常这部分金额都不值得交易，因为他们的交易费用常常都高于其本身价值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>攻击者向被攻击者钱包地址中发送少量的satoshis，将这些地址“粉尘化”。之后攻击者追踪已经被粉尘化的钱包中的资金和所有的交易，继而连接上这些地址，并最后确定这些钱包地址所属的公司或个人，从而破坏了被攻击者的隐私；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="对抗方案">对抗方案&lt;/h3>
&lt;ul>
&lt;li>对可疑的感染粉尘的账户进行预警(小于几百satoshis的交易)，避免移动；&lt;/li>
&lt;/ul>
&lt;h2 id="heading">&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://academy.binance.com/zh/articles/double-spending-explained">双花问题详解 | Binance Academy&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://academy.binance.com/zh/articles/what-is-a-dusting-attack">什么是粉尘攻击？ | Binance Academy&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://medium.com/@tokenroll/pos%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%BC%95%E5%8D%B7%E4%B9%8B%E4%BA%94-483c4639e0f8">PoS共识机制及设计哲学 — — 区块链技术引卷之五&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>只出现一次的数字 III</title><link>https://justice.bj.cn/post/leetcode/doc/260.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97iii/</link><pubDate>Tue, 14 Jun 2022 10:57:13 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/260.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97iii/</guid><description>&lt;h1 id="只出现一次的数字-iiihttpsleetcodecnproblemssingle-number-iiidescription-httpsleetcodecnproblemssingle-number-iiidescription">&lt;a href="https://leetcode.cn/problems/single-number-iii/description/" title="https://leetcode.cn/problems/single-number-iii/description/">只出现一次的数字 III&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Medium (73.51%)&lt;/td>
&lt;td>620&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/bit-manipulation" title="https://leetcode.com/tag/bit-manipulation">&lt;code>bit-manipulation&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>Unknown&lt;/code>&lt;/p>
&lt;p>给定一个整数数组 &lt;code>nums&lt;/code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 &lt;strong>任意顺序&lt;/strong> 返回答案。&lt;/p>
&lt;p>**进阶：**你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：nums = [-1,0]
输出：[-1,0]
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：nums = [0,1]
输出：[1,0]
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>2 &amp;lt;= nums.length &amp;lt;= 3 * 104&lt;/code>&lt;/li>
&lt;li>&lt;code>-231 &amp;lt;= nums[i] &amp;lt;= 231 - 1&lt;/code>&lt;/li>
&lt;li>除两个只出现一次的整数外，&lt;code>nums&lt;/code> 中的其他数字都出现两次&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode.cn/problems/single-number-iii/comments/" title="https://leetcode.cn/problems/single-number-iii/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode.cn/problems/single-number-iii/solution/" title="https://leetcode.cn/problems/single-number-iii/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * ## 解题思路
&lt;/span>&lt;span class="cm"> * 1. 先将所有数字进行异或操作，得到一个异或结果xor, 由于存在两个不同的元素，则xor必不为0；
&lt;/span>&lt;span class="cm"> * 2. 根据xor，计算mask = xor &amp;amp; -xor, 得到xor第一个1
&lt;/span>&lt;span class="cm"> * 3. 使用mask与每个数字进行与操作，将nums分成两个子nums1， nums2，
&lt;/span>&lt;span class="cm"> * 4. 分别对两个nums1, nums2执行xor操作，得到最后两个不同的数；
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">singleNumber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&amp;amp;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">div&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="nl">n&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">div&lt;/span> &lt;span class="o">^=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">div&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">div&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="nl">n&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">div&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">a&lt;/span> &lt;span class="o">^=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="n">b&lt;/span> &lt;span class="o">^=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>基本计算器</title><link>https://justice.bj.cn/post/leetcode/doc/224.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</link><pubDate>Mon, 13 Jun 2022 17:36:43 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/224.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</guid><description>&lt;h1 id="基本计算器httpsleetcodecnproblemsbasic-calculatordescription-httpsleetcodecnproblemsbasic-calculatordescription">&lt;a href="https://leetcode.cn/problems/basic-calculator/description/" title="https://leetcode.cn/problems/basic-calculator/description/">基本计算器&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Hard (41.92%)&lt;/td>
&lt;td>777&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/math" title="https://leetcode.com/tag/math">&lt;code>math&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/stack" title="https://leetcode.com/tag/stack">&lt;code>stack&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>google&lt;/code>&lt;/p>
&lt;p>给你一个字符串表达式 &lt;code>s&lt;/code> ，请你实现一个基本计算器来计算并返回它的值。&lt;/p>
&lt;p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 &lt;code>eval()&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;1 + 1&amp;#34;
输出：2
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34; 2-1 + 2 &amp;#34;
输出：3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;(1+(4+5+2)-3)+(6+8)&amp;#34;
输出：23
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= s.length &amp;lt;= 3 * 105&lt;/code>&lt;/li>
&lt;li>&lt;code>s&lt;/code> 由数字、&lt;code>'+'&lt;/code>、&lt;code>'-'&lt;/code>、&lt;code>'('&lt;/code>、&lt;code>')'&lt;/code>、和 &lt;code>' '&lt;/code> 组成&lt;/li>
&lt;li>&lt;code>s&lt;/code> 表示一个有效的表达式&lt;/li>
&lt;li>&amp;lsquo;+&amp;rsquo; 不能用作一元运算(例如， &amp;ldquo;+1&amp;rdquo; 和 &lt;code>&amp;quot;+(2 + 3)&amp;quot;&lt;/code> 无效)&lt;/li>
&lt;li>&amp;lsquo;-&amp;rsquo; 可以用作一元运算(即 &amp;ldquo;-1&amp;rdquo; 和 &lt;code>&amp;quot;-(2 + 3)&amp;quot;&lt;/code> 是有效的)&lt;/li>
&lt;li>输入中不存在两个连续的操作符&lt;/li>
&lt;li>每个数字和运行的计算将适合于一个有符号的 32位 整数&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode.cn/problems/basic-calculator/comments/" title="https://leetcode.cn/problems/basic-calculator/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode.cn/problems/basic-calculator/solution/" title="https://leetcode.cn/problems/basic-calculator/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> ## 解题思路
&lt;/span>&lt;span class="cm"> * 对于表达式： 1+(4—(5+2))-3+(6+8)-(10-(19-3))
&lt;/span>&lt;span class="cm"> = 1 + 4 + (-5) + (-2) + (-3) + 6 + 8 + (-10) + (--19) + (---3)
&lt;/span>&lt;span class="cm"> * 可以看出, 结果 = 各个数字与其前面的符号 的 和 组成
&lt;/span>&lt;span class="cm"> * 各个数字前面的符号由嵌套括号决定，每多一层括号，
&lt;/span>&lt;span class="cm"> * 如果括号前为+, 则括号中的各个数字符号不变；
&lt;/span>&lt;span class="cm"> * 如果括号前符号为-, 则括号中各个数字的符号取反；
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">calculate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//每个操作数的符号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//符号
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//空格，跳过
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;+&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//+, 上级符号不编号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;-&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//-，上级符号变相反；
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;(&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//左括号, 符号入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sign&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;)&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//右括号，符号出栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//数字，计算累加和
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="sc">&amp;#39;9&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">num&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ret&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// ## 解题思路
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 对于表达式： 1+(4—(5+2))-3+(6+8)-(10-(19-3))
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// = 1 + 4 + (-5) + (-2) + (-3) + 6 + 8 + (-10) + (--19) + (---3)
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 可以看出, 结果 = 各个数字与其前面的符号 的 和 组成
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 各个数字前面的符号由嵌套括号决定，每多一层括号，
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 如果括号前为+, 则括号中的各个数字符号不变；
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 如果括号前符号为-, 则括号中各个数字的符号取反；
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">calculate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">i32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bs&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">as_bytes&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ret&lt;/span>: &lt;span class="kt">i32&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">[];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sign&lt;/span>: &lt;span class="kt">i32&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>: &lt;span class="kt">usize&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">match&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">b&amp;#39; &amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">b&amp;#39;(&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sign&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">b&amp;#39;)&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">b&amp;#39;+&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sign&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">b&amp;#39;-&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sign&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">matches&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">b&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sc">b&amp;#39;9&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">b&amp;#39;0&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sign&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Rust模块及包管理</title><link>https://justice.bj.cn/post/14.language/rust/80.rust%E5%8C%85%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 13 Jun 2022 16:32:28 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/80.rust%E5%8C%85%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="rust模块及包管理">Rust模块及包管理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Rust程序代码组织分为三个层级：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>项目(package)&lt;/strong>：一个项目工程，一个项目通常由一个&lt;code>cargo.toml&lt;/code>定义，可包含多个crate；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>包(crate)&lt;/strong>：是一个独立的可编译单元成二进制的单元，可分为bin和lib两种类型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>模块(mod)&lt;/strong>：是包内代码组织单元，用于实现命名空间；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="项目package">项目(Package)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>项目是由cargo.toml定义的一个rust源码编译目录结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个项目由一个或多个crate组成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>项目可由cargo命令进行管理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="p">[&lt;/span>&lt;span class="nx">package&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;crate-name&amp;#34;&lt;/span>
&lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.1.0&amp;#34;&lt;/span>
&lt;span class="nx">authors&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;xxx&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">edition&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;2018&amp;#34;&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#xxx&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">features&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#default = [&amp;#34;test&amp;#34;]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="包crate">包(Crate)&lt;/h2>
&lt;p>包(&lt;code>crate&lt;/code>)是rust可独立编译的单元，包要点如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>包&lt;code>crate&lt;/code> 由一个或一批文件组成，可独立编译为二进制文件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>包分为两种类型：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>库(lib):&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可执行二进制文件(bin):&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>同一个crate的文件一般放在同一个目录下；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个crate有一个入口文件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>二进制包入口为&lt;code>main.rs&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>库的入口文件是&lt;code>lib.rs&lt;/code>;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>引入外部crate：&lt;code>extern crate xxx;&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用未发布的本地crate, 在&lt;code>Cargo.toml&lt;/code> &lt;code>dependencies&lt;/code>中声明；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="c">#... &lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#xxx&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">features&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#default = [&amp;#34;test&amp;#34;]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="模块module">模块（module）&lt;/h2>
&lt;p>模块(&lt;code>mod&lt;/code>)是包内部代码组织单元，模块要点如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>模块由关键字&lt;code>mod&lt;/code>定义：&lt;code>mod XXX { ... } &lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块的命名风格是 &lt;code>lower_snake_case&lt;/code>，跟其它的 Rust 的标识符一样；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块可以嵌套；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块中可以写任何合法的 Rust 代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个包默认实现了一个隐式的 &lt;code>根模块（root module）&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个文件就是一个mod, mod名就是文件名，main.rs, lib.rs, mod.rs文件除外；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mod.rs&lt;/code>的模块名是其所在目录的名字；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>main.rs&lt;/code>, &lt;code>lib.rs&lt;/code> 的模块名是其目录结构，如：&lt;code>exp/src/main.rs&lt;/code>或 &lt;code>lip/src/lib.rs&lt;/code> 的mod名分别是exp和lip；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mod foo;&lt;/code> 告诉编译器找寻./foo.rs或者./foo/mod.rs，并且将找寻到的文件内容作为module foo的内容;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文件和文件夹内的mod及其内部定义的函数默认都是private的，除非pub声明公开；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>private元素只有本模块内的元素以及它的子模块可以访问；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>public元素上一层的模块就有权访问它；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果存在与文件&lt;code>foo.rs&lt;/code>同名的目录&lt;code>foo/&lt;/code>， 则在该目录&lt;code>foo/*.rs&lt;/code>下定义的模块都是该文件的子模块；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>子模块必须在父模块在**声明(**mod child)，不然它们就不会存在。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">foo&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//声明mod
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//是将一个模块加进当前的scope。
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Rust 的多层模块遵循如下两条规则：&lt;/p>
&lt;ol>
&lt;li>优先查找&lt;code>xxx.rs&lt;/code> 文件
&lt;ol>
&lt;li>&lt;code>main.rs&lt;/code>、&lt;code>lib.rs&lt;/code>、&lt;code>mod.rs&lt;/code>中的&lt;code>mod xxx;&lt;/code> 默认优先查找同级目录下的 &lt;code>xxx.rs&lt;/code> 文件；&lt;/li>
&lt;li>其他文件&lt;code>yyy.rs&lt;/code>中的&lt;code>mod xxx;&lt;/code>默认优先查找同级目录的&lt;code>yyy&lt;/code>目录下的 &lt;code>xxx.rs&lt;/code> 文件；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>如果 &lt;code>xxx.rs&lt;/code> 不存在，则查找 &lt;code>xxx/mod.rs&lt;/code> 文件，即 &lt;code>xxx&lt;/code> 目录下的 &lt;code>mod.rs&lt;/code> 文件。&lt;/li>
&lt;/ol>
&lt;p>上述两种情况，加载成模块后，效果是相同的。Rust 就凭这两条规则，通过迭代使用，结合 &lt;code>pub&lt;/code> 关键字，实现了对深层目录下模块的加载；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">src
├── a
│ ├── b
│ │ ├── c
│ │ │ ├── d.rs
│ │ │ └── mod.rs
│ │ └── mod.rs
│ └── mod.rs
└── main.rs
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// a/b/c/d.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">print_ddd&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;i am ddd.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/b/c/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">d&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//声明mode
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/b/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">c&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">b&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">a&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>::&lt;span class="n">b&lt;/span>::&lt;span class="n">c&lt;/span>::&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">d&lt;/span>::&lt;span class="n">print_ddd&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="模块路径">模块路径&lt;/h3>
&lt;p>想要调用一个函数，就需要知道它的路径，在 Rust 中，这种路径有两种形式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>绝对路径&lt;/strong>，从包根开始，路径名以包名或者 &lt;code>crate&lt;/code> 作为开头&lt;/li>
&lt;li>&lt;strong>相对路径&lt;/strong>，从当前模块开始，以 &lt;code>self&lt;/code>，&lt;code>super&lt;/code> 或当前模块的标识符作为开头&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// src/lib.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">front_of_house&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">hosting&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">add_to_waitlist&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">eat_at_restaurant&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 绝对路径
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">crate&lt;/span>::&lt;span class="n">front_of_house&lt;/span>::&lt;span class="n">hosting&lt;/span>::&lt;span class="n">add_to_waitlist&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 相对路径
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">front_of_house&lt;/span>::&lt;span class="n">hosting&lt;/span>::&lt;span class="n">add_to_waitlist&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="模块系统">模块系统&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>单文件rust 中称为&lt;code>mod&lt;/code>，模块的名称就是文件的名称。&lt;/p>
&lt;p>模块内部的函数，只能在模块内部使用，如果要在模块外调用，需要用&lt;code>pub&lt;/code>关键词，显式声明函数可在外部使用。&lt;/p>
&lt;p>使用时，使用mod声明引入，mod name::&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//file: rustmod/src/functions.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 嵌套子模块
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">util&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rust/src/main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">functions&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//声明模块
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">functions&lt;/span>::&lt;span class="n">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">functions&lt;/span>::&lt;span class="n">util&lt;/span>::&lt;span class="n">hello2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用mod.rs, mod 会去对应目录下mod.rs中导入该目录下声明的mod&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//file: rustmod/src/util/functions.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rustmod/src/util/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">functions&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rustmod/src/main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">util&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">util&lt;/span>::&lt;span class="n">functions&lt;/span>::&lt;span class="n">util&lt;/span>::&lt;span class="n">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在同一层级不能同时存在文件夹和文件类型的模块，否则会名字冲突。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="典型rust项目结构">典型rust项目结构&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">.
├── Cargo.toml &lt;span class="c1">## cargo配置文件&lt;/span>
├── Cargo.lock
├── src
│ ├── main.rs &lt;span class="c1">## 默认二进制包入口&lt;/span>
│ ├── lib.rs &lt;span class="c1">## 默认lib包入口&lt;/span>
│ └── bin
│ └── main1.rs &lt;span class="c1">## 二进制可执行文件main1&lt;/span>
│ └── main2.rs &lt;span class="c1">## 二进制可执行文件main2&lt;/span>
├── tests
│ └── some_integration_tests.rs &lt;span class="c1">## 集成测试&lt;/span>
├── benches
│ └── simple_bench.rs &lt;span class="c1">## 性能测试&lt;/span>
└── examples
└── simple_example.rs &lt;span class="c1">## example&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://course.rs/basic/crate-module/intro.html#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97">Rust语言圣经(Rust Course)-包和模块&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Substrate</title><link>https://justice.bj.cn/post/60.blockchain/substrate/</link><pubDate>Mon, 13 Jun 2022 16:32:28 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/substrate/</guid><description>&lt;h1 id="substrate">Substrate&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2></description></item><item><title>区块链UTXO模型</title><link>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BEutxo%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 13 Jun 2022 16:32:28 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BEutxo%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="区块链utxo模型">区块链UTXO模型&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>UTXO(Unspent Transaction Output)是区块链中用来保存区块账户记录的方式之一。&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>blockchain_rust</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Bblockchain/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Bblockchain/</guid><description>&lt;h1 id="blockchain_rust">blockchain_rust&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>blockchain_rust是github上一个基于rust的blockchain实现；&lt;/p>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;ul>
&lt;li>block：&lt;/li>
&lt;/ul>
&lt;h2 id="操作">操作&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ mkdir -p data/node&lt;span class="o">{&lt;/span>1,2,3&lt;span class="o">}&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ &lt;span class="nb">cd&lt;/span> data/node1
&lt;span class="c1">## 创建wallet&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 13teoDGrDNhMrgGHHRESv7bhcnJoXnicqE
&lt;span class="c1">## 创建block0&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createblockchain 13teoDGrDNhMrgGHHRESv7bhcnJoXnicqE
Mining the block
00518dae1ee13a19da96d24f865654eed74dfb3188f4ae0fe56616c03535acb9
Done!
&lt;span class="c1">## 手动同步创世区块数据&lt;/span>
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span> &lt;span class="nb">cd&lt;/span> data/node2&lt;span class="p">;&lt;/span> cp -rf ../node1/data .
&lt;span class="o">[&lt;/span>node3&lt;span class="o">]&lt;/span> &lt;span class="nb">cd&lt;/span> data/node3&lt;span class="p">;&lt;/span> cp -rf ../node1/data .
&lt;span class="c1">## node2创建钱包&lt;/span>
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1JvjDQGrmzVLLAo9dPsXYNNednuNZrGrAm
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1JvjDQGrmzVLLAo9dPsXYNNednuNZrGrAm
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1FztXwduMcABm6x2yxRWgozqT8g1dgeiFS
&lt;span class="c1">## 转账&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>IPFS(星际文件系统)</title><link>https://justice.bj.cn/post/60.blockchain/ipfs%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/ipfs%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="ipfs星际文件系统">IPFS(星际文件系统)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>IPFS&lt;/code>(InterPlanetary File System，星际文件系统), 是一个对等的分布式文件系统，用于存储和访问文件、网站、应用程序和数据。IPFS 旨在为分布式 Web——DWeb 提供动力；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPFS项目通过整合已有的技术（BitTorrent、DHT、Git和SFS），创建一种点对点超媒体协议，试图打造一个更加快速、安全、开放的下一代互联网，实现互联网中永久可用、数据可以永久保存的全球文件存储系统。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时，该协议有内容寻址、版本化特性，尝试补充甚至最终取代伴随了我们20多年的超文本传输协议（即HTTP协议）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPFS是一个协议，也是一个P2P网络，它类似于现在的BT网络，只是拥有更强大的功能，使得IPFS拥有可以取代HTTP的潜力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可防止&lt;a href="https://zh.m.wikipedia.org/wiki/DDoS" title="DDoS">DDoS&lt;/a>攻击；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="基本原理">基本原理&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>IPFS先将文件分成一个个block，每个block通过hash得到blockid；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个文件的所有blockid组成一个&lt;code>merkledag&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不同block通过&lt;code>KAD算法&lt;/code>分发到不同的节点上；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为保证可靠性，同一个block 可能有多个copy, 分别存储在不同的网络节点上；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="filecoin">Filecoin&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Filecoin是运行在IPFS上的一个激励层，是一个基于区块链的分布式存储网络，它把云存储变为一个算法市场，代币（FIL）在这里起到了很重要的作用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代币是沟通资源（存储和检索）使用者（IPFS用户）和资源的提供者（Filecoin矿工）之间的中介桥梁，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Filecoin协议拥有两个交易市场—数据检索和数据存储，交易双方在市场里面提交自己的需求，达成交易。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="get">Get&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/06/12-18-52-38-ipfs_get.gif" alt="loading-ag-185">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zh.m.wikipedia.org/zh-hans/%E6%98%9F%E9%99%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">星际文件系统 - 维基百科，自由的百科全书&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://developer.aliyun.com/article/726565">https://developer.aliyun.com/article/726565&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.jianshu.com/p/3f7cc1ee9ec4">IPFS原理初探 - 简书&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.pseudoyu.com/zh/2021/03/25/blockchain_ipfs_structure/">IPFS 分布式存储协议分析与思考 · Pseudoyu&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Kademlia算法</title><link>https://justice.bj.cn/post/13.algorithm/kademlia%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/kademlia%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="kademlia算法">Kademlia算法&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Kademlia算法是2002年由Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kademlia后来被eMule、BitTorrent等P2P软件采用作为底层算法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kademlia可以作为信息安全技术的奠基之一。&lt;br>
Kademlia的优点在于：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>对于任意一个有[ 2(n−1) ,2𝑛)个节点的网络，最多只需要n步搜索即可找到目标节点；&lt;/li>
&lt;li>K-bucket的更新机制一定程度上保持了网络的活性和安全性。&lt;/li>
&lt;/ul>
&lt;p>Kademlia算法是一种分布式存储及路由的算法。&lt;/p>
&lt;p>什么是分布式存储？试想一下，一所1000人的学校，现在学校突然决定拆掉图书馆（不设立中心化的服务器），将图书馆里所有的书都分发到每位学生手上（所有的文件分散存储在各个节点上）。即是所有的学生，共同组成了一个分布式的图书馆。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-795f3af7231108b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="">&lt;/p>
&lt;p>由中心图书馆到分布式图书馆&lt;/p>
&lt;p>在这种场景下，有几个关键的问题需要回答。&lt;/p>
&lt;h3 id="1关键问题">1）关键问题&lt;/h3>
&lt;ol>
&lt;li>每个同学手上都分配哪些书。即如何分配存储内容到各个节点，新增/删除内容如何处理。&lt;/li>
&lt;li>当你需要找到一本书，譬如《分布式算法》的时候，如何知道哪位同学手上有《分布式算法》（对1000个人挨个问一遍，“你有没有《分布式算法》？”，显然是个不经济的做法），又如何联系上这位同学。即一个节点如果想获取某个特定的文件，如何找到存储文件的节点/地址/路径。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-8b12f9959fa3144f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/358/format/webp" alt="">&lt;/p>
&lt;p>如何寻找需要的书籍？&lt;/p>
&lt;p>接下来，让我们来看看Kademlia算法如何巧妙地解决这些问题。&lt;/p>
&lt;h3 id="2节点的要素">2）节点的要素&lt;/h3>
&lt;p>首先我们来看看每个同学（节点）都有哪些属性：&lt;/p>
&lt;ul>
&lt;li>学号（Node ID，2进制，160位）&lt;/li>
&lt;li>手机号码（节点的IP地址及端口）&lt;/li>
&lt;/ul>
&lt;p>每个同学会维护以下内容：&lt;/p>
&lt;ul>
&lt;li>从图书馆分发下来的书本（被分配到需要存储的内容），每本书当然都有书名和书本内容（内容以&amp;lt;key, value&amp;gt;对的形式存储，可以理解为文件名和文件内容）；&lt;/li>
&lt;li>一个通讯录，包含一小部分其他同学的学号和手机号，通讯录按学号分层（一个路由表，称为“k-bucket”，按Node ID分层，记录有限个数的其他节点的ID和IP地址及端口）。&lt;/li>
&lt;/ul>
&lt;p>根据上面那个类比，可以看看这个表格：&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-ac0338100a380c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/601/format/webp" alt="">&lt;/p>
&lt;p>概念对比&lt;/p>
&lt;p>&lt;em>（Hash的概念解释，可参见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%2593%2588%25E5%25B8%258C%25E7%25AE%2597%25E6%25B3%2595%2F4960188">百度百科-哈希算法&lt;/a>）&lt;/em>&lt;/p>
&lt;p>&lt;em>关于为什么不是每个同学都有全量通讯录（每个节点都维护全量路由信息）：其一，分布式系统中节点的进入和退出是相当频繁的，每次有变动时都全网广播通讯录更新，通讯量会很大；其二，一旦任意一个同学被坏人绑架了（节点被黑客攻破），则坏人马上就拥有了所有人的手机号码，这并不安全。&lt;/em>&lt;/p>
&lt;h3 id="3文件的存储及查找">3）文件的存储及查找&lt;/h3>
&lt;p>原来收藏在图书馆里，按索引号码得整整齐齐的书，以一种什么样的方式分发到同学们手里呢？&lt;/p>
&lt;p>大致的原则，包括：&lt;/p>
&lt;p>    1）书本能够比较均衡地分布在同学们的手里，不会出现部分同学手里书特别多、而大部分同学连一本书都没有的情况；&lt;/p>
&lt;p>    2）同学想找一本特定的书的时候，能够一种相对简单的索引方式找到这本书。&lt;br>
Kademlia作了下面这种安排：&lt;br>
假设《分布式算法》这本书的书名的hash值是 &lt;em>00010000&lt;/em>，那么这本书就会被要求存在学号为&lt;em>00010000&lt;/em>的同学手上。（这要求hash算法的值域与node ID的值域一致。Kademlia的Node ID是160位2进制。这里的示例对Node ID进行了简略）&lt;br>
但还得考虑到会有同学缺勤。万一&lt;em>00010000&lt;/em>今天没来上学（节点没有上线或彻底退出网络），那《分布式算法》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求同时存储在学号最接近&lt;em>00010000&lt;/em>的k位同学手上，即&lt;em>00010001&lt;/em>、&lt;em>00010010&lt;/em>、&lt;em>00010011&lt;/em>…等同学手上都会有这本书。&lt;/p>
&lt;p>同样地，当你需要找《分布式算法》这本书时，将书名hash一下，得到 &lt;em>00010000&lt;/em>，这个便是索书号，你就知道该找哪（几）位同学了。剩下的问题，就是找到这（几）位同学的手机号。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-54dfcb165392638e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp" alt="">&lt;/p>
&lt;p>书籍搜索定位&lt;/p>
&lt;h3 id="4节点的异或距离">4）节点的异或距离&lt;/h3>
&lt;p>由于你手上只有一部分同学的通讯录，你很可能并没有&lt;em>00010000&lt;/em>的手机号（IP地址）。那如何联系上目标同学呢？&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-41d8839bc652fea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/338/format/webp" alt="">&lt;/p>
&lt;p>通讯录上并没有目标同学的情况&lt;/p>
&lt;p>一个可行的思路就是在你的通讯录里找到一位拥有目标同学的联系方式的同学。前面提到，每位同学手上的通讯录都是按距离分层的。算法的设计是，如果一个同学离你越近，你手上的通讯录里存有ta的手机号码的概率越大。而算法的核心的思路就可以是：当你知道目标同学Z与你之间的距离，你可以在你的通讯录上先找到一个你认为与同学Z最相近的同学B，请同学B再进一步去查找同学Z的手机号。&lt;/p>
&lt;p>上文提到的距离，是学号（Node ID）之间的异或距离(XOR distance）。异或是针对yes/no或者二进制的运算.&lt;/p>
&lt;blockquote>
&lt;p>异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）&lt;br>
&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%25BC%2582%25E6%2588%2596%2F10993677%3Ffr%3Daladdin">百度百科-异或&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>举2个例子：&lt;br>
&lt;em>01010000&lt;/em>与&lt;em>01010010&lt;/em>距离（即是2个ID的异或值）为&lt;em>00000010&lt;/em>（换算为十进制即为2）；&lt;br>
&lt;em>01000000&lt;/em>与&lt;em>00000001&lt;/em>距离为&lt;em>01000001&lt;/em>（换算为十进制即为26+1，即65）；&lt;br>
如此类推。&lt;/p>
&lt;p>那通讯录是如何按距离分层呢？下面的示例会告诉你，按异或距离分层，基本上可以理解为按位数分层。设想以下情景：&lt;br>
以&lt;em>0000110&lt;/em>为基础节点，如果一个节点的ID，前面所有位数都与它相同，只有最后1位不同，这样的节点只有1个——&lt;em>0000111&lt;/em>，与基础节点的异或值为&lt;em>0000001&lt;/em>，即距离为1；对于&lt;em>0000110&lt;/em>而言，这样的节点归为**“k-bucket 1”**；&lt;br>
如果一个节点的ID，前面所有位数相同，从倒数第2位开始不同，这样的节点只有2个：*0000101*、*0000100*，与基础节点的异或值为*0000011*和*0000010*，即距离范围为3和2；对于*0000110*而言，这样的节点归为**“k-bucket 2”**；&lt;br>
……&lt;br>
如果一个节点的ID，前面所有位数相同，从倒数第n位开始不同，这样的节点只有2(i-1)个，与基础节点的距离范围为[2(i-1), 2i）；对于*0000110*而言，这样的节点归为**“k-bucket i”**；&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-6bdd6e96a80d0780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/430/format/webp" alt="">&lt;/p>
&lt;p>按位数区分k-bucket&lt;/p>
&lt;p>对上面描述的另一种理解方式：如果将整个网络的节点梳理为一个按节点ID排列的二叉树，树最末端的每个叶子便是一个节点，则下图就比较直观的展现出，节点之间的距离的关系。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-c12846900b0525db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/913/format/webp" alt="">&lt;/p>
&lt;p>k-bucket示意图：右下角的黑色实心圆，为基础节点（按wiki百科的配图修改）&lt;/p>
&lt;p>回到我们的类比。每个同学只维护一部分的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中只记录k位同学的手机号（k个节点的地址与端口，这里的k是一个可调节的常量参数）。&lt;br>
由于学号（节点的ID）有160位，所以每个同学的通讯录中共分160层（节点共有160个k-bucket）。整个网络最多可以容纳2^160个同学（节点），但是每个同学（节点）最多只维护160 * k 行通讯录（其他节点的地址与端口）。&lt;/p>
&lt;h3 id="5节点定位">5）节点定位&lt;/h3>
&lt;p>我们现在来阐述一个完整的索书流程。&lt;/p>
&lt;p>A同学（学号&lt;em>00000110&lt;/em>）想找《分布式算法》，&lt;/p>
&lt;p>A首先需要计算书名的哈希值，hash(《分布式算法》) = &lt;em>00010000&lt;/em>。那么A就知道ta需要找到&lt;em>00010000&lt;/em>号同学（命名为Z同学）或学号与Z邻近的同学。&lt;br>
Z的学号&lt;em>00010000&lt;/em>与自己的异或距离为 &lt;em>00010110&lt;/em>，距离范围在[24, 25)，所以这个Z同学可能在k-bucket 5中（或者说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。&lt;br>
然后A同学看看自己的k-bucket 5有没有Z同学：&lt;/p>
&lt;ul>
&lt;li>如果有，那就直接联系Z同学要书；&lt;/li>
&lt;li>如果没有，在k-bucket 5里随便找一个B同学（注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于24，相当于比Z、A之间的距离缩短了一半以上），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：&lt;br>
&amp;ndash; 如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；&lt;br>
&amp;ndash; 如果B也不知道Z同学，那B按同样的搜索方法，可以在自己的通讯录里找到一个离Z更近的C同学（Z、C之间距离小于23），把C同学推荐给A；A同学请求C同学进行下一步查找。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-1396765e4e0afb12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/866/format/webp" alt="">&lt;/p>
&lt;p>查询方式示意&lt;/p>
&lt;p>Kademlia的这种查询机制，有点像是将一张纸不断地对折来收缩搜索范围，保证对于任意n个学生，最多只需要查询log2(n)次，即可找到获得目标同学的联系方式（即在对于任意一个有[2(n−1), 2n)个节点的网络，最多只需要n步搜索即可找到目标节点）。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-1143169c8318a2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp" alt="">&lt;/p>
&lt;p>每次搜索都将距离至少收缩一半&lt;/p>
&lt;p>以上便是Kademlia算法的基本原理。&lt;/p>
&lt;p>以下再简要介绍协议中的技术细节。&lt;/p>
&lt;h3 id="6算法的三个参数keyspacek和α">6）算法的三个参数：keyspace，k和α&lt;/h3>
&lt;ul>
&lt;li>keyspace&lt;br>
&amp;ndash; 即ID有多少位&lt;br>
&amp;ndash; 决定每个节点的通讯录有几层&lt;/li>
&lt;li>k&lt;br>
&amp;ndash; 每个一层k-bucket里装k个node的信息，即&amp;lt;node ID, IP Adress, port&amp;gt;&lt;br>
&amp;ndash; 每次查找node时，返回k个node的信息&lt;br>
&amp;ndash; 对于某个特定的data，离其key最近的k个节点被会要求存储这个data&lt;/li>
&lt;li>α&lt;br>
&amp;ndash; 每次向其他node请求查找某个node时，会向α个node发出请求&lt;/li>
&lt;/ul>
&lt;h3 id="7节点的指令">7）节点的指令&lt;/h3>
&lt;p>Kademlia算法中，每个节点只有4个指令&lt;/p>
&lt;ul>
&lt;li>PING&lt;br>
&amp;ndash; 测试一个节点是否在线&lt;/li>
&lt;li>STORE&lt;br>
&amp;ndash; 要求一个节点存储一份数据&lt;/li>
&lt;li>FIND_NODE&lt;br>
&amp;ndash; 根据节点ID查找一个节点&lt;/li>
&lt;li>FIND_VALUE&lt;br>
&amp;ndash; 根据KEY查找一个数据，实则上跟FIND_NODE非常类似&lt;/li>
&lt;/ul>
&lt;h3 id="8k-bucket的维护及更新机制">8)k-bucket的维护及更新机制&lt;/h3>
&lt;ul>
&lt;li>每个bucket里的节点都按最后一次接触的时间倒序排列&lt;/li>
&lt;li>每次执行四个指令中的任意一个都会触发更新&lt;/li>
&lt;li>当一个节点与自己接触时，检查它是否在K-bucket中&lt;br>
&amp;ndash; 如果在，那么将它挪到k-bucket列表的最底（最新）&lt;br>
&amp;ndash; 如果不在，PING一下列表最上面（最旧）的一个节点&lt;br>
&amp;ndash; a) 如果PING通了，将旧节点挪到列表最底，并丢弃新节点&lt;br>
&amp;ndash; b) 如果PING不通，删除旧节点，并将新节点加入列表&lt;/li>
&lt;/ul>
&lt;p>该机制保证了任意节点加入和离开都不影响整体网络。&lt;/p>
&lt;h3 id="9总结">9）总结&lt;/h3>
&lt;p>Kademlia是分布式哈希表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。&lt;/p>
&lt;p>在这类系统中，每个节点（node）分别维护一部分的存储内容以及其他节点的路由/地址，使得网络中任何参与者（即节点）发生变更（进入/退出）时，对整个网络造成的影响最小。&lt;/p>
&lt;p>DHT可以用于构建更复杂的应用，包括分布式文件系统、点对点技术文件分享系统、合作的网页高速缓存、域名系统以及实时通信等。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDistributed_hash_table">wiki百科-分布式哈希表&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FKademlia">wiki百科-Kademlia&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=http%3A%2F%2Fpdos.csail.mit.edu%2F%7Epetar%2Fpapers%2Fmaymounkov-kademlia-lncs.pdf">Kademlia: A Peer-to-peer information system based on the XOR Metric&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000000351815">王子亭的Kademlia笔记&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Rust特性(trait)</title><link>https://justice.bj.cn/post/14.language/rust/20.rust%E7%89%B9%E6%80%A7trait/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/20.rust%E7%89%B9%E6%80%A7trait/</guid><description>&lt;h1 id="rust特性trait">Rust特性(trait)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>trait&lt;/code>(特性) 是一组方法的集合，实现trait的类型可以访问该 trait 中定义的其他方法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何类型都可以实现 trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="要点">要点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Trait&lt;/code>必须声明可见后才能使用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Trait本身并没有固定的大小，不能直接声明和使用Trait类型的变量，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>某个实现该Trait类型的实例的有效引用称为&lt;code>Trait Object&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有trait都有一个隐藏的类型&lt;code>Self&lt;/code>，代表当前实现此Trait的具体类型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数&lt;u>第一个参数&lt;/u>是&lt;code>self&lt;/code>且为&lt;code>Self&lt;/code>相关类型(&lt;code>Self, &amp;amp;Self, &amp;amp;mut Self, Box&amp;lt;Self&amp;gt;&lt;/code>)，则函数为&lt;strong>方法&lt;/strong>(method)，&lt;code>self&lt;/code>称为&lt;code>receiver&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有receiver参数的函数为&lt;strong>静态方法&lt;/strong>，可通过&lt;code>Type::Function()&lt;/code>方式调用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>匿名Trait无须名字，可直接在impl中实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以在trait的声明中定义默认方法；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展trait(extension trait), 可以为其它trait类型扩展出自定义trait的接口，impl块必须与trait或struct声明在同一个crate中（孤儿规则）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>继承：凡是实现了Subtrait(&lt;code>Creature&lt;/code>)的类型, 也必须实现父Trait(&lt;code>Visible&lt;/code>)的&lt;strong>所有方法&lt;/strong>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="孤儿规则orphan-rule">孤儿规则(orphan rule)&lt;/h2>
&lt;ul>
&lt;li>如果要实现外部定义的 &lt;code>trait&lt;/code> 需要先将其导入作用域；&lt;/li>
&lt;li>不允许对外部类型实现外部 &lt;code>trait&lt;/code>；&lt;/li>
&lt;li>可以对外部类型实现自定义的 &lt;code>trait&lt;/code>；&lt;/li>
&lt;li>可以对自定义类型上实现外部 &lt;code>trait&lt;/code>；&lt;/li>
&lt;/ul>
&lt;h2 id="示例">示例&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// trait声明
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//method1(self: Self);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//area(self: &amp;amp;Self);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">larger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>: &lt;span class="kt">f64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// trait 实现
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="kt">f64&lt;/span>::&lt;span class="n">consts&lt;/span>::&lt;span class="n">PI&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 匿名trait
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">get_radius&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="trait-泛型">Trait 泛型&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// where 从句
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>: &lt;span class="nc">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>: &lt;span class="nc">K&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>: &lt;span class="nb">Clone&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">K&lt;/span>: &lt;span class="nb">Clone&lt;/span> &lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Debug&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{:?}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="trait对象trait-object">Trait对象(Trait object)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>指向trait的指针就是&lt;code>Trait Object&lt;/code>，比如 &lt;code>&amp;amp;SomeTrait&lt;/code> 和 &lt;code>Box&amp;lt;SomeTrait&amp;gt;&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>&amp;amp;SomeTrait&lt;/code> 类型和普通的指针类型不同, 不仅包括指向真实对象的指针，还包括一个指向虚函数表的指针;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rust通过&lt;code>TraitObject&lt;/code>用来实现动态分发；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Trait Object&lt;/code>实际是一个胖指针&lt;code>fat pointer&lt;/code>, 占用两个机器字字节, 一个指向实际的实例对象, 一个指向虚基表&lt;code>vtable&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::raw
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">TraitObject&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>: &lt;span class="o">*&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vtable&lt;/span>: &lt;span class="o">*&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="supertrait">Supertrait&lt;/h2>
&lt;h2 id="关联类型">关联类型&lt;/h2>
&lt;p>关联类型是一个将类型占位符与trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>关联类型类似泛型，不同之处关联类型，无需标注类型，无须多次实现trait；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Iterator&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span> &lt;span class="nc">Item&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//关联类型
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Self&lt;/span>::&lt;span class="n">Item&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Iterator&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Counter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span> &lt;span class="nc">Item&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Self&lt;/span>::&lt;span class="n">Item&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// --snip--
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="常用trait">常用Trait&lt;/h2>
&lt;h3 id="default">Default&lt;/h3>
&lt;p>Default trait是针对无参构造函数的抽象&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::default::Default
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">default&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// Vec default
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">default&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="derive">Derive&lt;/h3>
&lt;p>Rust提供了一个特殊属性，以自动impl某些trait，编译阶段会自动展开为相应的impl块：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="cp">#[derive(Copy, Clone, Default)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Foo&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Rust支持自动derive的trait有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Debug&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Clone/Copy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hash&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PartialEq/Eq/PartialOrd/Ord&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Send/Sync&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Default&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FromPrimitive&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RustcEncodable/RustcDecodable&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="displaydebug">Display/Debug&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>实现&lt;code>Display&lt;/code>特性的类型，可用&lt;code>{}&lt;/code>格式控制打印；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现&lt;code>Debug&lt;/code>特性的类型，可用&lt;code>{:?},{:#?}&lt;/code>格式控制打印；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Display&lt;/code>一般给最终用户显示的，通常用utf-8格式字符输出；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Debug&lt;/code>特性主要用于调试，一般为byte字符，编译器提供自动derive功能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现&lt;code>Dispaly&lt;/code>特性的类型都自动实现了&lt;code>ToString&lt;/code>特性，可直接通过&lt;code>to_string()&lt;/code>格式化字符串；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::fmt::Display
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Display&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">fmt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Formatter&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//std::fmt::Debug
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Debug&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">fmt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Formatter&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="派生derive">派生(derive)&lt;/h2>
&lt;p>通过 &lt;code>#[derive]&lt;/code> &lt;a href="https://rustwiki.org/zh-CN/rust-by-example/attribute.html">属性&lt;/a>，编译器能够提供某些 trait 的基本实现。如果 需要更复杂的行为，这些 trait 也可以手动实现。&lt;/p>
&lt;p>下面是可以自动派生的 trait：&lt;/p>
&lt;ul>
&lt;li>比较 trait: &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html">&lt;code>Eq&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialEq.html">&lt;code>PartialEq&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html">&lt;code>Ord&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialOrd.html">&lt;code>PartialOrd&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html">&lt;code>Clone&lt;/code>&lt;/a>, 用来从 &lt;code>&amp;amp;T&lt;/code> 创建副本 &lt;code>T&lt;/code>。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/core/marker/trait.Copy.html">&lt;code>Copy&lt;/code>&lt;/a>，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/hash/trait.Hash.html">&lt;code>Hash&lt;/code>&lt;/a>，从 &lt;code>&amp;amp;T&lt;/code> 计算哈希值（hash）。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/default/trait.Default.html">&lt;code>Default&lt;/code>&lt;/a>, 创建数据类型的一个空实例。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/fmt/trait.Debug.html">&lt;code>Debug&lt;/code>&lt;/a>，使用 &lt;code>{:?}&lt;/code> formatter 来格式化一个值。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="cp">#[derive(PartialEq, PartialOrd)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">f64&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// `Inches`，可以打印的元组结构体
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#[derive(Debug)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Inches&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Inches&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">to_centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Centimeters&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">Inches&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inches&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inches&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">f64&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mf">2.54&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="ordpartialordeqpartialeq">Ord/PartialOrd/Eq/PartialEq&lt;/h3>
&lt;h2 id="标签trait">标签Trait&lt;/h2>
&lt;h3 id="sized">Sized&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Sized&lt;/code>是一种&lt;code>maker trait&lt;/code>，表示类型size是固定的 , 没有任何方法和联合类型，无法实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rust不能在变量里保存&lt;em>unsized&lt;/em>的值, 也不能把&lt;em>unsize&lt;/em>的值作为参数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有固定大小的类型都实现里&lt;code>std::marker::Sized&lt;/code>trait；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Sized trait只能用于绑定到类型参数, 也就是用于参数的类型声明(及检查), 例如 &lt;code>T: Sized&lt;/code>不能用于其它用途；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>?Sized&lt;/code>叫 &lt;em>questionably sized&lt;/em>, 允许固定大小, 也允许非固定大小类型.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>struct的最后一个字段允许是&lt;code>?Sized&lt;/code>类型, 但如果这样, struct本身就变为了unsized.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但如果写成泛型, 并传入一个Sized类型, 那么这个类型的struct仍然是Sized. 大小取决于泛型的参数类型:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="copyclone">Copy/Clone&lt;/h3>
&lt;p>Copy:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果一个类型 impl 了 Copy trait，意味着任何时候，我们可以通过简单的内存拷贝实现该类型的复制，而不会产生任何问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦一个类型实现了 Copy trait，那么它在变量绑定、函数参数传递、函数返回值传递等场景下，它都是 copy 语义，而不再是默认的 move 语义；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只有所有的成员都实现了 Copy trait，这个类型才有资格实现 Copy trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Clone:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Clone&lt;/code>是&lt;code>Sized&lt;/code>的sub-trait, 所以Self类型必须是Sized；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>clone&lt;/code>方法必须返回和&lt;code>self&lt;/code>独立无关的一份拷贝；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果所有的字段都实现了Clone, 那么&lt;code>struct&lt;/code>可以加上属性: &lt;code>#[derive(Clone)]&lt;/code>自动实现Clone trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>通常情况下clone的成本比较高, 但是对于&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code>和&lt;code>Arc&amp;lt;T&amp;gt;&lt;/code>这类的类型, Rust的对它们的clone只是简单的增加计数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通常尽可能使用&lt;code>clone_from&lt;/code>来减少clone开销, 这会允许一些优化. 例如, String的clone, 被赋值的String如果capacity够大, 可以不需要释放内存, 直接把源的内容拷贝过来.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果所有的字段都实现了Clone, 那么&lt;code>struct&lt;/code>可以加上属性: &lt;code>#[derive(Clone)]&lt;/code>自动实现Clone trait&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>clone&lt;/code>方法不能失败(&lt;em>infallible&lt;/em>), 对于&lt;code>std::fs::File&lt;/code>这样的类型, 有&lt;code>try_clone&lt;/code>方法, 返回&lt;code>std::io::Result&amp;lt;File&amp;gt;&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Clone&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">clone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">clone_from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">source&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">Self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="frominto">From/Into&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>From&lt;/code>: 对于类型为 &lt;code>U&lt;/code> 的对象 &lt;code>foo&lt;/code>，如果它实现了 &lt;code>From&amp;lt;T&amp;gt;&lt;/code>，那么，可以通过 &lt;code>let foo = U::from(bar)&lt;/code> 来生成自己&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Into&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">into&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">T&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">From&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 静态方法
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// as_ref和Borrow的区别 ?
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// as_ref 是转引用函数, 将具有所有权对象转换成引用对象,
&lt;/span>&lt;span class="c1">// 不改变被转换对象的基础上产生一个引用对象.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// as_ref 并不是所有类型都默认支持, 很多时候都需要自己去声明.
&lt;/span>&lt;span class="c1">// as_ref 是AsRef trait 的公共接口方法.
&lt;/span>&lt;span class="c1">// 只有那些实现了 as_ref 公共接口方法的类型才能使用as_ref.
&lt;/span>&lt;span class="c1">// 目前: Option, Box, Result 这三种类型默认提供支持as_ref.
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://wiki.jikexueyuan.com/project/rust-primer/">https://wiki.jikexueyuan.com/project/rust-primer/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://unpluggedcoder.me/2019/08/31/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BTraits&amp;amp;Generics/">https://unpluggedcoder.me/2019/08/31/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BTraits&amp;amp;Generics/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/21730929">https://zhuanlan.zhihu.com/p/21730929&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://unpluggedcoder.me/2019/09/01/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BUtility%20Traits/">https://unpluggedcoder.me/2019/09/01/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BUtility%20Traits/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://wiki.jikexueyuan.com/project/rust-primer/trait/trait-object.html">https://wiki.jikexueyuan.com/project/rust-primer/trait/trait-object.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/23791817">https://zhuanlan.zhihu.com/p/23791817&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Linux系统调用之Futex</title><link>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</guid><description>&lt;h1 id="linux系统调用之futex">Linux系统调用之Futex&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Futex（Fast Userspace muTexes）的缩写，由Hubertus Franke, Matthew Kirkwood, Ingo Molnar and Rusty Russell共同设计完成，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Futex是一种用户态和内核态混合的同步机制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>同步的进程间通过mmap共享一段内存，futex变量就位于这段共享 的内存中且操作是原子的，&lt;/li>
&lt;li>当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，
3. 如果没有竞争发生，则只修改futex,而不 用再执行系统调用了。
4. 如果futex变量告诉进程有竞争发生，则执行系统调用去完成相应的处理(wait 或者 wake up)。&lt;/li>
&lt;/ol>
&lt;p>futex 函数：&lt;/p>
&lt;ol>
&lt;li>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;/li>
&lt;li>不加timeout参数，它会一直被阻塞，直到FUTEX_WAKE:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/futex.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/time.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">futex&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">timespec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cp">#define __NR_futex 240
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;br>
FUTEX_WAKE: 最多唤醒val个等待在uaddr上进程。&lt;/p>
&lt;p>可见FUTEX_WAIT和FUTEX_WAKE只是用来挂起或者唤醒进程，当然这部分工作也只能在内核态下完成。有些人尝试着直接使用futex系统调 用来实现进程同步，并寄希望获得futex的性能优势，这是有问题的。应该区分futex同步机制和futex系统调用。futex同步机制还包括用户态 下的操作，我们将在下节提到。&lt;/p>
&lt;h2 id="futex同步机制">Futex同步机制&lt;/h2>
&lt;p>所有的futex同步操作都应该从用户空间开始，首先创建一个futex同步变量，也就是位于共享内存的一个整型计数器。&lt;br>
当 进程尝试持有锁或者要进入互斥区的时候，对futex执行&amp;quot;down&amp;quot;操作，即原子性的给futex同步变量减1。如果同步变量变为0，则没有竞争发生， 进程照常执行。如果同步变量是个负数，则意味着有竞争发生，需要调用futex系统调用的futex_wait操作休眠当前进程。&lt;br>
当进程释放锁或 者要离开互斥区的时候，对futex进行&amp;quot;up&amp;quot;操作，即原子性的给futex同步变量加1。如果同步变量由0变成1，则没有竞争发生，进程照常执行。如 果加之前同步变量是负数，则意味着有竞争发生，需要调用futex系统调用的futex_wake操作唤醒一个或者多个等待进程。&lt;/p>
&lt;p>这里的原子性加减通常是用CAS(Compare and Swap)完成的，与平台相关。CAS的基本形式是：CAS(addr,old,new),当addr中存放的值等于old时，用new对其替换。在x86平台上有专门的一条指令来完成它: cmpxchg。&lt;/p>
&lt;p>可见: futex是从用户态开始，由用户态和核心态协调完成的。&lt;/p>
&lt;h2 id="进线程利用futex同步">进/线程利用futex同步&lt;/h2>
&lt;p>进程或者线程都可以利用futex来进行同步。&lt;br>
对于线程，情况比较简单，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量。&lt;br>
对 于进程，情况相对复杂，因为进程有独立的虚拟内存空间，只有通过mmap()让它们共享一段地址空间来使用futex变量。每个进程用来访问futex的 虚拟地址可以是不一样的，只要系统知道所有的这些虚拟地址都映射到同一个物理内存地址，并用物理内存地址来唯一标识futex变量。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.shuzhiduo.com/A/rV57P2rLdP/">linux内核级同步机制&amp;ndash;futex&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/farmerjohngit/myblog/issues/6">关于同步的一点思考-上 · Issue #6 · farmerjohngit/myblog · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>ToyDB</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Btoydb/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Btoydb/</guid><description>&lt;h1 id="toydb">ToyDB&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>&lt;code>toydb&lt;/code>是&lt;code>Erik Grinaker&lt;/code>为学习&lt;code>rust&lt;/code>语言而开发的分布式sql数据库，支持分布式事务模型;&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;code>toydb&lt;/code>主要由3部分组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>sqlengine&lt;/code>: 负责sql语句的解析、执行计划；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>raftengine&lt;/code>: 负责存储层的数据副本同步；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>storage&lt;/code>: 负责提供kv及mvcc存储；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/10/07-18-54-21-2021-10-07-18-54-16-image.png" alt="">&lt;/p>
&lt;h2 id="sql层">SQL层&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>SQL层主要负责将输入的sql语句字符串转化为执行计划，并通过raft交给各个副本的mvcc存储引擎执行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SQL主要分为两个阶段：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>词法分析：sql语句&amp;mdash;&amp;mdash;-&amp;gt;token&amp;mdash;-&amp;gt;AST；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>生成执行计划：AST&amp;mdash;&amp;ndash;&amp;gt;planner&amp;mdash;&amp;ndash;&amp;gt;优化&amp;mdash;&amp;ndash;&amp;gt;执行；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL语句 &amp;ndash;&amp;gt; 词法分析 &amp;mdash;-&amp;gt; 语法分析&amp;mdash;&amp;gt;生成执行计划&amp;mdash;&amp;gt;&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-16-00-47-2021-06-18-16-00-44-image.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-15-38-36-2021-06-18-15-38-32-image.png" alt="">&lt;/p>
&lt;h3 id="词法分析lexer">词法分析(Lexer)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Lexer 也称为分词，从左向右扫描SQL，将其分割成一个个的toke(词元)，在将token组装为AST(Abstract Tree);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Lexer的实现一般都是构造DFA(确定性有限状态自动机)来实现的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>状态转移图如下，这是一个能够识别标识符，数字和一般运算符的词法解析器。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-14-44-04-2021-06-18-14-44-00-image.png" alt="">&lt;/p>
&lt;h3 id="语法分析parser">语法分析(Parser)&lt;/h3>
&lt;p>Parser阶段有两种类型方法来实现:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是自顶向下分析法，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一种是自底向上分析法，&lt;/p>
&lt;p>简单介绍一下两种类型分析法的处理思路。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="执行计划">执行计划&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">SQL String ---词法分析&amp;lt;Lexer&amp;gt;--&amp;gt; Token --&amp;lt;语法分析&amp;gt;--&amp;gt; AST Statement
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="sql-engine">Sql Engine&lt;/h2>
&lt;h3 id="parser解释器">Parser(解释器)&lt;/h3>
&lt;h3 id="planner">Planner&lt;/h3>
&lt;h3 id="executor">Executor&lt;/h3>
&lt;h2 id="storage存储">Storage(存储)&lt;/h2>
&lt;h3 id="memory">Memory&lt;/h3>
&lt;h2 id="mvcc">MVCC&lt;/h2>
&lt;h2 id="raft-engine">Raft Engine&lt;/h2>
&lt;p>&lt;code>toydb&lt;/code> 通过raft来实现各节点间数据的一致性，其自带的raft模块由rust语言提供的一个简单的实现。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/10/08-13-34-25-2021-10-08-13-34-19-image.png" alt="">&lt;/p>
&lt;p>Raft内部有2个状态机：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>复制状态机(): 主要用于日志复制，保证各个副本日志的落盘及一致；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指令状态机(&lt;code>State&lt;/code>): 主要作用是根据日志执行指令；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>由于复制状态机的Raft协议可以保证日志序列的唯一性，所以由日志驱动的不同副本的指令状态机将拥有相同的输入指令序列，在初始状态相同的情况下，指令状态机将会得到相同的输出，以此就保证了各个副本外部最终状态的一致性；&lt;/p>
&lt;ul>
&lt;li>
&lt;p>复制状态机是raft协议的核心；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指令状态机由raft日志驱动来改变外界状态，是raft协议和外界交互的接口；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="evenloop">EvenLoop&lt;/h2>
&lt;p>&lt;code>Raft&lt;/code> 的主驱动是&lt;code>EvenLoop&lt;/code>。节点启动时，会开启一个&lt;code>evenloop&lt;/code>后台异步任务，持续监听&lt;code>tick&lt;/code>, &lt;code>tcp_in_tx&lt;/code>, &lt;code>client_rx&lt;/code>, &lt;code>node_rx&lt;/code>这4个事件源上的消息&lt;code>Msg&lt;/code>，以此来驱动整个状态机的运行：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>tick&lt;/code>事件由定时器产生，转入相应rolenode的&lt;code>tick&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>tcp_in_tx&lt;/code>事件由其他节点peer产生，交由&lt;code>raft&lt;/code> 状态机&lt;code>step&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>node_rx&lt;/code>事件由节点内部产生，需根据事件消息的接收对象(&lt;code>to&lt;/code>)分别处理；&lt;/p>
&lt;ul>
&lt;li>发往副本（&lt;code>to&lt;/code>为&lt;code>Address::Peer&lt;/code>, &lt;code>Address::Peers&lt;/code>）的消息，放入&lt;code>tcp_tx&lt;/code>交由&lt;code>TcpSender&lt;/code>进行发送；&lt;/li>
&lt;li>发往&lt;code>Client&lt;/code>（&lt;code>Address::Client&lt;/code>） 且事件类型为&lt;code>Event::ClientResponse&lt;/code>的消息, 根据&lt;code>id&lt;/code>从&lt;code>requests&lt;/code>表中找到该消息响应rx&lt;code>response_tx&lt;/code>，通过&lt;code>response_tx&lt;/code>将消息响应回复给&lt;code>Client&lt;/code>;&lt;/li>
&lt;li>其他消息为非法消息, 报错并退出；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>client_rx&lt;/code>事件由客户端产生，处理如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>先为事件生成uuid作为唯一id；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以id为key, 将消息响应rx&lt;code>request_rx&lt;/code>放入&lt;code>requests&lt;/code> 哈希表中，该表用于后续消息响应时处理消息返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>生成一个&lt;code>ClientRequest&lt;/code>类型的消息 ，交由&lt;code>Rolenode&lt;/code>的&lt;code>step&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Evenloop&lt;/code>接收到消息后，通过&lt;code>tick()&lt;/code>, &lt;code>step()&lt;/code>来驱动复制状态机执行日志复制操作。&lt;/p>
&lt;p>各节点收到&lt;code>ClientRequest&lt;/code>后处理流程&lt;code>Step()&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>将&lt;code>ClientRequest&lt;/code>消息放入&lt;code>queued_reqs&lt;/code>队列中进行缓存，等待变为&lt;code>Leader&lt;/code>后，再依次处理；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果没有&lt;code>Leader&lt;/code>， 则也将消息放入&lt;code>queued_reqs&lt;/code>中缓存；// queud_reqs 后续处理?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果有&lt;code>Leader&lt;/code>, 则将消息(id, from)放入&lt;code>proxied_reqs&lt;/code>中记录下来，然后转发到&lt;code>Leader&lt;/code>，由&lt;code>Leader&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Leader&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Request::Query&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过&lt;code>state_tx&lt;/code>，向状态机发送&lt;code>Instruction::Query&lt;/code>指令，状态机将指令插入到&lt;code>queries&lt;/code>中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>state_tx&lt;/code>, 向状态机发送&lt;code>Instruction::Vote&lt;/code>指令, 统计；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若存在副本，则向副本发送&lt;code>Event::Heartbeat&lt;/code>消息，和&lt;code>Follower&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Request::Mutate&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将消息记录到本地log中;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制log到各个Follower；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接收到多数&lt;code>Follower&lt;/code>的确认消息后，commit消息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>给状态机发送&lt;code>Instruction::Notify&lt;/code>指令；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>peers&lt;/code>为空，提交；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Request::Status&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>根据当前节点状态，生成&lt;code>Instruction::Status&lt;/code>，通过&lt;code>state_tx&lt;/code>交由状态机执行；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="指令状态机">指令状态机&lt;/h3>
&lt;p>指令状态机由&lt;code>Driver::drive()&lt;/code>驱动。每个Raft Node新建时，会开启一个driver后台任务，该任务从&lt;code>state_rx&lt;/code>接收指令，交由&lt;code>execute&lt;/code>处理，各指令处理流程如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Instruction::Abort&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Apply&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Notify&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果指令&lt;code>index&lt;/code>大于状态机已经&lt;code>applied_index&lt;/code>, 将(index, (address, id))插入到状态机&lt;code>notify&lt;/code>哈希表中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>否则指令已被应用过，通过&lt;code>node_tx&lt;/code>给Raft Node 发送&lt;code>ClientResponse&lt;/code>消息，由Raft Node将错误消息返回给客户端；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Query&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Status&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Vote&lt;/code>:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="源码">源码&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Log&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Log&lt;/code>(日志)是Raft状态机&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="sd">/// The replicated Raft log
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">store&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">dyn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">log&lt;/span>::&lt;span class="n">Store&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commit_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commit_term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Driver&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//状态机接口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">State&lt;/span>: &lt;span class="nb">Send&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">applied_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">u64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">mutate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//修改状态机状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//查询状态机
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//状态机驱动
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Driver&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">state_rx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedReceiver&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Instruction&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//状态机指令输入口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//raft协议消息输出口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">applied_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">notify&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//通知客户端更改被采用
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queries&lt;/span>: &lt;span class="nc">BTreeMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BTreeMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//等待处理的客户端查询指令，
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 状态机指令
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">enum&lt;/span> &lt;span class="nc">Instruction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Abort&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//取消
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Apply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">entry&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//应用
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Notify&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span> &lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//通知
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">quorum&lt;/span>: &lt;span class="kt">u64&lt;/span> &lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//查询
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Status&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">status&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Status&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//状态机状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Vote&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//投票
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="raft角色">Raft角色&lt;/h3>
&lt;h4 id="leader">Leader&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// 节点共有属性
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">RoleNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//节点id
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peers&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">log&lt;/span>: &lt;span class="nc">Log&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pre_vote&lt;/span>: &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//和node之间发送Msg通道
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">state_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Instruction&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//节点往状态机驱动发送状态机指令通道
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queued_reqs&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Event&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">proxied_reqs&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">role&lt;/span>: &lt;span class="nc">R&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// leader专有属性字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Leader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">heartbeat_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//心跳计数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peer_next_index&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//复制到副本的下一个index
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peer_last_index&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//已知复制到副本的最后index
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// follower专有字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Follower&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader&lt;/span>: &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader_seen_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader_seen_timeout&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">voted_for&lt;/span>: &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// candidate专有字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Candidate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">election_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">election_timeout&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">votes&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/erikgrinaker/toydb">GitHub - erikgrinaker/toydb: Distributed SQL database in Rust, written as a learning project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/erikgrinaker/toydb/blob/master/docs/architecture.md">toydb/architecture.md at master · erikgrinaker/toydb · GitHub&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>AF_XDP</title><link>https://justice.bj.cn/post/21.linux/af_xdp/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/af_xdp/</guid><description>&lt;h1 id="af_xdp">AF_XDP&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>AF_XDP&lt;/strong>是一种用于高性能包处理的地址簇(Address Family)。&lt;/p>
&lt;p>使用XDP程序中的&lt;strong>XDP_REDIRECT&lt;/strong>操作，可以使用&lt;code>bpf_redirect_map（）&lt;/code>函数将入口帧重定向到其他启用XDP的网络设备。 AF_XDP套接字使XDP程序可以将帧重定向到用户空间应用程序中的内存缓冲区。&lt;/p>
&lt;p>可以通过&lt;code>socket()&lt;/code>系统调用创建AF_XDP socket (XSK)。每个XSK涉及两个ring：RX ring和TX ring。一个socket可以从RX ring上接收报文，并发送到TX ring。这两个rings分别通过socket选项&lt;code>XDP_RX_RING&lt;/code> 和&lt;code>XDP_TX_RING&lt;/code>进行注册。每个socket必须至少具有其中一个ring。RX或TX ring描述符指向内存域中的data buffer，称为UMEM。RX和TX可以共享相同的UMEM，这样一个报文无需在RX和TX之间进行拷贝。此外，如果一个报文由于重传需要保留一段时间，则指向该报文的描述符可以指向另外一个报文，这样就避免了数据的拷贝。基本流程&lt;a href="https://www.dpdk.org/wp-content/uploads/sites/35/2018/10/pm-06-DPDK-PMD-for-AF_XDP.pdf">如下&lt;/a>：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-39-2020-09-30-17-18-13-image.png" alt="">&lt;/p>
&lt;p>UMEM包含一系列大小相同的chunks，ring中的描述符通过引用帧的地址来引用该帧，该地址为整个UMEM域的偏移量。用户空间会使用合适的方式(malloc，mmap，大页内存等)为UMEM分配内存，然后使用使用新的socket选项&lt;code>XDP_UMEM_REG&lt;/code>将内存域注册到内核中。UMEM也包含两个ring：FILL ring和COMPLETION ring。应用会使用FILL ring下发addr，让内核填写RX包数据。一旦接收到报文，RX ring会引用这些帧。COMPLETION ring包含内核传输完的帧地址，且可以被用户空间使用，用于TX或RX。因此COMPLETION ring中的帧地址为先前使用TX ring传输的地址。总之，RX和FILL ring用于RX路径，TX和COMPLETION ring用于TX路径。&lt;/p>
&lt;p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。&lt;/p>
&lt;p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。&lt;/p>
&lt;p>可以在多个进程间共享UMEM 。如果一个进程需要更新UMEM，则会跳过注册UMEM和其对应的两个ring的过程。在bind调用中设置&lt;code>XDP_SHARED_UMEM&lt;/code> 标志，并提交该进程期望共享UMEM的XSK，以及新创建的XSK socket。新进程会在其共享UMEM的RX ring中接收到帧地址引用。注意，由于ring的结构是单生产者/单消费者的，新的进程的socket必须创建独立的RX和TX ring。同样的原因，每个UMEM也只能有一个FILL和COMPLETION ring。每个进程都需要正确地处理好UMEM。&lt;/p>
&lt;p>那么报文是怎么从XDP程序分发到XSKs的呢？通过名为&lt;code>XSKMAP&lt;/code>(完整名为BPF_MAP_TYPE_XSKMAP`) BPF map。用户空间的应用可以将一个XSK放到该map的任意位置，然后XDP程序就可以将一个报文重定向到该map中指定的索引中，此时XDP会校验map中的XSK确实绑定到该设备和ring号。如果没有，则会丢弃该报文。如果map中的索引为空，也会丢弃该报文。因此，当前的实现中强制要求必须加载一个XDP程序(以及保证XSKMAP存在一个XSK)，这样才能通过XSK将流量传送到用户空间。&lt;/p>
&lt;p>AF_XDP可以运行在两种模式上：&lt;code>XDP_SKB&lt;/code>和&lt;code>XDP_DRV&lt;/code>。如果驱动不支持XDP，则在加载XDP程序是需要明确指定使用XDP_SKB，&lt;code>XDP_SKB&lt;/code>模式使用SKB和通用的XDP功能，并将数据复制到用户空间，是一种适用于任何网络设备的回退模式。 如果驱动支持XDP，将使用AF_XDP代码提供更好的性能，但仍然会将数据拷贝到用户空间的操作。&lt;/p>
&lt;h5 id="术语">术语&lt;/h5>
&lt;h6 id="umem-umem是一个虚拟的连续内存域分割为相同大小的帧">UMEM: UMEM是一个虚拟的连续内存域，分割为相同大小的帧。&lt;/h6>
&lt;p>一个UMEM会关联一个netdev以及该netdev的队列id。通过&lt;code>XDP_UMEM_REG&lt;/code> socket选项进行创建和配置(chunk大小，headroom，开始地址和大小)。通过&lt;code>bind()&lt;/code>系统调用将一个UMEM绑定到一个netdev和队列id。umem的基本结构如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-49-1334952-20200807102005413-1869804955.png" alt="">&lt;/p>
&lt;p>一个AF_XDP为一个链接到一个独立的UMEM的socket，但一个UMEM可以有多个AF_XDP socket。为了共享一个通过socket A创建的UMEM，socket B可以将结构体&lt;code>sockaddr_xdp&lt;/code>中的成员sxdp_flags设置为&lt;code>XDP_SHARED_UMEM&lt;/code>，并将A的文件描述符传递给结构体&lt;code>sockaddr_xdp&lt;/code>的成员&lt;code>sxdp_shared_umem_fd&lt;/code>。&lt;/p>
&lt;p>UMEM有两个单生产者/单消费者ring，用于在内核和用户空间应用程序之间转移UMEM帧。&lt;/p>
&lt;h6 id="rings">Rings&lt;/h6>
&lt;p>有4类不同类型的ring：FILL, COMPLETION, RX 和TX，所有的ring都是单生产者/单消费者，因此用户空间的程序需要显示地同步对这些rings进行读/写的多进程/线程。&lt;/p>
&lt;p>UMEM使用2个ring：FILL和COMPLETION。每个关联到UMEM的socket必须有1个RX队列，1个TX队列或同时拥有2个队列。如果配置了4个socket(同时使用TX和RX)，那么此时会有1个FILL ring，1个COMPLETION ring，4个TX ring和4个RX ring。&lt;/p>
&lt;p>ring是基于首(生产者)尾(消费者)的结构。一个生产者会在结构体xdp_ring的producer成员指出的ring索引处写入数据，并增加生产者索引；一个消费者会结构体xdp_ring的consumer成员指出的ring索引处读取数据，并增加消费者索引。&lt;/p>
&lt;p>可以通过_RING setsockopt系统调用配置和创建ring，使用mmap()，并结合合适的偏移量，将其映射到用户空间&lt;/p>
&lt;p>ring的大小需要是2次幂。&lt;/p>
&lt;h6 id="umem-fill-ring">UMEM Fill Ring&lt;/h6>
&lt;p>FILL ring用于将UMEM帧从用户空间传递到内核空间，同时将UMEM地址传递给ring。例如，如果UMEM的大小为64k，且每个chunk的大小为4k，那么UMEM包含16个chunk，可以传递的地址为0到64k。&lt;/p>
&lt;p>传递给内核的帧用于ingress路径(RX rings)。&lt;/p>
&lt;p>用户应用也会在该ring中生成UMEM地址。注意，如果以对齐的chunk模式运行应用，则内核会屏蔽传入的地址。即，如果一个chunk大小为2k，则会屏蔽掉log2(2048) LSB的地址，意味着2048, 2050 和3000都将引用相同的chunk。如果用户应用使用非对其的chunk模式运行，那么传入的地址将保持不变。&lt;/p>
&lt;h6 id="umem-completion-ring">UMEM Completion Ring&lt;/h6>
&lt;p>COMPLETION Ring用于将UMEM帧从内核空间传递到用户空间，与FILL ring相同，使用了UMEM索引。&lt;/p>
&lt;p>已经发送的从内核空间传递到用户空间的帧还可以被用户空间使用。&lt;/p>
&lt;p>用户应用会消费该ring种的UMEM地址。&lt;/p>
&lt;h6 id="rx-ring">RX Ring&lt;/h6>
&lt;p>RX ring位于socket的接收侧，ring中的每个表项都是一个&lt;code>xdp_desc&lt;/code> 结构的描述符。该描述符包含UMEM偏移量(地址)以及数据的长度。&lt;/p>
&lt;p>如果没有帧从FILL ring传递给内核，则RX ring中不会出现任何描述符。&lt;/p>
&lt;p>用户程序会消费该ring中的&lt;code>xdp_desc&lt;/code>描述符。&lt;/p>
&lt;h6 id="tx-ring">TX Ring&lt;/h6>
&lt;p>TX Ring用于发送帧。在填充&lt;code>xdp_desc&lt;/code>(索引，长度和偏移量)描述符后传递给该ring。&lt;/p>
&lt;p>如果要启动数据传输，则必须调用&lt;code>sendmsg()&lt;/code>，未来可能会放宽这种限制。&lt;/p>
&lt;p>用户程序会给TX ring生成&lt;code>xdp_desc&lt;/code> 描述符。&lt;/p>
&lt;h5 id="xskmap--bpf_map_type_xskmap">XSKMAP / BPF_MAP_TYPE_XSKMAP&lt;/h5>
&lt;p>在XDP侧会用到类型为&lt;code>BPF_MAP_TYPE_XSKMAP&lt;/code> 的BPF map，并结合&lt;code>bpf_redirect_map()&lt;/code>将ingress帧传递给socket。&lt;/p>
&lt;p>用户应用会通过&lt;code>bpf()&lt;/code>系统调用将socket插入该map。&lt;/p>
&lt;p>注意，如果一个XDP程序尝试将帧重定向到一个与队列配置和netdev不匹配的socket时，会丢弃该帧。即，如果一个AF_XDP socket绑定到一个名为eth0，队列为17的netdev上时，只有当XDP程序指定到eth0且队列为17时，才会将数据传递给该socket。参见&lt;code>samples/bpf/&lt;/code>获取例子&lt;/p>
&lt;h5 id="配置标志位和socket选项">配置标志位和socket选项&lt;/h5>
&lt;h6 id="xdp_copy-和xdp_zero_copy-bind标志">XDP_COPY 和XDP_ZERO_COPY bind标志&lt;/h6>
&lt;p>当绑定到一个socket时，内核会首先尝试使用零拷贝进行拷贝。如果不支持零拷贝，则会回退为使用拷贝模式。即，将所有的报文拷贝到用户空间。但如果想强制指定一种特定的模式，则可以使用如下标志：如果给bind调用传递了&lt;code>XDP_COPY&lt;/code>，则内核将强制进入拷贝模式；如果没有使用拷贝模式，则bind调用会失败，并返回错误。相反地，&lt;code>XDP_ZERO_COPY&lt;/code> 将强制socket使用零拷贝或调用失败。&lt;/p>
&lt;h6 id="xdp_shared_umem-bind-标志">XDP_SHARED_UMEM bind 标志&lt;/h6>
&lt;p>该表示可以使多个socket绑定到系统的UMEM，但仅能使用系统的队列id。这种模式下，每个socket都有其各自的RX和TX ring，但UMEM只能有一个FILL ring和一个COMPLETION ring。为了使用这种模式，需要创建第一个socket，并使用正常模式进行绑定。然后创建第二个socket，含一个RX和一个TX(或二者之一)，但不会创建FILL 或COMPLETION ring(与第一个socket共享)。在bind调用中，设置&lt;code>XDP_SHARED_UMEM&lt;/code>选项，并在sxdp_shared_umem_fd中提供初始socket的fd。以此类推。&lt;/p>
&lt;p>那么当接收到一个报文后，应该上送到那个socket呢？答案是由XDP程序来决定。将所有的socket放到XDP_MAP中，然后将报文发送给数组中索引对应的socket。下面展示了一个简单的以轮询方式分发报文的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/bpf.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;bpf_helpers.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#define MAX_SOCKS 16
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BPF_MAP_TYPE_XSKMAP&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">max_entries&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MAX_SOCKS&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">xsks_map&lt;/span> &lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;.maps&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">rr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;xdp_sock&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">xdp_sock_prog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">xdp_md&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">rr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAX_SOCKS&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">bpf_redirect_map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">xsks_map&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">XDP_DROP&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，由于只有一个FILL和一个COMPLETION ring，且是单生产者单消费者的ring，需要确保多处理器或多线程不会同时使用这些ring。libbpf没有提供原子同步功能。&lt;/p>
&lt;p>当多个socket绑定到相同的umem时，libbpf会使用这种模式。然而，需要注意的是，需要在&lt;code>xsk_socket__create&lt;/code>调用中提供&lt;code>XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD&lt;/code> libbpf_flag，然后将其加载到自己的XDP程序中(因为libbpf没有内置路由流量功能)。&lt;/p>
&lt;h6 id="xdp_use_need_wakeup-bind标志">XDP_USE_NEED_WAKEUP bind标志&lt;/h6>
&lt;p>该选择支持在FILL ring和TX ring中设置一个名为&lt;code>need_wakeup&lt;/code>的标志，用户空间作为这些ring的生产者。当在bind调用中设置了该选项，如果需要明确地通过系统调用唤醒内核来继续处理报文时，会设置&lt;code>need_wakeup&lt;/code> 标志。&lt;/p>
&lt;p>如果将该标志设置给FILL ring，则应用需要调用&lt;code>poll()&lt;/code>，以便在RX ring上继续接收报文。如，当内核检测到FILL ring中没有足够的buff，且NIC的RX HW RING中也没有足够的buffer时会发生这种情况。此时会关中断，这样NIC就无法接收到任何报文(由于没有足够的buffer)，由于设置了need_wakeup，这样用户空间就可以在FILL ring上增加buffer，然后调用&lt;code>poll()&lt;/code>，这样内核驱动就可以将这些buffer添加到HW ring上继续接收报文。&lt;/p>
&lt;p>如果将该标志设置给TX ring，意味着应用需要明确地通知内核发送位于TX ring上的报文。可以通过调用&lt;code>poll()&lt;/code>，或调用&lt;code>sendto()&lt;/code>完成。&lt;/p>
&lt;p>可以在&lt;em>samples/bpf/xdpsock_user.c&lt;/em>中找到例子。在TX路径上使用libbpf辅助函数的例子如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">xsk_ring_prod__needs_wakeup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">my_tx_ring&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">sendto&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xsk_socket__fd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xsk_handle&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MSG_DONTWAIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>建议启用该模式，由于减少了TX路径上的系统调用的数目，因此可以在应用和驱动运行在同一个(或不同)core的情况下提升性能。&lt;/p>
&lt;h6 id="xdp_rxtxumem_fillumem_completion_ring-setsockopts">XDP_{RX|TX|UMEM_FILL|UMEM_COMPLETION}_RING setsockopts&lt;/h6>
&lt;p>这些socket选项分别设置RX, TX, FILL和COMPLETION ring的描述符数量(必须至少设置RX或TX ring的描述符大小)。如果同时设置了RX和TX，就可以同时接收和发送来自应用的流量；如果仅设置了其中一个，就可以节省相应的资源。如果需要将一个UMEM绑定到socket，需要同时设置FILL ring和COMPLETION ring。如果使用了&lt;code>XDP_SHARED_UMEM&lt;/code>标志，无需为除第一个socket之外的socket创建单独的UMEM，所有的socket将使用共享的UMEM。注意ring为单生产者单消费者结构，因此多进程无法同时访问同一个ring。参见&lt;code>XDP_SHARED_UMEM&lt;/code>章节。&lt;/p>
&lt;p>使用libbpf时，可以通过给&lt;code>xsk_socket__create&lt;/code>函数的rx和tx参数设置NULL来创建Rx-only和Tx-only的socket。&lt;/p>
&lt;p>如果创建了一个Tx-only的socket，建议不要在FILL ring中放入任何报文，否则，驱动可能会认为需要接收数据(但实际上并不是这样的)，进而影响性能。&lt;/p>
&lt;h6 id="xdp_umem_reg-setsockopt">XDP_UMEM_REG setsockopt&lt;/h6>
&lt;p>该socket选项会给一个socket注册一个UMEM，其对应的区域包含了可以容纳报文的buffer。该调用会使用一个指向该区域开始处的指针，以及该区域的大小。此外，还有一个UMEM可以切分的chunk大小参数(目前仅支持2K或4K)。如果一个UMEM区域的大小为128K，且chunk大小为2K，意味着该UMEM域最大可以有128K / 2K = 64个报文，且最大的报文大小为2K。&lt;/p>
&lt;p>还有一个选项可以在UMEM中设置每个buffer的headroom。如果设置为N字节，意味着报文会从buffer的第N个字节开始，为应用保留前N个字节。最后一个选项为标志位字段，会在每个UMEM标志中单独处理。&lt;/p>
&lt;h6 id="xdp_statistics-getsockopt">XDP_STATISTICS getsockopt&lt;/h6>
&lt;p>获取一个socket丢弃信息，用于调试。支持的信息为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">xdp_statistics&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">rx_dropped&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped for reasons other than invalid desc */&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">rx_invalid_descs&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped due to invalid descriptor */&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">tx_invalid_descs&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped due to invalid descriptor */&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h6 id="xdp_options-getsockopt">XDP_OPTIONS getsockopt&lt;/h6>
&lt;p>获取一个XDP socket的选项。目前仅支持&lt;code>XDP_OPTIONS_ZEROCOPY&lt;/code>，用于检查是否使用了零拷贝。&lt;/p>
&lt;blockquote>
&lt;p>从AF_XDP的特性上可以看到其&lt;a href="https://pantheon.tech/what-is-af_xdp/">局限性&lt;/a>：不能使用XDP将不同的流量重定向的多个AF_XDP socket上，原因是每个AF_XDP socket必须绑定到物理接口的TX队列上。大多数的物理和仿真HW的每个接口仅支持一个RX/TX队列，因此当该接口上绑定了一个AF_XDP后，后续的绑定操作都将失败。仅有少数HW支持多RX/TX队列，且通常仅有2/4/8个队列，无法扩展给cloud中的上百个容器使用。&lt;/p>
&lt;/blockquote>
&lt;p>更多细节参见AF_XDP&lt;a href="https://www.kernel.org/doc/html/latest/networking/af_xdp.html">官方文档&lt;/a>以及这篇&lt;a href="http://vger.kernel.org/lpc_net2018_talks/lpc18_paper_af_xdp_perf-v2.pdf">论文&lt;/a>。&lt;/p>
&lt;h2 id="tchttpsdocsciliumioenlatestbpftc-traffic-control">&lt;a href="https://docs.cilium.io/en/latest/bpf/#tc-traffic-control">TC&lt;/a>&lt;/h2>
&lt;p>除了XDP，BPF还可以在网络数据路径的内核tc(traffic control)层之外使用。上文已经给出了XDP和TC的区别。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>ingress&lt;/code> hook：&lt;code>__netif_receive_skb_core() -&amp;gt; sch_handle_ingress()&lt;/code>&lt;/li>
&lt;li>&lt;code>egress&lt;/code> hook：&lt;code>__dev_queue_xmit() -&amp;gt; sch_handle_egress()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-12-21-1334952-20200809204246404-1470995812.png" alt="">&lt;/p>
&lt;/blockquote>
&lt;p>运行在tc层的BPF程序使用的是 &lt;code>cls_bpf&lt;/code> (cls即Classifiers的简称)分类器。在tc中，将BPF的附着点描述为一个&amp;quot;分类器&amp;quot;，这个词有点误导，因此它少描述了&lt;code>cls_bpf&lt;/code>的所支持的功能。即一个完整的可编程的报文处理器不仅可以读取&lt;code>skb&lt;/code>的元数据和报文数据，还可以对其进行任意修改，最后终止tc的处理，并返回裁定的action(见下)。&lt;code>cls_bpf&lt;/code>可以认为是一个自包含的，可以管理和执行tc BPF程序的实体。&lt;/p>
&lt;p>&lt;code>cls_bpf&lt;/code>可以包含一个或多个tc BPF程序。通常，在传统的tc方案中，分类器和action模块是分开的，每个分类器可以附加一个或多个action，一旦匹配到分类器时就会执行action。但在现代软件数据路径中使用这种模式的tc处理复杂的报文时会遇到扩展性问题。由于附加到cls_bpf的tc BPF程序是完全自包含的，因此可以有效地将解析和操作过程融合到一个单元中。幸好有了&lt;code>cls_bpf&lt;/code>的&lt;code>direct-action&lt;/code>模式，该模式下，仅需要返回tc action裁定结果并立即结束处理流即可，可以在网络数据流中实现可扩展的可编程报文处理流程，同时避免了action的线性迭代。&lt;code>cls_bpf&lt;/code>是tc层中唯一能够实现这种快速路径的“分类器”模块。&lt;/p>
&lt;p>与XDP BPF程序类似，tc BPF程序可以在运行时通过cls_bpf自动更新，而不会中断任何网络流或重启服务。&lt;/p>
&lt;p>&lt;code>cls_bpf&lt;/code>可以附加的tc ingress和egree钩子都通过一个名为&lt;code>sch_clsact&lt;/code>的伪qdisc进行管理。由于该伪qdisc可以同时管理ingress和egress的tc钩子，因此它是ingress qdisc的超集(也可直接替换)。对于&lt;code>__dev_queue_xmit()&lt;/code>中的tc的egress钩子，需要注意的是，它不是在内核的qdisc root锁下运行的。因此，tc ingress和egress钩子都以无锁的方式运行在快速路径中，且这两个钩子都禁用了抢占，并运行在RCU读取侧。&lt;/p>
&lt;p>通常在egress上会存在附着到网络设备上的qdisc，如&lt;code>sch_mq&lt;/code>，&lt;code>sch_fq&lt;/code>，&lt;code>sch_fq_codel&lt;/code>或&lt;code>sch_htb&lt;/code>，其中有些是可分类的qdisc(包含子类)，因此会要求一个报文分类机制来决定在哪里解复用数据包。该过程通过调用&lt;code>tcf_classify()&lt;/code>进行处理，进而调用tc分类器(如果存在)。&lt;code>cls_bpf&lt;/code>也可以附加并用于如下场景：一些在qdisc root锁下的操作可能会收到锁竞争的影响。&lt;code>sch_clsact&lt;/code> qdisc的egress钩子出现在更早的时间点，但它不属于这个锁的范围，因此作完全独立于常规的egress qdiscs。因此，对于&lt;code>sch_htb&lt;/code>这样的情况，&lt;code>sch_clsact&lt;/code> qdisc可以通过qdisc root锁之外的tc BPF执行繁重的包分类工作，通过在这些 tc BPF 程序中设置 &lt;code>skb-&amp;gt;mark&lt;/code> 或 &lt;code>skb-&amp;gt;priority&lt;/code> ，这样 &lt;code>sch_htb&lt;/code> 只需要一个简单的映射即可，不需要在root锁下执行代价高昂的报文分类工作，通过这种方式可以减少锁竞争。&lt;/p>
&lt;p>在sch_clsact结合cls_bpf的场景下支持offloaded tc BPF程序，这种情况下，先前加载的BPF程序是从SmartNIC驱动程序jit生成的，以便在NIC上以本机方式运行。只有在&lt;code>direct-action&lt;/code>模式下运行的&lt;code>cls_bpf&lt;/code>程序才支持offloaded。&lt;code>cls_bpf&lt;/code>仅支持offload一个单独的程序(无法offload多个程序)，且只有ingress支持offload BPF程序。&lt;/p>
&lt;p>一个&lt;code>cls_bpf&lt;/code>实例可以包含多个tc BPF程序，如果是这种情况，那么&lt;code>TC_ACT_UNSPEC&lt;/code>程序返回码可以继续执行列表中的下一个tc BPF程序。然而，这样做的缺点是，多个程序需要多次解析相同的报文，导致性能下降。&lt;/p>
&lt;h3 id="返回码">返回码&lt;/h3>
&lt;p>tc的ingress和egress钩子共享相同的action来返回tc BPF程序使用的裁定结果，定义在 &lt;code>linux/pkt_cls.h&lt;/code>系统头文件中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define TC_ACT_UNSPEC (-1)
&lt;/span>&lt;span class="cp">#define TC_ACT_OK 0
&lt;/span>&lt;span class="cp">#define TC_ACT_SHOT 2
&lt;/span>&lt;span class="cp">#define TC_ACT_STOLEN 4
&lt;/span>&lt;span class="cp">#define TC_ACT_REDIRECT 7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>系统头文件中还有一些以&lt;code>TC_ACT_*&lt;/code>开头的action变量，可以被两个钩子使用。但它们与上面的语义相同。即，从tc BPF的角度来看&lt;code>TC_ACT_OK&lt;/code>和&lt;code>TC_ACT_RECLASSIFY&lt;/code>的语义相同，三个&lt;code>TC_ACT_stelled&lt;/code>、&lt;code>TC_ACT_QUEUED&lt;/code>和&lt;code>TC_ACT_TRAP&lt;/code>操作码的语义也是相同的。因此，对于这些情况，我们只描述 &lt;code>TC_ACT_OK&lt;/code> 和 &lt;code>TC_ACT_STOLEN&lt;/code> 操作码。&lt;/p>
&lt;p>从&lt;code>TC_ACT_UNSPEC&lt;/code>开始，表示&amp;quot;未指定的action&amp;quot;，用于以下三种场景：i)当一个offloaded tc程序的tc ingress钩子运行在&lt;code>cls_bpf&lt;/code>的位置，则该offloaded程序将返回&lt;code>TC_ACT_UNSPEC&lt;/code>；ii)为了在多程序场景下继续执行&lt;code>cls_bpf&lt;/code>中的下一个BPF程序，后续的程序需要与步骤i中的offloaded tc BPF程序配合使用，但出现了一个非offloaded场景下运行的tc BPF程序；iii)&lt;code>TC_ACT_UNSPEC&lt;/code>还可以用于单个程序场景，用于告诉内核继续使用skb，不会产生其他副作用。&lt;code>TC_ACT_UNSPEC&lt;/code>与&lt;code>TC_ACT_OK&lt;/code>类似，两者都会将skb通过ingress向上传递到网络栈的上层，或者通过egress向下传递到网络设备驱动程序，以便在egress进行传输。与&lt;code>TC_ACT_OK&lt;/code>的唯一不同之处是，&lt;code>TC_ACT_OK&lt;/code>基于tc BPF程序设定的classid来设置&lt;code>skb-&amp;gt;tc_index&lt;/code>，而 &lt;code>TC_ACT_UNSPEC&lt;/code> 是通过 tc BPF 程序之外的 BPF上下文中的 &lt;code>skb-&amp;gt;tc_classid&lt;/code> 进行设置。&lt;/p>
&lt;p>&lt;code>TC_ACT_SHOT&lt;/code>通知内核丢弃报文，即网络栈上层将不会在ingress的skb中看到该报文，类似地，这类报文也不会在egress中发送。&lt;code>TC_ACT_SHOT&lt;/code>和&lt;code>TC_ACT_STOLEN&lt;/code>本质上是相似的，仅存在部分差异：&lt;code>TC_ACT_SHOT&lt;/code>会通知内核已经通过&lt;code>kfree_skb()&lt;/code>释放skb，且会立即给调用者返回&lt;code>NET_XMIT_DROP&lt;/code>；而TC_ACT_STOLEN会通过&lt;code>consume_skb()&lt;/code>释放skb,并给上层返回&lt;code>NET_XMIT_SUCCESS&lt;/code>，假装传输成功。perf的报文丢弃监控会记录&lt;code>kfree_skb()&lt;/code>的操作，因此不会记录任何因为&lt;code>TC_ACT_STOLEN&lt;/code>丢弃的报文，因为从语义上说，这些 &lt;code>skb&lt;/code> 是被消费或排队的而不是被丢弃的。&lt;/p>
&lt;p>最后&lt;code>TC_ACT_REDIRECT&lt;/code> action允许tc BPF程序通过&lt;code>bpf_redirect()&lt;/code>辅助函数将skb重定向到相同或不同的设备ingress或egress路径上。通过将报文导入其他设备的ingress或egress方向，可以最大化地实现BPF的报文转发功能。使用该方式不需要对目标网络设备做任何更改，也不需要在目标设备上运行另外一个&lt;code>cls_bpf&lt;/code>实例。&lt;/p>
&lt;h3 id="加载tc-bpf程序">加载tc BPF程序&lt;/h3>
&lt;p>假设有一个名为&lt;code>prog.o&lt;/code>的tc BPF程序，可以通过tc命令将该程序加载到网络设备山。与XDP不同，它不需要依赖驱动将BPF程序附加到设备上，下面会用到一个名为&lt;code>em1&lt;/code>的网络设备，并将程序附加到&lt;code>em1&lt;/code>的&lt;code>ingress&lt;/code>报文路径上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter add dev em1 ingress bpf da obj prog.o&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一步首先配置一个&lt;code>clsact&lt;/code> qdisc。如上文所述，clsact是一个伪造的qdisc，与&lt;code>ingress&lt;/code> qdisc类似，仅包含分类器和action，但不会提供实际的队列功能，它是附加bpf分类器所必需的。&lt;code>clsact&lt;/code> 提供了两个特殊的钩子，称为&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>，分类器可以附加到这两个钩子上。&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>钩子都位于网络数据路径的中央接收和发送位置，每个经过设备的报文都会经过此处。&lt;code>ingees&lt;/code>钩子通过内核的&lt;code>__netif_receive_skb_core() -&amp;gt; sch_handle_ingress()&lt;/code>进行调用，&lt;code>egress&lt;/code>钩子通过&lt;code>__dev_queue_xmit() -&amp;gt; sch_handle_egress()&lt;/code>进行调用。&lt;/p>
&lt;p>将程序附加到&lt;code>egress&lt;/code>钩子上的操作为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 egress bpf da obj prog.o&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>clsact&lt;/code> qdisc以无锁的方式处理来自&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>方向的报文，且可以附加到一个无队列虚拟设备上，如连接到容器的&lt;code>veth&lt;/code>设备。&lt;/p>
&lt;p>在钩子之后，&lt;code>tc filter&lt;/code>命令选择使用&lt;code>bpf&lt;/code>的&lt;code>da&lt;/code>(direct-action)模式。推荐使用并指定da&lt;code>模式&lt;/code>，基本上意味着bpf分类器不再需要调用外部tc action模块，所有报文的修改，转发或其他action都可以通过附加的BPF程序来实现，因此处理速度更快。&lt;/p>
&lt;p>到此位置，已经附加bpf程序，一旦有报文传输到该设备后就会执行该程序。与XDP相同，如果不使用默认的section名称，则可以在加载期间进行指定，例如，下面指定的section名为&lt;code>foobar&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 egress bpf da obj prog.o sec foobar&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>iptables2的BPF加载器允许跨程序类型使用相同的命令行语法。&lt;/p>
&lt;p>附加的程序可以使用如下命令列出：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>ingress&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">1&lt;/span> tag c5f7825e5dac396f
&lt;span class="c1"># tc filter show dev em1 egress&lt;/span>
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>egress&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">2&lt;/span> tag b2fd5adc0f262714
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>prog.o:[ingress]&lt;/code>的输出说明程序段&lt;code>ingress&lt;/code>通过文件&lt;code>prog.o&lt;/code>进行加载，且&lt;code>bpf&lt;/code>运行在&lt;code>direct-action&lt;/code>模式下。上面两种情况附加了程序&lt;code>id&lt;/code>和&lt;code>tag&lt;/code>，其中后者表示对指令流的hash，该hash可以与目标文件或带有堆栈跟踪的perf report等相关。最后，&lt;code>id&lt;/code>表示系统范围内的BPF程序的唯一标识符，可以使用&lt;code>bpftool&lt;/code>来查看或dump附加的BPF程序。&lt;/p>
&lt;p>tc可以附加多个BPF程序，它提供了其他可以链接在一起的分类器。但附加一个BPF程序已经可以完全满足需求，因为通过&lt;code>da&lt;/code>(&lt;code>direct-action&lt;/code>)模式可以在一个程序中实现所有的报文操作，意味着BPF程序将返回tc action裁定结果，如&lt;code>TC_ACT_OK&lt;/code>, &lt;code>TC_ACT_SHOT&lt;/code>等。为了获得最佳性能和灵活性，推荐使用这种方式。&lt;/p>
&lt;p>在上述&lt;code>show&lt;/code>命令中，在BPF的相关输出旁显示了&lt;code>pref 49152&lt;/code> 和&lt;code>handle 0x1&lt;/code>。如果没有通过命令行显式地提供，会自动生成的这两个输出。&lt;code>perf&lt;/code>表明了一个优先级数字，即当附加了多个分类器时，将会按照优先级上升的顺序执行这些分类器。&lt;code>handle&lt;/code>表示一个标识符，当一个&lt;code>perf&lt;/code>加载了系统分类器的多个实例时起作用。由于在BPF场景下，一个程序足矣，&lt;code>perf&lt;/code>和&lt;code>handle&lt;/code>通常可以忽略。&lt;/p>
&lt;p>只有在需要自动替换附加的BPF程序的情况下，才会推荐在初始化加载前指定&lt;code>pref&lt;/code>和&lt;code>handle&lt;/code>，这样在以后执行&lt;code>replace&lt;/code>操作时就不必在进行查询。创建方式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar&lt;/span>
&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">1&lt;/span> bpf
filter protocol all pref &lt;span class="m">1&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>foobar&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">1&lt;/span> tag c5f7825e5dac396f
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于原子替换，可以使用(来自文件&lt;code>prog.o&lt;/code>中的&lt;code>foobar&lt;/code> section的BPF程序)如下命令来更新现有的&lt;code>ingress&lt;/code>钩子上的程序&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，为了移除所有ingress和egress上附加的程序，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter del dev em1 ingress&lt;/span>
&lt;span class="c1"># tc filter del dev em1 egress&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了移除网络设备上的整个&lt;code>clsact&lt;/code> qdisc，即移除掉ingress和egress钩子上附加的所有程序，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc del dev em1 clsact&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果NIC和驱动也像XDP BPF程序一样支持offloaded，则tc BPF程序也可以是offloaded的。Netronome的nfp同时支持两种类型的BPF offload。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o&lt;/span>
Error: TC offload is disabled on net device.
We have an error talking to the kernel
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果出现了如上错误，则表示首先需要通过ethtool的&lt;code>hw-tc-offload&lt;/code>来启动tc硬件offload：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># ethtool -K em1 hw-tc-offload on&lt;/span>
&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o&lt;/span>
&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">1&lt;/span> bpf
filter protocol all pref &lt;span class="m">1&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>classifier&lt;span class="o">]&lt;/span> direct-action skip_sw in_hw id &lt;span class="m">19&lt;/span> tag 57cd311f2e27366b
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>in_hw&lt;/code>标志表示程序已经offload到了NIC中。&lt;/p>
&lt;p>注意不能同时offload tc和XDP BPF，必须且只能选择其中之一。&lt;/p></description></item></channel></rss>