<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 04 Jan 2024 19:25:52 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>ELF文件格式</title><link>https://justice.bj.cn/post/21.linux/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</link><pubDate>Thu, 04 Jan 2024 19:25:52 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</guid><description>&lt;h1 id="elf文件格式">ELF文件格式&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>ELF (Executable and Linkable Format)是Linux的可执行文件格式(Windows下的可执行文件格式为PE(Portable Executable)格式), 是 &lt;strong>COFF（Common File Format）&lt;/strong> 格式的变种;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ELF格式文件包括：可执行文件，目标文件(.o)，共享链接库(.so)，静态连接库(.a)和内核转储(core dumps)文件;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="组成">组成&lt;/h2>
&lt;p>一个ELF文件由以下三部分组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ELF头(ELF header)：描述文件的主要特性：类型，CPU架构，入口地址，现有部分的大小和偏移等等；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序头表(Program header table):&lt;/p>
&lt;ul>
&lt;li>
&lt;p>列举了所有有效的段(segments)和他们的属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序头表需要加载器将文件中的节加载到虚拟内存段中；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Segment和Section：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>段(Segment)由若干区(Section)组成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>段在运行时被加载到进程地址空间中，包含在可执行文件中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>区是段的组成单元，包含在可执行文件和可重定位文件中；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>节头表(Section header table): 包含对节(sections)的描述；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/04-10-48-36-elf-file-format.png" alt="loading-ag-11966">&lt;/p>
&lt;h2 id="文件头header">文件头(Header)&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ readelf -h hello.o
ELF Header:
Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
Class: ELF64
Data: 2&amp;#39;s complement, little endian
Version: 1 (current)
OS/ABI: UNIX - System V
ABI Version: 0
Type: REL (Relocatable file)
Machine: Advanced Micro Devices X86-64
Version: 0x1
Entry point address: 0x0
Start of program headers: 0 (bytes into file)
Start of section headers: 672 (bytes into file)
Flags: 0x0
Size of this header: 64 (bytes)
Size of program headers: 0 (bytes)
Number of program headers: 0
Size of section headers: 64 (bytes)
Number of section headers: 13
Section header string table index: 10
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="魔数magic">魔数(Magic)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，通常被称为&lt;strong>魔数（Magic Number）&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过对魔数的判断可以确定文件的格式和类型。如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ELF的可执行文件格式的头4个字节为&lt;code>0x7F&lt;/code>、&lt;code>e&lt;/code>、&lt;code>l&lt;/code>、&lt;code>f&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java的可执行文件格式的头4个字节为&lt;code>c&lt;/code>、&lt;code>a&lt;/code>、&lt;code>f&lt;/code>、&lt;code>e&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是&lt;code>#!/bin/sh&lt;/code>或&lt;code>#!/usr/bin/perl&lt;/code>或&lt;code>#!/usr/bin/python&lt;/code>，此时前两个字节&lt;code>#&lt;/code>和&lt;code>!&lt;/code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="elf文件类型">ELF文件类型&lt;/h3>
&lt;p>ELF文件主要有三种类型，可以通过ELF Header中的&lt;code>e_type&lt;/code>成员进行区分。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可重定位文件（Relocatable File）&lt;/strong>：&lt;code>ETL_REL&lt;/code>。一般为&lt;code>.o&lt;/code>文件。可以被链接成可执行文件或共享目标文件。静态链接库属于可重定位文件。&lt;/li>
&lt;li>&lt;strong>可执行文件（Executable File）&lt;/strong>：&lt;code>ET_EXEC&lt;/code>。可以直接执行的程序。&lt;/li>
&lt;li>&lt;strong>共享目标文件（Shared Object File）&lt;/strong>：&lt;code>ET_DYN&lt;/code>。一般为&lt;code>.so&lt;/code>文件。有两种情况可以使用。
&lt;ul>
&lt;li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；&lt;/li>
&lt;li>动态链接器将其与其他共享目标文件、结合一个可执行文件，创建进程映像。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/04-10-54-21-different-elf-type.png" alt="">&lt;/p>
&lt;h2 id="程序头表program-header-table">程序头表(Program Header Table)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>在可执行文件或者共享链接库中所有的节(sections)都被分为多个段(segments)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序头是一个结构的数组，每一个结构都表示一个段(segments)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ readelf -l vmlinux
Elf file type is EXEC (Executable file)
Entry point 0x1000000
There are 5 program headers, starting at offset 64
Program Headers:
Type Offset VirtAddr PhysAddr
FileSiz MemSiz Flags Align
LOAD 0x0000000000200000 0xffffffff81000000 0x0000000001000000
0x0000000000cfd000 0x0000000000cfd000 R E 200000
LOAD 0x0000000001000000 0xffffffff81e00000 0x0000000001e00000
0x0000000000100000 0x0000000000100000 RW 200000
LOAD 0x0000000001200000 0x0000000000000000 0x0000000001f00000
0x0000000000014d98 0x0000000000014d98 RW 200000
LOAD 0x0000000001315000 0xffffffff81f15000 0x0000000001f15000
0x000000000011d000 0x0000000000279000 RWE 200000
NOTE 0x0000000000b17284 0xffffffff81917284 0x0000000001917284
0x0000000000000024 0x0000000000000024 4
Section to Segment mapping:
Segment Sections...
00 .text .notes __ex_table .rodata __bug_table .pci_fixup .builtin_fw
.tracedata __ksymtab __ksymtab_gpl __kcrctab __kcrctab_gpl
__ksymtab_strings __param __modver
01 .data .vvar
02 .data..percpu
03 .init.text .init.data .x86_cpu_dev.init .altinstructions
.altinstr_replacement .iommu_table .apicdrivers .exit.text
.smp_locks .data_nosave .bss .brk
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="段头表section-header-table">段头表(Section Header Table)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>ELF 节头表是一个节头数组;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ readelf -S hello.o
There are 13 section headers, starting at offset 0x2a0:
Section Headers:
[Nr] Name Type Address Offset
Size EntSize Flags Link Info Align
[ 0] NULL 0000000000000000 00000000
0000000000000000 0000000000000000 0 0 0
[ 1] .text PROGBITS 0000000000000000 00000040
0000000000000015 0000000000000000 AX 0 0 1
[ 2] .rela.text RELA 0000000000000000 000001f0
0000000000000030 0000000000000018 I 11 1 8
[ 3] .data PROGBITS 0000000000000000 00000055
0000000000000000 0000000000000000 WA 0 0 1
[ 4] .bss NOBITS 0000000000000000 00000055
0000000000000000 0000000000000000 WA 0 0 1
[ 5] .rodata PROGBITS 0000000000000000 00000055
000000000000000d 0000000000000000 A 0 0 1
[ 6] .comment PROGBITS 0000000000000000 00000062
0000000000000035 0000000000000001 MS 0 0 1
[ 7] .note.GNU-stack PROGBITS 0000000000000000 00000097
0000000000000000 0000000000000000 0 0 1
[ 8] .eh_frame PROGBITS 0000000000000000 00000098
0000000000000038 0000000000000000 A 0 0 8
[ 9] .rela.eh_frame RELA 0000000000000000 00000220
0000000000000018 0000000000000018 I 11 8 8
[10] .shstrtab STRTAB 0000000000000000 00000238
0000000000000061 0000000000000000 0 0 1
[11] .symtab SYMTAB 0000000000000000 000000d0
0000000000000108 0000000000000018 12 9 8
[12] .strtab STRTAB 0000000000000000 000001d8
0000000000000013 0000000000000000 0 0 1
Key to Flags:
W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
O (extra OS processing required) o (OS specific), p (processor specific)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="elf-sections">ELF Sections&lt;/h2>
&lt;h3 id="节的分类">节的分类&lt;/h3>
&lt;p>上述ELF Section Header Table部分已经简单介绍了节类型。接下来我们来介绍详细一些比较重要的节。&lt;/p>
&lt;h4 id="text节">.text节&lt;/h4>
&lt;p>&lt;code>.text&lt;/code>节是保存了程序代码指令的&lt;strong>代码节&lt;/strong>。&lt;strong>一段可执行程序，如果存在Phdr，则&lt;code>.text&lt;/code>节就会存在于&lt;code>text&lt;/code>段中&lt;/strong>。由于&lt;code>.text&lt;/code>节保存了程序代码，所以节类型为&lt;code>SHT_PROGBITS&lt;/code>。&lt;/p>
&lt;h4 id="rodata节">.rodata节&lt;/h4>
&lt;p>&lt;code>rodata&lt;/code>节保存了只读的数据，如一行C语言代码中的字符串。由于&lt;code>.rodata&lt;/code>节是只读的，所以只能存在于一个可执行文件的&lt;strong>只读段&lt;/strong>中。因此，只能在&lt;code>text&lt;/code>段（不是&lt;code>data&lt;/code>段）中找到&lt;code>.rodata&lt;/code>节。由于&lt;code>.rodata&lt;/code>节是只读的，所以节类型为&lt;code>SHT_PROGBITS&lt;/code>。&lt;/p>
&lt;h4 id="plt节过程链接表">.plt节（过程链接表）&lt;/h4>
&lt;p>&lt;code>.plt&lt;/code>节也称为&lt;strong>过程链接表（Procedure Linkage Table）&lt;/strong>，&lt;strong>其包含了动态链接器调用从共享库导入的函数所必需的相关代码&lt;/strong>。由于&lt;code>.plt&lt;/code>节保存了代码，所以节类型为&lt;code>SHT_PROGBITS&lt;/code>。&lt;/p>
&lt;h4 id="data节">.data节&lt;/h4>
&lt;p>&lt;code>.data&lt;/code>节存在于&lt;code>data&lt;/code>段中，&lt;strong>其保存了初始化的全局变量等数据&lt;/strong>。由于&lt;code>.data&lt;/code>节保存了程序的变量数据，所以节类型为&lt;code>SHT_PROGBITS&lt;/code>。&lt;/p>
&lt;h4 id="bss节">.bss节&lt;/h4>
&lt;p>&lt;code>.bss&lt;/code>节存在于&lt;code>data&lt;/code>段中，占用空间不超过4字节，仅表示这个节本省的空间。&lt;strong>&lt;code>.bss&lt;/code>节保存了未进行初始化的全局数据&lt;/strong>。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于&lt;code>.bss&lt;/code>节未保存实际的数据，所以节类型为&lt;code>SHT_NOBITS&lt;/code>。&lt;/p>
&lt;h4 id="gotplt节全局偏移表-过程链接表">.got.plt节（全局偏移表-过程链接表）&lt;/h4>
&lt;p>&lt;code>.got&lt;/code>节保存了&lt;strong>全局偏移表&lt;/strong>。&lt;strong>&lt;code>.got&lt;/code>节和&lt;code>.plt&lt;/code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改&lt;/strong>。由于&lt;code>.got.plt&lt;/code>节与程序执行有关，所以节类型为&lt;code>SHT_PROGBITS&lt;/code>。&lt;/p>
&lt;h4 id="dynsym节动态链接符号表">.dynsym节（动态链接符号表）&lt;/h4>
&lt;p>&lt;code>.dynsym&lt;/code>节保存在&lt;code>text&lt;/code>段中。&lt;strong>其保存了从共享库导入的动态符号表&lt;/strong>。节类型为&lt;code>SHT_DYNSYM&lt;/code>。&lt;/p>
&lt;h4 id="dynstr节动态链接字符串表">.dynstr节（动态链接字符串表）&lt;/h4>
&lt;p>&lt;code>.dynstr&lt;/code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。&lt;/p>
&lt;h4 id="rel节重定位表">.rel.*节（重定位表）&lt;/h4>
&lt;p>重定位表保存了重定位相关的信息，&lt;strong>这些信息描述了如何在链接或运行时，对ELF目标文件的某部分或者进程镜像进行补充或修改&lt;/strong>。由于重定位表保存了重定位相关的数据，所以节类型为&lt;code>SHT_REL&lt;/code>。&lt;/p>
&lt;h4 id="hash节">.hash节&lt;/h4>
&lt;p>&lt;code>.hash&lt;/code>节也称为&lt;code>.gnu.hash&lt;/code>，其保存了一个用于查找符号的散列表。&lt;/p>
&lt;h4 id="symtab节符号表">.symtab节（符号表）&lt;/h4>
&lt;p>&lt;code>.symtab&lt;/code>节是一个&lt;code>ElfN_Sym&lt;/code>的数组，保存了符号信息。节类型为&lt;code>SHT_SYMTAB&lt;/code>。&lt;/p>
&lt;h4 id="strtab节字符串表">.strtab节（字符串表）&lt;/h4>
&lt;p>&lt;code>.strtab&lt;/code>节保存的是符号字符串表，表中的内容会被&lt;code>.symtab&lt;/code>的&lt;code>ElfN_Sym&lt;/code>结构中的&lt;code>st_name&lt;/code>引用。节类型为&lt;code>SHT_STRTAB&lt;/code>。&lt;/p>
&lt;h4 id="ctors节和dtors节">.ctors节和.dtors节&lt;/h4>
&lt;p>&lt;code>.ctors&lt;/code>（&lt;strong>构造器&lt;/strong>）节和&lt;code>.dtors&lt;/code>（&lt;strong>析构器&lt;/strong>）节分别保存了指向构造函数和析构函数的函数指针，&lt;strong>构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码&lt;/strong>。&lt;/p>
&lt;h3 id="符号表">符号表&lt;/h3>
&lt;p>节的分类中我们介绍了&lt;code>.dynsym&lt;/code>节和&lt;code>.symtab&lt;/code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？&lt;/p>
&lt;p>&lt;strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名&lt;/strong>。例如，&lt;code>printf()&lt;/code>函数会在动态链接符号表&lt;code>.dynsym&lt;/code>中存有一个指向该函数的符号项（以&lt;code>Elf_Sym&lt;/code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即&lt;code>.dynsym&lt;/code>和&lt;code>.symtab&lt;/code>。&lt;/p>
&lt;p>&lt;strong>&lt;code>.dynsym&lt;/code>保存了引用来自外部文件符号的全局符号&lt;/strong>。如&lt;code>printf&lt;/code>库函数。&lt;strong>&lt;code>.dynsym&lt;/code>保存的符号是&lt;code>.symtab&lt;/code>所保存符合的子集，&lt;code>.symtab&lt;/code>中还保存了可执行文件的本地符号&lt;/strong>。如全局变量，代码中定义的本地函数等。&lt;/p>
&lt;p>既然&lt;code>.dynsym&lt;/code>是&lt;code>.symtab&lt;/code>的子集，那为何要同时存在两个符号表呢？&lt;/p>
&lt;p>通过&lt;code>readelf -S&lt;/code>命令可以查看可执行文件的输出，一部分节标志位（&lt;code>sh_flags&lt;/code>）被标记为了&lt;strong>A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）&lt;/strong>。其中，&lt;code>.dynsym&lt;/code>被标记为ALLOC，而&lt;code>.symtab&lt;/code>则没有标记。&lt;/p>
&lt;p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而&lt;code>.symtab&lt;/code>不是在运行时必需的，因此不会被装载到内存中。&lt;strong>&lt;code>.dynsym&lt;/code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号&lt;/strong>。&lt;code>.dynsym&lt;/code>对于动态链接可执行文件的执行是必需的，而&lt;code>.symtab&lt;/code>只是用来进行调试和链接的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/04-11-00-25-elf-symtab-strtab.png" alt="loading-ag-12284">&lt;/p>
&lt;p>上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个&lt;code>Elf_Sym&lt;/code>结构，对应可以在字符串表中索引得到一个字符串。该数据结构中成员的含义如下表所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>成员&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>st_name&lt;/td>
&lt;td>符号名。该值为该符号名在字符串表中的偏移地址。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>st_value&lt;/td>
&lt;td>符号对应的值。存放符号的值（可能是地址或位置偏移量）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>st_size&lt;/td>
&lt;td>符号的大小。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>st_other&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>st_shndx&lt;/td>
&lt;td>符号所在的节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>st_info&lt;/td>
&lt;td>符号类型及绑定属性&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>使用readelf工具我们也能够看到符号表的相关信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ readelf -s hello.o
Symbol table &amp;#39;.symtab&amp;#39; contains 11 entries:
Num: Value Size Type Bind Vis Ndx Name
0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND
1: 0000000000000000 0 FILE LOCAL DEFAULT ABS hello.c
2: 0000000000000000 0 SECTION LOCAL DEFAULT 1
3: 0000000000000000 0 SECTION LOCAL DEFAULT 3
4: 0000000000000000 0 SECTION LOCAL DEFAULT 4
5: 0000000000000000 0 SECTION LOCAL DEFAULT 5
6: 0000000000000000 0 SECTION LOCAL DEFAULT 7
7: 0000000000000000 0 SECTION LOCAL DEFAULT 8
8: 0000000000000000 0 SECTION LOCAL DEFAULT 6
9: 0000000000000000 21 FUNC GLOBAL DEFAULT 1 main
10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND puts
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="字符串表">字符串表&lt;/h3>
&lt;p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即&lt;code>.dynstr&lt;/code>和&lt;code>.strtab&lt;/code>，分别对应于&lt;code>.dynsym&lt;/code>和&lt;code>symtab&lt;/code>。此外，还有一个&lt;code>.shstrtab&lt;/code>的节头字符串表，用于保存节头表中用到的字符串，可通过&lt;code>sh_name&lt;/code>进行索引。&lt;/p>
&lt;p>ELF文件中所有字符表的结构基本一致，如上图所示。&lt;/p>
&lt;h3 id="重定位表">重定位表&lt;/h3>
&lt;p>&lt;strong>重定位就是将符号定义和符号引用进行连接的过程&lt;/strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。&lt;/p>
&lt;p>重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ objdump -r hello.o
hello.o: file format elf64-x86-64
RELOCATION RECORDS FOR [.text]:
OFFSET TYPE VALUE
0000000000000005 R_X86_64_32 .rodata
000000000000000a R_X86_64_PC32 puts-0x0000000000000004
RELOCATION RECORDS FOR [.eh_frame]:
OFFSET TYPE VALUE
0000000000000020 R_X86_64_PC32 .text
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>重定位表是一个&lt;code>Elf_Rel&lt;/code>类型的数组结构，每一项对应一个需要进行重定位的项。 其成员含义如下表所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>成员&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r_offset&lt;/td>
&lt;td>重定位入口的偏移。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>对于&lt;strong>可重定位文件&lt;/strong>来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>对于&lt;strong>可执行文件或共享对象文件&lt;/strong>来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>r_info&lt;/td>
&lt;td>重定位入口的类型和符号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>对于&lt;strong>可执行文件和共享目标文件&lt;/strong>来说，它们的重定位入口是动态链接类型的。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>重定位是目标文件链接成为可执行文件的关键。我们将在后面的进行介绍。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="http://chuquan.me/2018/05/21/elf-introduce/">计算机那些事(4)——ELF文件结构 | 楚权的世界&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://xinqiu.gitbooks.io/linux-inside-zh/content/Theory/linux-theory-2.html">ELF文件格式&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>01.最开始的两行代码</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/01.%E6%9C%80%E5%BC%80%E5%A7%8B%E7%9A%84%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/01.%E6%9C%80%E5%BC%80%E5%A7%8B%E7%9A%84%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81/</guid><description>&lt;h1 id="01最开始的两行代码">01.最开始的两行代码&lt;/h1>
&lt;p>当你按下开机键的那一刻，在主板上提前写死的固件程序 &lt;strong>BIOS&lt;/strong> 会将硬盘中&lt;strong>启动区的 512 字节&lt;/strong>的数据，原封不动复制到&lt;strong>内存中的 0x7c00&lt;/strong> 这个位置，并跳转到那个位置进行执行。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-31-29-f43655cb64b0bf1fb69c39e4cb1756b3.png" alt="图片">&lt;/p>
&lt;p>启动区的定义非常简单，只要硬盘中的 0 盘 0 道 1 扇区的 512 个字节的最后两个字节分别是 &lt;strong>0x55&lt;/strong> 和 &lt;strong>0xaa&lt;/strong>，那么 BIOS 就会认为它是个启动区。&lt;/p>
&lt;p>所以对于我们理解操作系统而言，此时的 BIOS 仅仅就是个代码搬运工，把 512 字节的二进制数据从硬盘搬运到了内存中而已。&lt;strong>所以作为操作系统的开发人员，仅仅需要把操作系统最开始的那段代码，编译并存储在硬盘的 0 盘 0 道 1 扇区即可&lt;/strong>。之后 BIOS 会帮我们把它放到内存里，并且跳过去执行。&lt;/p>
&lt;p>而 Linux-0.11 的最开始的代码，就是这个用汇编语言写的 &lt;strong>bootsect.s&lt;/strong>，位于 &lt;strong>boot&lt;/strong> 文件夹下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-31-43-3e6ebe90a46a8c82cc76c0d030463d1d.png" alt="图片">&lt;/p>
&lt;p>通过编译，这个 bootsect.s 会被编译成二进制文件，存放在启动区的第一扇区。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-31-50-46209abdfcc176f5aa379101fe570466.png" alt="图片">&lt;/p>
&lt;p>随后就会如刚刚所说，由 BIOS 搬运到内存的 0x7c00 这个位置，而 CPU 也会从这个位置开始，不断往后一条一条语句无脑地执行下去。&lt;/p>
&lt;p>那我们的梦幻之旅，就从这个文件的第一行代码开始啦！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x07c0&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好吧，先连续看两行。&lt;/p>
&lt;p>这段代码是用汇编语言写的，含义是把 0x07c0 这个值复制到 &lt;strong>ax 寄存器&lt;/strong>里，再将 ax 寄存器里的值复制到 &lt;strong>ds 寄存器&lt;/strong>里。那其实这一番折腾的结果就是，让 ds 这个寄存器里的值变成了 0x07c0。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-31-57-088a5c0d86a663c7a22adf82ce615c9f.png" alt="图片">&lt;/p>
&lt;p>ds 是一个 16 位的段寄存器，具体表示数据段寄存器，在内存寻址时充当段基址的作用。啥意思呢？就是当我们之后用汇编语言写一个内存地址时，实际上仅仅是写了偏移地址，比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0x0001&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实际上相当于&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mh">0x0001&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>ds 是默认加上的，表示在 ds 这个段基址处，往后再偏移 0x0001 单位，将这个位置的内存数据，复制到 ax 寄存器中。&lt;/p>
&lt;p>形象地比喻一下就是，你和朋友商量去哪玩比较好，你说天安门、南锣鼓巷、颐和园等等，实际上都是&lt;strong>偏移地址&lt;/strong>，省略了北京市这个&lt;strong>基址&lt;/strong>。&lt;/p>
&lt;p>当然你完全可以说北京天安门、北京南锣鼓巷这样，每次都加上北京这个前缀。不过如果你事先和朋友说好，以下我说的地方都是北京市里的哈，之后你就不用每次都带着北京市这个词了，是不是很方便？&lt;/p>
&lt;p>那 ds 这个数据段寄存器的作用就是如此，方便了描述一个内存地址时，可以省略一个基址，没什么神奇之处。&lt;/p>
&lt;p>ds : 0x0001&lt;/p>
&lt;p>北京市 : 南锣鼓巷&lt;/p>
&lt;p>再看，这个 ds 被赋值为了 0x07c0，由于 x86 为了让自己在 16 位这个实模式下能访问到 20 位的地址线这个历史因素（不了解这个的就先别纠结为啥了），所以段基址要先左移四位。&lt;strong>那 0x07c0 左移四位就是 0x7c00&lt;/strong>，那这就刚好和这段代码被 BIOS 加载到的内存地址 0x7c00 一样了。&lt;/p>
&lt;p>也就是说，之后再写的代码，里面访问的数据的内存地址，都先默认加上 0x7c00，再去内存中寻址。&lt;/p>
&lt;p>为啥统一加上 0x7c00 这个数呢？这很好解释，BIOS 规定死了把操作系统代码加载到内存 0x7c00，那么里面的各种数据自然就全都被偏移了这么多，所以把数据段寄存器 ds 设置为这个值，方便了以后通过这种基址的方式访问内存里的数据。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-32-06-6766eabd20fbbae85e6bae09813ff7e0.png" alt="图片">&lt;/p>
&lt;p>OK，赶紧消化掉前面的知识，那本篇就到此为止，只讲了两行代码，知识量很少，我没骗你吧。&lt;/p>
&lt;p>希望你能做到，对 BIOS 将操作系统代码加载到内存 0x7c00，以及我们通过 mov 指令将默认的数据段寄存器 ds 寄存器的值改为 0x07c0 方便以后的基址寻址方式，这两件事在心里认可，并且没有疑惑，这才方便后面继续进行。&lt;/p></description></item><item><title>02.自己给自己挪个地儿</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/02.%E8%87%AA%E5%B7%B1%E7%BB%99%E8%87%AA%E5%B7%B1%E6%8C%AA%E4%B8%AA%E5%9C%B0%E5%84%BF/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/02.%E8%87%AA%E5%B7%B1%E7%BB%99%E8%87%AA%E5%B7%B1%E6%8C%AA%E4%B8%AA%E5%9C%B0%E5%84%BF/</guid><description>&lt;h1 id="02自己给自己挪个地儿">02.自己给自己挪个地儿&lt;/h1>
&lt;p>书接上回，上回书咱们说到，CPU 执行操作系统的最开始的两行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x07c0&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将数据段寄存器 ds 的值变成了 &lt;strong>0x07c0&lt;/strong>，方便了之后访问内存时利用这个&lt;strong>段基址&lt;/strong>进行寻址。&lt;/p>
&lt;p>接下来我们带着这两行代码，继续往下看几行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x07c0&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x9000&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">es&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">cx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mi">256&lt;/span>
&lt;span class="nf">sub&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">si&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">si&lt;/span>
&lt;span class="nf">sub&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">di&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">di&lt;/span>
&lt;span class="nf">rep&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">movw&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时 ds 寄存器的值已经是 0x07c0 了，然后又通过同样的方式将 &lt;strong>es&lt;/strong> 寄存器的值变成 &lt;strong>0x9000&lt;/strong>，接着又把 &lt;strong>cx&lt;/strong> 寄存器的值变成 &lt;strong>256&lt;/strong>（代码里确实是用十进制表示的，与其他地方有些不一致，不过无所谓）。&lt;/p>
&lt;p>再往下看有两个 &lt;strong>sub&lt;/strong> 指令，这个 sub 指令很简单，比如&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sub a,b
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就表示&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">a = a - b
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么代码中的&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sub si,si
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就表示&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">si = si - si
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所以如果 sub 后面的两个寄存器一模一样，就相当于把这个寄存器里的值&lt;strong>清零&lt;/strong>，这是一个基本玩法。&lt;/p>
&lt;p>那就非常简单了，经过这些指令后，以下几个寄存器分别被附上了指定的值，我们梳理一下。&lt;/p>
&lt;p>&lt;strong>ds = 0x07c0&lt;/strong>&lt;/p>
&lt;p>&lt;strong>es = 0x9000&lt;/strong>&lt;/p>
&lt;p>&lt;strong>cx = 256&lt;/strong>&lt;/p>
&lt;p>&lt;strong>si = 0&lt;/strong>&lt;/p>
&lt;p>&lt;strong>di = 0&lt;/strong>&lt;/p>
&lt;p>还记得上一讲画的 CPU 寄存器的总图么？此时就是这样了&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-33-19-2aa5f289431f24f5538fd0df64fc31cb.png" alt="图片">&lt;/p>
&lt;p>干嘛要给这些毫不相干的寄存器附上值呢？其实就是为下一条指令服务的，就是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">rep movw
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中 &lt;strong>rep&lt;/strong> 表示重复执行后面的指令。&lt;/p>
&lt;p>而后面的指令 &lt;strong>movw&lt;/strong> 表示复制一个&lt;strong>字&lt;/strong>（word 16位），那其实就是&lt;strong>不断重复地复制一个字&lt;/strong>。&lt;/p>
&lt;p>那下面自然就有三连问：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>重复执行多少次呢？ cx 寄存器中的值，也就是 256 次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从哪复制到哪呢？从 ds:si 处复制到 es:di 处。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一次复制多少呢？一个字，16 位，也就是两个字节。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>上面是直译，那把这段话翻译成更人话的方式讲出来就是:&lt;/p>
&lt;p>    &lt;strong>将内存地址 0x7c00 处开始往后的 512 字节的数据，原封不动复制到 0x90000 处&lt;/strong>。&lt;/p>
&lt;p>就是下图的第二步。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-33-28-473d798e39c782462529871a24333534.png" alt="图片">&lt;/p>
&lt;p>没错，就是这么折腾了一下。现在，操作系统最开头的代码，已经被挪到了 &lt;strong>0x90000&lt;/strong> 这个位置了。&lt;/p>
&lt;p>再往后是一个&lt;strong>跳转&lt;/strong>指令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">    jmpi go,0x9000
go: 
    mov ax,cs
    mov ds,ax
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>仔细想想或许你能猜到它想干嘛。&lt;/p>
&lt;p>&lt;strong>jmpi&lt;/strong> 是一个&lt;strong>段间跳转指令&lt;/strong>，表示跳转到 &lt;strong>0x9000:go&lt;/strong> 处执行。&lt;/p>
&lt;p>还记得上一讲说的 &lt;strong>段基址 : 偏移地址&lt;/strong> 这种格式的内存地址要如何计算吧？段基址仍然要先左移四位，因此结论就是跳转到 &lt;strong>0x90000 + go&lt;/strong> 这个内存地址处执行。忘记的赶紧回去看看，这才过了一回哦，要稳扎稳打。&lt;/p>
&lt;p>再说 go，go 就是一个&lt;strong>标签&lt;/strong>，最终编译成机器码的时候会被翻译成一个值，这个值就是 go 这个标签在文件内的偏移地址。&lt;/p>
&lt;p>这个偏移地址再加上 0x90000，就刚好是 go 标签后面那段代码 &lt;strong>mov ax,cs&lt;/strong> 此时所在的内存地址了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-33-33-15ef0cbb2b1faa8b2a5531afa7e5863f.png" alt="图片">&lt;/p>
&lt;p>那假如 &lt;strong>mov ax,cx&lt;/strong> 这行代码位于最终编译好后的二进制文件的 &lt;strong>0x08&lt;/strong> 处，那 go 就等于 0x08，而最终 CPU 跳转到的地址就是 &lt;strong>0x90008&lt;/strong> 处。&lt;/p>
&lt;p>所以到此为止，前两回的内容，其实就是一段 &lt;strong>512&lt;/strong> 字节的代码和数据，从硬盘的启动区先是被移动到了内存 &lt;strong>0x7c00&lt;/strong> 处，然后又立刻被移动到 &lt;strong>0x90000&lt;/strong> 处，并且跳转到此处往后再稍稍偏移 &lt;strong>go&lt;/strong> 这个标签所代表的偏移地址处，也就是 &lt;strong>mov ax,cs&lt;/strong> 这行指令的位置。&lt;/p>
&lt;p>仍然是保持每回的简洁，本文就讲到这里，希望大家还跟得上，接下来的下一回，我们就把目光定位到 go 标签处往后的代码，看看他又要折腾些什么吧。&lt;/p>
&lt;p>后面的世界越来越精彩，欲知后事如何，且听下回分解。&lt;/p></description></item><item><title>03.做好最最基础的准备工作</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/03.%E5%81%9A%E5%A5%BD%E6%9C%80%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/03.%E5%81%9A%E5%A5%BD%E6%9C%80%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</guid><description>&lt;h1 id="03做好最最基础的准备工作">03.做好最最基础的准备工作&lt;/h1>
&lt;p>上回说到，操作系统的代码最开头的 512 字节的数据，从硬盘的启动区先是被移动到了内存 &lt;strong>0x7c00&lt;/strong> 处，然后又立刻被移动到 &lt;strong>0x90000&lt;/strong> 处，并且跳转到此处往后再稍稍偏移 &lt;strong>go&lt;/strong> 这个标签所代表的偏移地址处。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-33-45-b48a60587353a5da64eb7951d74d4c29.png" alt="图片">&lt;/p>
&lt;p> &lt;/p>
&lt;p>那我们接下来，就继续把我们的目光放在 go 这个标签的位置，跟着 CPU 的步伐往后看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">go:&lt;/span>&lt;span class="err"> &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">cs&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">es&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ss&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">sp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0xFF00&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>全都是 mov 操作，那好办了。&lt;/p>
&lt;p>这段代码的直接意思很容易理解，就是把 &lt;strong>cs&lt;/strong> 寄存器的值分别复制给 &lt;strong>ds&lt;/strong>、&lt;strong>es&lt;/strong> 和 &lt;strong>ss&lt;/strong> 寄存器，然后又把 0xFF00 给了 &lt;strong>sp&lt;/strong> 寄存器。&lt;/p>
&lt;p>回顾下 CPU 寄存器图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-33-57-840b9de63b749b39af20f50f822d0cae.png" alt="图片">&lt;/p>
&lt;p>cs 寄存器表示&lt;strong>代码段寄存器&lt;/strong>，CPU 当前正在执行的代码在内存中的位置，就是由 cs:ip 这组寄存器配合指向的，其中 cs 是基址，ip 是偏移地址。&lt;/p>
&lt;p>由于之前执行过一个段间跳转指令，还记得不？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">jmpi go,0x9000
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所以现在 cs 寄存器里的值就是 &lt;strong>0x9000&lt;/strong>，ip 寄存器里的值是 &lt;strong>go&lt;/strong> 这个标签的偏移地址。那这三个 mov 指令就分别给 ds、es 和 ss 寄存器赋值为了 0x9000。&lt;/p>
&lt;p>ds 为数据段寄存器，之前我们说过了，当时它被复制为 &lt;strong>0x07c0&lt;/strong>，是因为之前的代码在 0x7c00 处，现在代码已经被挪到了 0x90000 处，所以现在自然又改赋值为 &lt;strong>0x9000&lt;/strong> 了。&lt;/p>
&lt;p>es 是扩展段寄存器，仅仅是个扩展，不是主角，先不用理它。&lt;/p>
&lt;p>ss 为&lt;strong>栈段寄存器&lt;/strong>，后面要配合栈基址寄存器 sp 来表示此时的栈顶地址。而此时 sp 寄存器被赋值为了 &lt;strong>0xFF00&lt;/strong> 了，所以目前的栈顶地址就是 &lt;strong>ss:sp&lt;/strong> 所指向的地址 &lt;strong>0x9FF00&lt;/strong> 处。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-34-06-82a8347250d22ab48d7f7f92fff2b0c8.png" alt="图片">&lt;/p>
&lt;p>其实到这里，操作系统的一些最最最最基础的准备工作，就做好了。都做了些啥事呢？&lt;/p>
&lt;p>&lt;strong>第一&lt;/strong>，代码从硬盘移到内存，又从内存挪了个地方，放在了 &lt;strong>0x90000&lt;/strong> 处。&lt;/p>
&lt;p>&lt;strong>第二&lt;/strong>，&lt;strong>数据段寄存器 ds&lt;/strong> 和&lt;strong>代码段寄存器 cs&lt;/strong> 此时都被设置为了 0x9000，也就为跳转代码和访问内存数据，奠定了同一个内存的基址地址，方便了跳转和内存访问，因为仅仅需要指定偏移地址即可了。&lt;/p>
&lt;p>&lt;strong>第三&lt;/strong>，栈顶地址被设置为了 0x9FF00，具体表现为&lt;strong>栈段寄存器 ss&lt;/strong> 为 0x9000，&lt;strong>栈基址寄存器 sp&lt;/strong> 为 0xFF00。栈是向下发展的，这个栈顶地址 0x9FF00 要远远大于此时代码所在的位置 0x90000，所以栈向下发展就很难撞见代码所在的位置，也就比较安全。这也是为什么给栈顶地址设置为这个值的原因，其实只需要离代码的位置远远的即可。&lt;/p>
&lt;p>做好这些基础工作后，接下来就又该折腾了其他事了。&lt;/p>
&lt;p>总结拔高一下，这一部分其实就是把&lt;strong>代码段寄存器 cs&lt;/strong>，&lt;strong>数据段寄存器 ds&lt;/strong>，&lt;strong>栈段寄存器 ss&lt;/strong> 和&lt;strong>栈基址寄存器 sp&lt;/strong> 分别设置好了值，方便后续使用。&lt;/p>
&lt;p>再拔高一下，其实操作系统在做的事情，就是给如何访问代码，如何访问数据，如何访问栈进行了一下&lt;strong>内存的初步规划&lt;/strong>。其中访问代码和访问数据的规划方式就是设置了一个&lt;strong>基址&lt;/strong>而已，访问栈就是把&lt;strong>栈顶指针&lt;/strong>指向了一个远离代码位置的地方而已。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-34-16-8f34892f8b27a5ecbd2ad1b83dc6b307.png" alt="图片">&lt;/p>
&lt;p>所以，千万别多想，就这么点事儿。那再给大家留个作业，把当前的内存布局画出来，告诉我现在 &lt;strong>cs、ip、ds、ss、sp&lt;/strong> 这些寄存器的值，在内存布局中的位置。&lt;/p>
&lt;p>好了，接下来我们应该干什么呢？我们回忆下，我们目前仅仅把硬盘中 512 字节加载到内存中了，但操作系统还有很多代码仍然在硬盘里，不能抛下他们不管呀。&lt;/p>
&lt;p>所以你猜下一步要干嘛了？&lt;/p>
&lt;p>后面的世界越来越精彩，欲知后事如何，且听下回分解。&lt;/p></description></item><item><title>04.把自己在硬盘里的其他部分也放到内存来</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/04.%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%9C%A8%E7%A1%AC%E7%9B%98%E9%87%8C%E7%9A%84%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E4%B9%9F%E6%94%BE%E5%88%B0%E5%86%85%E5%AD%98%E6%9D%A5/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/04.%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%9C%A8%E7%A1%AC%E7%9B%98%E9%87%8C%E7%9A%84%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E4%B9%9F%E6%94%BE%E5%88%B0%E5%86%85%E5%AD%98%E6%9D%A5/</guid><description>&lt;h1 id="04把自己在硬盘里的其他部分也放到内存来">04.把自己在硬盘里的其他部分也放到内存来&lt;/h1>
&lt;p>书接上回，上回书咱们说到，操作系统的一些最最最最基础的准备工作，已经准备好了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-35-09-b48a60587353a5da64eb7951d74d4c29.png" alt="图片">&lt;/p>
&lt;p> &lt;/p>
&lt;p>如这张图所示，此时操作系统短短几行代码，将&lt;strong>数据段寄存器 ds&lt;/strong> 和&lt;strong>代码段寄存器 cs&lt;/strong> 设置为了 &lt;strong>0x9000&lt;/strong>，方便代码的跳转与数据的访问。并且，将&lt;strong>栈顶地址 ss:sp&lt;/strong> 设置在了离代码的位置 0x90000 足够遥远的 &lt;strong>0x9FF00&lt;/strong>，保证栈向下发展不会轻易撞见代码的位置。&lt;/p>
&lt;p>简单说，就是设置了如何访问数据的&lt;strong>数据&lt;/strong>段，如何访问代码的&lt;strong>代码&lt;/strong>段，以及如何访问栈的&lt;strong>栈顶&lt;/strong>指针，也即初步做了一次&lt;strong>内存规划&lt;/strong>，从 CPU 的角度看，访问内存，就这么三块地方而已。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-35-16-8f34892f8b27a5ecbd2ad1b83dc6b307.png" alt="图片">&lt;/p>
&lt;p>做好这些基础工作后，接下来就又该新的一翻折腾了，我们接着往下看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">load_setup:&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">dx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0000&lt;/span> &lt;span class="c1">; drive 0, head 0 &lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">cx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0002&lt;/span> &lt;span class="c1">; sector 2, track 0 &lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">bx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0200&lt;/span> &lt;span class="c1">; address = 512, in 0x9000 &lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0200&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="c1">; service 2, nr of sectors &lt;/span>
&lt;span class="nf">int&lt;/span> &lt;span class="mh">0x13&lt;/span> &lt;span class="c1">; read it &lt;/span>
&lt;span class="nf">jnc&lt;/span> &lt;span class="nv">ok_load_setup&lt;/span> &lt;span class="c1">; ok - continue &lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">dx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0000&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0000&lt;/span> &lt;span class="c1">; reset the diskette &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">int&lt;/span> &lt;span class="mh">0x13&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">load_setup&lt;/span>
&lt;span class="nl">ok_load_setup:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有两个 &lt;strong>int 指令&lt;/strong>我们还没见过。&lt;/p>
&lt;p>注意这个 int 是汇编指令，可不是高级语言的整型变量哟。int 0x13 表示&lt;strong>发起 0x13 号中断&lt;/strong>，这条指令上面给 dx、cx、bx、ax 赋值都是作为这个中断程序的参数。&lt;/p>
&lt;p>中断是啥如果你不理解，先不要管，如果你就是放不下，那可以看一眼我之前的文章：&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247498208&amp;amp;idx=1&amp;amp;sn=b784f8b4e627ebd1bfb9810d194fdb80&amp;amp;chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&amp;amp;scene=21#wechat_redirect">认认真真的聊聊中断&lt;/a>，里面讲得非常细致。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-46-27-0cf2886a19323e5249f1d586d8e95b2b.jpg" alt="图片">&lt;/p>
&lt;p>总之这个中断发起后，CPU 会通过这个&lt;strong>中断号&lt;/strong>，去寻找对应的&lt;strong>中断处理程序的入口地址&lt;/strong>，并&lt;strong>跳转&lt;/strong>过去执行，逻辑上就相当于&lt;strong>执行了一个函数&lt;/strong>。而 0x13 号中断的处理程序是 BIOS 提前给我们写好的，是&lt;strong>读取磁盘&lt;/strong>的相关功能的函数。&lt;/p>
&lt;p>之后真正进入操作系统内核后，中断处理程序是需要我们自己去重新写的，这个在后面的章节中，你会不断看到各个模块注册自己相关的中断处理程序，所以不要急。此时为了方便就先用 BIOS 提前给我们写好的程序了。&lt;/p>
&lt;p>可见即便是操作系统的源码，有时也需要去调用现成的函数方便自己，并不是造轮子的人就非得完全从头造。&lt;/p>
&lt;p>本段代码的注释已经写的很明确了，直接说最终的作用吧，&lt;strong>就是将硬盘的第 2 个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区&lt;/strong>，图示其实就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-35-37-ec37ac181e7f368d102ff5e22bf11956.png" alt="图片">&lt;/p>
&lt;p>为了图片清晰表达意思，可能比例就不那么严谨了，大家不必纠结。&lt;/p>
&lt;p>可以看到，如果复制成功，就跳转到 &lt;strong>ok_load_setup&lt;/strong> 这个标签，如果失败，则会不断重复执行这段代码，也就是重试。那我们就别管重试逻辑了，直接看成功后跳转的 ok_load_setup 这个标签后的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">ok_load_setup:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x1000&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">es&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">       &lt;/span>&lt;span class="c1">; segment of 0x10000    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">read_it&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmpi&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x9020&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码省略了很多非主逻辑的代码，比如在屏幕上输出 Loading system &amp;hellip; 这个字符串以防止用户等烦了。&lt;/p>
&lt;p>剩下的主要代码就都写在这里了，就这么几行，其作用是&lt;strong>把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处&lt;/strong>，和之前的从硬盘捣腾到内存是一个道理。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-35-48-c0f106e30e5f27c0c8054461ef014a55.png" alt="图片">&lt;/p>
&lt;p>至此，整个操作系统的&lt;strong>全部代码&lt;/strong>，就已经全部从硬盘中，被搬迁到内存来了。&lt;/p>
&lt;p>然后又通过一个熟悉的段间跳转指令 jmpi 0,0x9020，跳转到 &lt;strong>0x90200&lt;/strong> 处，就是硬盘第二个扇区开始处的内容。&lt;/p>
&lt;p>那这里的内容是什么呢？先不急，我们借这个机会把整个操作系统的编译过程说下。整个编译过程，就是通过 &lt;strong>Makefile&lt;/strong> 和 &lt;strong>build.c&lt;/strong> 配合完成的，最终会：&lt;/p>
&lt;p>&lt;em>&lt;strong>1.&lt;/strong>&lt;/em> 把 bootsect.s 编译成 bootsect 放在硬盘的 1 扇区。&lt;/p>
&lt;p>&lt;em>&lt;strong>2.&lt;/strong>&lt;/em> 把 setup.s 编译成 setup 放在硬盘的 2~5 扇区。&lt;/p>
&lt;p>&lt;em>&lt;strong>3.&lt;/strong>&lt;/em> 把剩下的全部代码（head.s 作为开头）编译成 system 放在硬盘的随后 240 个扇区。&lt;/p>
&lt;p>所以整个路径就是这样的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-36-02-4e9f1304adc40a4ce0c7076e72c0cb8a.png" alt="图片">&lt;/p>
&lt;p>所以，我们即将跳转到的内存中的 &lt;strong>0x90200&lt;/strong> 处的代码，就是从硬盘第二个扇区开始处加载到内存的。第二个扇区的最开始处，那也就是 setup.s 文件的第一行代码咯。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-36-11-07c50a97fc365f9cd6cd562d76d934af.png" alt="图片">&lt;/p>
&lt;p>那这个代码是什么呢？我们后面再说，不过先打开 setup.s 这个文件看看吧。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">start:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x9000&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="c1">; this is done in bootsect already, but...    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ah&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x03&lt;/span>&lt;span class="err">    &lt;/span>&lt;span class="c1">; read cursor pos    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">xor&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">bh&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">bh&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">int&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mh">0x10&lt;/span>&lt;span class="err">        &lt;/span>&lt;span class="c1">; save it in known place, con_init fetches    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nb">dx&lt;/span>&lt;span class="err">      &lt;/span>&lt;span class="c1">; it from 0x90000.    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好了，到目前为止，你是不是觉得，我去，这前面编译放在硬盘的位置，和后面代码写死的跳转地址，竟然如此地强耦合？那万一整错了咋办。&lt;/p>
&lt;p>是啊，就是这样，你以为呢？&lt;strong>在操作系统刚刚开始建立的时候，那是完全自己安排前前后后的关系&lt;/strong>，一个字节都不能偏，就是这么强耦合，需要小心翼翼，需要大脑时刻保持清醒，规划好自己写的代码被编译并存储在硬盘的哪个位置，而随后又会被加载到内存的哪个位置，不能错乱。&lt;/p>
&lt;p>但这也是很有好处的，那就是在这个阶段，你完完全全知道每一步跳转，每一步数据访问都是怎么设计和规划的，不存在黑盒。&lt;/p>
&lt;p>不像我们在写高级语言的时候，完全不知道是怎么底层帮我们做了多少工作。虽然这解脱了程序员关心底层细节的烦恼，但在遇到问题或者想知道原理的时候，就显得很讨厌了。所以珍惜这个阶段吧！&lt;/p>
&lt;p>而且，你在上层之所以能那么随心所欲，很多底层细节完全不用考虑，很省心，正是因为像今天这样以及之后每一章的各种底层代码小心翼翼的做了很多铺垫。&lt;/p>
&lt;p>好了，本文的内容就结束了。这也标志着我们走完了&lt;strong>第一个操作系统源码&lt;/strong>文件 &lt;strong>bootsect.s&lt;/strong>，开始向下一个文件 &lt;strong>setup.s&lt;/strong> 进发了！&lt;/p>
&lt;p>后面的世界越来越精彩，欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 多说两句 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>先给大家留个课后作业，文中不是提到了 BIOS 提供了很多中断函数方便操作系统刚启动的时候调用么？这些中断都是什么？大家负责去找一份&lt;strong>一手资料&lt;/strong>（注意是一手资料，不要网上整理的二手博客），并上传到我的 &lt;strong>GitHub&lt;/strong> 上（文末阅读原文就是）。&lt;/p>
&lt;p>不知不觉已经第四回了，刚刚才把 bootsect.s 这个汇编文件讲完，它所做的事情无非就是把硬盘中的数据复制到内存，然后挪来挪去的，并且根据放置在内存中的位置，设置了各种段基址寄存器的值。&lt;/p>
&lt;p>在解答读者疑问时，我发现有&lt;strong>两种特别极端的人&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>一种是把这几讲的内容想得极其复杂&lt;/strong>，什么代码段和数据段一样会不会相互影响，这些地址是虚拟地址还是物理地址，为什么要不断从内存一个地方挪动到另一个地方，BIOS 是怎么映射到内存的，硬盘中 512 字节是数据还是代码，等等。&lt;/p>
&lt;p>这样的人，我建议把你所知道的一切先忘掉，就把这几讲所说的东西理解清楚，因为它就是很简单，不涉及那么多乱七八糟的知识。你所产生的那些疑问，在这个阶段根本就不存在这些问题，现在内存就在这，你想怎么玩就怎么玩，无非就是访问数据，执行代码，自己能安排明白即可。&lt;/p>
&lt;p>&lt;strong>还有一种人，就是把这几讲的内容想得特别简单&lt;/strong>，这几讲确实就是复制硬盘数据和内存数据为主，但这就是操作系统呀！它就是不断通过这样简简单单的动作，把自己一点一点搞复杂的呢。&lt;/p>
&lt;p>首先它靠 BIOS 做了第一步加载动作，然后就可以用加载的这 512 字节，去加载更多在硬盘中的代码和数据，那整个过程就自己把自己加载完整了，你不觉得这个过程也很伟大和奇妙么？会不会有解答了你之前一直困惑的什么东西呢？&lt;/p>
&lt;p>多想想，多看看每回的扩展部分和延伸部分。&lt;/p></description></item><item><title>05.进入保护模式前的最后一次折腾内存</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/05.%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E5%86%85%E5%AD%98/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/05.%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E5%86%85%E5%AD%98/</guid><description>&lt;h1 id="05进入保护模式前的最后一次折腾内存">05.进入保护模式前的最后一次折腾内存&lt;/h1>
&lt;p>上回书咱们说到，操作系统已经完成了各种从硬盘到内存的加载，以及内存到内存的复制。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-36-25-4e9f1304adc40a4ce0c7076e72c0cb8a.png" alt="图片">&lt;/p>
&lt;p>至此，整个 &lt;strong>bootsect.s&lt;/strong> 的使命就完成了，也是我们品读完的第一个操作系统源码文件。之后便跳转到了 &lt;strong>0x90200&lt;/strong> 这个位置开始执行，这个位置处的代码就是位于 &lt;strong>setup.s&lt;/strong> 的开头，我们接着来看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">start:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x9000&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="c1">; this is done in bootsect already, but...    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ah&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x03&lt;/span>&lt;span class="err">    &lt;/span>&lt;span class="c1">; read cursor pos    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">xor&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">bh&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">bh&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">int&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mh">0x10&lt;/span>&lt;span class="err">        &lt;/span>&lt;span class="c1">; save it in known place, con_init fetches    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nb">dx&lt;/span>&lt;span class="err">      &lt;/span>&lt;span class="c1">; it from 0x90000.&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>又有个 &lt;strong>int&lt;/strong> 指令。&lt;/p>
&lt;p>前面的文章好好看过的话，一下就能猜出它要干嘛。还记不记得之前有个 &lt;strong>int 0x13&lt;/strong> 表示触发 BIOS 提供的&lt;strong>读磁盘&lt;/strong>中断程序？这个 &lt;strong>int 0x10&lt;/strong> 也是一样的，它也是触发 BIOS 提供的&lt;strong>显示服务&lt;/strong>中断处理程序，而 &lt;strong>ah&lt;/strong> 寄存器被赋值为 &lt;strong>0x03&lt;/strong> 表示显示服务里具体的&lt;strong>读取光标位置功能&lt;/strong>。&lt;/p>
&lt;p>具体 BIOS 提供了哪些中断服务，如何去调用和获取返回值，请大家自行寻找资料，这里只说结果。&lt;/p>
&lt;p>这个 int 0x10 中断程序执行完毕并返回时，&lt;strong>dx&lt;/strong> 寄存器里的值表示&lt;strong>光标的位置&lt;/strong>，具体说来其高八位 dh 存储了&lt;strong>行号&lt;/strong>，低八位 dl 存储了列号。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-36-35-76d116c9ac2b413cbfe012c608da053c.png" alt="图片">&lt;/p>
&lt;p>这里说明一下：计算机在加电自检后会自动初始化到文字模式，在这种模式下，一屏幕可以显示 25 行，每行 80 个字符，也就是 80 列。&lt;/p>
&lt;p>那下一步 &lt;strong>mov [0],dx&lt;/strong> 就是把这个光标位置存储在 [0] 这个内存地址处。注意，前面我们说过，这个内存地址仅仅是偏移地址，还需要加上 ds 这个寄存器里存储的段基址，最终的内存地址是在 &lt;strong>0x90000&lt;/strong> 处，这里存放着光标的位置，以便之后在初始化控制台的时候用到。&lt;/p>
&lt;p>所以从这里也可以看出，这和我们平时调用一个方法没什么区别，只不过这里的&lt;strong>寄存器&lt;/strong>的用法相当于&lt;strong>入参和返回值&lt;/strong>，这里的 &lt;strong>0x10 中断号&lt;/strong>相当于&lt;strong>方法名&lt;/strong>。&lt;/p>
&lt;p>这里又应了之前说的一句话，操作系统内核的最开始也处处都是 BIOS 的调包侠，有现成的就用呗。&lt;/p>
&lt;p>再接下来的几行代码，都是和刚刚一样的逻辑，调用一个 BIOS 中断获取点什么信息，然后存储在内存中某个位置，我们迅速浏览一下就好咯。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">; 比如获取内存信息。
; Get memory size (extended mem, kB)
mov ah,#0x88
int 0x15
mov [2],ax
; 获取显卡显示模式。
; Get video-card data:
mov ah,#0x0f
int 0x10
mov [4],bx ; bh = display page
mov [6],ax ; al = video mode, ah = window width
; 检查显示方式并取参数
; check for EGA/VGA and some config parameters
mov ah,#0x12
mov bl,#0x10
int 0x10
mov [8],ax
mov [10],bx
mov [12],cx
; 获取第一块硬盘的信息。
; Get hd0 data
mov ax,#0x0000
mov ds,ax
lds si,[4*0x41]
mov ax,#INITSEG
mov es,ax
mov di,#0x0080
mov cx,#0x10
rep movsb
; 获取第二块硬盘的信息。
; Get hd1 data
mov ax,#0x0000
mov ds,ax
lds si,[4*0x46]
mov ax,#INITSEG
mov es,ax
mov di,#0x0090
mov cx,#0x10
rep movsb
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上原理都是一样的。&lt;/p>
&lt;p>我们就没必要细琢磨了，对操作系统的理解作用不大，只需要知道最终存储在内存中的信息是什么，在什么位置，就好了，之后会用到他们的。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>内存地址&lt;/th>
&lt;th>长度(字节)&lt;/th>
&lt;th>名称&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x90000&lt;/td>
&lt;td>2&lt;/td>
&lt;td>光标位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90002&lt;/td>
&lt;td>2&lt;/td>
&lt;td>扩展内存数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90004&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显示页面&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90006&lt;/td>
&lt;td>1&lt;/td>
&lt;td>显示模式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90007&lt;/td>
&lt;td>1&lt;/td>
&lt;td>字符列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90008&lt;/td>
&lt;td>2&lt;/td>
&lt;td>未知&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000A&lt;/td>
&lt;td>1&lt;/td>
&lt;td>显示内存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000B&lt;/td>
&lt;td>1&lt;/td>
&lt;td>显示状态&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000C&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显卡特性参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000E&lt;/td>
&lt;td>1&lt;/td>
&lt;td>屏幕行数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000F&lt;/td>
&lt;td>1&lt;/td>
&lt;td>屏幕列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90080&lt;/td>
&lt;td>16&lt;/td>
&lt;td>硬盘1参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90090&lt;/td>
&lt;td>16&lt;/td>
&lt;td>硬盘2参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x901FC&lt;/td>
&lt;td>2&lt;/td>
&lt;td>根设备号&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>由于之后很快就会用 c 语言进行编程，虽然汇编和 c 语言也可以用变量的形式进行传递数据，但这需要编译器在链接时做一些额外的工作，所以这么多数据更方便的还是&lt;strong>双方共同约定一个内存地址&lt;/strong>，我往这里存，你从这里取，就完事了。这恐怕是最最原始和直观的变量传递的方式了。&lt;/p>
&lt;p>把这些信息存储好之后，操作系统又要做什么呢？我们继续往下看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">cli         ; no interrupts allowed ;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就一行 cli，表示&lt;strong>关闭中断&lt;/strong>的意思。&lt;/p>
&lt;p>因为后面我们要把原本是 BIOS 写好的中断向量表给覆盖掉，也就是给破坏掉了，写上我们自己的中断向量表，所以这个时候是不允许中断进来的。&lt;/p>
&lt;p>继续看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="c1">; first we move the system to it&amp;#39;s rightful place    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0000&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">cld&lt;/span>&lt;span class="err">         &lt;/span>&lt;span class="c1">; &amp;#39;direction&amp;#39;=0, movs moves forward&lt;/span>
&lt;span class="nl">do_move:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">es&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">       &lt;/span>&lt;span class="c1">; destination segment    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">add&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x1000&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">cmp&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x9000&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jz&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="nv">end_move&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>&lt;span class="err">       &lt;/span>&lt;span class="c1">; source segment    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">sub&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">di&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">di&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">sub&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">si&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">si&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">cx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x8000&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">rep&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">movsw&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_move&lt;/span>
&lt;span class="c1">; then we load the segment descriptors&lt;/span>
&lt;span class="nl">end_move:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到后面那个 &lt;strong>rep movsw&lt;/strong> 熟不熟悉，一开始我们把操作系统代码从 &lt;strong>0x7c00&lt;/strong> 移动到 &lt;strong>0x90000&lt;/strong> 的时候就是用的这个指令，来图回忆一下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-36-48-0ca44d29e1add2c568ed4ca0562ade31.png" alt="图片">&lt;/p>
&lt;p>同前面的原理一样，也是做了个内存复制操作，最终的结果是，把内存地址 &lt;strong>0x10000&lt;/strong> 处开始往后一直到 &lt;strong>0x90000&lt;/strong> 的内容，统统复制到内存的最开始的 &lt;strong>0&lt;/strong> 位置，大概就是这么个效果。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-36-55-49e0243b4b209160b235a0aa093f89e2.png" alt="图片">&lt;/p>
&lt;p>由于之前的各种加载和复制，导致内存看起来很乱，是时候进行一波取舍和整理了，我们重新梳理一下此时的内存布局。&lt;/p>
&lt;p>栈顶地址仍然是 &lt;strong>0x9FF00&lt;/strong> 没有改变。&lt;/p>
&lt;p>&lt;strong>0x90000&lt;/strong> 开始往上的位置，原来是 &lt;strong>bootsect&lt;/strong> 和 &lt;strong>setup&lt;/strong> 程序的代码，现 bootsect 的一部分代码在已经被操作系统为了记录内存、硬盘、显卡等一些&lt;strong>临时存放的&lt;/strong>数据给覆盖了一部分。&lt;/p>
&lt;p>内存最开始的 &lt;strong>0&lt;/strong> 到 &lt;strong>0x80000&lt;/strong> 这 512K 被 &lt;strong>system&lt;/strong> 模块给占用了，之前讲过，这个 system 模块就是除了 bootsect 和 setup 之外的全部程序链接在一起的结果，可以理解为&lt;strong>操作系统的全部&lt;/strong>。&lt;/p>
&lt;p>那么现在的内存布局就是这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-37-04-7c2f4af64e0ed98d08c634c33ae74404.png" alt="图片">&lt;/p>
&lt;p>好了，记住上面的图就好了，这回是不是又重新清晰起来了？之前的什么 0x7c00，已经是过去式了，&lt;strong>赶紧忘掉它&lt;/strong>，向前看！&lt;/p>
&lt;p>接下来，就要进行有点技术含量的工作了，那就是&lt;strong>模式的转换&lt;/strong>，需要从现在的 16 位的&lt;strong>实模式&lt;/strong>转变为之后 32 位的&lt;strong>保护模式&lt;/strong>，这是一项大工程！也是我认为的这趟操作系统源码旅程中，第一个颇为精彩的地方，大家做好准备！&lt;/p>
&lt;p>后面的世界越来越精彩，欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展与延伸 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>尝试在文本模式下，用直接写显存的方式，把自己的名字输出在屏幕上。实验源码请自行到 GitHub 上寻找。&lt;/p></description></item><item><title>06.先解决段寄存器的历史包袱问题</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/06.%E5%85%88%E8%A7%A3%E5%86%B3%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8C%85%E8%A2%B1%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/06.%E5%85%88%E8%A7%A3%E5%86%B3%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8C%85%E8%A2%B1%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="06先解决段寄存器的历史包袱问题">06.先解决段寄存器的历史包袱问题&lt;/h1>
&lt;p>上回书咱们说到，操作系统又折腾了一下内存，之后的很长一段时间内存布局就不会变了，终于稳定下来了，目前它长这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-37-17-d345b3fc056f120897aba11e13f8e2eb.png" alt="图片">&lt;/p>
&lt;p>0 地址开始处存放着操作系统的全部代码吗，也就是 system 模块，0x90000 位置处往后的几十个字节存放着一些设备的信息，方便以后使用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>内存地址&lt;/th>
&lt;th>长度(字节)&lt;/th>
&lt;th>名称&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x90000&lt;/td>
&lt;td>2&lt;/td>
&lt;td>光标位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90002&lt;/td>
&lt;td>2&lt;br>&lt;/td>
&lt;td>扩展内存数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90004&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显示页面&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90006&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>显示模式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90007&lt;/td>
&lt;td>1&lt;/td>
&lt;td>字符列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90008&lt;/td>
&lt;td>2&lt;/td>
&lt;td>未知&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000A&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>显示内存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000B&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>显示状态&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000C&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显卡特性参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000E&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>屏幕行数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000F&lt;/td>
&lt;td>1&lt;/td>
&lt;td>屏幕列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90080&lt;/td>
&lt;td>16&lt;br>&lt;/td>
&lt;td>硬盘1参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90090&lt;/td>
&lt;td>16&lt;/td>
&lt;td>硬盘2参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x901FC&lt;/td>
&lt;td>2&lt;br>&lt;/td>
&lt;td>根设备号&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>是不是十分清晰？不过别高兴得太早，清爽的内存布局，是方便后续操作系统的大显身手！&lt;/p>
&lt;p>接下来就要进行真正的第一项大工程了，那就是&lt;strong>模式的转换&lt;/strong>，需要从现在的 16 位的&lt;strong>实模式&lt;/strong>转变为之后 32 位的&lt;strong>保护模式&lt;/strong>。&lt;/p>
&lt;p>当然，虽说是一项非常难啃的大工程，但从代码量看，却是少得可怜，所以不必太过担心。&lt;/p>
&lt;p>每次讲这里都十分的麻烦，因为这是 &lt;strong>x86 的历史包袱&lt;/strong>问题，现在的 CPU 几乎都是支持 32 位模式甚至 64 位模式了，很少有还仅仅停留在 16 位的实模式下的 CPU。所以我们要为了这个历史包袱，&lt;strong>写一段模式转换的代码&lt;/strong>，如果 Intel CPU 被重新设计而不用考虑兼容性，那么今天的代码将会减少很多甚至不复存在。&lt;/p>
&lt;p>所以不用担心，听懂就听懂，听不懂就拉倒，放宽心。&lt;/p>
&lt;p>我不打算直接说实模式和保护模式的区别，我们还是跟着代码慢慢品味，来。&lt;/p>
&lt;p>这里仍然是 setup.s 文件中的代码咯。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">    &lt;/span>&lt;span class="nf">lidt&lt;/span> &lt;span class="nv">idt_48&lt;/span> &lt;span class="c1">; load idt with 0,0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">lgdt&lt;/span> &lt;span class="nv">gdt_48&lt;/span> &lt;span class="c1">; load gdt with whatever appropriate&lt;/span>
&lt;span class="nl">idt_48:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.word&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1">; idt limit=0 &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.word&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="c1">; idt base=0L&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上来就是两行看不懂的指令，别急。&lt;/p>
&lt;p>要理解这两条指令，就涉及到实模式和保护模式的第一个区别了。我们现在还处于实模式下，这个模式的 CPU 计算物理地址的方式还记得么？不记得的话看一下 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499226&amp;amp;idx=1&amp;amp;sn=1ff3d54a3608423b7781142ae3ac62ca&amp;amp;chksm=c2c58777f5b20e61664a51d31ab779bbe68c317c3459218c7cd4b9530887dbb33470628c3248&amp;amp;scene=21#wechat_redirect">第一回 最开始的两行代码&lt;/a>&lt;/p>
&lt;p>就是段基址左移四位，再加上偏移地址。比如：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-37-28-d089322cf665638a49e4d8b4a1980468.png" alt="图片">&lt;/p>
&lt;p>是不是觉得很别扭，那更别扭的地方就要来了。当 CPU 切换到&lt;strong>保护模式&lt;/strong>后，同样的代码，内存地址的计算方式还不一样，你说气不气人？&lt;/p>
&lt;p>变成啥样了呢？刚刚那个 ds 寄存器里存储的值，在实模式下叫做&lt;strong>段基址&lt;/strong>，在保护模式下叫&lt;strong>段选择子&lt;/strong>。段选择子里存储着&lt;strong>段描述符&lt;/strong>的索引。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-37-40-b20e37ee621c59421c5bb3f61c7565bd.png" alt="图片">&lt;/p>
&lt;p>通过段描述符索引，可以从&lt;strong>全局描述符表 gdt&lt;/strong> 中找到一个段描述符，段描述符里存储着段基址。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-37-52-c85d99cfcc463fe47d7b6bccd14c0f1e.png" alt="图片">&lt;/p>
&lt;p>段基址取出来，再和偏移地址相加，就得到了物理地址，整个过程如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-38-00-64c6b4e89cb80433bd848c1a9ec1c6ee.png" alt="图片">&lt;/p>
&lt;p>你就说烦不烦吧？同样一段代码，实模式下和保护模式下的结果还不同，但没办法，x86 的历史包袱我们不得不考虑，谁让我们没其他 CPU 可选呢。&lt;/p>
&lt;p>总结一下就是，&lt;strong>段寄存器（比如 ds、ss、cs）里存储的是段选择子，段选择子去全局描述符表中寻找段描述符，从中取出段基址&lt;/strong>。&lt;/p>
&lt;p>好了，那问题自然就出来了，**全局描述符表（gdt）**长什么样？它在哪？怎么让 CPU 知道它在哪？&lt;/p>
&lt;p>长什么样先别管，一定又是一个令人头疼的数据结构，先说说它在哪？在内存中呗，那么怎么告诉 CPU 全局描述符表（gdt）在内存中的什么位置呢？答案是由操作系统把这个位置信息存储在一个叫 &lt;strong>gdtr&lt;/strong> 的寄存器中。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-38-08-cfdec78ae8ffc687a2de0e2f379ad06a.png" alt="图片">&lt;/p>
&lt;p>怎么存呢？就是刚刚那条指令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">lgdt&lt;/span> &lt;span class="nv">gdt_48&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中 &lt;strong>lgdt&lt;/strong> 就表示把**后面的值（gdt_48）**放在 &lt;strong>gdtr&lt;/strong> 寄存器中，gdt_48 标签，我们看看它长什么样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">gdt_48:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x800&lt;/span> &lt;span class="c1">; gdt limit=2048, 256 GDT entries &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.word&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nv">gdt&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x9&lt;/span> &lt;span class="c1">; gdt base = 0X9xxxx&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到这个标签位置处表示一个 48 位的数据，其中高 32 位存储着的正是全局描述符表 gdt 的内存地址&lt;/p>
&lt;p>&lt;strong>0x90200 + gdt&lt;/strong>&lt;/p>
&lt;p>&lt;strong>gdt&lt;/strong> 是个标签，表示在本文件内的偏移量，而本文件是 &lt;strong>setup.s&lt;/strong>，编译后是放在 &lt;strong>0x90200&lt;/strong> 这个内存地址的，还记得吧？所以要加上 0x90200 这个值。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-38-17-52475622dc23017ba52cc7535b534c88.png" alt="图片">&lt;/p>
&lt;p>那 gdt 这个标签处，就是全局描述符表在内存中的真正数据了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">gdt:
    .word 0,0,0,0 ; dummy
    .word 0x07FF ; 8Mb - limit=2047 (2048*4096=8Mb)
    .word 0x0000 ; base address=0
    .word 0x9A00 ; code read/exec
    .word 0x00C0 ; granularity=4096, 386
    .word 0x07FF ; 8Mb - limit=2047 (2048*4096=8Mb)
    .word 0x0000 ; base address=0
    .word 0x9200 ; data read/write
    .word 0x00C0 ; granularity=4096, 386
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>具体细节不用关心，跟我看重点。&lt;/p>
&lt;p>根据刚刚的段描述符格式。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-38-27-c85d99cfcc463fe47d7b6bccd14c0f1e.png" alt="图片">&lt;/p>
&lt;p>可以看出目前全局描述符表有三个段描述符，第一个为&lt;strong>空&lt;/strong>，第二个是&lt;strong>代码段描述符（type=code）&lt;/strong>，第三个是&lt;strong>数据段描述符（type=data）&lt;/strong>，第二个和第三个段描述符的段基址都是 0，也就是之后在逻辑地址转换物理地址的时候，通过段选择子查找到无论是代码段还是数据段，取出的段基址都是 0，那么物理地址将直接等于程序员给出的逻辑地址（准确说是逻辑地址中的偏移地址）。先记住这点就好。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-38-41-588c4850dfaa3b60e5109a68d5f7c777.png" alt="图片">&lt;/p>
&lt;p>具体段描述符的细节还有很多，就不展开了，比如这里的高 22 位就表示它是代码段还是数据段。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-38-49-c85d99cfcc463fe47d7b6bccd14c0f1e.png" alt="图片">&lt;/p>
&lt;p>接下来我们看看目前的内存布局，还是别管比例。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-38-58-6c49f0dea2d622c3c637015fb6554ecd.png" alt="图片">&lt;/p>
&lt;p>这里我把 &lt;strong>idtr&lt;/strong> 寄存器也画出来了，这个是&lt;strong>中断描述符表&lt;/strong>，其原理和全局描述符表一样。全局描述符表是让段选择子去里面寻找段描述符用的，而中断描述符表是用来在发生中断时，CPU 拿着中断号去中断描述符表中寻找中断处理程序的地址，找到后就跳到相应的中断程序中去执行，具体我们后面遇到了再说。&lt;/p>
&lt;p>好了，今天我们就讲，操作系统设置了个&lt;strong>全局描述符表 gdt&lt;/strong>，为后面切换到&lt;strong>保护模式&lt;/strong>后，能去那里寻找到段描述符，然后拼凑成最终的物理地址，就这个作用。当然，还有很多段描述符，作用不仅仅是转换成最终的物理地址，不过这是后话了。&lt;/p>
&lt;p>这仅仅是进入保护模式前准备工作的其中一个，后面的路还长着呢。欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展资料 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>保护模式下逻辑地址到线性地址（不开启分页时就是物理地址）的转化，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4 Logical And Linear Addresses&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-39-07-a9bf11644fe6d8be6569420ee4ab3d90.png" alt="图片">&lt;/p>
&lt;p>段描述符结构和详细说明，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4.5 Segment Descriptors&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-39-18-d5a69a8c76451deb6fc08390f1d1aa88.png" alt="图片">&lt;/p>
&lt;p>比如文中说的数据段与代码段的划分，其实还有更细分的权限控制。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-39-26-d76ff193ff7fdb6dbdbe181ccd5615a8.png" alt="图片">&lt;/p></description></item><item><title>07.六行代码就进入了保护模式</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/07.%E5%85%AD%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B0%B1%E8%BF%9B%E5%85%A5%E4%BA%86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/07.%E5%85%AD%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B0%B1%E8%BF%9B%E5%85%A5%E4%BA%86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h1 id="07六行代码就进入了保护模式">07.六行代码就进入了保护模式&lt;/h1>
&lt;p>上回书咱们说到，操作系统设置了个全局描述符表 gdt。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-39-37-cdc976147f46b0bf4b8d2900097d82b7.png" alt="图片">&lt;/p>
&lt;p>为后面切换到保护模式后，能去那里寻找到段描述符，然后拼凑成最终的物理地址。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-39-46-28110b9eb6f6bcf717ca099228b013c3.png" alt="图片">&lt;/p>
&lt;p>而此时我们的内存布局变成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-39-54-21771f2ecc69315804a907b9965d7135.png" alt="图片">&lt;/p>
&lt;p>这仅仅是进入保护模式前准备工作的其中一个，我们接着往下看。代码仍然是 setup.s 中的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">mov al,#0xD1 ; command write
out #0x64,al
mov al,#0xDF ; A20 on
out #0x60,al
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码的意思是，&lt;strong>打开 A20 地址线&lt;/strong>。&lt;/p>
&lt;p>说人话就是，打开 A20 地址线。哈哈，开玩笑，到底什么是 A20 地址线呢？&lt;/p>
&lt;p>简单理解，这一步就是为了突破地址信号线 20 位的宽度，变成 32 位可用。这是由于 8086 CPU 只有 20 位的地址线，所以如果程序给出 21 位的内存地址数据，那多出的一位就被忽略了，比如如果经过计算得出一个内存地址为&lt;/p>
&lt;p>1 0000 00000000 00000000&lt;/p>
&lt;p>那实际上内存地址相当于 0，因为高位的那个 1 被忽略了，地方不够。&lt;/p>
&lt;p>当 CPU 到了 32 位时代之后，由于要考虑&lt;strong>兼容性&lt;/strong>，还必须保持一个只能用 20 位地址线的模式，所以如果你不手动开启的话，即使地址线已经有 32 位了，仍然会限制只能使用其中的 20 位。&lt;/p>
&lt;p>简单吧？我们继续。&lt;/p>
&lt;p>接下来的一段代码，你完全完全不用看，但为了防止你一直记挂在心上，我给你截出来说道说道，这样以后我说完全不用看的代码时，你就真的可以放宽心完全不看了。&lt;/p>
&lt;p>就是这一大坨，还有 Linus 自己的注释。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="c1">; well, that went ok, I hope. Now we have to reprogram the interrupts :-(&lt;/span>
&lt;span class="c1">; we put them right after the intel-reserved hardware interrupts, at&lt;/span>
&lt;span class="c1">; int 0x20-0x2F. There they won&amp;#39;t mess up anything. Sadly IBM really&lt;/span>
&lt;span class="c1">; messed this up with the original PC, and they haven&amp;#39;t been able to&lt;/span>
&lt;span class="c1">; rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,&lt;/span>
&lt;span class="c1">; which is used for the internal hardware interrupts as well. We just&lt;/span>
&lt;span class="c1">; have to reprogram the 8259&amp;#39;s, and it isn&amp;#39;t fun. &lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x11&lt;/span> &lt;span class="c1">; initialization sequence &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0x20&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span> &lt;span class="c1">; send it to 8259A-1 &lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span> &lt;span class="c1">; jmp $+2, jmp $+2 &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0xA0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span> &lt;span class="c1">; and to 8259A-2 &lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x20&lt;/span> &lt;span class="c1">; start of hardware int&amp;#39;s (0x20) &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x28&lt;/span> &lt;span class="c1">; start of hardware int&amp;#39;s 2 (0x28) &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0xA1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x04&lt;/span> &lt;span class="c1">; 8259-1 is master &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x02&lt;/span> &lt;span class="c1">; 8259-2 is slave &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0xA1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x01&lt;/span> &lt;span class="c1">; 8086 mode for both &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0xA1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0xFF&lt;/span> &lt;span class="c1">; mask off all interrupts for now &lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;span class="nf">.word&lt;/span> &lt;span class="mh">0x00eb&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x00eb&lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0xA1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里是对&lt;strong>可编程中断控制器 8259 芯片&lt;/strong>进行的编程。&lt;/p>
&lt;p>因为中断号是不能冲突的， Intel 把 0 到 0x19 号中断都作为&lt;strong>保留中断&lt;/strong>，比如 0 号中断就规定为&lt;strong>除零异常&lt;/strong>，软件自定义的中断都应该放在这之后，但是 IBM 在原 PC 机中搞砸了，跟保留中断号发生了冲突，以后也没有纠正过来，所以我们得重新对其进行编程，不得不做，却又一点意思也没有。这是 Linus 在上面注释上的原话。&lt;/p>
&lt;p>所以我们也不必在意，只要知道重新编程之后，8259 这个芯片的引脚与中断号的对应关系，变成了如下的样子就好。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>PIC 请求号&lt;/th>
&lt;th>中断号&lt;/th>
&lt;th>用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>IRQ0&lt;/td>
&lt;td>0x20&lt;/td>
&lt;td>时钟中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ1&lt;/td>
&lt;td>0x21&lt;/td>
&lt;td>键盘中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ2&lt;/td>
&lt;td>0x22&lt;/td>
&lt;td>接连从芯片&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ3&lt;/td>
&lt;td>0x23&lt;/td>
&lt;td>串口2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ4&lt;/td>
&lt;td>0x24&lt;/td>
&lt;td>串口1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ5&lt;/td>
&lt;td>0x25&lt;/td>
&lt;td>并口2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ6&lt;/td>
&lt;td>0x26&lt;/td>
&lt;td>软盘驱动器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ7&lt;/td>
&lt;td>0x27&lt;/td>
&lt;td>并口1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ8&lt;/td>
&lt;td>0x28&lt;/td>
&lt;td>实时钟中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ9&lt;/td>
&lt;td>0x29&lt;/td>
&lt;td>保留&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ10&lt;/td>
&lt;td>0x2a&lt;/td>
&lt;td>保留&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ11&lt;/td>
&lt;td>0x2b&lt;/td>
&lt;td>保留&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ12&lt;/td>
&lt;td>0x2c&lt;/td>
&lt;td>鼠标中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ13&lt;/td>
&lt;td>0x2d&lt;/td>
&lt;td>数学协处理器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ14&lt;/td>
&lt;td>0x2e&lt;/td>
&lt;td>硬盘中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IRQ15&lt;/td>
&lt;td>0x2f&lt;/td>
&lt;td>保留&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>好了，接下来的一步，就是真正切换模式的一步了，从代码上看就两行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">mov ax,#0x0001 ; protected mode (PE) bitlmsw ax ; This is it;jmpi 0,8 ; jmp offset 0 of segment 8 (cs)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>前两行，将 cr0 这个寄存器的位 0 置 1，模式就从实模式切换到保护模式了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-40-07-90cd058fb59f2f081e01e9bf6e384da9.png" alt="图片">&lt;/p>
&lt;p>所以真正的模式切换十分简单，重要的是之前做的准备工作。&lt;/p>
&lt;p>再往后，又是一个段间跳转指令 &lt;strong>jmpi&lt;/strong>，后面的 8 表示 cs（代码段寄存器）的值，0 表示偏移地址。请注意，此时已经是保护模式了，之前也说过，保护模式下内存寻址方式变了，段寄存器里的值被当做段选择子。&lt;/p>
&lt;p>回顾下段选择子的模样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-40-15-66aee41ab36fa9ac638333ef7baf6ad1.png" alt="图片">&lt;/p>
&lt;p>8 用二进制表示就是&lt;/p>
&lt;p>00000,0000,0000,1000&lt;/p>
&lt;p>对照上面段选择子的结构，可以知道&lt;strong>描述符索引值是 1&lt;/strong>，也就是要去**全局描述符表（gdt）**中找第一项段描述符。&lt;/p>
&lt;p>还记得上一讲中的全局描述符的具体内容么？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">gdt:
    .word 0,0,0,0 ; dummy
    .word 0x07FF ; 8Mb - limit=2047 (2048*4096=8Mb)
    .word 0x0000 ; base address=0
    .word 0x9A00 ; code read/exec
    .word 0x00C0 ; granularity=4096, 386
    .word 0x07FF ; 8Mb - limit=2047 (2048*4096=8Mb)
    .word 0x0000 ; base address=0
    .word 0x9200 ; data read/write
    .word 0x00C0 ; granularity=4096, 386
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们说了，第 0 项是空值，第一项被表示为&lt;strong>代码段描述符&lt;/strong>，是个可读可执行的段，第二项为&lt;strong>数据段描述符&lt;/strong>，是个可读可写段，不过他们的段基址都是 0。&lt;/p>
&lt;p>所以，这里取的就是这个代码段描述符，&lt;strong>段基址是 0&lt;/strong>，偏移也是 0，那加一块就还是 0 咯，所以最终这个跳转指令，就是跳转到内存地址的 0 地址处，开始执行。&lt;/p>
&lt;p>零地址处是什么呢？还是回顾之前的内存布局图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-40-28-650b3b41130054acc3545c65c42ca1a1.png" alt="图片">&lt;/p>
&lt;p>就是操作系统全部代码的 system 这个大模块，system 模块怎么生成的呢？由 Makefile 文件可知，是由 head.s 和 main.c 以及其余各模块的操作系统代码合并来的，可以理解为操作系统的全部核心代码编译后的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-makefile" data-lang="makefile">&lt;span class="nf">tools/system&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">boot&lt;/span>/&lt;span class="n">head&lt;/span>.&lt;span class="n">o&lt;/span> &lt;span class="n">init&lt;/span>/&lt;span class="n">main&lt;/span>.&lt;span class="n">o&lt;/span> \
&lt;span class="k">$(&lt;/span>ARCHIVES&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>DRIVERS&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>MATH&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>LIBS&lt;span class="k">)&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> &lt;span class="k">$(&lt;/span>LD&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>LDFLAGS&lt;span class="k">)&lt;/span> boot/head.o init/main.o &lt;span class="se">\ &lt;/span>
&lt;span class="k">$(&lt;/span>ARCHIVES&lt;span class="k">)&lt;/span> &lt;span class="se">\ &lt;/span>
&lt;span class="k">$(&lt;/span>DRIVERS&lt;span class="k">)&lt;/span> &lt;span class="se">\ &lt;/span>
    &lt;span class="k">$(&lt;/span>&lt;span class="nv">MATH&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="err">\&lt;/span>
    &lt;span class="k">$(&lt;/span>&lt;span class="nv">LIBS&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="err">\&lt;/span>
    &lt;span class="err">-o&lt;/span> &lt;span class="err">tools/system&lt;/span> &lt;span class="err">&amp;gt;&lt;/span> &lt;span class="err">System.map&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所以，接下来，我们就要重点阅读 &lt;strong>head.s&lt;/strong> 了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-40-38-07b0d2f083ae4f23d14a616f565e8b51.png" alt="图片">&lt;/p>
&lt;p>这也是 boot 文件夹下的最后一个由汇编写就的源代码文件，哎呀，不知不觉就把两个操作系统源码文件（&lt;strong>bootsect.s&lt;/strong> 和 &lt;strong>setup.s&lt;/strong>）讲完了，而且是汇编写的令人头疼的代码。&lt;/p>
&lt;p>&lt;strong>head.s&lt;/strong> 这个文件仅仅是为了顺利进入由后面的 c 语言写就的 main.c 做的准备，所以咬咬牙看完这个之后，我们就终于可以进入 c 语言的世界了！也终于可以看到我们熟悉的 main 函数了！&lt;/p>
&lt;p>在那里，操作系统真正秀操作的地方，才刚刚开始！欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展资料 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>保护模式下逻辑地址到线性地址（不开启分页时就是物理地址）的转化，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4 Logical And Linear Addresses&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-40-48-a9bf11644fe6d8be6569420ee4ab3d90.png" alt="图片">&lt;/p>
&lt;p>段描述符结构和详细说明，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4.5 Segment Descriptors&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-40-56-d5a69a8c76451deb6fc08390f1d1aa88.png" alt="图片">&lt;/p>
&lt;p>对操作系统如何编译的，比如好奇那个 system 是怎么来的，可以尝试理解一下 Linux 0.11 源码中的 Makefile，这个我就不展开讲了，我们把更多经历，放在操作系统是怎么一步一步构建起来的这个过程。&lt;/p></description></item><item><title>08.烦死了又要重新设置一遍 idt 和 gdt</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/08.%E7%83%A6%E6%AD%BB%E4%BA%86%E5%8F%88%E8%A6%81%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E4%B8%80%E9%81%8Didt%E5%92%8Cgdt/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/08.%E7%83%A6%E6%AD%BB%E4%BA%86%E5%8F%88%E8%A6%81%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E4%B8%80%E9%81%8Didt%E5%92%8Cgdt/</guid><description>&lt;h1 id="08烦死了又要重新设置一遍-idt-和-gdt">08.烦死了又要重新设置一遍 idt 和 gdt&lt;/h1>
&lt;p>上回书咱们说到，CPU 进入了 32 位保护模式，我们快速回顾一下关键的代码。&lt;/p>
&lt;p>首先配置了全局描述符表 gdt 和中断描述符表 idt。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">lidt&lt;/span> &lt;span class="nv">idt_48&lt;/span>
&lt;span class="nf">lgdt&lt;/span> &lt;span class="nv">gdt_48&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后打开了 A20 地址线。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0xD1&lt;/span> &lt;span class="c1">; command writeout #0x64,al&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">al&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0xDF&lt;/span> &lt;span class="c1">; A20 on&lt;/span>
&lt;span class="nf">out&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="mh">0x60&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">al&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后更改 cr0 寄存器开启保护模式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="mh">0x0001&lt;/span>
&lt;span class="nf">lmsw&lt;/span> &lt;span class="nb">ax&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，一个干脆利落的跳转指令，跳到了内存地址 0 处开始执行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">jmpi&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">8&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>0 位置处存储着操作系统全部核心代码，是由 head.s 和 main.c 以及后面的无数源代码文件编译并链接在一起而成的 system 模块。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-41-14-c1831c417fc139e87a23c11f415d45b3.png" alt="图片">&lt;/p>
&lt;p>那接下来，我们就品品，正式进入 c 语言写的 main.c 之前的 &lt;strong>head.s&lt;/strong> 究竟写了点啥？&lt;/p>
&lt;p>head.s 文件很短，我们一点点品。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">_pg_dir:
_startup_32:
    mov eax,0x10
    mov ds,ax
    mov es,ax
    mov fs,ax
    mov gs,ax
    lss esp,_stack_start
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意到开头有个标号 &lt;strong>_pg_dir&lt;/strong>。先留个心眼，这个表示&lt;strong>页目录&lt;/strong>，之后在设置分页机制时，页目录会存放在这里，也会覆盖这里的代码。&lt;/p>
&lt;p>再往下连续五个 &lt;strong>mov&lt;/strong> 操作，分别给 ds、es、fs、gs 这几个段寄存器赋值为 &lt;strong>0x10&lt;/strong>，根据段描述符结构解析，表示这几个段寄存器的值为指向全局描述符表中的第二个段描述符，也就是数据段描述符。&lt;/p>
&lt;p>最后 &lt;strong>lss&lt;/strong> 指令相当于让 &lt;strong>ss:esp&lt;/strong> 这个栈顶指针指向了 &lt;strong>_stack_start&lt;/strong> 这个标号的位置。还记得图里的那个原来的栈顶指针在哪里吧？往上翻一下，&lt;strong>0x9FF00&lt;/strong>，现在要变咯。&lt;/p>
&lt;p>这个 stack_start 标号定义在了很久之后才会讲到的 &lt;strong>sched.c&lt;/strong> 里，我们这里拿出来分析一波。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">long&lt;/span> &lt;span class="n">user_stack&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4096&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">struct&lt;/span>&lt;span class="p">{&lt;/span>  
    &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>  
    &lt;span class="kt">short&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>&lt;span class="n">stack_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">user_stack&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4096&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="mh">0x10&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这啥意思呢？&lt;/p>
&lt;p>首先，stack_start 结构中的高位 8 字节是 &lt;strong>0x10&lt;/strong>，将会赋值给 &lt;strong>ss&lt;/strong> 栈段寄存器，低位 16 字节是 &lt;strong>user_stack&lt;/strong> 这个数组的最后一个元素的地址值，将其赋值给 &lt;strong>esp&lt;/strong> 寄存器。&lt;/p>
&lt;p>赋值给 ss 的 0x10 仍然按照保护模式下的&lt;strong>段选择子&lt;/strong>去解读，其指向的是全局描述符表中的第二个段描述符（数据段描述符），段基址是 0。&lt;/p>
&lt;p>赋值给 esp 寄存器的就是 user_stack 数组的最后一个元素的内存地址值，那最终的&lt;strong>栈顶地址&lt;/strong>，也指向了这里（user_stack + 0），后面的压栈操作，就是往这个新的栈顶地址处压咯。&lt;/p>
&lt;p>继续往下看&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">call&lt;/span> &lt;span class="nv">setup_idt&lt;/span> &lt;span class="c1">;设置中断描述符表&lt;/span>
&lt;span class="nf">call&lt;/span> &lt;span class="nv">setup_gdt&lt;/span> &lt;span class="c1">;设置全局描述符表&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">10h&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">es&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">fs&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">gs&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">ax&lt;/span>
&lt;span class="nf">lss&lt;/span> &lt;span class="nb">esp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_stack_start&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先设置了 &lt;strong>idt&lt;/strong> 和 &lt;strong>gdt&lt;/strong>，然后又重新执行了一遍刚刚执行过的代码。&lt;/p>
&lt;p>为什么要重新设置这些段寄存器呢？因为上面修改了 gdt，所以要重新设置一遍以刷新才能生效。那我们接下来就把目光放到设置 idt 和 gdt 上。&lt;/p>
&lt;p>中断描述符表 idt 我们之前没设置过，所以这里设置具体的值，理所应当。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">setup_idt:&lt;/span>
&lt;span class="nf">lea&lt;/span> &lt;span class="nb">edx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">ignore_int&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">00080000h&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">dx&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">dx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">8E00h&lt;/span>
&lt;span class="nf">lea&lt;/span> &lt;span class="nb">edi&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_idt&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ecx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">256&lt;/span>
&lt;span class="nl">rp_sidt:&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">edi&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">edi&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nb">edx&lt;/span>
&lt;span class="nf">add&lt;/span> &lt;span class="nb">edi&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">8&lt;/span>
&lt;span class="nf">dec&lt;/span> &lt;span class="nb">ecx&lt;/span>
&lt;span class="nf">jne&lt;/span> &lt;span class="nv">rp_sidt&lt;/span>
&lt;span class="nf">lidt&lt;/span> &lt;span class="nv">fword&lt;/span> &lt;span class="nv">ptr&lt;/span> &lt;span class="nv">idt_descr&lt;/span>
&lt;span class="nf">ret&lt;/span>
&lt;span class="nl">idt_descr:&lt;/span>
&lt;span class="kd">dw&lt;/span> &lt;span class="mi">256&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="kd">dd&lt;/span> &lt;span class="nv">_idt&lt;/span>
&lt;span class="nl">_idt:&lt;/span>
&lt;span class="kd">DQ&lt;/span> &lt;span class="mi">256&lt;/span> &lt;span class="nv">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不用细看，我给你说最终效果。&lt;/p>
&lt;p>中断描述符表 idt 里面存储着一个个中断描述符，每一个中断号就对应着一个中断描述符，而中断描述符里面存储着主要是中断程序的地址，这样一个中断号过来后，CPU 就会自动寻找相应的中断程序，然后去执行它。&lt;/p>
&lt;p>那这段程序的作用就是，&lt;strong>设置了 256 个中断描述符&lt;/strong>，并且让每一个中断描述符中的中断程序例程都指向一个 &lt;strong>ignore_int&lt;/strong> 的函数地址，这个是个&lt;strong>默认的中断处理程序&lt;/strong>，之后会逐渐被各个具体的中断程序所覆盖。比如之后键盘模块会将自己的键盘中断处理程序，覆盖过去。&lt;/p>
&lt;p>那现在，产生任何中断都会指向这个默认的函数 ignore_int，也就是说现在这个阶段&lt;strong>你按键盘还不好使&lt;/strong>。&lt;/p>
&lt;p>设置中断描述符表 setup_idt 说完了，那接下来 &lt;strong>setup_gdt&lt;/strong> 就同理了。我们就直接看设置好后的新的全局描述符表长什么样吧？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">_gdt:
    DQ 0000000000000000h ;/* NULL descriptor */
    DQ 00c09a0000000fffh ;/* 16Mb */
    DQ 00c0920000000fffh ;/* 16Mb */
    DQ 0000000000000000h ;/* TEMPORARY - don&amp;#39;t use */
    DQ 252 dup(0)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其实和我们原先设置好的 gdt 一模一样。&lt;/p>
&lt;p>也是有&lt;strong>代码段描述符&lt;/strong>和&lt;strong>数据段描述符&lt;/strong>，然后第四项系统段描述符并没有用到，不用管。最后还留了 252 项的空间，这些空间后面会用来放置&lt;strong>任务状态段描述符 TSS&lt;/strong> 和&lt;strong>局部描述符 LDT&lt;/strong>，这个后面再说。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-41-26-2f3e83803ce608e337451dbc72351262.png" alt="图片">&lt;/p>
&lt;p>为什么原来已经设置过一遍了，这里又要重新设置一遍，你可千万别想有什么复杂的原因，就是因为原来设置的 gdt 是在 setup 程序中，之后这个地方要被缓冲区覆盖掉，所以这里重新设置在 head 程序中，这块内存区域之后就不会被其他程序用到并且覆盖了，就这么个事。&lt;/p>
&lt;p>说的口干舌燥，还是来张图吧。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-41-34-dff9127298e03c540a6069b845adeb37.png" alt="图片">&lt;/p>
&lt;p>如果你本文的内容完全不能理解，那就记住最后这张图就好了，本文代码就是完成了这个图中所示的一个指向转换而已，并且给所有中断设置了一个默认的中断处理程序 ignore_int，然后全局描述符表仍然只有代码段描述符和数据段描述符。&lt;/p>
&lt;p>好了，本文就是两个描述符表位置的变化以及重新设置，再后面一行代码就是又一个令人兴奋的功能了！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">after_page_tables&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="nl">after_page_tables:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">_main&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">setup_paging&lt;/span>
&lt;span class="nl">L6:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那就是开启分页机制，并且跳转到 main 函数！&lt;/p>
&lt;p>这可太令人兴奋了！开启分页后，配合着之前讲的分段，就构成了内存管理的最最底层的机制。而跳转到 main 函数，标志着我们正式进入 c 语言写的操作系统核心代码！&lt;/p>
&lt;p>欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展资料 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>保护模式下逻辑地址到线性地址（不开启分页时就是物理地址）的转化，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4 Logical And Linear Addresses&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-41-43-a9bf11644fe6d8be6569420ee4ab3d90.png" alt="图片">&lt;/p>
&lt;p>段描述符结构和详细说明，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4.5 Segment Descriptors&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-41-51-d5a69a8c76451deb6fc08390f1d1aa88.png" alt="图片">&lt;/p>
&lt;p>对操作系统如何编译的，比如好奇那个 system 是怎么来的，可以尝试理解一下 Linux 0.11 源码中的 Makefile，这个我就不展开讲了，我们把更多经历，放在操作系统是怎么一步一步构建起来的这个过程。&lt;/p></description></item><item><title>09.Intel 内存管理两板斧：分段与分页</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/09.intel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%A4%E6%9D%BF%E6%96%A7_%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/09.intel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%A4%E6%9D%BF%E6%96%A7_%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5/</guid><description>&lt;h1 id="09intel-内存管理两板斧分段与分页">09.Intel 内存管理两板斧：分段与分页&lt;/h1>
&lt;p>head.s 代码在重新设置了 gdt 与 idt 后。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-03-43-e5a3467caa9f51f269e0f1c3fbadbe21.png" alt="图片">&lt;/p>
&lt;p>来到了这样一段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">after_page_tables&lt;/span>
&lt;span class="nf">...&lt;/span>
&lt;span class="nl">after_page_tables:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">_main&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">setup_paging&lt;/span>
&lt;span class="nl">L6:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那就是开启分页机制，并且跳转到 main 函数。&lt;/p>
&lt;p>如何跳转到之后用 c 语言写的 main.c 里的 main 函数，是个有趣的事，也包含在这段代码里。不过我们先瞧瞧这&lt;strong>分页机制&lt;/strong>是如何开启的，也就是 &lt;strong>setup_paging&lt;/strong> 这个标签处的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">setup_paging:&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ecx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">5&lt;/span>
&lt;span class="nf">xor&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="nf">xor&lt;/span> &lt;span class="nb">edi&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">edi&lt;/span>
&lt;span class="nf">pushf&lt;/span>
&lt;span class="nf">cld&lt;/span>
&lt;span class="nf">rep&lt;/span> &lt;span class="nv">stosd&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">edi&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4092&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">00fff007h&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">std&lt;/span>
&lt;span class="nl">L3:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">stosd&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">sub&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">00001000h&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jge&lt;/span> &lt;span class="nv">L3&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">popf&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">xor&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">cr3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">cr0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">or&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">80000000h&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">cr0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>别怕，我们一点点来分析。&lt;/p>
&lt;p>首先要了解的就是，啥是分页机制？&lt;/p>
&lt;p>还记不记得之前我们在代码中给出一个内存地址，在保护模式下要先经过分段机制的转换，才能最终变成物理地址，就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-03-50-e39b50ee2c579ffaf8b34f18f4237a42.png" alt="图片">&lt;/p>
&lt;p>这是在没有开启分页机制的时候，只需要经过这一步转换即可得到最终的物理地址了，但是在开启了分页机制后，又会&lt;strong>多一步转换&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-03-55-5e94c299d3d3667016e9b63e44abc0d2.png" alt="图片">&lt;/p>
&lt;p>也就是说，在没有开启分页机制时，由程序员给出的&lt;strong>逻辑地址&lt;/strong>，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是&lt;strong>线性地址&lt;/strong>，然后再通过一次分页机制转换，得到最终的物理地址。&lt;/p>
&lt;p>分段机制我们已经清楚如何对地址进行变换了，那分页机制又是如何变换的呢？我们直接以一个例子来学习过程。&lt;/p>
&lt;p>比如我们的线性地址（已经经过了分段机制的转换）是&lt;/p>
&lt;p>15M&lt;/p>
&lt;p>二进制表示就是&lt;/p>
&lt;p>0000000011_0100000000_000000000000&lt;/p>
&lt;p>我们看一下它的转换过程&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-00-1dedd0086f3c1636e423c07d1489c107.png" alt="图片">&lt;/p>
&lt;p>也就是说，CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成&lt;/p>
&lt;p>高 10 位：中间 10 位：后 12 位&lt;/p>
&lt;p>高 10 位负责在&lt;strong>页目录表&lt;/strong>中找到一个&lt;strong>页目录项&lt;/strong>，这个页目录项的值加上中间 10 位拼接后的地址去&lt;strong>页表&lt;/strong>中去寻找一个&lt;strong>页表项&lt;/strong>，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。&lt;/p>
&lt;p>而这一切的操作，都由计算机的一个硬件叫 &lt;strong>MMU&lt;/strong>，中文名字叫&lt;strong>内存管理单元&lt;/strong>，有时也叫 PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。&lt;/p>
&lt;p>所以整个过程我们不用操心，作为操作系统这个软件层，只需要提供好页目录表和页表即可，这种页表方案叫做&lt;strong>二级页表&lt;/strong>，第一级叫&lt;strong>页目录表 PDE&lt;/strong>，第二级叫&lt;strong>页表 PTE&lt;/strong>。他们的结构如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-05-9d10c38f804b5f9a1bb86bb9ab143699.png" alt="图片">&lt;/p>
&lt;p>之后再开启分页机制的开关。其实就是更改 &lt;strong>cr0&lt;/strong> 寄存器中的一位即可（31 位），还记得我们开启保护模式么，也是改这个寄存器中的一位的值。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-11-11728d8426c69ca78cb1920b3f86f533.png" alt="图片">&lt;/p>
&lt;p>然后，MMU 就可以帮我们进行分页的转换了。此后指令中的内存地址（就是程序员提供的逻辑地址），就统统要先经过分段机制的转换，再通过分页机制的转换，才能最终变成物理地址。&lt;/p>
&lt;p>所以这段代码，就是帮我们把页表和页目录表在内存中写好，之后开启 cr0 寄存器的分页开关，仅此而已，我们再把代码贴上来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">setup_paging: mov ecx,1024*5 xor eax,eax xor edi,edi pushf cld rep stosd mov eax,_pg_dir mov [eax],pg0+7 mov [eax+4],pg1+7 mov [eax+8],pg2+7 mov [eax+12],pg3+7 mov edi,pg3+4092 mov eax,00fff007h stdL3: stosd sub eax,00001000h jge L3 popf xor eax,eax mov cr3,eax mov eax,cr0 or eax,80000000h mov cr0,eax ret
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们先说这段代码最终产生的效果吧。&lt;/p>
&lt;p>当时 linux-0.11 认为，总共可以使用的内存不会超过 &lt;strong>16M&lt;/strong>，也即最大地址空间为 &lt;strong>0xFFFFFF&lt;/strong>。&lt;/p>
&lt;p>而按照当前的页目录表和页表这种机制，1 个页目录表最多包含 1024 个页目录项（也就是 1024 个页表），1 个页表最多包含 1024 个页表项（也就是 1024 个页），1 页为 4KB（因为有 12 位偏移地址），因此，16M 的地址空间可以用 1 个页目录表 + 4 个页表搞定。&lt;/p>
&lt;p>4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB&lt;/p>
&lt;p>所以，上面这段代码就是，&lt;strong>将页目录表放在内存地址的最开头&lt;/strong>，还记得上一讲开头让你留意的 _pg_dir 这个标签吧？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">_pg_dir:
_startup_32:
    mov eax,0x10
    mov ds,ax
    ...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>之后紧挨着这个页目录表，放置 4 个页表&lt;/strong>，代码里也有这四个页表的标签项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">.org 0x1000 pg0:
.org 0x2000 pg1:
.org 0x3000 pg2:
.org 0x4000 pg3:
.org 0x5000
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终将页目录表和页表填写好数值，来覆盖整个 16MB 的内存。随后，开启分页机制。此时内存中的页表相关的布局如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-17-d8c5ccab8f627ac9f184d268dd6e42bf.png" alt="图片">&lt;/p>
&lt;p>这些页目录表和页表放到了整个内存布局中最开头的位置，就是覆盖了开头的 system 代码了，不过被覆盖的 system 代码已经执行过了，所以无所谓。&lt;/p>
&lt;p>同时，如 idt 和 gdt 一样，我们也需要通过一个寄存器告诉 CPU 我们把这些页表放在了哪里，就是这段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">xor&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">cr3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你看，我们相当于告诉 cr3 寄存器，&lt;strong>0 地址处就是页目录表，再通过页目录表可以找到所有的页表&lt;/strong>，也就相当于 CPU 知道了分页机制的全貌了。&lt;/p>
&lt;p>至此后，整个内存布局如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-22-38240f8404e640c9770f44bdd3cd6507.png" alt="图片">&lt;/p>
&lt;p>那么具体页表设置好后，映射的内存是怎样的情况呢？那就要看页表的具体数据了，就是这一坨代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">setup_paging:
    ...
    mov eax,_pg_dir
    mov [eax],pg0+7
    mov [eax+4],pg1+7
    mov [eax+8],pg2+7
    mov [eax+12],pg3+7
    mov edi,pg3+4092
    mov eax,00fff007h
    stdL3: stosd    
    sub eax, 1000h    
    jpe L3
    ...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，对照刚刚的页目录表与页表结构看。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-27-9d10c38f804b5f9a1bb86bb9ab143699.png" alt="图片">&lt;/p>
&lt;p>前五行表示，页目录表的前 4 个页目录项，分别指向 4 个页表。比如页目录项中的第一项 &lt;strong>[eax]&lt;/strong> 被赋值为 &lt;strong>pg0+7&lt;/strong>，也就是 &lt;strong>0x00001007&lt;/strong>，根据页目录项的格式，表示页表地址为 &lt;strong>0x1000&lt;/strong>，页属性为 &lt;strong>0x07&lt;/strong> 表示改页存在、用户可读写。&lt;/p>
&lt;p>后面几行表示，填充 4 个页表的每一项，一共 &lt;strong>4*1024=4096&lt;/strong> 项，依次映射到内存的前 16MB 空间。&lt;/p>
&lt;p>画出图就是这个样子，其实刚刚的图就是。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-34-1dedd0086f3c1636e423c07d1489c107.png" alt="图片">&lt;/p>
&lt;p>看，最终的效果就是，经过这套分页机制，&lt;strong>线性地址将恰好和最终转换的物理地址一样&lt;/strong>。&lt;/p>
&lt;p>现在只有四个页目录项，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-39-dd889ce71a3449d8d38c336e5a2bbdc3.png" alt="图片">&lt;/p>
&lt;p>好了，我知道你目前可能有点晕头转向，关于地址，我们已经出现了好多词了，包括&lt;strong>逻辑地址&lt;/strong>、&lt;strong>线性地址&lt;/strong>、&lt;strong>物理地址&lt;/strong>，以及本文中没出现的，你可能在很多地方看到过的&lt;strong>虚拟地址&lt;/strong>。&lt;/p>
&lt;p>而这些地址后面加上空间两个字，似乎又成为了一个新词，比如&lt;strong>线性地址空间&lt;/strong>、&lt;strong>物理地址空间&lt;/strong>、&lt;strong>虚拟地址空间&lt;/strong>等。&lt;/p>
&lt;p>那就是时候展开一波讨论，将这块的内容梳理一番了，且听我说。&lt;/p>
&lt;p>Intel 体系结构的&lt;strong>内存管理&lt;/strong>可以分成两大部分，也就是标题中的两板斧，&lt;strong>分段&lt;/strong>和&lt;strong>分页&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>分段机制&lt;/strong>在之前几回已经讨论过多次了，其目的是为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。&lt;/p>
&lt;p>&lt;strong>分页机制&lt;/strong>是本回讲的内容，开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。其目的在于可以按需使用物理内存，同时也可以在多任务时起到隔离的作用，这个在后面将多任务时将会有所体会。&lt;/p>
&lt;p>在 Intel 的保护模式下，分段机制是没有开启和关闭一说的，它必须存在，而分页机制是可以选择开启或关闭的。所以如果有人和你说，它实现了一个没有分段机制的操作系统，那一定是个外行。&lt;/p>
&lt;p>再说说那些地址：&lt;/p>
&lt;p>&lt;strong>逻辑地址&lt;/strong>：我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。&lt;/p>
&lt;p>&lt;strong>线性地址&lt;/strong>：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。&lt;/p>
&lt;p>&lt;strong>物理地址&lt;/strong>：就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。&lt;/p>
&lt;p>&lt;strong>虚拟地址&lt;/strong>：如果没有开启分页机制，那么线性地址就和物理地址是一一对应的，可以理解为相等。如果开启了分页机制，那么线性地址将被视为虚拟地址，这个虚拟地址将会通过分页机制的转换，最终转换成物理地址。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-44-5e94c299d3d3667016e9b63e44abc0d2.png" alt="图片">&lt;/p>
&lt;p>但实际上，我本人是不喜欢虚拟地址这个叫法的，因为它在 Intel 标准手册上出现的次数很少，我觉得知道逻辑地址、线性地址、物理地址这三个概念就够了，逻辑地址是程序员给出的，经过分段机制转换后变成线性地址，然后再经过分页机制转换后变成物理地址，就这么简单。&lt;/p>
&lt;p>好了，我们终于把这些杂七杂八的，idt、gdt、页表都设置好了，并且也开启了保护模式，之后我们就要做好进入 main.c 的准备了，那里是个新世界！&lt;/p>
&lt;p>不过进入 main.c 之前还差最后一哆嗦，就是 head.s 最后的代码，也就是本文开头的那段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">after_page_tables&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="nl">after_page_tables:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">_main&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">setup_paging&lt;/span>
&lt;span class="nl">L6:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到没，这里有个 push _main，把 main 函数的地址压栈了，那最终跳转到这个 main.c 里的 main 函数，一定和这个压栈有关。&lt;/p>
&lt;p>压栈为什么和跳转到这里还能联系上呢？留作本文思考题，下一篇将揭秘这个过程，你会发现仍然简单得要死。&lt;/p>
&lt;p>欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展资料 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>关于逻辑地址-线性地址-物理地址的转换，可以参考 Intel 手册：&lt;/p>
&lt;p>Intel 3A Chapter 3 Protected-Mode Memory Management&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-50-6173d7b155edf1163656a92accadfd50.png" alt="图片">&lt;/p>
&lt;p>而有关这些地址的定义和说明，在本小节中也做了详细的说明，看这里的介绍是最权威也是最透彻的。相信我，它很简单。&lt;/p>
&lt;p>页目录表和页表的具体结构，可以看&lt;/p>
&lt;p>Intel 3A Chapter 4.3 32-bit paging&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-55-7ce1ce0354904b2535f1293057c855e7.png" alt="图片">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-00-dc74426a214fda8f1885299cfb8d4dbc.png" alt="图片">&lt;/p></description></item><item><title>10.1.小结</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/10.1.%E5%B0%8F%E7%BB%93/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/10.1.%E5%B0%8F%E7%BB%93/</guid><description>&lt;h1 id="101小结">10.1.小结&lt;/h1>
&lt;p>当你按下开机键的那一刻，在主板上提前写死的固件程序 BIOS 会将硬盘中启动区的 512 字节的数据，原封不动复制到内存中的 0x7c00 这个位置，并跳转到那个位置进行执行，&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-42-26-f43655cb64b0bf1fb69c39e4cb1756b3.png" alt="图片">&lt;/p>
&lt;p>有了这个步骤之后，我们就可以把代码写在硬盘第一扇区，让 BIOS 帮我们加载到内存并由 CPU 去执行，我们不用操心这个过程。&lt;/p>
&lt;p>而这一个扇区的代码，就是操作系统源码中最最最开始的部分，它可以执行一些指令，也可以把硬盘的其他部分加载到内存，其实本质上也是执行一些指令。这样，整个计算机今后如何运作，就完全交到我们自己的手中，想怎么玩就怎么玩了。&lt;/p>
&lt;p>这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499226&amp;amp;idx=1&amp;amp;sn=1ff3d54a3608423b7781142ae3ac62ca&amp;amp;chksm=c2c58777f5b20e61664a51d31ab779bbe68c317c3459218c7cd4b9530887dbb33470628c3248&amp;amp;scene=21#wechat_redirect">第一回 | 最开始的两行代码&lt;/a> 讲的内容。&lt;/p>
&lt;p>接下来，直到 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499359&amp;amp;idx=1&amp;amp;sn=233812a464996b9566cdf3258132bc22&amp;amp;chksm=c2c584f2f5b20de40a7990c754cdbf3073b4652f318d479ac0c8ff686ca7aa74eef1ba7c6c2f&amp;amp;scene=21#wechat_redirect">第四回 | 把自己在硬盘里的其他部分也放到内存来&lt;/a>，我们才讲到整个操作系统的编译和加载过程的全貌，就是下面这张图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-50-23-4e9f1304adc40a4ce0c7076e72c0cb8a.png" alt="图片">&lt;/p>
&lt;p>而我们整个的第一部分，其实就在讲 boot 文件夹下的三个汇编文件的内容，bootsect.s，setup.s 以及后面要和其他全部操作系统代码做链接的 head.s。&lt;/p>
&lt;p>前五回的内容一直在调整内存的布局，把这块内存复制到那块，又把那块内存复制到这块，所以在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499558&amp;amp;idx=1&amp;amp;sn=d5d057fae2fb835d38f82804c2649463&amp;amp;chksm=c2c5858bf5b20c9de2db5c31dd34fbe766f6c46cda17f54f4518a75fc1838f2ada6fe5717aad&amp;amp;scene=21#wechat_redirect">第五回 | 进入保护模式前的最后一次折腾内存&lt;/a> 的结尾，我让你记住这样一张图，在很长一段时间这个内存布局的大体框架就不会再变了，前五回的内容你也可以抛在脑后了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-50-12-7c2f4af64e0ed98d08c634c33ae74404.png" alt="图片">&lt;/p>
&lt;p>从第六回开始往后，就是逐渐进入保护模式，并设置分段、分页、中断等机制的地方。最终的内存布局变成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-50-05-38240f8404e640c9770f44bdd3cd6507.png" alt="图片">&lt;/p>
&lt;p>你看，idtr 寄存器指向了 idt，这个就是中断的设置；gdtr 寄存器指向了 gdt，这个就是全局描述符表的设置，可以简单理解为分段机制的设置；cr3 寄存器指向了页目录表的位置，这个就是分页机制的设置。&lt;/p>
&lt;p>中断的设置，就引出了 CPU 与操作系统处理中断的流程。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-50-46-0cf2886a19323e5249f1d586d8e95b2b.jpg" alt="图片">&lt;/p>
&lt;p>分段和分页的设置，引出了逻辑地址到物理地址的转换。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-50-54-5e94c299d3d3667016e9b63e44abc0d2.png" alt="图片">&lt;/p>
&lt;p>具体来说，逻辑地址到线性地址的转换，依赖 Intel 的分段机制。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-51-02-e39b50ee2c579ffaf8b34f18f4237a42.png" alt="图片">&lt;/p>
&lt;p>而线性地址到物理地址的转换，依赖 Intel 的分页机制。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-51-11-1dedd0086f3c1636e423c07d1489c107.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>分段&lt;/strong>和&lt;strong>分页&lt;/strong>，就是 Intel 管理内存的两大利器，也是内存管理最最最最底层的支撑。&lt;/p>
&lt;p>而 Intel 本身对于访问内存就分成三类：&lt;/p>
&lt;p>&lt;strong>代码&lt;/strong>&lt;/p>
&lt;p>&lt;strong>数据&lt;/strong>&lt;/p>
&lt;p>&lt;strong>栈&lt;/strong>&lt;/p>
&lt;p>而 Intel 也提供了三个段寄存器来分别对应着三类内存：&lt;/p>
&lt;p>&lt;strong>代码段寄存器（cs）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>数据段寄存器（ds）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>栈段寄存器（ss）&lt;/strong>&lt;/p>
&lt;p>具体来说：&lt;/p>
&lt;p>&lt;strong>cs:eip&lt;/strong> 表示了我们要执行哪里的代码。&lt;/p>
&lt;p>&lt;strong>ds:xxx&lt;/strong> 表示了我们要访问哪里的数据。&lt;/p>
&lt;p>&lt;strong>ss:esp&lt;/strong> 表示了我们的栈顶地址在哪里。&lt;/p>
&lt;p>而第一部分的代码，也做了如下工作：&lt;/p>
&lt;p>将 &lt;strong>ds&lt;/strong> 设置为了 0x10，表示指向了索引值为 2 的全局描述符，即数据段描述符。&lt;/p>
&lt;p>将 &lt;strong>cs&lt;/strong> 通过一次长跳转指令设置为了 8，表示指向了索引值为 1 的全局描述符，即代码段描述符。&lt;/p>
&lt;p>将 &lt;strong>ss:esp&lt;/strong> 这个栈顶地址设置为 user_stack 数组的末端。&lt;/p>
&lt;p>你看，分段和分页，以及这几个寄存器的设置，其实本质上就是安排我们今后访问内存的方式，做了一个初步规划，&lt;strong>包括去哪找代码、去哪找数据、去哪找栈，以及如何通过分段和分页机制将逻辑地址转换为最终的物理地址&lt;/strong>。&lt;/p>
&lt;p>而所有上面说的这一切，和 Intel CPU 这个硬件打交道比较多，设置了一些最最最最基础的环境和内存布局，为之后进入 main 函数做了充分的准备，因为 c 语言虽然很底层了，但也有其不擅长的事情，就交给第一部分的汇编语言来做，所以我称第一部分为&lt;strong>进入内核前的苦力活&lt;/strong>。&lt;/p>
&lt;p>接下来，也就是从第二部分开始，我将会讲述 main.c 里的 main 函数，短短几行，包含了操作系统的全部核心思想。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">ROOT_DEV&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ORIG_ROOT_DEV&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">drive_info&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DRIVE_INFO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EXT_MEM_K&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>         
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">main_memory_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>敬请期待吧！&lt;/p>
&lt;p>另外，前十回几乎每一回都有资料扩展部分，基本是围绕着 Intel 手册，把一些文中提到的知识点在一手资料中给出标准答案，大家可以多看看，培养下自己看一手资料的习惯。&lt;/p>
&lt;p>由此也可以看出，前十回的苦力活，大部分是在和 Intel CPU 这个硬件打交道，因此阅读 Intel 技术手册从而了解 CPU 体系结构和机制，是理解这一切最直接和有效的办法。&lt;/p>
&lt;p>以下列出我所有让大家扩展阅读的资料&lt;/p>
&lt;p>有关寄存器的详细信息，可以参考 Intel 手册：&lt;/p>
&lt;p>Volume 1 Chapter 3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMEN&lt;/p>
&lt;p>如果想了解计算机启动时详细的初始化过程，还是得参考 Intel 手册：&lt;/p>
&lt;p>Volume 3A Chapter 9 PROCESSOR MANAGEMENT AND INITIALIZATION&lt;/p>
&lt;p>如果想了解汇编指令的信息，可以参考 Intel 手册：&lt;/p>
&lt;p>Volume 2 Chapter 3 ~ Chapter 5&lt;/p>
&lt;p>保护模式下逻辑地址到线性地址（不开启分页时就是物理地址）的转化，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4 Logical And Linear Addresses&lt;/p>
&lt;p>关于逻辑地址-线性地址-物理地址的转换，可以参考 Intel 手册：&lt;/p>
&lt;p>Intel 3A Chapter 3 Protected-Mode Memory Management&lt;/p>
&lt;p>段描述符结构和详细说明，看 Intel 手册：&lt;/p>
&lt;p>Volume 3 Chapter 3.4.5 Segment Descriptors&lt;/p>
&lt;p>页目录表和页表的具体结构，可以看&lt;/p>
&lt;p>Intel 3A Chapter 4.3 32-bit paging&lt;/p>
&lt;p>关于 ret 指令，其实 Intel CPU 是配合 call 设计的，有关 call 和 ret 指令，即调用和返回指令，可以参考 Intel 手册：&lt;/p>
&lt;p>Intel 1 Chapter 6.4 CALLING PROCEDURES USING CALL AND RET&lt;/p>
&lt;p>资料就摆在你眼前了，你再不去看，我就没办法咯，加油！&lt;/p></description></item><item><title>10.进入 main 函数前的最后一跃</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/10.%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E8%B7%83/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC1%E9%83%A8%E5%88%86/10.%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E8%B7%83/</guid><description>&lt;h1 id="10进入-main-函数前的最后一跃">10.进入 main 函数前的最后一跃&lt;/h1>
&lt;p>上回书咱们说到，我们终于把这些杂七杂八的，idt、gdt、页表都设置好了，并且也开启了保护模式，相当于所有苦力活都做好铺垫了，之后我们就要准备进入 main.c！那里是个新世界！&lt;/p>
&lt;p>注意不是进入，而是准备进入哦，就差一哆嗦了。&lt;/p>
&lt;p>由于上一讲的知识量非常大，所以这一讲将会非常简单，作为进入 main 函数前的衔接，大家放宽心。&lt;/p>
&lt;p>这仍然要回到上一讲我们跳转到设置分页代码的那个地方（head.s 里），这里有个骚操作帮我们跳转到 main.c。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">after_page_tables:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">_main&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">setup_paging&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="nl">setup_paging:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>直接解释起来非常简单。&lt;/p>
&lt;p>push 指令就是&lt;strong>压栈&lt;/strong>，五个 push 指令过去后，栈会变成这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-13-156eda85004701c15cf3e4b8f42a1009.png" alt="图片">&lt;/p>
&lt;p>然后注意，setup_paging 最后一个指令是 &lt;strong>ret&lt;/strong>，也就是我们上一回讲的设置分页的代码的最后一个指令，形象地说它叫&lt;strong>返回指令&lt;/strong>，但 CPU 可没有那么聪明，它并不知道该返回到哪里执行，只是很机械地&lt;strong>把栈顶的元素值当做返回地址&lt;/strong>，跳转去那里执行。&lt;/p>
&lt;p>再具体说是，把 esp 寄存器（栈顶地址）所指向的内存处的值，赋值给 eip 寄存器，而 cs:eip 就是 CPU 要执行的下一条指令的地址。而此时栈顶刚好是 main.c 里写的 main 函数的内存地址，是我们刚刚特意压入栈的，所以 CPU 就理所应当跳过来了。&lt;/p>
&lt;p>当然 Intel CPU 是设计了 call 和 ret 这一配对儿的指令，意为调用函数和返回，具体可以看后面本回扩展资料里的内容。&lt;/p>
&lt;p>至于其他压入栈的 L6 是用作当 main 函数返回时的跳转地址，但由于在操作系统层面的设计上，main 是绝对不会返回的，所以也就没用了。而其他的三个压栈的 0，本意是作为 main 函数的参数，但实际上似乎也没有用到，所以也不必关心。&lt;/p>
&lt;p>总之，经过这一个小小的骚操作，程序终于跳转到 main.c 这个由 c 语言写就的主函数 main 里了！我们先一睹为快一下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">ROOT_DEV&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ORIG_ROOT_DEV&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">drive_info&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DRIVE_INFO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EXT_MEM_K&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>         
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">main_memory_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>没错，这就是这个 main 函数的全部了。&lt;/p>
&lt;p>而整个操作系统也会最终停留在最后一行死循环中，永不返回，直到关机。&lt;/p>
&lt;p>好了，至此，整个第一部分就圆满结束了，为了跳进 main 函数的准备工作，我称之为进入内核前的苦力活，就完成了！我们看看我们做了什么。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-19-95de6488cde7af9dc9c3483b4006abdb.png" alt="图片">&lt;/p>
&lt;p>我把这些称为&lt;strong>进入内核前的苦力活&lt;/strong>，经过这样的流程，内存被搞成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-24-db3b5f601cc9850919800c42baa9b9c1.png" alt="图片">&lt;/p>
&lt;p>之后，main 方法就开始执行了，靠着我们辛辛苦苦建立起来的内存布局，向崭新的未来前进！&lt;/p>
&lt;p>欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展资料 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>关于 ret 指令，其实 Intel CPU 是配合 call 设计的，有关 call 和 ret 指令，即调用和返回指令，可以参考 Intel 手册：&lt;/p>
&lt;p>Intel 1 Chapter 6.4 CALLING PROCEDURES USING CALL AND RET&lt;/p>
&lt;p>可以看到还分为不改变段基址的 near call 和 near ret&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-30-84032e07ec13d82c05ffa1cf1171961b.png" alt="图片">&lt;/p>
&lt;p>以及改变段基址的 far call 和 far ret&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-35-4611f11048ec93378617d517223d342c.png" alt="图片">&lt;/p>
&lt;p>压栈和出栈的具体过程，上面文字写的清清楚楚，下面 Intel 手册还非常友好地放了张图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-40-4264be57f8e7c1a0b7b660d2cc6b6faa.png" alt="图片">&lt;/p>
&lt;p>可以看到，我们本文就是左边的那一套，把 main 函数地址值当做 Calling EIP 压入栈，仿佛是执行了 call 指令调用了一个函数一样，但实际上这是我们通过骚操作代码伪造的假象，骗了 CPU。&lt;/p>
&lt;p>然后 ret 的时候就把栈顶的那个 Calling EIP 也就是 main 函数地址弹出栈，存入 EIP 寄存器，这样 CPU 就相当于“返回”到了 main 函数开始执行。&lt;/p></description></item><item><title>11.整个操作系统就 20 几行代码</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/11.%E6%95%B4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%B120%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/11.%E6%95%B4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%B120%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81/</guid><description>&lt;h1 id="11整个操作系统就-20-几行代码">11.整个操作系统就 20 几行代码&lt;/h1>
&lt;p>在第一部分，用了总共十回的篇章，把进入 main 方法前的苦力工作都完成了，我们的程序终于跳到第一个由 c 语言写的，也是操作系统的全部代码骨架的地方，就是 main.c 文件里的 main 方法。&lt;/p>
&lt;p>数一数看，总共也就 20 几行代码。&lt;/p>
&lt;p>但这的确是操作系统启动流程的全部秘密了，我用空格将这个代码分成了几个部分。&lt;/p>
&lt;p>第一部分是一些参数的取值和计算。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">ROOT_DEV&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ORIG_ROOT_DEV&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">drive_info&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DRIVE_INFO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EXT_MEM_K&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>         
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">main_memory_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>包括&lt;strong>根设备 ROOT_DEV&lt;/strong>，之前在汇编语言中获取的各个设备的&lt;strong>参数信息 drive_info&lt;/strong>，以及通过计算得到的&lt;strong>内存边界&lt;/strong>&lt;/p>
&lt;p>main_memory_start&lt;/p>
&lt;p>main_memory_end&lt;/p>
&lt;p>buffer_memory_start&lt;/p>
&lt;p>buffer_memory_end&lt;/p>
&lt;p>从哪获得之前的设备参数信息呢？如果你前面看了，那一定还记得这个表，都是由 setup.s 这个汇编程序调用 BIOS 中断获取的各个设备的信息，并保存在约定好的内存地址 0x90000 处，现在这不就来取了么，我就不赘述了。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>内存地址&lt;/th>
&lt;th>长度(字节)&lt;/th>
&lt;th>名称&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x90000&lt;/td>
&lt;td>2&lt;/td>
&lt;td>光标位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90002&lt;/td>
&lt;td>2&lt;br>&lt;/td>
&lt;td>扩展内存数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90004&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显示页面&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90006&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>显示模式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90007&lt;/td>
&lt;td>1&lt;/td>
&lt;td>字符列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90008&lt;/td>
&lt;td>2&lt;/td>
&lt;td>未知&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000A&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>显示内存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000B&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>显示状态&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000C&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显卡特性参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000E&lt;/td>
&lt;td>1&lt;br>&lt;/td>
&lt;td>屏幕行数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000F&lt;/td>
&lt;td>1&lt;/td>
&lt;td>屏幕列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90080&lt;/td>
&lt;td>16&lt;br>&lt;/td>
&lt;td>硬盘1参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90090&lt;/td>
&lt;td>16&lt;/td>
&lt;td>硬盘2参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x901FC&lt;/td>
&lt;td>2&lt;br>&lt;/td>
&lt;td>根设备号&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>第二部分是各种初始化 &lt;strong>init&lt;/strong> 操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void main(void) {    ...    mem_init(main_memory_start,memory_end);    trap_init();    blk_dev_init();    chr_dev_init();    tty_init();    time_init();    sched_init();    buffer_init(buffer_memory_end);    hd_init();    floppy_init();    ...}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>包括&lt;strong>内存初始化 mem_init&lt;/strong>，&lt;strong>中断初始化 trap_init&lt;/strong>、&lt;strong>进程调度初始化 sched_init&lt;/strong> 等等。我们知道学操作系统知识的时候，其实就分成这么几块来学的，看来在操作系统源码上看，也确实是这么划分的，那我们之后照着源码慢慢品，就好了。&lt;/p>
&lt;p>第三部分是&lt;strong>切换到用户态模式&lt;/strong>，并在一个新的进程中做一个最终的初始化 init。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void main(void) {    ...    sti();    move_to_user_mode();    if (!fork()) {        init();    }    ...}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 init 函数里会创建出一个进程，设置终端的标准 IO，并且再创建出一个执行 shell 程序的进程用来接受用户的命令，到这里其实就出现了我们熟悉的画面（下面是 bochs 启动 Linux 0.11 后的画面）。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-51-46-0657cf01aa84e1e8b41e2bbb5fdd34e2.png" alt="图片">&lt;/p>
&lt;p>第四部分是个&lt;strong>死循环&lt;/strong>，如果没有任何任务可以运行，操作系统会一直陷入这个死循环无法自拔。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>OK，不要细品每一句话，我们本回就是要你有个整体印象，之后会细细讲这里的每一个部分。&lt;/p>
&lt;p>这里再放上目前的内存布局图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-51-54-577c7164fbe2af172d3e6a6ad2156a92.png" alt="图片">&lt;/p>
&lt;p>这个图大家一定要牢记在心，操作系统说白了就是在内存中放置各种的数据结构，来实现“管理”的功能。&lt;/p>
&lt;p>所以之后我们的学习过程，主心骨其实就是看看，操作系统在经过一番折腾后，又在内存中建立了什么数据结构，而这些数据结构后面又是如何用到的。&lt;/p>
&lt;p>比如进程管理，就是在内存中建立好多复杂的数据结构用来记录进程的信息，再配合上进程调度的小算法，完成了进程这个强大的功能。&lt;/p>
&lt;p>为了让大家目前心里有个底，我们把前面的工作再再再再在这里做一个回顾，用一张图表示就是：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-52-02-b132907e3383fd6714732ab52a2c7920.png" alt="图片">&lt;/p>
&lt;p> &lt;/p>
&lt;p>看到了吧，我们已经把 boot 文件夹下的三个汇编文件的全部代码都一行一行品读过了，其主要功能就是三张表的设置：全局描述符表、中断描述符表、页表。同时还设置了各种段寄存器，栈顶指针。并且，还为后续的程序提供了设备信息，保存在 0x90000 处往后的几个位置上。&lt;/p>
&lt;p>最后，一个华丽的跳转，将程序跳转到了 main.c 文件里的 main 函数中。&lt;/p>
&lt;p>所以，本讲就是让大家深呼吸，把之前的准备工作再消化消化。如果第一部分全部认真看过的同学，必定觉得这一回是废话。&lt;/p>
&lt;p>如果你不这样觉得，那就得再回去重新梳理一边咯，如果有不会的，赶紧查资料搞懂它，因为之后要打一系列的硬仗了！根基不稳，地动山摇！&lt;/p></description></item><item><title>12.管理内存前先划分出三个边界值</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/12.%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E5%89%8D%E5%85%88%E5%88%92%E5%88%86%E5%87%BA%E4%B8%89%E4%B8%AA%E8%BE%B9%E7%95%8C%E5%80%BC/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/12.%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E5%89%8D%E5%85%88%E5%88%92%E5%88%86%E5%87%BA%E4%B8%89%E4%B8%AA%E8%BE%B9%E7%95%8C%E5%80%BC/</guid><description>&lt;h1 id="12管理内存前先划分出三个边界值">12.管理内存前先划分出三个边界值&lt;/h1>
&lt;p>上回书咱们回顾了一下 main.c 函数之前我们做的全部工作，给进入 main 函数做了一个充分的准备。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-52-14-b132907e3383fd6714732ab52a2c7920.png" alt="图片">&lt;/p>
&lt;p>那今天我们就话不多说，从 main 函数的第一行代码开始读。&lt;/p>
&lt;p>还是把 main 的全部代码都先写出来，很少。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">ROOT_DEV&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ORIG_ROOT_DEV&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">drive_info&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DRIVE_INFO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EXT_MEM_K&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>         
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">main_memory_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>      
        &lt;span class="cm">/* we count on this going ok */&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们今天就看这第一小段。&lt;/p>
&lt;p>首先，ROOT_DEV 为系统的根文件设备号，drive_info 为之前 setup.s 程序获取并存储在内存 0x90000 处的设备信息，我们先不管这俩，等之后用到了再说。&lt;/p>
&lt;p>我们看后面这一坨很影响整体画风的一段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EXT_MEM_K&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>         
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">main_memory_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这一坨代码和后面规规整整的 xxx_init 平级的位置，要是我们这么写代码，肯定被老板批评，被同事鄙视了。但 Linus 写的，就是经典，学就完事了。&lt;/p>
&lt;p>这一坨代码虽然很乱，但仔细看就知道它只是为了计算出三个变量罢了。&lt;/p>
&lt;p>&lt;strong>main_memory_start&lt;/strong>&lt;/p>
&lt;p>&lt;strong>memory_end&lt;/strong>&lt;/p>
&lt;p>&lt;strong>buffer_memory_end&lt;/strong>&lt;/p>
&lt;p>而观察最后一行代码发现，其实两个变量是相等的，所以其实仅仅计算出了两个变量。&lt;/p>
&lt;p>&lt;strong>main_memory_start&lt;/strong>&lt;/p>
&lt;p>&lt;strong>memory_end&lt;/strong>&lt;/p>
&lt;p>然后再具体分析这个逻辑，其实就是一堆 if else 判断而已，判断的标准都是 memory_end 也就是内存最大值的大小，而这个内存最大值由第一行代码可以看出，是等于 1M + 扩展内存大小。&lt;/p>
&lt;p>那 ok 了，&lt;strong>其实就只是针对不同的内存大小，设置不同的边界值罢了&lt;/strong>，为了理解它，我们完全没必要考虑这么周全，就假设总内存一共就 &lt;strong>8M&lt;/strong> 大小吧。&lt;/p>
&lt;p>那么如果内存为 8M 大小，&lt;strong>memory_end&lt;/strong> 就是&lt;/p>
&lt;p>8 * 1024 * 1024&lt;/p>
&lt;p>也就只会走倒数第二个分支，那么 &lt;strong>buffer_memory_end&lt;/strong> 就为&lt;/p>
&lt;p>2 * 1024 * 1024&lt;/p>
&lt;p>那么 &lt;strong>main_memory_start&lt;/strong> 也为&lt;/p>
&lt;p>2 * 1024 * 1024&lt;/p>
&lt;p>那这些值有什么用呢？一张图就给你说明白了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-52-25-971226124a833d3dbe81d79fd19880a1.png" alt="图片">&lt;/p>
&lt;p>你看，其实就是定了三个箭头所指向的地址的三个边界变量，具体主内存区是如何管理和分配的，要看下面代码的功劳。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而缓冲区是如何管理和分配的，就要看&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是如何折腾的了。&lt;/p>
&lt;p>那我们今天就不背着这两个负担了，仅仅需要知道这三个参数的计算，以及后面是为谁效力的，就好啦，是不是很轻松？后面我们再讲，如何利用这三个参数，来做到内存的管理。&lt;/p></description></item><item><title>13.主内存初始化mem_init</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/13.%E4%B8%BB%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96mem_init/</link><pubDate>Wed, 03 Jan 2024 21:41:02 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/13.%E4%B8%BB%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96mem_init/</guid><description>&lt;h1 id="13主内存初始化mem_init">13.主内存初始化mem_init&lt;/h1>
&lt;p>今天我们不聊具体内存管理的算法，我们就来看看，操作系统用什么样的一张表，达到了管理内存的效果。&lt;/p>
&lt;p>我们以 Linux 0.11 源码为例，发现进入内核的 main 函数后不久，有这样一坨代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void main(void) {    
    ...    
    memory_end = (1&amp;lt;&amp;lt;20) + (EXT_MEM_K&amp;lt;&amp;lt;10);    
    memory_end &amp;amp;= 0xfffff000;    
    if (memory_end &amp;gt; 16*1024*1024)        
        memory_end = 16*1024*1024;    
    if (memory_end &amp;gt; 12*1024*1024)         
        buffer_memory_end = 4*1024*1024;    
    else if (memory_end &amp;gt; 6*1024*1024)        
        buffer_memory_end = 2*1024*1024;    
    else        
        buffer_memory_end = 1*1024*1024;    
    main_memory_start = buffer_memory_end;    
    mem_init(main_memory_start,memory_end);    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>除了最后一行外，前面的那一大坨的作用很简单。&lt;/p>
&lt;p>&lt;strong>其实就只是针对不同的内存大小，设置不同的边界值罢了&lt;/strong>，为了理解它，我们完全没必要考虑这么周全，就假设总内存一共就 &lt;strong>8M&lt;/strong> 大小吧。&lt;/p>
&lt;p>那么如果内存为 8M 大小，&lt;strong>memory_end&lt;/strong> 就是&lt;/p>
&lt;p>8 * 1024 * 1024&lt;/p>
&lt;p>也就只会走倒数第二个分支，那么 &lt;strong>buffer_memory_end&lt;/strong> 就为&lt;/p>
&lt;p>2 * 1024 * 1024&lt;/p>
&lt;p>那么 &lt;strong>main_memory_start&lt;/strong> 也为&lt;/p>
&lt;p>2 * 1024 * 1024&lt;/p>
&lt;p>你仔细看看代码逻辑，看是不是这样？&lt;/p>
&lt;p>当然，你不愿意细想也没关系，上述代码执行后，就是如下效果而已。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-52-38-e0cc100badd0bbd46572c76e476884aa.png" alt="图片">&lt;/p>
&lt;p>你看，其实就是定了三个箭头所指向的地址的三个边界变量。具体主内存区是如何管理和分配的，要看 mem_init 里做了什么。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void main(void) {    ...    mem_init(main_memory_start, memory_end);    ...}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而缓冲区是如何管理和分配的，就要看再后面的 buffer_init 里干了什么。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void main(void) {    ...    buffer_init(buffer_memory_end);    ...}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不过我们今天只看，主内存是如何管理的，很简单，放轻松。&lt;/p>
&lt;p>进入 mem_init 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define LOW_MEM 0x100000#define PAGING_MEMORY (15*1024*1024)
&lt;/span>&lt;span class="cp">#define PAGING_PAGES (PAGING_MEMORY&amp;gt;&amp;gt;12)
&lt;/span>&lt;span class="cp">#define MAP_NR(addr) (((addr)-LOW_MEM)&amp;gt;&amp;gt;12)
&lt;/span>&lt;span class="cp">#define USED 100
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">HIGH_MEMORY&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">PAGING_PAGES&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="c1">// start_mem = 2 * 1024 * 1024
&lt;/span>&lt;span class="c1">// end_mem = 8 * 1024 * 1024
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">start_mem&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">end_mem&lt;/span>&lt;span class="p">){&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">HIGH_MEMORY&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">end_mem&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">PAGING_PAGES&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
    &lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">USED&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MAP_NR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start_mem&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="n">end_mem&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">start_mem&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">end_mem&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;=&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">end_mem&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>发现也没几行，而且并没有更深的方法调用，看来是个好欺负的方法。&lt;/p>
&lt;p>仔细一看这个方法，其实折腾来折腾去，就是给一个 &lt;strong>mem_map&lt;/strong> 数组的各个位置上赋了值，而且显示全部赋值为 USED 也就是 100，然后对其中一部分又赋值为了 0。&lt;/p>
&lt;p>赋值为 100 的部分就是 USED，也就表示内存被占用，如果再具体说是占用了 100 次，这个之后再说。剩下赋值为 0 的部分就表示未被使用，也即使用次数为零。&lt;/p>
&lt;p>是不是很简单？&lt;strong>就是准备了一个表，记录了哪些内存被占用了，哪些内存没被占用&lt;/strong>。这就是所谓的“管理”，并没有那么神乎其神。&lt;/p>
&lt;p>那接下来自然有两个问题，每个元素表示占用和未占用，这个表示的范围是多大？初始化时哪些地方是占用的，哪些地方又是未占用的？&lt;/p>
&lt;p>还是一张图就看明白了，我们仍然假设内存总共只有 8M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-52-47-510fa98ab0ed6f2c146d433185eaccb8.png" alt="图片">&lt;/p>
&lt;p>可以看出，初始化完成后，其实就是 mem_map 这个数组的每个元素都代表一个 4K 内存是否空闲（准确说是使用次数）。&lt;/p>
&lt;p>4K 内存通常叫做 1 页内存，而这种管理方式叫&lt;strong>分页管理&lt;/strong>，就是把内存分成一页一页（4K）的单位去管理。&lt;/p>
&lt;p>1M 以下的内存这个数组干脆没有记录，这里的内存是无需管理的，或者换个说法是无权管理的，也就是没有权利申请和释放，因为这个区域是内核代码所在的地方，不能被“污染”。&lt;/p>
&lt;p>1M 到 2M 这个区间是&lt;strong>缓冲区&lt;/strong>，2M 是缓冲区的末端，缓冲区的开始在哪里之后再说，这些地方不是主内存区域，因此直接标记为 USED，产生的效果就是无法再被分配了。&lt;/p>
&lt;p>2M 以上的空间是&lt;strong>主内存区域&lt;/strong>，而主内存目前没有任何程序申请，所以初始化时统统都是零，未来等着应用程序去申请和释放这里的内存资源。&lt;/p>
&lt;p>那应用程序如何申请内存呢？我们本讲不展开，不过我们简单展望一下，看看申请内存的过程中，是如何使用 mem_map 这个结构的。&lt;/p>
&lt;p>在 &lt;strong>memory.c&lt;/strong> 文件中有个函数 &lt;strong>get_free_page()&lt;/strong>，用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。&lt;/p>
&lt;p>比如我们在 fork 子进程的时候，会调用 &lt;strong>copy_process&lt;/strong> 函数来复制进程的结构信息，其中有一个步骤就是要&lt;strong>申请一页内存&lt;/strong>，用于存放进程结构信息 task_struct。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们看 get_free_page 的具体实现，是内联汇编代码，看不懂不要紧，注意它里面就有 &lt;strong>mem_map&lt;/strong> 结构的使用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">get_free_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">register&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">__res&lt;/span> &lt;span class="k">asm&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;ax&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">__asm__&lt;/span>&lt;span class="p">(&lt;/span>        
        &lt;span class="s">&amp;#34;std ; repne ; scasb&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;jne 1f&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;movb $1,1(%%edi)&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;sall $12,%%ecx&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;addl %2,%%ecx&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;movl %%ecx,%%edx&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;movl $1024,%%ecx&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;leal 4092(%%edx),%%edi&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;rep ; stosl&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;movl %%edx,%%eax&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>        
        &lt;span class="s">&amp;#34;1:&amp;#34;&lt;/span>        
        &lt;span class="o">:&lt;/span>&lt;span class="s">&amp;#34;=a&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">__res&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="o">:&lt;/span>&lt;span class="s">&amp;#34;0&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="s">&amp;#34;i&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">LOW_MEM&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="s">&amp;#34;c&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">PAGING_PAGES&lt;/span>&lt;span class="p">),&lt;/span>        
        &lt;span class="s">&amp;#34;D&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">mem_map&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">PAGING_PAGES&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="o">:&lt;/span>&lt;span class="s">&amp;#34;di&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;cx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;dx&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">__res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是选择 mem_map 中首个空闲页面，并标记为已使用。&lt;/p>
&lt;p>好了，本讲就这么多，只是填写了一张大表而已，简单吧？之后的内存申请与释放等骚操作，统统是跟着张大表 &lt;strong>mem_map&lt;/strong> 打交道而已，你一定要记住它哦。&lt;/p></description></item></channel></rss>