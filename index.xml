<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 02 Jan 2024 18:45:57 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Intel 内存管理两板斧：分段与分页</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC1%E9%83%A8%E5%88%86/09.intel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%A4%E6%9D%BF%E6%96%A7_%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5/</link><pubDate>Tue, 02 Jan 2024 18:45:57 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC1%E9%83%A8%E5%88%86/09.intel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%A4%E6%9D%BF%E6%96%A7_%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5/</guid><description>&lt;h1 id="intel-内存管理两板斧分段与分页">Intel 内存管理两板斧：分段与分页&lt;/h1>
&lt;p>head.s 代码在重新设置了 gdt 与 idt 后。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-03-43-e5a3467caa9f51f269e0f1c3fbadbe21.png" alt="图片">&lt;/p>
&lt;p>来到了这样一段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">after_page_tables&lt;/span>
&lt;span class="nf">...&lt;/span>
&lt;span class="nl">after_page_tables:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">_main&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">setup_paging&lt;/span>
&lt;span class="nl">L6:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那就是开启分页机制，并且跳转到 main 函数。&lt;/p>
&lt;p>如何跳转到之后用 c 语言写的 main.c 里的 main 函数，是个有趣的事，也包含在这段代码里。不过我们先瞧瞧这&lt;strong>分页机制&lt;/strong>是如何开启的，也就是 &lt;strong>setup_paging&lt;/strong> 这个标签处的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">setup_paging:&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">ecx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">5&lt;/span>
&lt;span class="nf">xor&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="nf">xor&lt;/span> &lt;span class="nb">edi&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">edi&lt;/span>
&lt;span class="nf">pushf&lt;/span>
&lt;span class="nf">cld&lt;/span>
&lt;span class="nf">rep&lt;/span> &lt;span class="nv">stosd&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">edi&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4092&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">00fff007h&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">std&lt;/span>
&lt;span class="nl">L3:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">stosd&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">sub&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">00001000h&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jge&lt;/span> &lt;span class="nv">L3&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">popf&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">xor&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">cr3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">cr0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">or&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">80000000h&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">mov&lt;/span> &lt;span class="nb">cr0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>别怕，我们一点点来分析。&lt;/p>
&lt;p>首先要了解的就是，啥是分页机制？&lt;/p>
&lt;p>还记不记得之前我们在代码中给出一个内存地址，在保护模式下要先经过分段机制的转换，才能最终变成物理地址，就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-03-50-e39b50ee2c579ffaf8b34f18f4237a42.png" alt="图片">&lt;/p>
&lt;p>这是在没有开启分页机制的时候，只需要经过这一步转换即可得到最终的物理地址了，但是在开启了分页机制后，又会&lt;strong>多一步转换&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-03-55-5e94c299d3d3667016e9b63e44abc0d2.png" alt="图片">&lt;/p>
&lt;p>也就是说，在没有开启分页机制时，由程序员给出的&lt;strong>逻辑地址&lt;/strong>，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是&lt;strong>线性地址&lt;/strong>，然后再通过一次分页机制转换，得到最终的物理地址。&lt;/p>
&lt;p>分段机制我们已经清楚如何对地址进行变换了，那分页机制又是如何变换的呢？我们直接以一个例子来学习过程。&lt;/p>
&lt;p>比如我们的线性地址（已经经过了分段机制的转换）是&lt;/p>
&lt;p>15M&lt;/p>
&lt;p>二进制表示就是&lt;/p>
&lt;p>0000000011_0100000000_000000000000&lt;/p>
&lt;p>我们看一下它的转换过程&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-00-1dedd0086f3c1636e423c07d1489c107.png" alt="图片">&lt;/p>
&lt;p>也就是说，CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成&lt;/p>
&lt;p>高 10 位：中间 10 位：后 12 位&lt;/p>
&lt;p>高 10 位负责在&lt;strong>页目录表&lt;/strong>中找到一个&lt;strong>页目录项&lt;/strong>，这个页目录项的值加上中间 10 位拼接后的地址去&lt;strong>页表&lt;/strong>中去寻找一个&lt;strong>页表项&lt;/strong>，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。&lt;/p>
&lt;p>而这一切的操作，都由计算机的一个硬件叫 &lt;strong>MMU&lt;/strong>，中文名字叫&lt;strong>内存管理单元&lt;/strong>，有时也叫 PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。&lt;/p>
&lt;p>所以整个过程我们不用操心，作为操作系统这个软件层，只需要提供好页目录表和页表即可，这种页表方案叫做&lt;strong>二级页表&lt;/strong>，第一级叫&lt;strong>页目录表 PDE&lt;/strong>，第二级叫&lt;strong>页表 PTE&lt;/strong>。他们的结构如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-05-9d10c38f804b5f9a1bb86bb9ab143699.png" alt="图片">&lt;/p>
&lt;p>之后再开启分页机制的开关。其实就是更改 &lt;strong>cr0&lt;/strong> 寄存器中的一位即可（31 位），还记得我们开启保护模式么，也是改这个寄存器中的一位的值。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-11-11728d8426c69ca78cb1920b3f86f533.png" alt="图片">&lt;/p>
&lt;p>然后，MMU 就可以帮我们进行分页的转换了。此后指令中的内存地址（就是程序员提供的逻辑地址），就统统要先经过分段机制的转换，再通过分页机制的转换，才能最终变成物理地址。&lt;/p>
&lt;p>所以这段代码，就是帮我们把页表和页目录表在内存中写好，之后开启 cr0 寄存器的分页开关，仅此而已，我们再把代码贴上来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">setup_paging: mov ecx,1024*5 xor eax,eax xor edi,edi pushf cld rep stosd mov eax,_pg_dir mov [eax],pg0+7 mov [eax+4],pg1+7 mov [eax+8],pg2+7 mov [eax+12],pg3+7 mov edi,pg3+4092 mov eax,00fff007h stdL3: stosd sub eax,00001000h jge L3 popf xor eax,eax mov cr3,eax mov eax,cr0 or eax,80000000h mov cr0,eax ret
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们先说这段代码最终产生的效果吧。&lt;/p>
&lt;p>当时 linux-0.11 认为，总共可以使用的内存不会超过 &lt;strong>16M&lt;/strong>，也即最大地址空间为 &lt;strong>0xFFFFFF&lt;/strong>。&lt;/p>
&lt;p>而按照当前的页目录表和页表这种机制，1 个页目录表最多包含 1024 个页目录项（也就是 1024 个页表），1 个页表最多包含 1024 个页表项（也就是 1024 个页），1 页为 4KB（因为有 12 位偏移地址），因此，16M 的地址空间可以用 1 个页目录表 + 4 个页表搞定。&lt;/p>
&lt;p>4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB&lt;/p>
&lt;p>所以，上面这段代码就是，&lt;strong>将页目录表放在内存地址的最开头&lt;/strong>，还记得上一讲开头让你留意的 _pg_dir 这个标签吧？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">_pg_dir:
_startup_32:
    mov eax,0x10
    mov ds,ax
    ...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>之后紧挨着这个页目录表，放置 4 个页表&lt;/strong>，代码里也有这四个页表的标签项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">.org 0x1000 pg0:
.org 0x2000 pg1:
.org 0x3000 pg2:
.org 0x4000 pg3:
.org 0x5000
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终将页目录表和页表填写好数值，来覆盖整个 16MB 的内存。随后，开启分页机制。此时内存中的页表相关的布局如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-17-d8c5ccab8f627ac9f184d268dd6e42bf.png" alt="图片">&lt;/p>
&lt;p>这些页目录表和页表放到了整个内存布局中最开头的位置，就是覆盖了开头的 system 代码了，不过被覆盖的 system 代码已经执行过了，所以无所谓。&lt;/p>
&lt;p>同时，如 idt 和 gdt 一样，我们也需要通过一个寄存器告诉 CPU 我们把这些页表放在了哪里，就是这段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">xor&lt;/span> &lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="nb">cr3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">eax&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你看，我们相当于告诉 cr3 寄存器，&lt;strong>0 地址处就是页目录表，再通过页目录表可以找到所有的页表&lt;/strong>，也就相当于 CPU 知道了分页机制的全貌了。&lt;/p>
&lt;p>至此后，整个内存布局如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-22-38240f8404e640c9770f44bdd3cd6507.png" alt="图片">&lt;/p>
&lt;p>那么具体页表设置好后，映射的内存是怎样的情况呢？那就要看页表的具体数据了，就是这一坨代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">setup_paging:
    ...
    mov eax,_pg_dir
    mov [eax],pg0+7
    mov [eax+4],pg1+7
    mov [eax+8],pg2+7
    mov [eax+12],pg3+7
    mov edi,pg3+4092
    mov eax,00fff007h
    stdL3: stosd    
    sub eax, 1000h    
    jpe L3
    ...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，对照刚刚的页目录表与页表结构看。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-27-9d10c38f804b5f9a1bb86bb9ab143699.png" alt="图片">&lt;/p>
&lt;p>前五行表示，页目录表的前 4 个页目录项，分别指向 4 个页表。比如页目录项中的第一项 &lt;strong>[eax]&lt;/strong> 被赋值为 &lt;strong>pg0+7&lt;/strong>，也就是 &lt;strong>0x00001007&lt;/strong>，根据页目录项的格式，表示页表地址为 &lt;strong>0x1000&lt;/strong>，页属性为 &lt;strong>0x07&lt;/strong> 表示改页存在、用户可读写。&lt;/p>
&lt;p>后面几行表示，填充 4 个页表的每一项，一共 &lt;strong>4*1024=4096&lt;/strong> 项，依次映射到内存的前 16MB 空间。&lt;/p>
&lt;p>画出图就是这个样子，其实刚刚的图就是。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-34-1dedd0086f3c1636e423c07d1489c107.png" alt="图片">&lt;/p>
&lt;p>看，最终的效果就是，经过这套分页机制，&lt;strong>线性地址将恰好和最终转换的物理地址一样&lt;/strong>。&lt;/p>
&lt;p>现在只有四个页目录项，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-39-dd889ce71a3449d8d38c336e5a2bbdc3.png" alt="图片">&lt;/p>
&lt;p>好了，我知道你目前可能有点晕头转向，关于地址，我们已经出现了好多词了，包括&lt;strong>逻辑地址&lt;/strong>、&lt;strong>线性地址&lt;/strong>、&lt;strong>物理地址&lt;/strong>，以及本文中没出现的，你可能在很多地方看到过的&lt;strong>虚拟地址&lt;/strong>。&lt;/p>
&lt;p>而这些地址后面加上空间两个字，似乎又成为了一个新词，比如&lt;strong>线性地址空间&lt;/strong>、&lt;strong>物理地址空间&lt;/strong>、&lt;strong>虚拟地址空间&lt;/strong>等。&lt;/p>
&lt;p>那就是时候展开一波讨论，将这块的内容梳理一番了，且听我说。&lt;/p>
&lt;p>Intel 体系结构的&lt;strong>内存管理&lt;/strong>可以分成两大部分，也就是标题中的两板斧，&lt;strong>分段&lt;/strong>和&lt;strong>分页&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>分段机制&lt;/strong>在之前几回已经讨论过多次了，其目的是为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。&lt;/p>
&lt;p>&lt;strong>分页机制&lt;/strong>是本回讲的内容，开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。其目的在于可以按需使用物理内存，同时也可以在多任务时起到隔离的作用，这个在后面将多任务时将会有所体会。&lt;/p>
&lt;p>在 Intel 的保护模式下，分段机制是没有开启和关闭一说的，它必须存在，而分页机制是可以选择开启或关闭的。所以如果有人和你说，它实现了一个没有分段机制的操作系统，那一定是个外行。&lt;/p>
&lt;p>再说说那些地址：&lt;/p>
&lt;p>&lt;strong>逻辑地址&lt;/strong>：我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。&lt;/p>
&lt;p>&lt;strong>线性地址&lt;/strong>：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。&lt;/p>
&lt;p>&lt;strong>物理地址&lt;/strong>：就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。&lt;/p>
&lt;p>&lt;strong>虚拟地址&lt;/strong>：如果没有开启分页机制，那么线性地址就和物理地址是一一对应的，可以理解为相等。如果开启了分页机制，那么线性地址将被视为虚拟地址，这个虚拟地址将会通过分页机制的转换，最终转换成物理地址。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-44-5e94c299d3d3667016e9b63e44abc0d2.png" alt="图片">&lt;/p>
&lt;p>但实际上，我本人是不喜欢虚拟地址这个叫法的，因为它在 Intel 标准手册上出现的次数很少，我觉得知道逻辑地址、线性地址、物理地址这三个概念就够了，逻辑地址是程序员给出的，经过分段机制转换后变成线性地址，然后再经过分页机制转换后变成物理地址，就这么简单。&lt;/p>
&lt;p>好了，我们终于把这些杂七杂八的，idt、gdt、页表都设置好了，并且也开启了保护模式，之后我们就要做好进入 main.c 的准备了，那里是个新世界！&lt;/p>
&lt;p>不过进入 main.c 之前还差最后一哆嗦，就是 head.s 最后的代码，也就是本文开头的那段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">after_page_tables&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="nl">after_page_tables:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">_main&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">setup_paging&lt;/span>
&lt;span class="nl">L6:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到没，这里有个 push _main，把 main 函数的地址压栈了，那最终跳转到这个 main.c 里的 main 函数，一定和这个压栈有关。&lt;/p>
&lt;p>压栈为什么和跳转到这里还能联系上呢？留作本文思考题，下一篇将揭秘这个过程，你会发现仍然简单得要死。&lt;/p>
&lt;p>欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展资料 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>关于逻辑地址-线性地址-物理地址的转换，可以参考 Intel 手册：&lt;/p>
&lt;p>Intel 3A Chapter 3 Protected-Mode Memory Management&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-50-6173d7b155edf1163656a92accadfd50.png" alt="图片">&lt;/p>
&lt;p>而有关这些地址的定义和说明，在本小节中也做了详细的说明，看这里的介绍是最权威也是最透彻的。相信我，它很简单。&lt;/p>
&lt;p>页目录表和页表的具体结构，可以看&lt;/p>
&lt;p>Intel 3A Chapter 4.3 32-bit paging&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-04-55-7ce1ce0354904b2535f1293057c855e7.png" alt="图片">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-00-dc74426a214fda8f1885299cfb8d4dbc.png" alt="图片">&lt;/p></description></item><item><title>一个新进程的诞生（七）透过 fork 来看进程的内存规划</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/27.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 02 Jan 2024 18:45:57 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/27.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="一个新进程的诞生七透过-fork-来看进程的内存规划">一个新进程的诞生（七）透过 fork 来看进程的内存规划&lt;/h1>
&lt;p>书接上回，上回书咱们说到，&lt;strong>fork&lt;/strong> 函数为新的进程（进程 1）申请了槽位，并把全部 &lt;strong>task_struct&lt;/strong> 结构的值都从进程零复制了过来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-44-7970d5e1e0f763b9e0e69afd9dbebfa3.png" alt="图片">&lt;/p>
&lt;p>之后，覆盖了新进程自己的基本信息，包括元信息和 tss 里的寄存器信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">..&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">edx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ebx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这可以说将 fork 函数的一半都讲完了，那我们今天展开讲讲另一半，也就是 &lt;strong>copy_mem&lt;/strong> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这将会决定进程之间的内存规划问题，十分精彩，我们开始吧。&lt;/p>
&lt;hr>
&lt;p>整个函数不长，我们还是试着先直译一下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 局部描述符表 LDT 赋值    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">old_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">data_limit&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">old_code_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">code_limit&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">code_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x0f&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">data_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x17&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">new_code_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">new_data_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 拷贝页表    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">old_code_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">old_data_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">data_limit&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，其实就是&lt;strong>新进程 LDT 表项的赋值，以及页表的拷贝&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>LDT 的赋值&lt;/strong>&lt;/p>
&lt;p>那我们先看 LDT 表项的赋值，要说明白这个赋值的意义，得先回忆一下我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499821&amp;amp;idx=1&amp;amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;amp;scene=21#wechat_redirect">第九回 | Intel 内存管理两板斧：分段与分页&lt;/a> 刚设置完页表时说过的问题。&lt;/p>
&lt;p>程序员给出的逻辑地址最终转化为物理地址要经过这几步骤。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-38-87c01d12d6cdfe079ed2674d79751a78.png" alt="图片">&lt;/p>
&lt;p>而我们已经开启了分页，那么分页机制的具体转化是这样的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-33-49c4c8a3621c3dd867e0c3c89e366ac0.png" alt="图片">&lt;/p>
&lt;p>因为有了页表的存在，所以多了&lt;strong>线性地址空间&lt;/strong>的概念，即经过分段机制转化后，分页机制转化前的地址。&lt;/p>
&lt;p>不考虑段限长的话，32 位的 CPU 线性地址空间应为 4G。现在只有四个页目录表，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-28-f1f35edd25b98b1ce4c089865d91da64.png" alt="图片">&lt;/p>
&lt;p>把这个图和全局描述符表 GDT 联系起来，这个线性地址空间，就是经过分段机制（段可能是 GDT 也可能是 LDT）后的地址，是这样对应的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-22-17ac5f973da5f1a9aaac30b117e9f9e3.png" alt="图片">&lt;/p>
&lt;p>我们给进程 0 准备的 LDT 的代码段和数据段，段基址都是 0，段限长是 640K。给进程 1，也就是我们现在正在 fork 的这个进程，其代码段和数据段还没有设置。&lt;/p>
&lt;p>所以第一步，&lt;strong>局部描述符表 LDT 的赋值&lt;/strong>，就是给上图中那两个还未设置的代码段和数据段赋值。&lt;/p>
&lt;p>其中&lt;strong>段限长&lt;/strong>，就是取自进程 0 设置好的段限长，也就是 640K。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">code_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x0f&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">data_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x17&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而&lt;strong>段基址&lt;/strong>有点意思，是取决于当前是几号进程，也就是 nr 的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_mem(int nr,struct task_struct * p) {    
    ...    
    new_code_base = nr * 0x4000000;    
    new_data_base = nr * 0x4000000;    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的 0x4000000 等于 64M。&lt;/p>
&lt;p>也就是说，今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间（暂不考虑段限长），且紧挨着。&lt;/p>
&lt;p>接着就把 LDT 设置进了 LDT 表里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_mem(int nr,struct task_struct * p) {    ...    set_base(p-&amp;gt;ldt[1],new_code_base);    set_base(p-&amp;gt;ldt[2],new_data_base);    ...}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终效果如图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-16-aa192a75588df6873a9c46c74c7c174a.png" alt="图片">&lt;/p>
&lt;p>经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是&lt;strong>段式&lt;/strong>管理。&lt;/p>
&lt;p>当然，Linux 0.11 不但是分段管理，也开启了分页管理，最终形成&lt;strong>段页式&lt;/strong>的管理方式。这就涉及到下面要说的，页表的复制。&lt;/p>
&lt;p>&lt;strong>页表的复制&lt;/strong>&lt;/p>
&lt;p>OK，上面刚刚讲完段表的赋值，接下来就是页表的复制了，这也是 copy_mem 函数里的最后一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_mem(int nr,struct task_struct * p) {    
    ...    
    // old=0, new=64M, limit=640K    
    copy_page_tables(old_data_base,new_data_base,data_limit)
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>原来进程 0 有&lt;strong>一个页目录表&lt;/strong>和&lt;strong>四个页表&lt;/strong>，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-11-f1f35edd25b98b1ce4c089865d91da64.png" alt="图片">&lt;/p>
&lt;p>那么新诞生的这个进程 2，也需要一套映射关系的页表，那我们看看这些页表是怎么建立的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">/* 
*  Well, here is one of the most complicated functions in mm. It 
* copies a range of linerar addresses by copying only the pages. 
* Let&amp;#39;s hope this is bug-free, &amp;#39;cause this one I don&amp;#39;t want to debug :-) 
*/
int copy_page_tables(unsigned long from,unsigned long to,long size){    
    unsigned long * from_page_table;    
    unsigned long * to_page_table;    
    unsigned long this_page;    
    unsigned long * from_dir, * to_dir;    
    unsigned long nr;    
    from_dir = (unsigned long *) ((from&amp;gt;&amp;gt;20) &amp;amp; 0xffc);    
    to_dir = (unsigned long *) ((to&amp;gt;&amp;gt;20) &amp;amp; 0xffc);    
    size = ((unsigned) (size+0x3fffff)) &amp;gt;&amp;gt; 22;    
    for( ; size--&amp;gt;0 ; from_dir++,to_dir++) {        
        if (!(1 &amp;amp; *from_dir))            
            continue;        
        from_page_table = (unsigned long *) (0xfffff000 &amp;amp; *from_dir);        
        to_page_table = (unsigned long *) get_free_page()        
        *to_dir = ((unsigned long) to_page_table) | 7;        
        nr = (from==0)?0xA0:1024;        
        for ( ; nr-- &amp;gt; 0 ; from_page_table++,to_page_table++) {            
            this_page = *from_page_table;            
            if (!(1 &amp;amp; this_page))                
                continue;            
            this_page &amp;amp;= ~2;            
            *to_page_table = this_page;            
            if (this_page &amp;gt; LOW_MEM) {                
                *from_page_table = this_page;                
                this_page -= LOW_MEM;                
                this_page &amp;gt;&amp;gt;= 12;                
                mem_map[this_page]++;            
            }        
        }    
    }    
    invalidate();    
    return 0;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先不讲这个函数，我们先看看注释。&lt;/p>
&lt;p>注释是 Linus 自己写的，他说：&lt;/p>
&lt;p>&amp;ldquo;这部分是内存管理中最复杂的代码，希望这段代码没有错误（bug-free），因为我实在不想调试它！&amp;rdquo;&lt;/p>
&lt;p>可见这是一套让 Linus 都觉得烧脑的逻辑。&lt;/p>
&lt;p>虽说代码实现很复杂，但要完成的事情确实非常简单！我想我们要是产品经理，一定会和 Linus 说这么简单的功能有啥难实现的？哈哈。&lt;/p>
&lt;p>回归正题，这个函数要完成什么事情呢？&lt;/p>
&lt;p>你想，现在进程 0 的线性地址空间是 0 - 64M，进程 1 的线性地址空间是 64M - 128M。&lt;strong>我们现在要造一个进程 1 的页表，使得进程 1 和进程 0 最终被映射到的物理空间都是 0 - 64M&lt;/strong>，这样进程 1 才能顺利运行起来，不然就乱套了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-04-7c8fdea0cad3c9569d717bd4f15bf4df.png" alt="图片">&lt;/p>
&lt;p>总之，最终的效果就是：&lt;/p>
&lt;p>假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。&lt;/p>
&lt;p>假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-22-58-0fe064755cc493e1955fe810417a0ca1.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>即，进程 0 和进程 1 目前共同映射物理内存的前 640K 的空间。&lt;/strong>&lt;/p>
&lt;p>至于如何将不同地址通过不同页表映射到相同物理地址空间，很简单，举个刚刚的例子。&lt;/p>
&lt;p>刚刚的进程 1 的线性地址 64M + 0x03 用二进制表示是：&lt;/p>
&lt;p>0000010000_0000000000_000000000011&lt;/p>
&lt;p>刚刚的进程 0 的线性地址 0x03 用二进制表示是：&lt;/p>
&lt;p>0000000000_0000000000_000000000011&lt;/p>
&lt;p>根据分页机制的转化规则，&lt;strong>前 10 位表示页目录项，中间 10 位表示页表项，后 12 位表页内偏移。&lt;/strong>&lt;/p>
&lt;p>进程 1 要找的是页目录项 16 中的第 0 号页表&lt;/p>
&lt;p>进程 0 要找的是页目录项 0 中的第 0 号页表&lt;/p>
&lt;p>那只要让这俩最终找到的两个页表里的数据一模一样即可。&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500507&amp;amp;idx=1&amp;amp;sn=a7863ac6144a1fce942a91a9d573ef1a&amp;amp;chksm=c2c5b876f5b23160502f3d1e7a7d00ad43231aa49eea9809e063f010d65846c512ec87e752a0&amp;amp;scene=21#wechat_redirect">我居然会认为权威书籍写错了&amp;hellip;&lt;/a>&lt;/p>
&lt;p>由于理解起来非常简单，但代码中的计算就非常绕，所以我们就不细致分析代码了，只要理解其最终的作用就好。&lt;/p>
&lt;hr>
&lt;p>OK，本章的内容就讲完了，再稍稍展开一个未来要说的东西。还记得页表的结构吧？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-38-22-89e1ac732ea56be5a529c434daa35db2.png" alt="图片">&lt;/p>
&lt;p>其中 RW 位表示读写状态，0 表示只读（或可执行），1表示可读写（或可执行）。当然，在内核态也就是 0 特权级时，这个标志位是没用的。&lt;/p>
&lt;p>那我们看下面的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">from&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">to&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">LOW_MEM&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>                
                &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>                
                &lt;span class="p">...&lt;/span>            
            &lt;span class="p">}&lt;/span>        
        &lt;span class="p">}&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>~2 表示取反，2 用二进制表示是 10，取反就是 01，其目的是把 this_page 也就是当前的页表的 RW 位置零，也就是是&lt;strong>把该页变成只读&lt;/strong>。&lt;/p>
&lt;p>而 *from_page_table = this_page 表示&lt;strong>又把源页表也变成只读&lt;/strong>。&lt;/p>
&lt;p>也就是说，经过 fork 创建出的新进程，其页表项都是只读的，而且导致源进程的页表项也变成了只读。&lt;/p>
&lt;p>这个就是&lt;strong>写时复制&lt;/strong>的基础，新老进程一开始共享同一个物理内存空间，如果只有读，那就相安无事，但如果任何一方有写操作，由于页面是只读的，将触发缺页中断，然后就会分配一块新的物理内存给产生写操作的那个进程，此时这一块内存就不再共享了。&lt;/p>
&lt;p>这是后话了，这里先埋个伏笔。&lt;/p>
&lt;hr>
&lt;p>好了，至此 fork 中的 &lt;strong>copy_process&lt;/strong> 函数就全部被我们读完了，总共做了三件事，把整个进程的数据结构个性化地从进程 0 复制给了进程 1。&lt;/p>
&lt;p>&lt;strong>第一，原封不动复制了一下 task_struct。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-38-28-7970d5e1e0f763b9e0e69afd9dbebfa3.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第二，LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-39-00-aa192a75588df6873a9c46c74c7c174a.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第三，页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-39-07-78a2e21ba9b35003349fc7b8b289a3df.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>最后，将新老进程的页表都变成只读状态，为后面写时复制的缺页中断做准备。&lt;/strong>&lt;/p></description></item><item><title>一个新进程的诞生（三）如果让你来设计进程调度</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/23.%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Tue, 02 Jan 2024 18:45:57 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/23.%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="一个新进程的诞生三如果让你来设计进程调度">一个新进程的诞生（三）如果让你来设计进程调度&lt;/h1>
&lt;p>书接上回，上回书咱们说到，操作系统通过 &lt;strong>move_to_user_mode&lt;/strong> 方法，通过伪造一个中断和中断返回，巧妙地从内核态切换到了用户态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>        
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>今天，本来应该再往下讲 fork。&lt;/p>
&lt;p>但这个是创建新进程的过程，是一个很能体现操作系统设计的地方。&lt;/p>
&lt;p>所以我们先别急着看代码，我们今天就头脑风暴一下，就是&lt;strong>如果让你来设计整个进程调度&lt;/strong>，你会怎么搞？&lt;/p>
&lt;p>别告诉我你先设计锁、设计 volatile 啥的，这都不是进程调度本身需要关心的最根本问题。&lt;/p>
&lt;p>进程调度本质是什么？很简单，假如有三段代码被加载到内存中。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-22-13-11bf0b397b2327b5733894c1d846e755.png" alt="图片">&lt;/p>
&lt;p>进程调度就是让 CPU 一会去程序 1 的位置处运行一段时间，一会去程序 2 的位置处运行一段时间。&lt;/p>
&lt;p>嗯，就这么简单，别反驳我，接着往下看。&lt;/p>
&lt;h1 id="heading">&lt;/h1>
&lt;p>&lt;strong>整体流程设计&lt;/strong>&lt;/p>
&lt;p>如何做到刚刚说的，一会去这运行，一会去那运行？&lt;/p>
&lt;p>&lt;strong>第一种办法&lt;/strong>就是，程序 1 的代码里，每隔几行就写一段代码，主动放弃自己的执行权，跳转到程序 2 的地方运行。然后程序 2 也是如此。&lt;/p>
&lt;p>但这种依靠程序自己的办法肯定不靠谱。&lt;/p>
&lt;p>所以&lt;strong>第二种办法&lt;/strong>就是，由一个不受任何程序控制的，第三方的不可抗力，每隔一段时间就中断一下 CPU 的运行，然后跳转到一个特殊的程序那里，这个程序通过某种方式获取到 CPU 下一个要运行的程序的地址，然后跳转过去。&lt;/p>
&lt;p>这个每隔一段时间就中断 CPU 的不可抗力，就是由定时器触发的&lt;strong>时钟中断&lt;/strong>。&lt;/p>
&lt;p>不知道你是否还记得，这个定时器和时钟中断，早在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的&lt;/a> 里讲的 &lt;strong>sched_init&lt;/strong> 函数里就搞定了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-14-19-70ae7bec16f72f3c8d9d00ca14091bb9.gif" alt="图片">&lt;/p>
&lt;p>而那个特殊的程序，就是具体的&lt;strong>进程调度函数&lt;/strong>了。&lt;/p>
&lt;p>好了，整个流程就这样处理完了，那么应该设计什么样的&lt;strong>数据结构&lt;/strong>，来支持这个流程呢？不妨假设这个结构叫 &lt;strong>tast_struct&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    &lt;span class="o">?&lt;/span>&lt;span class="p">}&lt;/span> 
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>换句话说，你总得有一个结构来记录各个进程的信息，比如它上一次执行到哪里了，要不 CPU 就算决定好了要跳转到你这个进程上运行，具体跳到哪一行运行，总得有个地方存吧？&lt;/p>
&lt;p>我们一个个问题抛开来看。&lt;/p>
&lt;h1 id="heading-1">&lt;/h1>
&lt;p>&lt;strong>上下文环境&lt;/strong>&lt;/p>
&lt;p>每个程序最终的本质就是执行指令。这个过程会涉及&lt;strong>寄存器&lt;/strong>，&lt;strong>内存&lt;/strong>和&lt;strong>外设端口&lt;/strong>。&lt;/p>
&lt;p>内存还有可能设计成相互错开的，互不干扰，比如进程 1 你就用 0~1K 的内存空间，进程 2 就用 1K~2K 的内存空间，咱谁也别影响谁。&lt;/p>
&lt;p>虽然有点浪费空间，而且对程序员十分不友好，但起码还是能实现的。&lt;/p>
&lt;p>不过寄存器一共就那么点，肯定做不到互不干扰，可能一个进程就把寄存器全用上了，那其他进程咋整。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-22-03-8cd7beea3634fd0618c3ed025e209987.png" alt="图片">&lt;/p>
&lt;p>比如程序 1 刚刚往 eax 写入一个值，准备用，这时切换到进程 2 了，又往 eax 里写入了一个值。那么之后再切回进程 1 的时候，就出错了。&lt;/p>
&lt;p>所以最稳妥的做法就是，每次切换进程时，都把当前这些寄存器的值存到一个地方，以便之后切换回来的时候恢复。&lt;/p>
&lt;p>Linux 0.11 就是这样做的，每个进程的结构 task_struct 里面，有一个叫 &lt;strong>tss&lt;/strong> 的结构，存储的就是 CPU 这些&lt;strong>寄存器&lt;/strong>的信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">back_link&lt;/span>&lt;span class="p">;&lt;/span>  &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss0&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss1&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp2&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss2&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">cr3&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">eflags&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ecx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">edx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ebp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">edi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">es&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">cs&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ds&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">fs&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">gs&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ldt&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">trace_bitmap&lt;/span>&lt;span class="p">;&lt;/span>   &lt;span class="cm">/* bits: trace 0, bitmap 16-31 */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">i387_struct&lt;/span> &lt;span class="n">i387&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里提个细节。&lt;/p>
&lt;p>你发现 tss 结构里还有个 &lt;strong>cr3&lt;/strong> 不？它表示 cr3 寄存器里存的值，而 cr3 寄存器是指向页目录表首地址的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-21-58-34fa974385fb2acdfb08645cb50160d0.png" alt="图片">&lt;/p>
&lt;p>那么指向不同的页目录表，整个页表结构就是完全不同的一套，那么线性地址到物理地址的映射关系就有能力做到不同。&lt;/p>
&lt;p>也就是说，在我们刚刚假设的理想情况下，不同程序用不同的内存地址可以做到内存互不干扰。&lt;/p>
&lt;p>但是有了这个 cr3 字段，就完全可以无需由各个进程自己保证不和其他进程使用的内存冲突，因为只要建立不同的映射关系即可，由操作系统来建立不同的页目录表并替换 cr3 寄存器即可。&lt;/p>
&lt;p>这也可以理解为，保存了&lt;strong>内存映射的上下文信息&lt;/strong>。&lt;/p>
&lt;p>当然 Linux 0.11 并不是通过替换 cr3 寄存器来实现内存互不干扰的，它的实现更为简单，这是后话了。&lt;/p>
&lt;h1 id="heading-2">&lt;/h1>
&lt;p>&lt;strong>运行时间信息&lt;/strong>&lt;/p>
&lt;p>如何判断一个进程该让出 CPU 了，切换到下一个进程呢？&lt;/p>
&lt;p>总不能是每次时钟中断时都切换一次吧？一来这样不灵活，二来这完全依赖时钟中断的频率，有点危险。&lt;/p>
&lt;p>所以一个好的办法就是，给进程一个属性，叫&lt;strong>剩余时间片&lt;/strong>，每次时钟中断来了之后都 &lt;strong>-1&lt;/strong>，如果减到 0 了，就触发切换进程的操作。&lt;/p>
&lt;p>在 Linux 0.11 里，这个属性就是 &lt;strong>counter&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而他的用法也非常简单，就是每次中断都判断一下是否到 0 了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void do_timer(long cpl) {    
    ...    
    // 当前线程还有剩余时间片，直接返回    
    if ((--current-&amp;gt;counter)&amp;gt;0) 
        return;    
    // 若没有剩余时间片，调度    
    schedule();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果还没到 0，就直接返回，相当于这次时钟中断什么也没做，仅仅是给当前进程的时间片属性做了 -1 操作。&lt;/p>
&lt;p>如果已经到 0 了，就触发&lt;strong>进程调度&lt;/strong>，选择下一个进程并使 CPU 跳转到那里运行。&lt;/p>
&lt;p>进程调度的逻辑就是在 &lt;strong>schedule&lt;/strong> 函数里，怎么调，我们先不管。&lt;/p>
&lt;h1 id="heading-3">&lt;/h1>
&lt;p>&lt;strong>优先级&lt;/strong>&lt;/p>
&lt;p>上面那个 counter 一开始的时候该是多少呢？而且随着 counter 不断递减，减到 0 时，下一轮回中这个 counter 应该赋予什么值呢？&lt;/p>
&lt;p>其实这俩问题都是一个问题，就是 &lt;strong>counter 的初始化&lt;/strong>问题，也需要有一个属性来记录这个值。&lt;/p>
&lt;p>往宏观想一下，这个值越大，那么 counter 就越大，那么每次轮到这个进程时，它在 CPU 中运行的时间就越长，也就是这个进程比其他进程得到了更多 CPU 运行的时间。&lt;/p>
&lt;p>那我们可以把这个值称为&lt;strong>优先级&lt;/strong>，是不是很形象。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每次一个进程初始化时，都把 counter 赋值为这个 priority，而且当 counter 减为 0 时，下一次分配时间片，也赋值为这个。&lt;/p>
&lt;p>其实叫啥都行，反正就是这么用的，就叫优先级吧。&lt;/p>
&lt;h1 id="heading-4">&lt;/h1>
&lt;p>&lt;strong>进程状态&lt;/strong>&lt;/p>
&lt;p>其实我们有了上面那三个信息，就已经可以完成进程的调度了。&lt;/p>
&lt;p>甚至如果你的操作系统让所有进程都得到同样的运行时间，连 counter 和 priority 都不用记录，就操作系统自己定一个固定值一直递减，减到 0 了就随机切一个新进程。&lt;/p>
&lt;p>这样就仅仅维护好寄存器的上下文信息 tss 就好了。&lt;/p>
&lt;p>但我们总要不断优化以适应不同场景的用户需求的，那我们再优化一个细节。&lt;/p>
&lt;p>很简单的一个场景，一个进程中有一个读取硬盘的操作，发起读请求后，要等好久才能得到硬盘的中断信号。&lt;/p>
&lt;p>那这个时间其实该进程再占用着 CPU 也没用，此时就可以选择主动放弃 CPU 执行权，然后再把自己的状态标记为等待中。&lt;/p>
&lt;p>意思是告诉进程调度的代码，先别调度我，因为我还在等硬盘的中断，现在轮到我了也没用，把机会给别人吧。&lt;/p>
&lt;p>那这个状态可以记录一个属性了，叫 &lt;strong>state&lt;/strong>，记录了此时&lt;strong>进程的状态&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而这个进程的状态在 Linux 0.11 里有这么五种。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define TASK_RUNNING          0
&lt;/span>&lt;span class="cp">#define TASK_INTERRUPTIBLE    1
&lt;/span>&lt;span class="cp">#define TASK_UNINTERRUPTIBLE  2
&lt;/span>&lt;span class="cp">#define TASK_ZOMBIE           3
&lt;/span>&lt;span class="cp">#define TASK_STOPPED          4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好了，目前我们这几个字段，就已经可以完成简单的进程调度任务了。&lt;/p>
&lt;p>有表示状态的 &lt;strong>state&lt;/strong>，表示剩余时间片的 &lt;strong>counter&lt;/strong>，表示优先级的 &lt;strong>priority&lt;/strong>，和表示上下文信息的 &lt;strong>tss&lt;/strong>。&lt;/p>
&lt;p>其他字段我们需要用到的时候再说，今天只是头脑风暴一下进程调度设计的思路。&lt;/p>
&lt;p>我们看一下 Linux 0.11 中进程结构的全部，心里先有个数，具体干嘛的先别管，就记住我们刚刚头脑风暴的那四个字段就行了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="cm">/* these are hardcoded - don&amp;#39;t touch */&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* -1 unrunnable, 0 runnable, &amp;gt;0 stopped */&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">signal&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">sigaction&lt;/span> &lt;span class="n">sigaction&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">32&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">blocked&lt;/span>&lt;span class="p">;&lt;/span>   &lt;span class="cm">/* bitmap of masked signals */&lt;/span>
    &lt;span class="cm">/* various fields */&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">exit_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">start_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end_data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">brk&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start_stack&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">father&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">pgrp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">session&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">leader&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">uid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">euid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">suid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">gid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">egid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">sgid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">alarm&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">utime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">stime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cutime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cstime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start_time&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">used_math&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="cm">/* file system info */&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* -1 if no tty, so it must be signed */&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">umask&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pwd&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">executable&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">close_on_exec&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NR_OPEN&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="cm">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;amp;ss */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">desc_struct&lt;/span> &lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="cm">/* tss for this task */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看吧，其实也没多少咯～&lt;/p>
&lt;p>好了，今天我们完全由自己从零到有设计出了进程调度的大体流程，以及它需要的数据结构。&lt;/p>
&lt;p>我们知道了进程调度的开始，要从一次定时器滴答来触发，通过时钟中断处理函数走到进程调度函数，然后去进程的结构 task_struct 中取出所需的数据，进行策略计算，并挑选出下一个可以得到 CPU 运行的进程，跳转过去。&lt;/p>
&lt;p>那么下一讲，我们从一次时钟中断出发，看看一次 Linux 0.11 的进程调度的全过程。有了这两回做铺垫，之后再看主流程中的 fork 代码，将会非常清晰！&lt;/p></description></item><item><title>大名鼎鼎的进程调度就是从这里开始的</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/18.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96sched_init/</link><pubDate>Tue, 02 Jan 2024 18:45:57 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/18.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96sched_init/</guid><description>&lt;h1 id="大名鼎鼎的进程调度就是从这里开始的">大名鼎鼎的进程调度就是从这里开始的&lt;/h1>
&lt;p>书接上回，上回书咱们说到，&lt;strong>time_init&lt;/strong> 方法通过与 CMOS 端口进行读写交互，获取到了年月日时分秒等数据，并通过这些计算出了开机时间 &lt;strong>startup_time&lt;/strong> 变量，是从 1970 年 1 月 1 日 0 时起到开机当时经过的秒数。&lt;/p>
&lt;p>我们继续往下看，大名鼎鼎的进程调度初始化，&lt;strong>shed_init&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>        
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这方法可了不起，因为它就是多进程的基石！&lt;/p>
&lt;p>终于来到了兴奋的时刻，是不是很激动？不过先别激动，这里只是进程调度的初始化，也就是为进程调度所需要用到的数据结构做个准备，真正的进程调度还需要调度算法、时钟中断等机制的配合。&lt;/p>
&lt;p>当然，对于理解操作系统，流程和数据结构最为重要了，而这一段作为整个流程的起点，以及建立数据结构的地方，就显得格外重要了。&lt;/p>
&lt;p>我们进入这个方法，一点点往后看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sched_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">set_tss_desc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gdt&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">init_task&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">set_ldt_desc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gdt&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">init_task&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>两行代码初始化了下 &lt;strong>TSS&lt;/strong> 和 &lt;strong>LDT&lt;/strong>。&lt;/p>
&lt;p>先别急问这俩结构是啥。还记得之前讲的全局描述符表 gdt 么？它在内存的这个位置，并且被设置成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-55-34-1c6c1cc4c595f30e6d829a29a5566f77.png" alt="图片">&lt;/p>
&lt;p>忘了的看一下&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499734&amp;amp;idx=1&amp;amp;sn=89045b51e41d2e74754f5475d25d7b54&amp;amp;chksm=c2c5857bf5b20c6d1698df2abd0e1eea601e83612ee6af58dc8eb79f93c751f73d7c62e565ce&amp;amp;scene=21#wechat_redirect">第八回 | 烦死了又要重新设置一遍 idt 和 gdt&lt;/a>，这就说明之前看似没用的细节有多重要了，大家一定要有耐心。&lt;/p>
&lt;p>说回这两行代码，其实就是往后又加了两项，分别是 TSS 和 LDT。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-55-43-2dbbf33d359ded0ab55a1015b2484828.png" alt="图片">&lt;/p>
&lt;p>好，那再说说这俩结构是干嘛的，不过本篇先简单理解，后面会详细讲到。&lt;/p>
&lt;p>TSS 叫&lt;strong>任务状态段&lt;/strong>，就是&lt;strong>保存和恢复进程的上下文的&lt;/strong>，所谓上下文，其实就是各个寄存器的信息而已，这样进程切换的时候，才能做到保存和恢复上下文，继续执行。&lt;/p>
&lt;p>由它的数据结构你应该可以看出点意思。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span>&lt;span class="p">{&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">back_link&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">esp0&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">ss0&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">esp1&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">ss1&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">esp2&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">ss2&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">cr3&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">eip&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">eflags&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ecx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">ebp&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">esi&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">edi&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">es&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">cs&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">ss&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">ds&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">fs&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">gs&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">ldt&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">trace_bitmap&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">i387_struct&lt;/span> &lt;span class="n">i387&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而 LDT 叫&lt;strong>局部描述符表&lt;/strong>，是与 GDT 全局描述符表相对应的，内核态的代码用 GDT 里的数据段和代码段，而用户进程的代码用每个用户进程自己的 LDT 里得数据段和代码段。&lt;/p>
&lt;p>先不管它，我这里放一张超纲的图，你先找找感觉。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-55-52-bee8d5b96e4be9fab2067ea7021a2e78.png" alt="图片">&lt;/p>
&lt;p>我们接着往下看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">desc_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">init_task&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">sched_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">desc_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>        
    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">gdt&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码有个循环，干了两件事。&lt;/p>
&lt;p>一个是给一个长度为 64，结构为 &lt;strong>task_struct&lt;/strong> 的数组 task 附上初始值。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-56-02-88f6a76498fec7be9e0ab49f5c5ab55e.png" alt="图片">&lt;/p>
&lt;p>这个 task_struct 结构就是代表&lt;strong>每一个进程的信息&lt;/strong>，这可是个相当相当重要的结构了，把它放在心里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="cm">/* these are hardcoded - don&amp;#39;t touch */&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* -1 unrunnable, 0 runnable, &amp;gt;0 stopped */&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">signal&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">sigaction&lt;/span> &lt;span class="n">sigaction&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">32&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">blocked&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* bitmap of masked signals */&lt;/span>  
    &lt;span class="cm">/* various fields */&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">exit_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">start_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end_data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">brk&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start_stack&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">father&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">pgrp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">session&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">leader&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">uid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">euid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">suid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">gid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">egid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">sgid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">alarm&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">utime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">stime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cutime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cstime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start_time&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">used_math&lt;/span>&lt;span class="p">;&lt;/span>  &lt;span class="cm">/* file system info */&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">;&lt;/span>  &lt;span class="cm">/* -1 if no tty, so it must be signed */&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">umask&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pwd&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">executable&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">close_on_exec&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NR_OPEN&lt;/span>&lt;span class="p">];&lt;/span>  
    &lt;span class="cm">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;amp;ss */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">desc_struct&lt;/span> &lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>  
    &lt;span class="cm">/* tss for this task */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个循环做的另一件事，是给 gdt 剩下的位置填充上 0，也就是把剩下留给 TSS 和 LDT 的描述符都先附上空值。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-56-11-2ab1fe119fe755d84dfd8b0f593bc96f.png" alt="图片">&lt;/p>
&lt;p>往后展望一下的话，就是以后每创建一个新进程，就会在后面添加一组 TSS 和 LDT 表示这个进程的任务状态段以及局部描述符表信息。&lt;/p>
&lt;p>还记得刚刚的超纲图吧，未来整个内存的规划就是这样的，不过你先不用理解得很细。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-56-20-bee8d5b96e4be9fab2067ea7021a2e78.png" alt="图片">&lt;/p>
&lt;p>那为什么一开始就先有了一组 TSS 和 LDT 呢？现在也没创建进程呀。错了，现在虽然我们还没有建立起进程调度的机制，但我们正在运行的代码就是会作为&lt;strong>未来的一个进程的指令流&lt;/strong>。&lt;/p>
&lt;p>也就是当未来进程调度机制一建立起来，正在执行的代码就会化身成为&lt;strong>进程 0&lt;/strong> 的代码。所以我们需要提前把这些未来会作为进程 0 的信息写好。&lt;/p>
&lt;p>如果你觉得很疑惑，别急，等后面整个进程调度机制建立起来，并且让你亲眼看到进程 0 以及进程 1 的创建，以及它们后面因为进程调度机制而切换，你就明白这一切的意义了。&lt;/p>
&lt;p>好，收回来，初始化了一组 TSS 和 LDT 后，再往下看两行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">#define ltr(n) __asm__(&amp;#34;ltr %%ax&amp;#34;::&amp;#34;a&amp;#34; (_TSS(n)))
#define lldt(n) __asm__(&amp;#34;lldt %%ax&amp;#34;::&amp;#34;a&amp;#34; (_LDT(n)))
void sched_init(void) {    
    ...    
    ltr(0);    
    lldt(0);    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这又涉及到之前的知识咯。&lt;/p>
&lt;p>还记得 &lt;strong>lidt&lt;/strong> 和 &lt;strong>lgdt&lt;/strong> 指令么？一个是给 idtr 寄存器赋值，以告诉 CPU 中断描述符表 idt 在内存的位置；一个是给 gdtr 寄存器赋值，以告诉 CPU 全局描述符表 gdt 在内存的位置。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-56-30-9844a54bbcc17806fe52080010401a6e.png" alt="图片">&lt;/p>
&lt;p>那这两行和刚刚的类似，&lt;strong>ltr&lt;/strong> 是给 &lt;strong>tr&lt;/strong> 寄存器赋值，以告诉 CPU 任务状态段 TSS 在内存的位置；&lt;strong>lldt&lt;/strong> 一个是给 &lt;strong>ldt&lt;/strong> 寄存器赋值，以告诉 CPU 局部描述符 LDT 在内存的位置。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-18-31-278dc1074ae864ad5277e06964629880.png" alt="">&lt;/p>
&lt;p>这样，CPU 之后就能通过 tr 寄存器找到当前进程的任务状态段信息，也就是上下文信息，以及通过 ldt 寄存器找到当前进程在用的局部描述符表信息。&lt;/p>
&lt;p>我们继续看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sched_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">outb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x36&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x43&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="cm">/* binary, mode 3, LSB/MSB, ch 0 */&lt;/span>
&lt;span class="n">outb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">LATCH&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xff&lt;/span> &lt;span class="p">,&lt;/span> &lt;span class="mh">0x40&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="cm">/* LSB */&lt;/span>
&lt;span class="n">outb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">LATCH&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="p">,&lt;/span> &lt;span class="mh">0x40&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="cm">/* MSB */&lt;/span>
    &lt;span class="n">set_intr_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x20&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">timer_interrupt&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="n">outb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;~&lt;/span>&lt;span class="mh">0x01&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="n">set_system_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">system_call&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>四行端口读写代码，两行设置中断代码。&lt;/p>
&lt;p>端口读写我们已经很熟悉了，就是 CPU 与外设交互的一种方式，之前讲硬盘读写以及 CMOS 读写时，已经接触过了。&lt;/p>
&lt;p>而这次交互的外设是一个&lt;strong>可编程定时器&lt;/strong>的芯片，这四行代码就开启了这个定时器，之后这个定时器变会&lt;strong>持续的、以一定频率的向 CPU 发出中断信号&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-12-55-4e506f09f2995a7e0145a1da9680baf6.gif" alt="图片">&lt;/p>
&lt;p>而这段代码中设置的两个中断，第一个就是&lt;strong>时钟中断&lt;/strong>，中断号为 &lt;strong>0x20&lt;/strong>，中断处理程序为 &lt;strong>timer_interrupt&lt;/strong>。那么每次定时器向 CPU 发出中断后，便会执行这个函数。&lt;/p>
&lt;p>这个定时器的触发，以及时钟中断函数的设置，是操作系统主导进程调度的一个关键！没有他们这样的外部信号不断触发中断，操作系统就没有办法作为进程管理的主人，通过强制的手段收回进程的 CPU 执行权限。&lt;/p>
&lt;p>第二个设置的中断叫系统调用 &lt;strong>system_call&lt;/strong>，中断号是 &lt;strong>0x80&lt;/strong>，这个中断又是个非常非常非常非常非常非常非常重要的中断，所有用户态程序想要调用内核提供的方法，都需要基于这个系统调用来进行。&lt;/p>
&lt;p>比如 Java 程序员写一个 read，底层会执行汇编指令 &lt;strong>int 0x80&lt;/strong>，这就会触发系统调用这个中断，最终调用到 Linux 里的 sys_read 方法。&lt;/p>
&lt;p>这个过程之后会重点讲述，现在只需要知道，在这个地方，偷偷把这个极为重要的中断，设置好了。&lt;/p>
&lt;p>所以你看这一章的内容，偷偷设置了影响进程和影响用户程序调用系统方法的两个重量级中断处理函数，不简单呀~&lt;/p>
&lt;p>到目前为止，中断已经设置了不少了，我们现在看看所设置好的中断有哪些。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>中断号&lt;/th>
&lt;th>中断处理函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 ~ 0x10&lt;/td>
&lt;td>trap_init 里设置的一堆&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x20&lt;/td>
&lt;td>timer_interrupt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x21&lt;/td>
&lt;td>keyboard_interrupt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x80&lt;/td>
&lt;td>system_call&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>其中 &lt;strong>0-0x10&lt;/strong> 这 17 个中断是 trap_init 里初始化设置的，是一些基本的中断，比如除零异常等。这个在 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500119&amp;amp;idx=1&amp;amp;sn=f46331f70677aba168243040a96be1c0&amp;amp;scene=21#wechat_redirect">第14回 中断初始化 trap_init&lt;/a> 有讲到。&lt;/p>
&lt;p>之后，在控制台初始化 con_init 里，我们又设置了 &lt;strong>0x21&lt;/strong> 键盘中断，这样按下键盘就有反应了。这个在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500190&amp;amp;idx=1&amp;amp;sn=b0bebe846b55f7e29fc009e1b6587214&amp;amp;chksm=c2c5bb33f5b23225845ab699d1b8fcee39a04ca98a48ebf0e2c22584b638fa0b0839d1212485&amp;amp;scene=21#wechat_redirect">第16回 控制台初始化 tty_init&lt;/a> 有讲到。&lt;/p>
&lt;p>现在，我们又设置了 &lt;strong>0x20&lt;/strong> 时钟中断，并且开启定时器。最后又偷偷设置了一个极为重要的 &lt;strong>0x80&lt;/strong> 系统调用中断。&lt;/p>
&lt;p>找到些感觉没，有没有越来越发现，操作系统有点靠中断驱动的意思，各个模块不断初始化各种中断处理函数，并且开启指定的外设开关，让操作系统自己慢慢“活”了起来，逐渐通过中断忙碌于各种事情中，无法自拔。&lt;/p>
&lt;p>恭喜你，我们已经逐渐在接近操作系统的本质了。&lt;/p>
&lt;p>回顾一下我们今天干了什么，就三件事。&lt;/p>
&lt;p>&lt;strong>第一&lt;/strong>，我们往全局描述符表写了两个结构，TSS 和 LDT，作为未来进程 0 的任务状态段和局部描述符表信息。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-56-47-2dbbf33d359ded0ab55a1015b2484828.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第二&lt;/strong>，我们初始化了一个结构为 task_struct  的数组，未来这里会存放所有进程的信息，并且我们给数组的第一个位置附上了 init_task.init 这个具体值，也是作为未来进程 0 的信息。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-56-54-88f6a76498fec7be9e0ab49f5c5ab55e.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第三&lt;/strong>，设置了时钟中断 0x20 和系统调用 0x80，一个作为进程调度的起点，一个作为用户程序调用操作系统功能的桥梁，非常之重要。&lt;/p>
&lt;p>后面，我们将会逐渐看到，这些重要的事情，是如何紧密且精妙地结合在一起，发挥出奇妙的作用。&lt;/p></description></item><item><title>操作系统就是用这两个面试常考的结构管理的缓冲区</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/19.%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96buffer_init/</link><pubDate>Tue, 02 Jan 2024 18:45:57 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/19.%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96buffer_init/</guid><description>&lt;h1 id="操作系统就是用这两个面试常考的结构管理的缓冲区">操作系统就是用这两个面试常考的结构管理的缓冲区&lt;/h1>
&lt;p>书接上回，上回书我们说到了进程调度的初始化，定义了一个长度为 64 的 task 数组用于管理全部进程的结构。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-21-26-8f928e2ccdae769bd8a53d0cfd6180cd.png" alt="图片">&lt;/p>
&lt;p>之后在 GDT 中预定义了进程调度需要用到的 TSS 和 LDT 结构。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-21-21-4c6250af54bd6893b66fac280a83450c.png" alt="图片">&lt;/p>
&lt;p>之后开启了定时器，准备迎接时钟中断的到来，进而触发进程调度。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-21-11-f2bf07d9b7809e13b5115f1f753da169.gif" alt="图片">&lt;/p>
&lt;p>那接下来我们就冷静下，回到 main 函数，继续看下一个初始化的过程。&lt;/p>
&lt;p>那就是缓冲区初始化 buffer_init，加油，没剩多少了！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void main(void) {    
    ...    
    mem_init(main_memory_start,memory_end);    
    trap_init();    
    blk_dev_init();    
    chr_dev_init();    
    tty_init();    
    time_init();    
    sched_init();    
    buffer_init(buffer_memory_end);    
    hd_init();    
    floppy_init();    
    sti();    
    move_to_user_mode();    
    if (!fork()) {        
        init();    
    }    
    for(;;) 
        pause();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先要注意到，这个函数传了个参数 buffer_memory_end，这个是在老早之前就设置好的，就在&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500061&amp;amp;idx=1&amp;amp;sn=6cb3382d7ac35ebeac52bbba3a89db4e&amp;amp;scene=21#wechat_redirect">第12回 | 管理内存前先划分出三个边界值&lt;/a>，回顾下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-21-03-e0c36899a837dc5841ac66ae4f65b83b.png" alt="图片">&lt;/p>
&lt;p>想起来了吧？而且我们在 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;scene=21#wechat_redirect">第13回 | 主内存初始化 mem_init&lt;/a> 中，用 mem_init 设置好了主内存的管理结构 mam_map。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-20-56-feb456da6218d76b42a2fbb25b2f3238.png" alt="图片">&lt;/p>
&lt;p>再想不起来那就需要把前面的章节再读一读咯，不然后面越来越难。&lt;/p>
&lt;p>前面是把主内存区管理起来了，所以今天就是把剩下的缓冲区部分，也初始化管理起来。目的就是这么单纯，我们看代码。&lt;/p>
&lt;p>我们还是采用之前的方式，就假设内存只有 8M，把一些不相干的分支去掉，方便理解。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">extern&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">start_buffer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">buffer_end&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start_buffer&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">buffer_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_dev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_dirt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_uptodate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_wait&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_prev_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_next_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">h&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">free_list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start_buffer&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">free_list&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_prev_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_next_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">free_list&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">307&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">hash_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>虽然很长，但其实就造了&lt;strong>两个数据结构&lt;/strong>而已。&lt;/p>
&lt;p>不过别急，我们先看这一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">extern&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">end&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">buffer_end&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">start_buffer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有个外部变量 &lt;strong>end&lt;/strong>，而我们的缓冲区开始位置 &lt;strong>start_buffer&lt;/strong> 就等于这个变量的内存地址。&lt;/p>
&lt;p>这个外部变量 end 并不是操作系统代码写就的，而是由&lt;strong>链接器 ld&lt;/strong> 在链接整个程序时设置的一个外部变量，帮我们计算好了整个内核代码的末尾地址。&lt;/p>
&lt;p>那在这之前的是内核代码区域肯定不能用，在这之后的，就给 buffer 用了。所以我们的内存分布图可以更精确一点了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-20-46-a63932429bd1382abf2e874975de463f.png" alt="图片">&lt;/p>
&lt;p>你看，之前的疑惑解决了吧？很好理解嘛，内核程序和缓冲区的划分，肯定有个分界线，这个分界线就是 end 变量的值。&lt;/p>
&lt;p>这个值定多少合适呢？&lt;/p>
&lt;p>像主内存和缓冲区的分界线，就直接代码里写死了，就是上图中的 2M。&lt;/p>
&lt;p>可是内核程序占多大内存在写的时候完全不知道，就算知道了如果改动一点代码也会变化，所以就由程序编译链接时由链接器程序帮我们把这个内核代码末端的地址计算出来，作为一个外部变量 end 我们拿来即用，就方便多了。&lt;/p>
&lt;p>好，回过头我们再看看，&lt;strong>整段代码创造了哪两个管理结构&lt;/strong>？&lt;/p>
&lt;p>我们先看这段结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">buffer_end&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start_buffer&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">buffer_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_prev_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_next_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">h&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就俩变量。&lt;/p>
&lt;p>一个是 &lt;strong>buffer_head&lt;/strong> 结构的 &lt;strong>h&lt;/strong>，代表缓冲头，其指针值是 start_buffer，刚刚我们计算过了，就是图中的内核代码末端地址 end，也就是缓冲区开头。&lt;/p>
&lt;p>一个是 &lt;strong>b&lt;/strong>，代表缓冲块，指针值是 buffer_end，也就是图中的 2M，就是缓冲区结尾。&lt;/p>
&lt;p>缓冲区结尾的 b 每次循环 -1024，也就是一页的值，缓冲区结尾的 h 每次循环 +1（一个 buffer_head 大小的内存），直到碰一块为止。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-20-38-f925501c53c99edc79c515e9e4e258b7.png" alt="图片">&lt;/p>
&lt;p>可以看到，其实这个 b 就代表缓冲块，h 代表缓冲头，一个从上往下，一个从下往上。&lt;/p>
&lt;p>而且这个过程中，h 被附上了属性值，其中比较关键的是这个 buffer 所表示的数据部分 &lt;strong>b_data&lt;/strong>，也就是指向了上面的缓冲块 b。&lt;/p>
&lt;p>还有这个 buffer 的前后空闲 buffer 的指针 &lt;strong>b_prev_free&lt;/strong> 和 &lt;strong>b_next_free&lt;/strong>。&lt;/p>
&lt;p>那画成图就是如下这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-20-31-6e902bd7f249b79bd39a47297a96b067.png" alt="图片">&lt;/p>
&lt;p>当缓冲头 h 的所有 next 和 prev 指针都指向彼此时，就构成了一个双向链表。继续看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">buffer_end&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">free_list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start_buffer&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">free_list&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_prev_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">h&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_next_free&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">free_list&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这三行代码，结合刚刚的双向链表 h，我画出图，你就懂了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-20-23-d0b5d6eb872b3468921c93935f638b3e.png" alt="图片">&lt;/p>
&lt;p>看，free_list 指向了缓冲头双向链表的第一个结构，然后就可以顺着这个结构，从双向链表中遍历到任何一个&lt;strong>缓冲头&lt;/strong>结构了，而通过缓冲头又可以找到这个缓冲头对应的&lt;strong>缓冲块&lt;/strong>。&lt;/p>
&lt;p>简单说，&lt;strong>缓冲头就是具体缓冲块的管理结构，而 free_list 开头的双向链表又是缓冲头的管理结构&lt;/strong>，整个管理体系就这样建立起来了。&lt;/p>
&lt;p>现在，从 free_list 开始遍历，就可以找到这里的所有内容了。&lt;/p>
&lt;p>不过，还有最后一个事，能帮助更好管理，往下看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">buffer_end&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">307&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">hash_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一个 307 大小的 &lt;strong>hash_table&lt;/strong> 数组，这是干嘛的呢？&lt;/p>
&lt;p>其实今天的这个代码在 &lt;strong>buffer.c&lt;/strong> 中，而 buffer.c 是在 &lt;strong>fs&lt;/strong> 包下的，也就是&lt;strong>文件系统&lt;/strong>包下的。所以它今后是为文件系统而服务，具体是内核程序如果需要访问块设备中的数据，就都需要经过缓冲区来间接地操作。&lt;/p>
&lt;p>也就是说，读取块设备的数据（硬盘中的数据），需要先读到缓冲区中，如果缓冲区已有了，就不用从块设备读取了，直接取走。&lt;/p>
&lt;p>那怎么知道缓冲区已经有了要读取的块设备中的数据呢？从双向链表从头遍历当然可以，但是这效率可太低了。所以需要一个 hashmap 的结构方便快速查找，这就是 hash_table 这个数组的作用。&lt;/p>
&lt;p>现在只是&lt;strong>初始化&lt;/strong>这个 hash_table，还并没有哪个地方用到了它，所以我就先简单剧透下。&lt;/p>
&lt;p>之后当要读取某个块设备上的数据时，首先要搜索相应的缓冲块，是下面这个函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define _hashfn(dev,block) (((unsigned)(dev^block))%307)
&lt;/span>&lt;span class="cp">#define hash(dev,block) hash_table[_hashfn(dev,block)]
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// 搜索合适的缓冲块
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">getblk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_hash_table&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">；&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">get_hash_table&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">find_buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">find_buffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一路跟下来发现，就是通过&lt;/p>
&lt;p>&lt;strong>dev^block % 307&lt;/strong>&lt;/p>
&lt;p>即&lt;/p>
&lt;p>&lt;strong>(设备号^逻辑块号) Mod 307&lt;/strong>&lt;/p>
&lt;p>找到在 hash_table 里的索引下标，接下来就和 Java 里的 HashMap 类似，如果哈希冲突就形成链表，画成图就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-57-10-1dd0310f44e067fffa8674869dffcfe0.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>哈希表 + 双向链表&lt;/strong>，如果刷算法题多了，很容易想到这可以实现 &lt;strong>LRU 算法&lt;/strong>，没错，之后的缓冲区使用和弃用，正是这个算法发挥了作用。&lt;/p>
&lt;p>也就是之后在讲通过文件系统来读取硬盘文件时，都需要使用和弃用这个缓冲区里的内容，缓冲区即是用户进程的内存和硬盘之间的桥梁。&lt;/p>
&lt;p>好了好了，再多说几句就把文件系统里读操作讲出来了，压力太大，本章还是主要就了解这个缓冲区的管理工作是如何初始化的，为后面做铺垫。&lt;/p>
&lt;p>回过头来看看我们目前的进度吧！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>        
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="p">();}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整个初始化的部分，就差 &lt;strong>hd_init&lt;/strong> 和 &lt;strong>floppy_init&lt;/strong> 这两个块设备的初始化还没讲了。&lt;/p>
&lt;p>而且幸运的是，floppy_init 是软盘初始化，现在软盘几乎都被淘汰了，计算机中也没有软盘驱动器了，所以这个我们完全可以不看，那就剩下一个 &lt;strong>hd_init 硬盘初始化&lt;/strong>了，非常简单！&lt;/p>
&lt;p>还记得小时候我特别喜欢收集软盘，里面分门别类存上我做的 Flash 动画，然后在软盘上的那个纸标签上写上文字，表示软盘存了什么，想想看还是回忆呢。&lt;/p>
&lt;p>扯远了。&lt;/p>
&lt;p>之前的各种初始化工作所建立的数据结构，会在后面各个模块发挥最最核心的作用，&lt;strong>任何操作系统的管理都离不开这些初始化工作所建立的数据结构&lt;/strong>，所以一定要把这些根基搭建好，别急别慌。&lt;/p>
&lt;p>等初始化工作全部完成，我会专门用一回给大家梳理一下，大家就尽可能把初始化这一大部分的数据结构记在心里吧！&lt;/p></description></item><item><title>调试 Linux 最早期的代码</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC4%E9%83%A8%E5%88%86/39.%E7%95%AA%E5%A4%96%E7%AF%87-linux_0.11%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/</link><pubDate>Tue, 02 Jan 2024 18:45:57 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC4%E9%83%A8%E5%88%86/39.%E7%95%AA%E5%A4%96%E7%AF%87-linux_0.11%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/</guid><description>&lt;h1 id="调试-linux-最早期的代码">调试 Linux 最早期的代码&lt;/h1>
&lt;p>Linux 0.11 是 Linux 最早期的代码，非常适合作为第一款深入探索操作系统原理的代码。&lt;/p>
&lt;p>但同时，Linux 0.11 因为很多古老工具链的缺失，以及一些过时的文件格式比如 a.out，导致成功编译并运行它十分困难，更别说进行源码级别的 debug 调试了。&lt;/p>
&lt;p>要想成功调试 Linux 0.11，需要进行很多改造，并依赖一些古老的工具链，对于仅仅是将 Linux 0.11 作为研究操作系统的手段的我们，无需花费精力自己去改造它，踩各种坑。&lt;/p>
&lt;p>所以今天我就分享一下我调试 Linux 0.11 的一种方式，同时也为了我自己以后换电脑的时候方便照着自己的教程直接无脑搭建环境，那我们开始吧~&lt;/p>
&lt;p>&lt;strong>整体思路和效果&lt;/strong>&lt;/p>
&lt;p>我用的方式是，在 windows 上，搞一个 Ubuntu 16.04 的虚拟机，在里面用 qemu 启动一个开启了调试的 Linux 0.11 系统，然后用本机的 vscode remote ssh 连接到虚拟机，并开启 gdb 调试，最终的效果如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-36-65d7d934154c1e93ccd4a086ef8214fa.png" alt="图片">&lt;/p>
&lt;p>这是最舒服的方式，因为 vscode 是本机的，完全不受虚拟机的影响，这也是我调试其他代码时比较喜欢的方式。&lt;/p>
&lt;p>如果你有自己的豪华服务器，虚拟机也可以换成服务器，这样不但编译速度快，不消耗自己电脑的性能，同时也可以不受终端的影响，在家在公司都可以随时调试（方便摸鱼~）&lt;/p>
&lt;p>当然如果你不需要这么直观 vscode 这一步也可以换成 gdb 命令行，在虚拟机里直接执行 gdb 相关命令即可。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-41-fa8e1e16b008346c82a0e69b7eabe645.png" alt="图片">&lt;/p>
&lt;p>下面我们就一步步来实现这个效果。&lt;/p>
&lt;h1 id="heading">&lt;/h1>
&lt;p>&lt;strong>第一步：配置虚拟机&lt;/strong>&lt;/p>
&lt;p>我用的虚拟机软件是&lt;/p>
&lt;p>&lt;strong>Oracle VM VirtualBox Version 6.0.8 Edition&lt;/strong>&lt;/p>
&lt;p>官网是：&lt;/p>
&lt;p>&lt;a href="https://ubuntu.com/">https://ubuntu.com/&lt;/a>&lt;/p>
&lt;p>下载页面是：&lt;/p>
&lt;p>&lt;a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_0">https://www.virtualbox.org/wiki/Download_Old_Builds_6_0&lt;/a>&lt;/p>
&lt;p>我这个版本的直接下载地址是：&lt;/p>
&lt;p>&lt;a href="https://download.virtualbox.org/virtualbox/6.0.8/VirtualBox-6.0.8-130520-Win.exe">https://download.virtualbox.org/virtualbox/6.0.8/VirtualBox-6.0.8-130520-Win.exe&lt;/a>&lt;/p>
&lt;p>安装的操作系统镜像是&lt;/p>
&lt;p>&lt;strong>ubuntu-16.04.7-desktop-amd64&lt;/strong>&lt;/p>
&lt;p>官网是：&lt;/p>
&lt;p>&lt;a href="https://ubuntu.com/">https://ubuntu.com/&lt;/a>&lt;/p>
&lt;p>下载页面是：&lt;/p>
&lt;p>&lt;a href="https://releases.ubuntu.com/xenial/">https://releases.ubuntu.com/xenial/&lt;/a>&lt;/p>
&lt;p>我这个版本的直接下载地址是：&lt;/p>
&lt;p>&lt;a href="https://releases.ubuntu.com/xenial/ubuntu-16.04.7-desktop-amd64.iso">https://releases.ubuntu.com/xenial/ubuntu-16.04.7-desktop-amd64.iso&lt;/a>&lt;/p>
&lt;p>这个就不详细展开讲解了，最终达到这个效果就行。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-48-da00082b3cd2361979e2770229f04491.png" alt="图片">&lt;/p>
&lt;h1 id="heading-1">&lt;/h1>
&lt;p>&lt;strong>第二步：安装 qemu&lt;/strong>&lt;/p>
&lt;p>qemu 是模拟器，简单理解和虚拟机一样，用来当做真机启动 Linux 0.11 的。&lt;/p>
&lt;p>官网是这个：&lt;/p>
&lt;p>&lt;a href="https://www.qemu.org/">https://www.qemu.org/&lt;/a>&lt;/p>
&lt;p>我们在刚刚的 Ubuntu 虚拟机里直接按照官方教程下载 qemu&lt;/p>
&lt;p>&lt;strong>sudo apt-get install qemu&lt;/strong>&lt;/p>
&lt;p>下载好后，我们输入 &lt;strong>qemu-&lt;/strong>，按两下 tab，查看下支持的体系结构。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-53-824cec1c7ed1c99cfcbd24ae3d2c09b5.png" alt="图片">&lt;/p>
&lt;p>看到有 &lt;strong>qemu-system-x86_64&lt;/strong> 即可，一会我们会用这个来模拟启动 Linux 0.11。&lt;/p>
&lt;h1 id="heading-2">&lt;/h1>
&lt;p>&lt;strong>第三步：下载并运行可调试的 Linux 0.11 源码&lt;/strong>&lt;/p>
&lt;p>这一步直接下官网上的是不行的，因为那个依赖好多古老的工具链。&lt;/p>
&lt;p>这里一般网上都是参考了赵炯老师为我们修改好的 Linux 0.11 源码，用现代的工具链即可构建，造福了广大热爱内核的开发者，我们直接拿来主义即可。&lt;/p>
&lt;p>在赵炯老师准备好的源码的基础上，很多人又进行了二次改造，使得其可以一键 qemu 或 bochs 启动，这里我选择了仓库：&lt;/p>
&lt;p>&lt;a href="https://github.com/yuan-xy/Linux-0.11">https://github.com/yuan-xy/Linux-0.11&lt;/a>&lt;/p>
&lt;p>直接把源码下载下来，进入根目录，输入命令 &lt;strong>make start&lt;/strong> 就可以把 Linux 0.11 跑起来了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-58-c3ad3b57c48581ccc9eb840e7b2c93c5.png" alt="图片">&lt;/p>
&lt;p>如果想 debug，那么就以 debug 形式启动，输入命令 &lt;strong>make debug&lt;/strong>，它会卡住不动。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-03-5eecaddc641e0cc630fde8bd92f5f666.png" alt="图片">&lt;/p>
&lt;p>此时其实你就可以通过 gdb 进行调试了。&lt;/p>
&lt;p>再开一个窗口，输入命令 &lt;strong>gdb tools/system&lt;/strong>&lt;/p>
&lt;p>然后 &lt;strong>target remote :1234&lt;/strong>&lt;/p>
&lt;p>就可以愉快地进行 gdb 调试了&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-08-fa8e1e16b008346c82a0e69b7eabe645.png" alt="图片">&lt;/p>
&lt;p>具体 gdb 怎么玩，就不展开讲解了。&lt;/p>
&lt;h1 id="heading-3">&lt;/h1>
&lt;p>&lt;strong>第四步：通过 vscode 远程调试&lt;/strong>&lt;/p>
&lt;p>当然，你也可以在虚拟机里用 vscode 进行本地调试，但我觉得不爽。&lt;/p>
&lt;p>所以，在本机的 windows 里安装好 vscode，下载 &lt;strong>remote-ssh&lt;/strong> 插件。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-13-0b407d81e66d46020c21b66ad176718f.png" alt="图片">&lt;/p>
&lt;p>下载好后按下 &lt;strong>ctrl + p&lt;/strong>，输入 &lt;strong>&amp;gt;remote-ssh&lt;/strong>，找到 &lt;strong>Connect to Host&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-18-813005ffc72a0560290dc8a7f7472555.png" alt="图片">&lt;/p>
&lt;p>按照它提示的格式输入你的虚拟机 IP 和用户名，随后输入密码，即可远程连接到虚拟机。&lt;/p>
&lt;p>之后点击菜单栏 &lt;strong>运行-启用调试&lt;/strong>，在弹出的 &lt;strong>launch.json&lt;/strong> 中做如下配置&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-23-7a03d0abddd5155ff4c18eb87ff8e676.png" alt="图片">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>    
    &lt;span class="nt">&amp;#34;version&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;0.2.0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>    
    &lt;span class="nt">&amp;#34;configurations&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>        
        &lt;span class="p">{&lt;/span>
            &lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;(gdb) Launch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;cppdbg&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;request&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;launch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;program&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;${workspaceFolder}/tools/system&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;miDebuggerServerAddress&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;127.0.0.1:1234&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;args&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[],&lt;/span>
            &lt;span class="nt">&amp;#34;stopAtEntry&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;cwd&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;${workspaceFolder}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;environment&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[],&lt;/span>
            &lt;span class="nt">&amp;#34;externalConsole&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;MIMode&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;gdb&amp;#34;&lt;/span>
        &lt;span class="p">}&lt;/span>
    &lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>配置好后保存，在 main 函数里打个断点，再次点击菜单栏 &lt;strong>运行-启用调试&lt;/strong>，可以发现调试成功。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-30-65d7d934154c1e93ccd4a086ef8214fa.png" alt="图片">&lt;/p>
&lt;p>当然，记得每次 vscode 调试前，在虚拟机里先把 Linux 0.11 跑起来，就是执行命令 &lt;strong>make debug&lt;/strong>。&lt;/p>
&lt;p>这一步也可以配置到 vscode 里，但这一步没多少工作量，而且也不方便直观看到虚拟机里的行为，我就懒得弄了。&lt;/p>
&lt;p>好了，这个教程到这里就结束了，这就是我调试 Linux 0.11 的其中一个办法，当然每个人可能都有自己喜欢的方式，只要适合自己就好。&lt;/p></description></item><item><title>进入 main 函数前的最后一跃</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC1%E9%83%A8%E5%88%86/10.%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E8%B7%83/</link><pubDate>Tue, 02 Jan 2024 18:45:57 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC1%E9%83%A8%E5%88%86/10.%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E8%B7%83/</guid><description>&lt;h1 id="进入-main-函数前的最后一跃">进入 main 函数前的最后一跃&lt;/h1>
&lt;p>上回书咱们说到，我们终于把这些杂七杂八的，idt、gdt、页表都设置好了，并且也开启了保护模式，相当于所有苦力活都做好铺垫了，之后我们就要准备进入 main.c！那里是个新世界！&lt;/p>
&lt;p>注意不是进入，而是准备进入哦，就差一哆嗦了。&lt;/p>
&lt;p>由于上一讲的知识量非常大，所以这一讲将会非常简单，作为进入 main 函数前的衔接，大家放宽心。&lt;/p>
&lt;p>这仍然要回到上一讲我们跳转到设置分页代码的那个地方（head.s 里），这里有个骚操作帮我们跳转到 main.c。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">after_page_tables:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">L6&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span> &lt;span class="nv">_main&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">jmp&lt;/span> &lt;span class="nv">setup_paging&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="nl">setup_paging:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>直接解释起来非常简单。&lt;/p>
&lt;p>push 指令就是&lt;strong>压栈&lt;/strong>，五个 push 指令过去后，栈会变成这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-13-156eda85004701c15cf3e4b8f42a1009.png" alt="图片">&lt;/p>
&lt;p>然后注意，setup_paging 最后一个指令是 &lt;strong>ret&lt;/strong>，也就是我们上一回讲的设置分页的代码的最后一个指令，形象地说它叫&lt;strong>返回指令&lt;/strong>，但 CPU 可没有那么聪明，它并不知道该返回到哪里执行，只是很机械地&lt;strong>把栈顶的元素值当做返回地址&lt;/strong>，跳转去那里执行。&lt;/p>
&lt;p>再具体说是，把 esp 寄存器（栈顶地址）所指向的内存处的值，赋值给 eip 寄存器，而 cs:eip 就是 CPU 要执行的下一条指令的地址。而此时栈顶刚好是 main.c 里写的 main 函数的内存地址，是我们刚刚特意压入栈的，所以 CPU 就理所应当跳过来了。&lt;/p>
&lt;p>当然 Intel CPU 是设计了 call 和 ret 这一配对儿的指令，意为调用函数和返回，具体可以看后面本回扩展资料里的内容。&lt;/p>
&lt;p>至于其他压入栈的 L6 是用作当 main 函数返回时的跳转地址，但由于在操作系统层面的设计上，main 是绝对不会返回的，所以也就没用了。而其他的三个压栈的 0，本意是作为 main 函数的参数，但实际上似乎也没有用到，所以也不必关心。&lt;/p>
&lt;p>总之，经过这一个小小的骚操作，程序终于跳转到 main.c 这个由 c 语言写就的主函数 main 里了！我们先一睹为快一下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">ROOT_DEV&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ORIG_ROOT_DEV&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">drive_info&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DRIVE_INFO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EXT_MEM_K&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>         
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memory_end&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">buffer_memory_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">main_memory_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>没错，这就是这个 main 函数的全部了。&lt;/p>
&lt;p>而整个操作系统也会最终停留在最后一行死循环中，永不返回，直到关机。&lt;/p>
&lt;p>好了，至此，整个第一部分就圆满结束了，为了跳进 main 函数的准备工作，我称之为进入内核前的苦力活，就完成了！我们看看我们做了什么。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-19-95de6488cde7af9dc9c3483b4006abdb.png" alt="图片">&lt;/p>
&lt;p>我把这些称为&lt;strong>进入内核前的苦力活&lt;/strong>，经过这样的流程，内存被搞成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-24-db3b5f601cc9850919800c42baa9b9c1.png" alt="图片">&lt;/p>
&lt;p>之后，main 方法就开始执行了，靠着我们辛辛苦苦建立起来的内存布局，向崭新的未来前进！&lt;/p>
&lt;p>欲知后事如何，且听下回分解。&lt;/p>
&lt;p>&lt;strong>&amp;mdash;&amp;mdash;- 本回扩展资料 &amp;mdash;&amp;mdash;-&lt;/strong>&lt;/p>
&lt;p>关于 ret 指令，其实 Intel CPU 是配合 call 设计的，有关 call 和 ret 指令，即调用和返回指令，可以参考 Intel 手册：&lt;/p>
&lt;p>Intel 1 Chapter 6.4 CALLING PROCEDURES USING CALL AND RET&lt;/p>
&lt;p>可以看到还分为不改变段基址的 near call 和 near ret&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-30-84032e07ec13d82c05ffa1cf1171961b.png" alt="图片">&lt;/p>
&lt;p>以及改变段基址的 far call 和 far ret&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-35-4611f11048ec93378617d517223d342c.png" alt="图片">&lt;/p>
&lt;p>压栈和出栈的具体过程，上面文字写的清清楚楚，下面 Intel 手册还非常友好地放了张图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-05-40-4264be57f8e7c1a0b7b660d2cc6b6faa.png" alt="图片">&lt;/p>
&lt;p>可以看到，我们本文就是左边的那一套，把 main 函数地址值当做 Calling EIP 压入栈，仿佛是执行了 call 指令调用了一个函数一样，但实际上这是我们通过骚操作代码伪造的假象，骗了 CPU。&lt;/p>
&lt;p>然后 ret 的时候就把栈顶的那个 Calling EIP 也就是 main 函数地址弹出栈，存入 EIP 寄存器，这样 CPU 就相当于“返回”到了 main 函数开始执行。&lt;/p></description></item><item><title>一个新进程的诞生 完结撒花</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE/</guid><description>&lt;h1 id="一个新进程的诞生-完结撒花">一个新进程的诞生 完结撒花&lt;/h1>
&lt;p>整个第三部分，我们用前四回的内容讲述了&lt;strong>进程调度机制&lt;/strong>，又用后三回内容讲述了 &lt;strong>fork&lt;/strong> 函数的全部细节。先看进程调度机制。&lt;/p>
&lt;p>&lt;strong>进程调度机制&lt;/strong>&lt;/p>
&lt;p>前四回内容循序渐进地讲述了进程调度机制的设计思路和细节。&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501340&amp;amp;idx=1&amp;amp;sn=fc3ca3a7d8a206a6d82ab7199aac64f9&amp;amp;scene=21#wechat_redirect">第21回 | 新进程诞生全局概述&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501522&amp;amp;idx=1&amp;amp;sn=936f7837421870a572ee2a82d745a519&amp;amp;scene=21#wechat_redirect">第22回 | 从内核态切换到用户态&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501576&amp;amp;idx=1&amp;amp;sn=657e1c89d1007a935820d394d64f4035&amp;amp;scene=21#wechat_redirect">第23回 | 如果让你来设计进程调度&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501609&amp;amp;idx=1&amp;amp;sn=fe5bd9b9f69045fd70f6d7aeaea273bc&amp;amp;scene=21#wechat_redirect">第24回 | 从一次定时器滴答来看进程调度&lt;/a>&lt;/p>
&lt;p>进程调度的始作俑者，就是那个每 10ms 触发一次的定时器滴答。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-15-47-450c8c8d7755fdc58b1e1622465afccf.gif" alt="图片">&lt;/p>
&lt;p>而这个滴答将会给 CPU 产生一个&lt;strong>时钟中断&lt;/strong>信号。&lt;/p>
&lt;p>而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 &lt;strong>do_timer&lt;/strong>。&lt;/p>
&lt;p>do_timer 会首先将当前进程的 &lt;strong>counter&lt;/strong> 变量 -1，如果 counter 此时仍然大于 0，则就此结束。&lt;/p>
&lt;p>但如果 counter = 0 了，就开始进行进程的调度。&lt;/p>
&lt;p>进程调度就是找到所有处于 &lt;strong>RUNNABLE&lt;/strong> 状态的进程，并找到一个 counter 值最大的进程，把它丢进 &lt;strong>switch_to&lt;/strong> 函数的入参里。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-15-52-4e39b6734ea2f8ed48269bb56645099c.gif" alt="图片">&lt;/p>
&lt;p>switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-43-07-30e4fce99a9b0aae19382fb96fd9da4f.png" alt="图片">&lt;/p>
&lt;p>上图来源于《Linux内核完全注释V5.0》&lt;/p>
&lt;p>接着，这个进程就舒舒服服地运行了起来，等待着下一次&lt;strong>时钟中断&lt;/strong>的来临。&lt;/p>
&lt;p>聊完进程调度机制，我们再看看 fork 函数的原理。&lt;/p>
&lt;p>&lt;strong>fork&lt;/strong>&lt;/p>
&lt;p>后三回内容讲述了 fork 函数的全部细节。&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501700&amp;amp;idx=1&amp;amp;sn=1b0167cf9852f89748a337d9b06c940b&amp;amp;chksm=c2c5bd29f5b2343ff01c68f1cbc654fbb12148f00eff8c21bb2e725a6054a7a6fbddbc253afb&amp;amp;scene=21#wechat_redirect">第25回 | 通过 fork 看一次系统调用&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501748&amp;amp;idx=1&amp;amp;sn=2ad618817656321501b2c8e734ffefe6&amp;amp;chksm=c2c5bd19f5b2340f0ae684fa2a2a808a9a5210693736d21019ed542cf5351c3b65b2784d40ee&amp;amp;scene=21#wechat_redirect">第26回 | fork 中进程基本信息的复制&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501866&amp;amp;idx=1&amp;amp;sn=64adec9179345945d095a1a1bdebcdac&amp;amp;chksm=c2c5b287f5b23b9175d8eacf7731b22823a576f78e14d8b93b2e8c9814bcb11076967d878a12&amp;amp;scene=21#wechat_redirect">第27回 | 透过 fork 来看进程的内存规划&lt;/a>&lt;/p>
&lt;p>用一张图来表示的话，就是。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-43-15-dc34b5ad8b1dec9570605c1480c75606.png" alt="图片">&lt;/p>
&lt;p>其中 &lt;strong>copy_process&lt;/strong> 是复制进程的关键，总共分三步来。&lt;/p>
&lt;p>&lt;strong>第一&lt;/strong>，原封不动复制了一下 task_struct。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-43-21-bec51be34285efe75570ab853f3d30fb.png" alt="图片">&lt;/p>
&lt;p>并且覆盖了一些基本信息，包括元信息和一些寄存器的信息。其中比较重要的是将内核态堆栈栈顶指针的指向了自己进程结构所在 4K 内存页的最顶端。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-43-26-aa0b12e1dddb413220f09b57a434c26d.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第二&lt;/strong>，LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-43-31-ef49827f2115ca7e879e8aef879c8d54.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第三&lt;/strong>，页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-43-36-13f32cbd06177df5b8e9168aedaa3cf9.png" alt="图片">&lt;/p>
&lt;p>最后，将新老进程的页表都变成只读状态，为后面&lt;strong>写时复制&lt;/strong>的&lt;strong>缺页中断&lt;/strong>做准备。&lt;/p>
&lt;p>这一部分的 fork 函数只用于进程 0 创造进程 1 的过程，而之后的新进程创建，比如进程 1 里 fork 创建进程 2，也都是这样的套路。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-43-41-bee8d5b96e4be9fab2067ea7021a2e78.png" alt="图片">&lt;/p>
&lt;p>整个核心函数 copy_process 的代码如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_process(int nr, ...) {    struct task_struct p =         (struct task_struct *) get_free_page();    task[nr] = p;    *p = *current;    p-&amp;gt;state = TASK_UNINTERRUPTIBLE;    p-&amp;gt;pid = last_pid;    p-&amp;gt;counter = p-&amp;gt;priority;    ..    p-&amp;gt;tss.edx = edx;    p-&amp;gt;tss.ebx = ebx;    p-&amp;gt;tss.esp = esp;    ...    copy_mem(nr,p);    ...    set_tss_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_TSS_ENTRY,&amp;amp;(p-&amp;gt;tss));    set_ldt_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_LDT_ENTRY,&amp;amp;(p-&amp;gt;ldt));    p-&amp;gt;state = TASK_RUNNING;    return last_pid;}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意图中的两个标黄的代码。&lt;/p>
&lt;p>开始复制进程信息的时候，由于进程 1 的结构还没弄好，此时如果进程调度到了进程 1，那就坏事了。&lt;/p>
&lt;p>所以一开始把进程 1 的状态先设置为 &lt;strong>TASK_UNINTERRUPTIBLE&lt;/strong>，使得其不会被进程调度算法选中。&lt;/p>
&lt;p>而所有复制工作完成后，进程 1 就拥有了运行的内容，进程基本信息也有了，进程的内存规划也完成了。&lt;/p>
&lt;p>此时就把进程设置为 &lt;strong>TASK_RUNNING&lt;/strong>，允许被 CPU 调度。&lt;/p>
&lt;p>看到这行代码，其实我们也可以很自信地认为，&lt;strong>到这里进程 1 的初步建立工作已经圆满结束，可以达到运行在 CPU 上的标准了&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>第四部分的展望&lt;/strong>&lt;/p>
&lt;p>那我们此时又该回到之前的 main 方法，是不是都忘了最初的目的了？哈哈。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，下一行代码，是 &lt;strong>init&lt;/strong>。&lt;/p>
&lt;p>fork 只是把进程 1 搞成可以在 CPU 中运行的进程，之后创建新进程，都可以用这个 fork 方法。&lt;/p>
&lt;p>不过进程 1 具体要做什么事情呢？那就是 init 这个函数的故事了。&lt;/p>
&lt;p>虽然就一行代码，但这里的事情可多了去了，我们先看一下整体结构。我已经把单纯的日志打印和错误校验逻辑去掉了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="cm">/* nothing */&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">setsid&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
    &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="cm">/* NOTE! _exit, not exit() */&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是不是看着还挺复杂？&lt;/p>
&lt;p>&lt;strong>不过还好，我们几乎已经把计算机体系结构，和操作系统的设计思想，通过前面的源码阅读，不知不觉建立起来了。&lt;/strong>&lt;/p>
&lt;p>接下来的工作，就是基于这些建立好的能力，站在巨人的肩膀上，做些更伟大的事情！&lt;/p>
&lt;p>说伟大其实也没什么伟大的，就是最终建立好一个人机交互的 shell 程序，无限等待用户输入的命令。&lt;/p></description></item><item><title>一个新进程的诞生（四）从一次定时器滴答来看进程调度</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/24.%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BB%B4%E7%AD%94%E6%9D%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC3%E9%83%A8%E5%88%86/24.%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BB%B4%E7%AD%94%E6%9D%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="一个新进程的诞生四从一次定时器滴答来看进程调度">一个新进程的诞生（四）从一次定时器滴答来看进程调度&lt;/h1>
&lt;p>书接上回，上回书咱们说到，我们完全由自己从零到有设计出了进程调度的大体流程，以及它需要的数据结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这一讲，我们从一次定时器滴答出发，看看一次 Linux 0.11 的进程调度的全过程。&lt;/p>
&lt;p>Let&amp;rsquo;s Go！&lt;/p>
&lt;p>还记得我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的&lt;/a> &lt;strong>sched_init&lt;/strong> 的时候，开启了&lt;strong>定时器&lt;/strong>吧？这个定时器每隔一段时间就会向 CPU 发起一个中断信号。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-14-32-450c8c8d7755fdc58b1e1622465afccf.gif" alt="图片">&lt;/p>
&lt;p>这个间隔时间被设置为 10 ms，也就是 100 Hz。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">schedule.c#define HZ 100
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>发起的中断叫&lt;strong>时钟中断&lt;/strong>，其中断向量号被设置为了 &lt;strong>0x20&lt;/strong>。&lt;/p>
&lt;p>还记得我们在 &lt;strong>sched_init&lt;/strong> 里设置的时钟中断和对应的中断处理函数吧？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">schedule.cset_intr_gate(0x20, &amp;amp;timer_interrupt);
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样，当时钟中断，也就是 0x20 号中断来临时，CPU 会查找中断向量表中 0x20 处的函数地址，即中断处理函数，并跳转过去执行。&lt;/p>
&lt;p>这个中断处理函数就是 &lt;strong>timer_interrupt&lt;/strong>，是用汇编语言写的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="c1">; system_call.s&lt;/span>
&lt;span class="nl">_timer_interrupt:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="err">    // 增加系统滴答数&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">incl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_jiffies&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="err">    // 调用函数 &lt;/span>&lt;span class="nf">do_timer&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_do_timer&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数做了两件事，一个是将&lt;strong>系统滴答数&lt;/strong>这个变量 &lt;strong>jiffies&lt;/strong> 加一，一个是调用了另一个函数 &lt;strong>do_timer&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// sched.c
void do_timer(long cpl) {
    ...
    // 当前线程还有剩余时间片，直接返回
    if ((--current-&amp;gt;counter)&amp;gt;0) return;
    // 若没有剩余时间片，调度
    schedule();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>do_timer 最重要的部分就是上面这段代码，非常简单。&lt;/p>
&lt;p>首先将当先进程的时间片 -1，然后判断：&lt;/p>
&lt;p>如果时间片仍然大于零，则什么都不做直接返回。&lt;/p>
&lt;p>如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NR_TASKS&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NR_TASKS&lt;/span>&lt;span class="p">];&lt;/span>
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!*--&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TASK_RUNNING&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="p">}&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">LAST_TASK&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">FIRST_TASK&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span>
                        &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">}&lt;/span>
    &lt;span class="n">switch_to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>别看这么一大坨，我做个不严谨的简化，你就明白了&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_max_counter_and_runnable_thread&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="n">refresh_all_thread_counter&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="n">switch_to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到没，就剩这么点了。&lt;/p>
&lt;p>很简答，这个函数就做了三件事：&lt;/p>
&lt;p>&lt;strong>1.&lt;/strong> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/1a49bdd4f41fa02f7ad396f78ec6a04b75f924c6.gif" alt="图片">&lt;/p>
&lt;p>&lt;strong>2.&lt;/strong> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。&lt;/p>
&lt;p>&lt;strong>3.&lt;/strong> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。&lt;/p>
&lt;p>看 switch_to 方法，是用内联汇编语句写的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sched.h
#define switch_to(n) {\
    struct {long a,b;} __tmp; \
        __asm__(&amp;#34;cmpl %%ecx,_current\n\t&amp;#34; \    
            &amp;#34;je 1f\n\t&amp;#34; \    
            &amp;#34;movw %%dx,%1\n\t&amp;#34; \    
            &amp;#34;xchgl %%ecx,_current\n\t&amp;#34; \    
            &amp;#34;ljmp %0\n\t&amp;#34; \    
            &amp;#34;cmpl %%ecx,_last_task_used_math\n\t&amp;#34; \    
            &amp;#34;jne 1f\n\t&amp;#34; \    
            &amp;#34;clts\n&amp;#34; \    
            &amp;#34;1:&amp;#34; \    
            ::&amp;#34;m&amp;#34; (*&amp;amp;__tmp.a),&amp;#34;m&amp;#34; (*&amp;amp;__tmp.b), \    
            &amp;#34;d&amp;#34; (_TSS(n)),&amp;#34;c&amp;#34; ((long) task[n])); \
    }
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段话就是进程切换的最最最最底层的代码了。&lt;/p>
&lt;p>看不懂没关系，其实主要就干了一件事，就是 ljmp 到新进程的 tss 段处。&lt;/p>
&lt;p>啥意思？&lt;/p>
&lt;p>CPU 规定，如果 ljmp 指令后面跟的是一个 tss 段，那么，会由硬件将当前各个寄存器的值保存在当前进程的 tss 中，并将新进程的 tss 信息加载到各个寄存器。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-35-12-30e4fce99a9b0aae19382fb96fd9da4f.png" alt="图片">&lt;/p>
&lt;p>上图来源于《Linux内核完全注释V5.0》&lt;/p>
&lt;p>这个图在完全注释这本书里里画的非常清晰，我就不重复造轮子了。&lt;/p>
&lt;p>简单说就是，&lt;strong>保存当前进程上下文，恢复下一个进程的上下文，跳过去&lt;/strong>！&lt;/p>
&lt;p>看，不知不觉，我们上一讲和本讲开头提到的那些进程数据结构的字段，就都用上了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>至此，我们梳理完了一个进程切换的整条链路，来回顾一下。&lt;/p>
&lt;p>&amp;mdash;&amp;ndash; 流水账开始 &amp;mdash;&amp;ndash;&lt;/p>
&lt;p>罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。&lt;/p>
&lt;p>而这个滴答将会给 CPU 产生一个时钟中断信号。&lt;/p>
&lt;p>而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。&lt;/p>
&lt;p>do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。&lt;/p>
&lt;p>但如果 counter = 0 了，就开始进行进程的调度。&lt;/p>
&lt;p>进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。&lt;/p>
&lt;p>switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。&lt;/p>
&lt;p>接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。&lt;/p>
&lt;p>&amp;mdash;&amp;ndash; 流水账结束 &amp;mdash;&amp;ndash;&lt;/p>
&lt;p>好了，这两回我们自己设计了一遍进程调度，又看了一次 Linux 0.11 的进程调度的全过程。有了这两回做铺垫，我们下一回就该非常自信地回到我们的主流程，开始看我们心心念念的 &lt;strong>fork&lt;/strong> 函数！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>        
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>欲知后事如何，且听下回分解。&lt;/p></description></item><item><title>你的键盘是什么时候生效的？</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/14.%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96trap_init/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/14.%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96trap_init/</guid><description>&lt;h1 id="你的键盘是什么时候生效的">你的键盘是什么时候生效的？&lt;/h1>
&lt;p>当你的计算机刚刚启动时，你按下键盘是不生效的，但是过了一段时间后，再按下键盘就有效果了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-42-52-2fa9c71755d09a9f049d11155f425500.gif" alt="图片">&lt;/p>
&lt;p>那我们今天就来刨根问底一下，&lt;strong>到底过了多久之后，按下键盘才有效果呢？&lt;/strong>&lt;/p>
&lt;p>当然首先你得知道，按下键盘后会触发中断，CPU 收到你的键盘中断后，根据中断号，寻找由操作系统写好的键盘中断处理程序。&lt;/p>
&lt;p>中断的原理和过程不了解的，可以看我的文章，&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247498208&amp;amp;idx=1&amp;amp;sn=b784f8b4e627ebd1bfb9810d194fdb80&amp;amp;chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&amp;amp;scene=21#wechat_redirect">认认真真的聊聊中断&lt;/a>&lt;/p>
&lt;p>这个中断处理程序会把你的键盘码放入一个队列中，由相应的用户程序或内核程序读取，并显示在控制台，或者其他用途，这就代表你的键盘生效了。&lt;/p>
&lt;p>不过放宽心，我们不展开讲这个中断处理程序以及用户程序读取键盘码后的处理细节，我们把关注点放在，究竟是**“什么时候”**，按下键盘才会有这个效果。&lt;/p>
&lt;p>我们以 &lt;strong>Linux 0.11&lt;/strong> 源码为例，发现进入内核的 main 函数后不久，有这样一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到这个方法的全部代码后，你可能会会心一笑，也可能一脸懵逼。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">trap_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">divide_error&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">debug&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">nmi&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_system_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">int3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cm">/* int3-5 can be called from all */&lt;/span>
&lt;span class="n">set_system_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">overflow&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_system_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">bounds&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">invalid_op&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">device_not_available&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">double_fault&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">coprocessor_segment_overrun&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">invalid_TSS&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">segment_not_present&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">stack_segment&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">general_protection&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">page_fault&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">reserved&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">coprocessor_error&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">48&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
     &lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">reserved&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">45&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">irq13&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">39&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">¶&lt;/span>&lt;span class="n">llel_interrupt&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这啥玩意？这么多 &lt;strong>set_xxx_gate&lt;/strong>。&lt;/p>
&lt;p>有密集恐惧症的话，绝对看不下去这个代码，所以我就给他简化一下。&lt;/p>
&lt;p>把相同功能的去掉。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void trap_init(void) {    
int i;    
// set 了一堆 trap_gate    
set_trap_gate(0, &amp;amp;divide_error);    
...     
// 又 set 了一堆 system_gate    
set_system_gate(45, &amp;amp;bounds);    
...    
// 又又批量 set 了一堆 trap_gate    
for (i=17;i&amp;lt;48;i++)        
set_trap_gate(i, &amp;amp;reserved);    
...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就简单多了，我们一块一块看。&lt;/p>
&lt;p>首先我们看 &lt;strong>set_trap_gate&lt;/strong> 和 &lt;strong>set_system_gate&lt;/strong> 这俩货，发现了这么几个宏定义。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define _set_gate(gate_addr,type,dpl,addr) \
&lt;/span>&lt;span class="cp"> __asm__ (&amp;#34;movw %%dx,%%ax\n\t&amp;#34; \    
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="s">&amp;#34;movw %0,%%dx&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span> &lt;span class="err">\&lt;/span>    
&lt;span class="s">&amp;#34;movl %%eax,%1&lt;/span>&lt;span class="se">\n\t&lt;/span>&lt;span class="s">&amp;#34;&lt;/span> &lt;span class="err">\&lt;/span>    
&lt;span class="s">&amp;#34;movl %%edx,%2&amp;#34;&lt;/span> &lt;span class="err">\&lt;/span>    
&lt;span class="o">:&lt;/span> &lt;span class="err">\&lt;/span>    
&lt;span class="o">:&lt;/span> &lt;span class="s">&amp;#34;i&amp;#34;&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">short&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mh">0x8000&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dpl&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">))),&lt;/span> &lt;span class="err">\&lt;/span>    
&lt;span class="s">&amp;#34;o&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">gate_addr&lt;/span>&lt;span class="p">))),&lt;/span> &lt;span class="err">\&lt;/span>    
&lt;span class="s">&amp;#34;o&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">gate_addr&lt;/span>&lt;span class="p">))),&lt;/span> &lt;span class="err">\&lt;/span>    
&lt;span class="s">&amp;#34;d&amp;#34;&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">)),&lt;/span>&lt;span class="s">&amp;#34;a&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mh">0x00080000&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="cp">#define set_trap_gate(n,addr) \    
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="n">_set_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="cp">#define set_system_gate(n,addr) \    
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="n">_set_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">idt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>别怕，我也看不懂。&lt;/p>
&lt;p>不过这俩都是最终指向了相同的另一个宏定义 &lt;strong>_set_gate&lt;/strong>，说明是有共性的。&lt;/p>
&lt;p>啥共性呢？我直接说吧，那段你完全看不懂的代码，是将汇编语言嵌入到 c 语言了，这种内联汇编的格式非常恶心，所以我也不想搞懂它，最终的效果就是&lt;strong>在中断描述符表中插入了一个中断描述符&lt;/strong>。&lt;/p>
&lt;p>中断描述符表还记得吧，英文叫 idt。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-41-46-980a6ab69c8cc1c112cf57a8aaa4be6b.png" alt="图片">&lt;/p>
&lt;p>这段代码就是往这个 idt 表里一项一项地写东西，其对应的中断号就是第一个参数，中断处理程序就是第二个参数。&lt;/p>
&lt;p>产生的效果就是，之后如果来一个中断后，CPU 根据其中断号，就可以到这个中断描述符表 idt 中找到对应的中断处理程序了。&lt;/p>
&lt;p>比如这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">set_trap_gate(0,&amp;amp;divide_error);
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是设置 &lt;strong>0 号中断&lt;/strong>，对应的中断处理程序是 &lt;strong>divide_error&lt;/strong>。&lt;/p>
&lt;p>等 CPU 执行了一条除零指令的时候，会从硬件层面发起一个 0 号异常中断，然后执行由我们操作系统定义的 divide_error 也就是除法异常处理程序，执行完之后再返回。&lt;/p>
&lt;p>再比如这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">set_system_gate(5,&amp;amp;overflow);
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是设置 5 号中断，对应的中断处理程序是 overflow，是边界出错中断。&lt;/p>
&lt;p>TIPS：这个 trap 与 system 的区别仅仅在于，设置的中断描述符的特权级不同，前者是 0（内核态），后者是 3（用户态），这块展开将会是非常严谨的、绕口的、复杂的特权级相关的知识，不明白的话先不用管，就理解为都是设置一个中断号和中断处理程序的对应关系就好了。&lt;/p>
&lt;p>再往后看，批量操作这里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">trap_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">48&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">reserved&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>17 到 48 号中断都批量设置为了 &lt;strong>reserved&lt;/strong> 函数，这是暂时的，后面各个硬件初始化时要重新设置好这些中断，把暂时的这个给覆盖掉，此时你留个印象。&lt;/p>
&lt;p>所以整段代码执行下来，内存中那个 idt 的位置会变成如下的样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-41-56-d55bc92607d5761f34d490c8c549d8b0.png" alt="图片">&lt;/p>
&lt;p>好了，我们看到了设置中断号与中断处理程序对应的地方，那这行代码过去后，键盘好使了么？&lt;/p>
&lt;p>&lt;strong>NO&lt;/strong>&lt;/p>
&lt;p>键盘产生的中断的中断号是 &lt;strong>0x21&lt;/strong>，此时这个中断号还仅仅对应着一个临时的中断处理程序 &amp;amp;reserved，我们接着往后看。&lt;/p>
&lt;p>在这行代码往后几行，还有这么一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">tty_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">rs_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">con_init&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">keyboard_interrupt&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我省略了大量的代码，只保留了我们关心的。&lt;/p>
&lt;p>注意到 trap_init 后有个 &lt;strong>tty_init&lt;/strong>，最后根据调用链，会调用到一行添加 0x21 号中断处理程序的代码，就是刚刚熟悉的 &lt;strong>set_trap_gate&lt;/strong>。&lt;/p>
&lt;p>而后面的 &lt;strong>keyboard_interrupt&lt;/strong> 根据名字也可以猜出，就是键盘的中断处理程序嘛！&lt;/p>
&lt;p>好了，那我们终于找到大案了，就是从这一行代码开始，我们的键盘生效了！&lt;/p>
&lt;p>没错，不过还有点小问题，不过不重要，就是我们现在的中断处于&lt;strong>禁用状态&lt;/strong>，不论是键盘中断还是其他中断，通通都不好使。&lt;/p>
&lt;p>而 main 方法继续往下读，还有一行这个东西。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>sti 最终会对应一个同名的汇编指令 sti，表示&lt;strong>允许中断&lt;/strong>。所以这行代码之后，键盘才真正开始生效！&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-43-14-65419d0147dd0e8d398089f6338cb138.gif" alt="图片">&lt;/p>
&lt;p>动画酷不酷？好啦，今天的文章就到这里了，中断的原理和细节，就看我之前的文章，&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247498208&amp;amp;idx=1&amp;amp;sn=b784f8b4e627ebd1bfb9810d194fdb80&amp;amp;chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&amp;amp;scene=21#wechat_redirect">认认真真的聊聊中断&lt;/a>。&lt;/p>
&lt;p>键盘处理的具体流程，可以跟着我今天的代码深入进去看看哟，Linux 0.11 里还是很简单的。&lt;/p></description></item><item><title>原来操作系统获取时间的方式也这么low</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/17.%E6%97%B6%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96time_init/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/17.%E6%97%B6%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96time_init/</guid><description>&lt;h1 id="原来操作系统获取时间的方式也这么low">原来操作系统获取时间的方式也这么low&lt;/h1>
&lt;p>书接上回，上回书咱们说到，通过初始化控制台的 tty_init 操作，内核代码可以很方便地在控制台输出字符啦！&lt;/p>
&lt;p>作为用户也可以通过敲击键盘，或调用诸如 printf 这样的库函数，在屏幕上输出信息，同时支持换行和滚屏等友好设计，这些都是 tty_init 初始化，以及其对外封装的小功能函数，来实现的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-12-15-55ce05e563c97e43db49cc53dab22aaf.gif" alt="图片">&lt;/p>
&lt;p>我们继续往下看下一个初始化的倒霉鬼，&lt;strong>time_init&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>        
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>曾经我很好奇，&lt;strong>操作系统是怎么获取到当前时间的呢&lt;/strong>？&lt;/p>
&lt;p>当然，现在都联网了，可以从网络上实时同步。那当没有网络时，为什么操作系统在启动之后，可以显示出当前时间呢？难道操作系统在电脑关机后，依然不停地在某处运行着，勤勤恳恳数着秒表么？&lt;/p>
&lt;p>当然不是，那我们今天就打开这个 &lt;strong>time_init&lt;/strong> 函数一探究竟。&lt;/p>
&lt;p>打开这个函数后我又是很开心，因为很短，且没有更深入的方法调用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define CMOS_READ(addr) ({ \    
&lt;/span>&lt;span class="cp">&lt;/span>    &lt;span class="n">outb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x70&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">\&lt;/span>    
    &lt;span class="n">inb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x71&lt;/span>&lt;span class="p">);&lt;/span> \
&lt;span class="p">})&lt;/span>
&lt;span class="cp">#define BCD_TO_BIN(val) ((val)=((val)&amp;amp;15) + ((val)&amp;gt;&amp;gt;4)*10)
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">time_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tm&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_sec&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_min&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_hour&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mday&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mon&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_year&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">9&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_sec&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_sec&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_min&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_hour&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mday&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mon&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mon&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">startup_time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">kernel_mktime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>梦想的代码呀！&lt;/p>
&lt;p>那主要就是对 &lt;strong>CMOS_READ&lt;/strong> 和 &lt;strong>BCD_TO_BIN&lt;/strong> 都是啥意思展开讲一下就明白了了。&lt;/p>
&lt;p>首先是 &lt;strong>CMOS_READ&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define CMOS_READ(addr) ({ \    
&lt;/span>&lt;span class="cp">&lt;/span>    &lt;span class="n">outb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x70&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">\&lt;/span>    
    &lt;span class="n">inb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x71&lt;/span>&lt;span class="p">);&lt;/span> \
&lt;span class="p">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是对一个端口先 &lt;strong>out&lt;/strong> 写一下，再 &lt;strong>in&lt;/strong> 读一下。&lt;/p>
&lt;p>这是 CPU 与外设交互的一个基本玩法，CPU 与外设打交道基本是通过端口，往某些端口写值来表示要这个外设干嘛，然后从另一些端口读值来接受外设的反馈。&lt;/p>
&lt;p>至于这个外设内部是怎么实现的，对使用它的操作系统而言，是个黑盒，无需关心。那对于我们程序员来说，就更不用关心了。&lt;/p>
&lt;p>对 CMOS 这个外设的交互讲起来可能没感觉，我们看看与硬盘的交互。&lt;/p>
&lt;p>最常见的就是读硬盘了，我们看硬盘的端口表。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>端口&lt;/th>
&lt;th>读&lt;/th>
&lt;th>写&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x1F0&lt;/td>
&lt;td>数据寄存器&lt;/td>
&lt;td>数据寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x1F1&lt;/td>
&lt;td>错误寄存器&lt;/td>
&lt;td>特征寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x1F2&lt;/td>
&lt;td>扇区计数寄存器&lt;/td>
&lt;td>扇区计数寄存器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x1F3&lt;/td>
&lt;td>扇区号寄存器或 LBA 块地址 0~7&lt;/td>
&lt;td>扇区号或 LBA 块地址 0~7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x1F4&lt;/td>
&lt;td>磁道数低 8 位或 LBA 块地址 8~15&lt;/td>
&lt;td>磁道数低 8 位或 LBA 块地址 8~15&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x1F5&lt;/td>
&lt;td>磁道数高 8 位或 LBA 块地址 16~23&lt;/td>
&lt;td>磁道数高 8 位或 LBA 块地址 16~23&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x1F6&lt;/td>
&lt;td>驱动器/磁头或 LBA 块地址 24~27&lt;/td>
&lt;td>驱动器/磁头或 LBA 块地址 24~27&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x1F7&lt;/td>
&lt;td>命令寄存器或状态寄存器&lt;/td>
&lt;td>命令寄存器&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>那读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 0x1F0 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。&lt;/p>
&lt;p>如果觉得不够具体，那来个具体的版本。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在 0x1F2 写入要读取的扇区数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 0x1F7 处写入读命令的指令号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>看，是不是对 CPU 最底层是如何与外设打交道有点感觉了？是不是也不难？就是按照人家的操作手册，然后无脑按照要求读写端口就行了。&lt;/p>
&lt;p>当然，读取硬盘的这个无脑循环，可以 &lt;strong>CPU&lt;/strong> 直接读取并做写入内存的操作，这样就会占用 CPU 的计算资源。&lt;/p>
&lt;p>也可以交给 &lt;strong>DMA&lt;/strong> 设备去读，解放 CPU，但和硬盘的交互，通通都是按照硬件手册上的端口说明，来操作的，实际上也是做了一层封装。&lt;/p>
&lt;p>好了，我们已经学会了和一个外设打交道的基本玩法了。&lt;/p>
&lt;p>那我们代码中要打交道的是哪个外设呢？就是 &lt;strong>CMOS&lt;/strong>。&lt;/p>
&lt;p>它是主板上的一个可读写的 RAM 芯片，你在开机时长按某个键就可以进入设置它的页面。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-55-18-411d42b688bc0d18c019381141d979ed.jpg" alt="图片">&lt;/p>
&lt;p>那我们的代码，其实就是与它打交道，获取它的一些数据而已。&lt;/p>
&lt;p>我们回过头看代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">time_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tm&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_sec&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_min&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_hour&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mday&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mon&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_year&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">9&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_sec&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">CMOS_READ&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_sec&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_min&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_hour&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mday&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mon&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">BCD_TO_BIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tm_mon&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">startup_time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">kernel_mktime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>前面几个赋值语句 &lt;strong>CMOS_READ&lt;/strong> 就是通过读写 CMOS 上的指定端口，依次获取&lt;strong>年月日时分秒&lt;/strong>等信息。具体咋操作代码上也写了，也是按照 CMOS 手册要求的读写指定端口就行了，我们就不展开了。&lt;/p>
&lt;p>所以你看，其实操作系统程序，也是要依靠与一个外部设备打交道，来获取这些信息的，并不是它自己有什么魔力。操作系统最大的魅力，就在于它借力完成了一项伟大的事，借 CPU 的力，借硬盘的力，借内存的力，以及现在借 CMOS 的力。&lt;/p>
&lt;p>至于 CMOS 又是如何知道时间的，这个就不在我们讨论范围了。&lt;/p>
&lt;p>接下来 &lt;strong>BCD_TO_BIN&lt;/strong> 就是 BCD 转换成 BIN，因为从 CMOS 上获取的这些年月日都是 BCD 码值，需要转换成存储在我们变量上的二进制数值，所以需要一个小算法来转换一下，没什么意思。&lt;/p>
&lt;p>最后一步 &lt;strong>kernel_mktime&lt;/strong> 也很简单，就是根据刚刚的那些时分秒数据，计算从 &lt;strong>1970 年 1 月 1 日 0 时&lt;/strong>起到开机当时经过的秒数，作为开机时间，存储在 &lt;strong>startup_time&lt;/strong> 这个变量里。&lt;/p>
&lt;p>想研究可以仔细看看这段代码，不过我觉得这种细节不必看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">startup_time = kernel_mktime(&amp;amp;time);
// kernel/mktime.clong 
kernel_mktime(struct tm * tm){    
    long res;    
    int year;    
    year = tm-&amp;gt;tm_year - 70;    
    res = YEAR*year + DAY*((year+1)/4);    
    res += month[tm-&amp;gt;tm_mon];    
    if (tm-&amp;gt;tm_mon&amp;gt;1 &amp;amp;&amp;amp; ((year+2)%4))        
        res -= DAY;    
    res += DAY*(tm-&amp;gt;tm_mday-1);    
    res += HOUR*tm-&amp;gt;tm_hour;    
    res += MINUTE*tm-&amp;gt;tm_min;    
    res += tm-&amp;gt;tm_sec;    
    return res;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就这。&lt;/p>
&lt;p>所以今天其实就是，计算出了一个 &lt;strong>startup_time&lt;/strong> 变量而已，至于这个变量今后会被谁用，怎么用，那就是后话了。&lt;/p>
&lt;p>相信你逐渐也体会到了，此时操作系统好多地方都是用外设要求的方式去询问，比如硬盘信息、显示模式，以及今天的开机时间的获取等。&lt;/p>
&lt;p>所以至少到目前来说，你还不应该感觉操作系统有多么的“高端”，很多时候都是繁琐地，读人家的硬件手册，获取到想要的的信息，拿来给自己用，或者对其进行各种设置。&lt;/p></description></item><item><title>按下键盘后为什么屏幕上就会有输出</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/16.%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%9D%E5%A7%8B%E5%8C%96tty_init/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/16.%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%9D%E5%A7%8B%E5%8C%96tty_init/</guid><description>&lt;h1 id="按下键盘后为什么屏幕上就会有输出">按下键盘后为什么屏幕上就会有输出&lt;/h1>
&lt;p>继内存管理结构 mem_map 和中断描述符表 &lt;strong>idt&lt;/strong> 建立好之后，我们又在内存中倒腾出一个新的数据结构 request。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-54-29-0cd1b1507c1b3a1def8e8ae2318cc454.png" alt="图片">&lt;/p>
&lt;p>并且把它们都放在了一个数组中。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-54-35-67de5d8590db81f3635813a587755d0d.png" alt="图片">&lt;/p>
&lt;p>这是&lt;strong>块设备驱动程序&lt;/strong>与&lt;strong>内存缓冲区&lt;/strong>的桥梁，通过它可以完整地表示一个块设备读写操作要做的事。&lt;/p>
&lt;p>我们继续往下看，tty_init。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>        
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法执行完成之后，我们将会具备键盘输入到显示器输出字符这个最常用的功能。&lt;/p>
&lt;p>打开这个函数后我有点慌。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">tty_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">){&lt;/span>    
    &lt;span class="n">rs_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">con_init&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看来这个方法已经多到需要拆成两个子方法了。&lt;/p>
&lt;p>打开第一个方法，还好。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">rs_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">){&lt;/span>    
    &lt;span class="n">set_intr_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x24&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">rs1_interrupt&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">set_intr_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x23&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">rs2_interrupt&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">outb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mh">0xE7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法是串口中断的开启，以及设置对应的中断处理程序，串口在我们现在的 PC 机上已经很少用到了，所以这个直接忽略，要讲我也不懂。&lt;/p>
&lt;p>看第二个方法，这是重点。代码非常长，有点吓人，我先把大体框架写出。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ORIG_VIDEO_MODE&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">ORIG_VIDEO_EGA_BX&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xff&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mh">0x10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">ORIG_VIDEO_EGA_BX&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xff&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mh">0x10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="p">...&lt;/span>
        &lt;span class="p">}&lt;/span>
    &lt;span class="p">}&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，非常多的 if else。&lt;/p>
&lt;p>这是为了应对不同的显示模式，来分配不同的变量值，那如果我们仅仅找出一个显示模式，这些分支就可以只看一个了。&lt;/p>
&lt;p>啥是显示模式呢？那我们得简单说说显示，&lt;strong>一个字符是如何显示在屏幕上的呢&lt;/strong>？换句话说，如果你可以随意操作内存和 CPU 等设备，你如何操作才能使得你的显示器上，显示一个字符‘a’呢？&lt;/p>
&lt;p>我们先看一张图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-54-44-e0114d9f3618a7346926003c3b291a67.png" alt="图片">&lt;/p>
&lt;p>内存中有这样一部分区域，是和显存映射的。啥意思，就是你往上图的这些内存区域中写数据，相当于写在了显存中。而往显存中写数据，就相当于在屏幕上输出文本了。&lt;/p>
&lt;p>没错，就是这么简单。&lt;/p>
&lt;p>如果我们写这一行汇编语句。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0xB8000&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="s">&amp;#39;h&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>后面那个 h 相当于汇编编辑器帮我们转换成 ASCII 码的二进制数值，当然我们也可以直接写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0xB8000&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="mh">0x68&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其实就是往内存中 &lt;strong>0xB8000&lt;/strong> 这个位置写了一个值，只要一写，屏幕上就会是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-54-52-02dc025a09c12d800b8a9eeac411d1eb.png" alt="图片">&lt;/p>
&lt;p>简单吧，具体说来，这片内存是每两个字节表示一个显示在屏幕上的字符，&lt;strong>第一个是字符的编码，第二个是字符的颜色&lt;/strong>，那我们先不管颜色，如果多写几个字符就像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0xB8000&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="s">&amp;#39;h&amp;#39;&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0xB8002&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="s">&amp;#39;e&amp;#39;&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0xB8004&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="s">&amp;#39;l&amp;#39;&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0xB8006&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="s">&amp;#39;l&amp;#39;&lt;/span>
&lt;span class="nf">mov&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mh">0xB8008&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="s">&amp;#39;o&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时屏幕上就会是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-15-54-58-7c963e70e140abbc4f8657661d009382.png" alt="图片">&lt;/p>
&lt;p>是不是贼简单？那我们回过头看刚刚的代码，我们就假设显示模式是我们现在的这种文本模式，那条件分支就可以去掉好多。&lt;/p>
&lt;p>代码可以简化成这个样子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define ORIG_X          (*(unsigned char *)0x90000)
&lt;/span>&lt;span class="cp">#define ORIG_Y          (*(unsigned char *)0x90001)
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">register&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 第一部分 获取显示模式相关信息    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">video_num_columns&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(((&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="mh">0x90006&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mh">0xff00&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">video_size_row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">video_num_columns&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">video_num_lines&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">25&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">video_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="mh">0x90004&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">video_erase_char&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x0720&lt;/span>&lt;span class="p">;&lt;/span>    
    
    &lt;span class="c1">// 第二部分 显存映射的内存区域     
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">video_mem_start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0xb8000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">video_port_reg&lt;/span>  &lt;span class="o">=&lt;/span> &lt;span class="mh">0x3d4&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">video_port_val&lt;/span>  &lt;span class="o">=&lt;/span> &lt;span class="mh">0x3d5&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">video_mem_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0xba000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 第三部分 滚动屏幕操作时的信息    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">origin&lt;/span>  &lt;span class="o">=&lt;/span> &lt;span class="n">video_mem_start&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">scr_end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">video_mem_start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">video_num_lines&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">video_size_row&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">bottom&lt;/span>  &lt;span class="o">=&lt;/span> &lt;span class="n">video_num_lines&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 第四部分 定位光标并开启键盘中断    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">gotoxy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ORIG_X&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ORIG_Y&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">keyboard_interrupt&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">outb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mh">0xfd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">inb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x61&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">outb_p&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="mh">0x80&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x61&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">outb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mh">0x61&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>别看这么多，一点都不难。&lt;/p>
&lt;p>首先还记不记得之前汇编语言的时候做的工作，存了好多以后要用的数据在内存中。就在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499558&amp;amp;idx=1&amp;amp;sn=d5d057fae2fb835d38f82804c2649463&amp;amp;chksm=c2c5858bf5b20c9de2db5c31dd34fbe766f6c46cda17f54f4518a75fc1838f2ada6fe5717aad&amp;amp;scene=21#wechat_redirect">第五回 | 进入保护模式前的最后一次折腾内存&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>内存地址&lt;/th>
&lt;th>长度(字节)&lt;/th>
&lt;th>名称&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0x90000&lt;/td>
&lt;td>2&lt;/td>
&lt;td>光标位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90002&lt;/td>
&lt;td>2&lt;/td>
&lt;td>扩展内存数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90004&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显示页面&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90006&lt;/td>
&lt;td>1&lt;/td>
&lt;td>显示模式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90007&lt;/td>
&lt;td>1&lt;/td>
&lt;td>字符列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90008&lt;/td>
&lt;td>2&lt;/td>
&lt;td>未知&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000A&lt;/td>
&lt;td>1&lt;/td>
&lt;td>显示内存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000B&lt;/td>
&lt;td>1&lt;/td>
&lt;td>显示状态&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000C&lt;/td>
&lt;td>2&lt;/td>
&lt;td>显卡特性参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000E&lt;/td>
&lt;td>1&lt;/td>
&lt;td>屏幕行数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x9000F&lt;/td>
&lt;td>1&lt;/td>
&lt;td>屏幕列数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90080&lt;/td>
&lt;td>16&lt;/td>
&lt;td>硬盘1参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x90090&lt;/td>
&lt;td>16&lt;/td>
&lt;td>硬盘2参数表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x901FC&lt;/td>
&lt;td>2&lt;/td>
&lt;td>根设备号&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p> &lt;/p>
&lt;p>所以，&lt;strong>第一部分&lt;/strong>获取 0x90006 地址处的数据，就是获取显示模式等相关信息。&lt;/p>
&lt;p>&lt;strong>第二部分&lt;/strong>就是显存映射的内存地址范围，我们现在假设是 CGA 类型的文本模式，所以映射的内存是从 0xB8000 到 0xBA000。&lt;/p>
&lt;p>&lt;strong>第三部分&lt;/strong>是设置一些滚动屏幕时需要的参数，定义顶行和底行是哪里，这里顶行就是第一行，底行就是最后一行，很合理。&lt;/p>
&lt;p>&lt;strong>第四部分&lt;/strong>是把光标定位到之前保存的光标位置处（取内存地址 0x90000 处的数据），然后设置并开启键盘中断。&lt;/p>
&lt;p>开启键盘中断后，键盘上敲击一个按键后就会触发中断，中断程序就会读键盘码转换成 ASCII 码，然后写到光标处的内存地址，也就相当于往显存写，于是这个键盘敲击的字符就显示在了屏幕上。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-26-00-16aa8fd06abcb45912d37ffdc64487f2.gif" alt="图片">&lt;/p>
&lt;p>这一切具体是怎么做到的呢？我们先看看我们干了什么。&lt;/p>
&lt;p>&lt;strong>1.&lt;/strong> 我们现在根据已有信息已经可以实现往屏幕上的任意位置写字符了，而且还能指定颜色。&lt;/p>
&lt;p>&lt;strong>2.&lt;/strong> 并且，我们也能接受键盘中断，根据键盘码中断处理程序就可以得知哪个键按下了。&lt;/p>
&lt;p>有了这俩功能，那我们想干嘛还不是为所欲为？&lt;/p>
&lt;p>好，接下来我们看看代码是怎么处理的，很简单。一切的起点，就是第四步的 &lt;strong>gotoxy&lt;/strong> 函数，定位当前光标。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define ORIG_X          (*(unsigned char *)0x90000)
&lt;/span>&lt;span class="cp">#define ORIG_Y          (*(unsigned char *)0x90001)
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 第四部分 定位光标并开启键盘中断    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">gotoxy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ORIG_X&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ORIG_Y&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里面干嘛了呢？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">gotoxy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">new_x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">new_y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> 
    &lt;span class="p">...&lt;/span> 
    &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_x&lt;/span>&lt;span class="p">;&lt;/span> 
    &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_y&lt;/span>&lt;span class="p">;&lt;/span> 
    &lt;span class="n">pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">origin&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">video_size_row&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是给 &lt;strong>x y pos&lt;/strong> 这三个参数附上了值。&lt;/p>
&lt;p>其中 &lt;strong>x&lt;/strong> 表示光标在哪一列，&lt;strong>y&lt;/strong> 表示光标在哪一行，&lt;strong>pos&lt;/strong> 表示根据列号和行号计算出来的内存指针，也就是往这个 pos 指向的地址处写数据，就相当于往控制台的 x 列 y 行处写入字符了，简单吧？&lt;/p>
&lt;p>然后，当你按下键盘后，触发键盘中断，之后的程序调用链是这样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">_keyboard_interrupt:    
    ...    
    call _do_tty_interrupt    
    ...    
    void do_tty_interrupt(int tty) {   
        copy_to_cooked(tty_table+tty);
    }
    void copy_to_cooked(struct tty_struct * tty) {    
        ...    
        tty-&amp;gt;write(tty);    
        ...
    }
    // 控制台时 tty 的 write 为 con_write 函数
    void con_write(struct tty_struct * tty) {    
        ...    
        __asm__(&amp;#34;movb _attr,%%ah\n\t&amp;#34;      
                &amp;#34;movw %%ax,%1\n\t&amp;#34;      
                ::&amp;#34;a&amp;#34; (c),&amp;#34;m&amp;#34; (*(short *)pos)      
                :&amp;#34;ax&amp;#34;);     
        pos += 2;     
        x++;    
        ...
    }
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>前面的过程不用管，我们看最后一个函数 con_write 中的关键代码。&lt;/p>
&lt;p>&lt;strong>asm&lt;/strong> 内联汇编，就是把键盘输入的字符 &lt;strong>c&lt;/strong> 写入 &lt;strong>pos&lt;/strong> 指针指向的内存，相当于往屏幕输出了。&lt;/p>
&lt;p>之后两行 pos+=2 和 x++，就是调整所谓的&lt;strong>光标&lt;/strong>。&lt;/p>
&lt;p>你看，写入一个字符，最底层，&lt;strong>其实就是往内存的某处写个数据，然后顺便调整一下光标&lt;/strong>。&lt;/p>
&lt;p>由此我们也可以看出，光标的本质，其实就是这里的 x y pos 这仨变量而已。&lt;/p>
&lt;p>我们还可以做&lt;strong>换行效果&lt;/strong>，当发现光标位置处于某一行的结尾时（这个应该很好算吧，我们都知道屏幕上一共有几行几列了），就把光标计算出一个新值，让其处于下一行的开头。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-25-50-51defc61554d51be3a436dfb5e15b217.gif" alt="图片">&lt;/p>
&lt;p>就一个小计算公式即可搞定，仍然在 con_write 源码处有体现，就是判断列号 x 是否大于了总列数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="n">video_num_columns&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">x&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">video_num_columns&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">pos&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">video_size_row&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">lf&lt;/span>&lt;span class="p">();&lt;/span>  
    &lt;span class="p">}&lt;/span>  
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">lf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>   
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">bottom&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>      
        &lt;span class="n">y&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>      
        &lt;span class="n">pos&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">video_size_row&lt;/span>&lt;span class="p">;&lt;/span>      
        &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>   
    &lt;span class="p">}&lt;/span> 
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相似的，我们还可以实现&lt;strong>滚屏&lt;/strong>的效果，无非就是当检测到光标已经出现在最后一行最后一列了，那就把每一行的字符，都复制到它上一行，其实就是算好哪些内存地址上的值，拷贝到哪些内存地址，就好了。&lt;/p>
&lt;p>这里大家自己看源码寻找。&lt;/p>
&lt;p>所以，有了这个初始化工作，我们就可以利用这些信息，弄几个小算法，实现各种我们常见控制台的操作。&lt;/p>
&lt;p>或者换句话说，我们见惯不怪的控制台，&lt;strong>回车&lt;/strong>、&lt;strong>换行&lt;/strong>、&lt;strong>删除&lt;/strong>、&lt;strong>滚屏&lt;/strong>、&lt;strong>清屏&lt;/strong>等操作，其实底层都要实现相应的代码的。&lt;/p>
&lt;p>所以 console.c 中的其他方法就是做这个事的，我们就不展开每一个功能的方法体了，简单看看有哪些方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// 定位光标的
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">gotoxy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">new_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">new_y&lt;/span>&lt;span class="p">){}&lt;/span>
&lt;span class="c1">// 滚屏，即内容向上滚动一行
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">scrup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">){}&lt;/span>
&lt;span class="c1">// 光标同列位置下移一行
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">lf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">currcons&lt;/span>&lt;span class="p">){}&lt;/span>
&lt;span class="c1">// 光标回到第一列
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">cr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">){}...&lt;/span>
&lt;span class="c1">// 删除一行
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">delete_line&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">){}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>内容繁多，但没什么难度，只要理解了基本原理即可了。&lt;/p>
&lt;p>OK，整个 &lt;strong>console.c&lt;/strong> 就讲完了，要知道这个文件可是整个内核中代码量最大的文件，可是功能特别单一，也都很简单，主要是处理键盘各种不同的按键，需要写好多 switch case 等语句，十分麻烦，我们这里就完全没必要去展开了，就是个苦力活。&lt;/p>
&lt;p>到这里，我们就正式讲完了 &lt;strong>tty_init&lt;/strong> 的作用。&lt;/p>
&lt;p>在此之后，内核代码就可以用它来方便地在控制台输出字符啦！这在之后内核想要在启动过程中告诉用户一些信息，以及后面内核完全建立起来之后，由用户用 shell 进行操作时手动输入命令，都是可以用到这里的代码的！&lt;/p>
&lt;p>让我们继续向前进发，看下一个被初始化的倒霉鬼是什么东东。&lt;/p>
&lt;p>欲知后事如何，且听下回分解。&lt;/p></description></item><item><title>第二部分小结</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC2%E9%83%A8%E5%88%86/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE/</guid><description>&lt;h1 id="第二部分小结">第二部分小结&lt;/h1>
&lt;p>第二部分所讲的代码，就和第二部分的目录一样规整，一个 init 方法对应一个章节，简单粗暴。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个过程，你可能觉得无聊，因为全是各种数据结构、中断、外设的初始化工作，后面将会怎么用它们，并没有展开讲解。&lt;/p>
&lt;p>但你也可能觉得兴奋，因为后面操作系统的全部工作，都是围绕着这几个初始化了的结构展开的，而它们却都是那么的好理解。&lt;/p>
&lt;p>其实我是蛮喜欢这个过程的，比如我看电影，其实我对高潮部分并不是很感兴趣，我就喜欢看一场大战或者一场阴谋前各部门的准备工作，看着它们为了后面一个完美的计划，所做的前期筹备，是一种享受，你懂的！&lt;/p>
&lt;p>所以今天特地花一章的功夫，把之前的初始化工作梳理一遍，之前没仔细看的同学，这章是个重新开始的机会！&lt;/p>
&lt;p>&amp;mdash;&amp;mdash;- 开始 &amp;mdash;&amp;mdash;-&lt;/p>
&lt;p>电脑开机后，首先由 BIOS 将操作系统程序加载到内存，之后在进入 main 函数前，我们用汇编语言（boot 包下的三个汇编文件）做了好多苦力活。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-00-39-5842ff28f8ee3ff369e500083ec104f2.png" alt="图片">&lt;/p>
&lt;p> &lt;/p>
&lt;p>这些苦力活做好后，内存布局变成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-00-47-aa6fb6afed20bd2cf4d18b96ae782faf.png" alt="图片">&lt;/p>
&lt;p>其中页表的映射关系，被做成了线性地址与物理地址相同。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-00-56-f83e89ef32c7a89f1e659dd689c0731a.png" alt="图片">&lt;/p>
&lt;p>也因为有了页表的存在，所以多了线性地址空间的概念，即经过分段机制转化后，分页机制转化前的地址，不考虑段限长的话，32 位的 CPU 线性地址空间应为 4G。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-04-46801d4a735b246d73179ecd447f2288.png" alt="图片">&lt;/p>
&lt;p>以上这些，是进入 main 函数之前的事情，由 boot 文件夹下的三个汇编文件完成，具体可以看整个第一部分的总结：&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499882&amp;amp;idx=1&amp;amp;sn=68fd16c5aeae15084be58afb1e5bd9e8&amp;amp;chksm=c2c5bac7f5b233d1c486fa57e9e3a2bc907a92ab69ff0344babab4d50bdaf76e7766b4b42914&amp;amp;scene=21#wechat_redirect">第一部分完结 进入内核前的苦力活&lt;/a>&lt;/p>
&lt;p>&amp;mdash;&amp;mdash;&amp;ndash; 进入 main 函数后 &amp;mdash;&amp;mdash;&amp;mdash;&lt;/p>
&lt;p>进入 main 函数后，首先进行了内存划分，其实就是设置几个边界值，将内核程序、缓冲区、主内存三个部分划分开界限。这就是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500061&amp;amp;idx=1&amp;amp;sn=6cb3382d7ac35ebeac52bbba3a89db4e&amp;amp;scene=21#wechat_redirect">第12回 | 管理内存前先划分出三个边界值&lt;/a> 所做的事情。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-15-d74711a7a01648fdf8a92f76021d62b3.png" alt="图片">&lt;/p>
&lt;p>随后，通过 mem_init 函数，对主内存区域用 mem_map[] 数组管理了起来，其实就是每个位置表示一个 4K 大小的内存页的使用次数而已，今后对主内存的申请和释放，其实都是对 mem_map 数组的操作。这是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;scene=21#wechat_redirect">第13回 | 主内存初始化 mem_init&lt;/a> 所做的事。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-22-eadd7b7ab08de923dd31e4315edbd036.png" alt="图片">&lt;/p>
&lt;p>后面又通过 buffer_init 函数，对缓冲区区域用多种数据结构管理起来。其中包括双向链表缓冲头 h 和每个缓冲头管理的 1024 字节大小的缓冲块 b。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500596&amp;amp;idx=1&amp;amp;sn=0df64f9f5133cfe8a259b8ce7b7feaeb&amp;amp;chksm=c2c5b999f5b2308f76095af30e8915f125f18702df9c58be7612b58e4d009c14948193974f9b&amp;amp;scene=21#wechat_redirect">第19回 | 缓冲区初始化 buffer_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-30-9e0c93a6c20e4071c78f4058101fe157.png" alt="图片">&lt;/p>
&lt;p>同时，又用一个 hashmap 结构，索引到所有缓冲头，方便快速查找，为之后的通过 LRU 算法使用缓冲区做准备。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-37-d9a496e63fb8d1db70414c4fa80a8d44.png" alt="图片">&lt;/p>
&lt;p>这些结构，就是缓冲区部分的管理，而缓冲区的目的是为了加速磁盘的读写效率，后面将读写文件全流程的时候，你会看到它在整个流程中起到中流砥柱的作用。&lt;/p>
&lt;p>再往后，通过 trap_init 函数把中断描述符表的一些默认中断都设置好了，随后再由各个模块设置它们自己需要的个性化的中断（比如硬盘中断、时钟中断、键盘中断等）。这是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500119&amp;amp;idx=1&amp;amp;sn=f46331f70677aba168243040a96be1c0&amp;amp;scene=21#wechat_redirect">第14回 | 中断初始化 trap_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-44-160eaeba72dee3db15d816d635205da3.png" alt="图片">&lt;/p>
&lt;p>再之后，通过 blk_dev_init 对读写块设备（比如硬盘）的管理进行了初始化，比如对硬盘的读写操作，都要封装为一个 request 结构放在 request[] 数组里，后面用电梯调度算法进行排队读写硬盘。这是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500147&amp;amp;idx=1&amp;amp;sn=409f5ed34ae3822e40a6b443207d40c5&amp;amp;scene=21#wechat_redirect">第15回 | 块设备请求项初始化 blk_dev_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-50-a1f5bad28101fd35f8fcb97e5fb5290d.png" alt="图片">&lt;/p>
&lt;p>再往后，通过 tty_init 里的 con_init，实现了在控制台输出字符的功能，并且可以支持换行、滚屏等效果。当然此处也开启了键盘中断，如果此时中断已经处于打开状态，我们就可以用键盘往屏幕上输出字符啦。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500190&amp;amp;idx=1&amp;amp;sn=b0bebe846b55f7e29fc009e1b6587214&amp;amp;chksm=c2c5bb33f5b23225845ab699d1b8fcee39a04ca98a48ebf0e2c22584b638fa0b0839d1212485&amp;amp;scene=21#wechat_redirect">第16回 | 控制台初始化 tty_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-13-32-1b692caf245f5f7394c7e9735e16d023.gif" alt="图片">&lt;/p>
&lt;p>再之后，整个操作系统的精髓，进程调度，其初始化函数 shed_init，定义好了全部进程的管理结构 task[64] 数组，并在索引 0 位置处赋上了初始值，作为零号进程的结构体。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 进程调度初始化 sched_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-59-35fc10afb266a06ae71d596a65979b66.png" alt="图片">&lt;/p>
&lt;p>然后又将全局描述符表增添了 TSS 和 LDT，用来管理 0 号进程的上下文信息以及内存规划，结构里面具体是什么，先不用管哟。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-06-c6537d21252cae6d3dd38447fd8a7e9f.png" alt="图片">&lt;/p>
&lt;p>同时，将这两个结构的地址，告诉 tr 寄存器和 ldt 寄存器，让 CPU 能够找到它们。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-14-cbe797778a2c502aa98b6342c4f89a39.png" alt="图片">&lt;/p>
&lt;p>随后，开启定时器，以及设置了时钟中断，用于响应定时器每隔 100ms 发来的中断信号。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/2c614feed87da9bbb61467ef39db49ae7eaa7726.gif" alt="图片">&lt;/p>
&lt;p>这样就算把进程调度的初始化工作完成了，之后进程调度就从定时器发出中断开始，先判断当前进程时间片是不是到了，如果到了就去 task[64] 数组里找下一个被调度的进程的信息，切换过去。&lt;/p>
&lt;p>这就是进程调度的简单流程，也是后面要讲的一个非常精彩的环节。&lt;/p>
&lt;p>最后最后，一个简单的硬盘初始化 hd_init，为我们开启了硬盘中断，并设置了硬盘中断处理函数，此时我们便可以真正通过硬盘的端口与其进行读写交互了。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500686&amp;amp;idx=1&amp;amp;sn=c950e586af062e16c7e13a35084ca1d1&amp;amp;chksm=c2c5b923f5b230357ad1bca01a1b0ed76862f696681c92a232e687ab6eff5dbd3990217ac552&amp;amp;scene=21#wechat_redirect">第20回 | 硬盘初始化 hd_init&lt;/a> 的内容。&lt;/p>
&lt;p>把之前几个模块设置的中断放一块，此时的中断表我们看一下。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>中断号&lt;/th>
&lt;th>中断处理函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 ~ 0x10&lt;br>&lt;/td>
&lt;td>trap_init 里设置的一堆&lt;br>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x20&lt;br>&lt;/td>
&lt;td>timer_interrupt&lt;br>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x21&lt;br>&lt;/td>
&lt;td>keyboard_interrupt&lt;br>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x2E&lt;br>&lt;/td>
&lt;td>hd_interrupt&lt;br>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x80&lt;br>&lt;/td>
&lt;td>system_call&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这里我又提了一嘴，操作系统本质上就是个中断驱动的死循环，这个后面你会慢慢体会到。&lt;/p>
&lt;p>而我们再往下看一行 main 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define sti() __asm__ (&amp;#34;sti&amp;#34;::)
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是一个 &lt;strong>sti&lt;/strong> 汇编指令，意思是打开中断。其本质上是将 eflags 寄存器里的中断允许标志位 IF 位置 1。（由于已经是 32 位保护模式了，所以我把寄存器也都偷偷换成了 32 位的名字）&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-26-ed37de83e38c451d23dbbedfeb91fed5.png" alt="图片">&lt;/p>
&lt;p>这样 CPU 就开始可以接收并处理中断信号了，键盘可以按了，硬盘可以读写了，时钟可以震荡了，系统调用也可以生效了！&lt;/p>
&lt;p>这就代表着，操作系统具有了控制台交互能力，硬盘读写能力，进程调度能力，以及响应用户进程的系统调用请求！&lt;/p>
&lt;p>至此，全部初始化工作，就结束了！这里有几个初始化函数没有讲，都是可以忽略的，不要担心。&lt;/p>
&lt;p>一个是 chr_dev_init，因为这个函数里面本身就是空的，什么也没做。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-33-2530392bb368667cd391288a6cdabbfe.png" alt="图片">&lt;/p>
&lt;p>一个是 tty_init 里的 rs_init，这个方法是串口中断的开启，以及设置对应的中断处理程序，串口在我们现在的 PC 机上已经很少用到了，所以这个直接忽略。&lt;/p>
&lt;p>还一个是 floppy_init，这个是软盘的初始化，软盘现在已经被淘汰了，且电脑上也没有软盘控制器了，所以也忽略即可。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-39-1dd57c9c76269a05c86b8bea52042e2f.png" alt="图片">&lt;/p>
&lt;p>除了这些之外，全部的初始化工作，我们就全部梳理清楚了！再次为我们这一阶段性的胜利，鼓掌吧！！！&lt;/p>
&lt;p>同时，这章也会作为之后工作的一个索引章节，初始化工作所设置的所有数据结构都十分重要，后面如果你忘了，可以常来这里看看，祝大家好运。&lt;/p></description></item><item><title>缺页中断</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC4%E9%83%A8%E5%88%86/36.%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC4%E9%83%A8%E5%88%86/36.%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD/</guid><description>&lt;h1 id="缺页中断">缺页中断&lt;/h1>
&lt;p>书接上回，上回书咱们说到，进程 2 通过 &lt;strong>execve&lt;/strong> 函数，将自己摇身一变成为 &lt;strong>/bin/sh&lt;/strong> 程序，也就是 &lt;strong>shell&lt;/strong> 程序开始执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么此时进程 2 就是 shell 程序了。&lt;/p>
&lt;p>再进一步讲，相当于之前的进程 1 通过 &lt;strong>fork + execve&lt;/strong> 这两个函数的组合，创建了一个新的进程去加载并执行了 shell 程序。&lt;/p>
&lt;p>我们在 Linux 里执行一个程序，比如在命令行中 ./xxx，其内部实现逻辑都是 fork + execve 这个原理。&lt;/p>
&lt;p>当然，此时我们仅仅是通过 execve，使得下一条 CPU 指令将会执行到 /bin/sh 程序所在的内存起始位置处，也就是 /bin/sh 头部结构中 &lt;strong>a_entry&lt;/strong> 所描述的地址。&lt;/p>
&lt;p>但有个问题是，我们仅仅将 /bin/sh 文件的头部加载到了内存，其他部分并没有进行加载，那我们是怎么执行到的 /bin/sh 的程序指令呢？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-22-2ddc77fe8686ba8e985c099d1efe6d7d.png" alt="图片">&lt;/p>
&lt;p>我们就带着这个问题，开始今天的探索。&lt;/p>
&lt;h1 id="heading">&lt;/h1>
&lt;p>&lt;strong>跳转到一个不存在的地址会发生什么&lt;/strong>&lt;/p>
&lt;p>/bin/sh 这个文件并不是 Linux 0.11 源码里的内容，Linux 0.11 只管按照 a.out 这种格式去解读它，跳转到 a.out 格式头部数据结构 &lt;strong>exec.a_entry&lt;/strong> 所指向的内存地址去执行指令。&lt;/p>
&lt;p>所以这个 a_entry 的值是多少，就完全取决于硬盘中 /bin/sh 这个文件是怎么构造的了，我们简单点，就假设它为 &lt;strong>0&lt;/strong>，这表示随后的 CPU 将跳转到 0 地址处进行执行。&lt;/p>
&lt;p>当然，这个 0 仅仅表示&lt;strong>逻辑地址&lt;/strong>，既没有进行分段，也没有进行分页。&lt;/p>
&lt;p>之前说过无数次了，Linux 0.11 的每个进程是通过不同的局部描述符在线性地址空间中瓜分出不同的空间，一个进程占 64M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-29-a49168ac30ab0b1f45ae4daac902533d.png" alt="图片">&lt;/p>
&lt;p>由于我们现在所处的代码是属于进程 2，所以逻辑地址 0 通过分段机制映射到线性地址空间，就是 &lt;strong>0x8000000&lt;/strong>，表示 &lt;strong>128M&lt;/strong> 位置处。&lt;/p>
&lt;p>好，128M 这个线性地址，随后将会通过&lt;strong>分页机制&lt;/strong>的映射转化为物理地址，这才定位到最终的真实物理内存。&lt;/p>
&lt;p>可是，128M 这个线性地址并没有页表映射它，也就是因为上面我们说的，我们除了 /bin/sh 文件的头部加载到了内存外，其他部分并没有进行加载操作。&lt;/p>
&lt;p>&lt;strong>再准确点说，是 0x8000000 这个线性地址的访问，遇到了页表项的存在位 P 等于 0 的情况。&lt;/strong>&lt;/p>
&lt;p>一旦遇到了这种情况，CPU 会触发一个中断：&lt;strong>页错误（Page-Fault）&lt;/strong>，这在 Intel 手册 Volume-3 Chapter 4.7 章节里给出了这个信息。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-36-228eec2d7f2b4640d7441ca0d4aa7be9.png" alt="图片">&lt;/p>
&lt;p>当然，Page-Fault 在很多情况都会触发，具体是因为什么情况触发的，CPU 会帮我们保存在中断的出错码 &lt;strong>Error Code&lt;/strong> 里，这在随后的 Figure 4-12 中给出了详细的出错码说明。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-42-371d5c9369c149d21699fa1f594c81f2.png" alt="图片">&lt;/p>
&lt;p>这块之所以讲这么详细，因为我想让大家知道一切的原理都有最一手资料的来源，这些一手资料写的都非常详细和友好，大家完全不必道听途说，也不必毫无头绪地搜索网上的博客。&lt;/p>
&lt;p>当然，与本文相关的，就是这个&lt;strong>存在位 P&lt;/strong>。&lt;/p>
&lt;p>当触发这个 Page-Fault 中断后，就会进入 Linux 0.11 源码中的 &lt;strong>page_fault&lt;/strong> 方法，由于 Linux 0.11 的 page_fault 是汇编写的，很不直观，这里我选 Linux 1.0 的代码给大家看，逻辑是一样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_page_fault&lt;/span>&lt;span class="p">(...,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">error_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>       
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">do_wp_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 &lt;strong>error_code&lt;/strong> 的不同，有不同的逻辑。&lt;/p>
&lt;p>刚刚说了，这个中断是由于 &lt;strong>0x8000000&lt;/strong> 这个线性地址的访问，遇到了页表项的&lt;strong>存在位 P&lt;/strong> 等于 0 的情况，所以 error_code 的第 0 位就是 0，会走 &lt;strong>do_no_page&lt;/strong> 逻辑。&lt;/p>
&lt;p>之前在讲 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502033&amp;amp;idx=1&amp;amp;sn=1acfd8b7f4c805906ecd51c33d0010eb&amp;amp;chksm=c2c5b27cf5b23b6a41051c7f93407afc97094a4b0a36ea050616778f4d072f074602f98983b2&amp;amp;scene=21#wechat_redirect">第30回 | 番外篇 - 写时复制就这么几行代码&lt;/a> 的时候，讲了 &lt;strong>do_wp_page&lt;/strong>，这是在 P=1 时的逻辑，文章的结尾我说过，后面会把页表项的存在位 P 为 0 时触发的 do_no_page 逻辑讲给大家，这不就来了么。&lt;/p>
&lt;p>do_wp_page 叫&lt;strong>页写保护中断&lt;/strong>，do_no_page 叫&lt;strong>缺页中断&lt;/strong>。&lt;/p>
&lt;p>好了，我们用了很大篇幅，说明白了跳转到一个 P=0 的地址会发生什么，接下来就是具体看 do_no_page 函数的逻辑咯。&lt;/p>
&lt;h1 id="heading-1">&lt;/h1>
&lt;p>&lt;strong>缺页中断 do_no_page&lt;/strong>&lt;/p>
&lt;p>我们先一睹为快它的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// memory.c
// address 缺页产生的线性地址 0x8000000
void do_no_page(unsigned long error_code,unsigned long address) {    
    int nr[4];    
    unsigned long tmp;    
    unsigned long page;    
    int block,i;    
    address &amp;amp;= 0xfffff000;    
    tmp = address - current-&amp;gt;start_code;    
    if (!current-&amp;gt;executable || tmp &amp;gt;= current-&amp;gt;end_data) {        
        get_empty_page(address);        
        return;    
    }    
    if (share_page(tmp))        
        return;    
    if (!(page = get_free_page()))        
        oom();
    /* remember that 1 block is used for header */    
    block = 1 + tmp/BLOCK_SIZE;    
    for (i=0 ; i&amp;lt;4 ; block++,i++)        
        nr[i] = bmap(current-&amp;gt;executable,block);    
    bread_page(page,current-&amp;gt;executable-&amp;gt;i_dev,nr);    
    i = tmp + 4096 - current-&amp;gt;end_data;    
    tmp = page + 4096;    
    while (i-- &amp;gt; 0) {        
        tmp--;        
        *(char *)tmp = 0;    
    }    
    if (put_page(page,address))        
        return;    
    free_page(page);    
    oom();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们仍然是去掉一些不重要的分支，假设跳转不会超过数据末端 end_data，也没有共享内存页面，申请空闲内存时也不会内存不足产生 oom 等，将程序简化如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="c1">// 计算这个地址在文件中的哪个数据块 1    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就简单多了，我们还是一点点看。&lt;/p>
&lt;p>首先，缺页产生的线性地址，之前假设过了，是 0x8000000，也就是进程 2 自己线性地址空间的起始处 128M 这个位置。&lt;/p>
&lt;p>由于我们的页表映射是以&lt;strong>页&lt;/strong>为单位的，所以首先计算出 address 所在的页，其实就是完成一次 &lt;strong>4KB 的对齐&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时 address 对齐后仍然是 0x8000000。&lt;/p>
&lt;p>这个地址是整个线性地址空间的地址，但对于进程 2 自己来说，需要计算出相对于进程 2 的偏移地址，也就是去掉进程 2 的段基址部分。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的 current-&amp;gt;start_code 就是进程 2 的段基址，也是 128M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-51-a49168ac30ab0b1f45ae4daac902533d.png" alt="图片">&lt;/p>
&lt;p>所以偏移地址 tmp 计算后等于 &lt;strong>0&lt;/strong>，这和我们之前假设的 a_entry = 0 是一致的。&lt;/p>
&lt;p>接下来很简单，就是寻找一个空闲页。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 &lt;strong>get_free_page&lt;/strong> 是用汇编语言写的，其实就是去 &lt;strong>mem_map[]&lt;/strong> 中寻找一个值为 0 的位置，这就表示找到了空闲内存。&lt;/p>
&lt;p>这部分忘记的同学，可以看一下 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;scene=21#wechat_redirect">第13回 | 主内存初始化 mem_init&lt;/a>，之前苦苦建立的一些初始化的数据结构，就用上了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-57-150f714f07d49eae3c6ee4a2cda35b6e.png" alt="图片">&lt;/p>
&lt;p>找到一页物理内存后，当然是把硬盘中的数据加载进来，下面的代码就是完成这个工作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// memory.c
// address 缺页产生的线性地址 0x8000000
void do_no_page(unsigned long address) {    
    ...    
    // 计算这个地址在文件中的哪个数据块 1    
    int block = 1 + tmp/BLOCK_SIZE;    
    // 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
    int nr[4];    
    for (int i=0 ; i&amp;lt;4 ; block++,i++)        
        nr[i] = bmap(current-&amp;gt;executable,block);    
    bread_page(page,current-&amp;gt;executable-&amp;gt;i_dev,nr);    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>从硬盘的哪个位置开始读呢？&lt;strong>首先 0 内存地址，应该就对应着这个文件 0 号数据块，当然由于 /bin/sh 这个 a.out 格式的文件使用了 1 个数据块作为头部 exec 结构，所以我们&lt;/strong>跳过头部&lt;/strong>，从文件 1 号数据块开始读。&lt;/p>
&lt;p>**读多少块呢？**因为硬盘中的 1 个数据块为 1024 字节，而一页内存为 4096 字节，所以要读 4 块，这就是 nr[4] 的缘故。&lt;/p>
&lt;p>之后读取数据主要是两个函数，&lt;strong>bmap&lt;/strong> 负责将相对于文件的数据块转换为相对于整个硬盘的数据块，比如这个文件的第 1 块数据，可能对应在整个硬盘的第 24 块的位置。&lt;/p>
&lt;p>&lt;strong>bread_page&lt;/strong> 就是连续读取 4 个数据块到 1 页内存的函数，这个函数原理就复杂了，之后第五部分会讲这块的内容，但站在用户层的效果很好理解，就是把硬盘数据复制到内存罢了。&lt;/p>
&lt;p>OK，现在硬盘上所需要的内容已经被读入物理内存了。&lt;/p>
&lt;p>最后一步完成&lt;strong>页表的映射&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是因为我们此时仅仅是申请了物理内存页，并且把硬盘数据复制了进来，但我们并没有把这个物理内存页和线性地址空间的内存页进行映射，也就是没建立相关的&lt;strong>页表&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-45-05-b7d999c9bc53aea332ff6ddfa99b976d.png" alt="图片">&lt;/p>
&lt;p>建立页表的映射，由于 Linux 0.11 使用的是二级页表，所以实际上就是写入&lt;strong>页目录项&lt;/strong>和&lt;strong>页表项&lt;/strong>的过程，我把 &lt;strong>put_page&lt;/strong> 函数简化了一下，只考虑页目录项还不存在的场景。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// memory.c
unsigned long put_page(unsigned long page,unsigned long address) {    
    unsigned long tmp, *page_table;    
    // 找到页目录项    
    page_table = (unsigned long *) ((address&amp;gt;&amp;gt;20) &amp;amp; 0xffc);    
    // 写入页目录项    
    tmp = get_free_page();    
    *page_table = tmp|7;    
    // 写入页表项    
    page_table = (unsigned long *) tmp;    
    page_table[(address&amp;gt;&amp;gt;12) &amp;amp; 0x3ff] = page | 7;    
    return page;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>大家可以结合页目录表和页表的数据结构看一下，很简单，就是个计算过程。&lt;/p>
&lt;p>关于页目录表和页表这些&lt;strong>分页&lt;/strong>相关的知识，可以回顾之前的 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499821&amp;amp;idx=1&amp;amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;amp;scene=21#wechat_redirect">第9回 | Intel 内存管理两板斧：分段与分页&lt;/a>，这里就不再赘述。&lt;/p>
&lt;h1 id="heading-2">&lt;/h1>
&lt;p>&lt;strong>缺页中断返回&lt;/strong>&lt;/p>
&lt;p>好了，这就是整个缺页中断处理的过程，本质上就是加载硬盘对应位置的数据，然后建立页表的过程。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="c1">// 计算这个地址在文件中的哪个数据块 1    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再回过头看整个代码，是不是清晰了不少？&lt;/p>
&lt;p>好，那我们再往上看，我们之前是在进程 2 里执行了 execve 函数将程序替换成 /bin/sh，也就是 shell 程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>execve 函数返回后，CPU 就跳转到 /bin/sh 程序的第一行开始执行，但由于跳转到的线性地址不存在，所以引发了今天我们讲的&lt;strong>缺页中断&lt;/strong>，把硬盘里 /bin/sh 所需要的内容加载到了内存，此时缺页中断返回。&lt;/p>
&lt;p>返回后，CPU 会再次尝试跳转到 0x8000000 这个线性地址，此时由于缺页中断的处理结果，&lt;strong>使得该线性地址已有对应的页表进行映射&lt;/strong>，所以顺利地映射到了物理地址，也就是 /bin/sh 的代码部分（从硬盘加载过来的），那接下来就终于可以执行 /bin/sh 程序，也就是 shell 程序了。&lt;/p>
&lt;p>那这个 shell 程序到底是啥呢？他的代码并不在 Linux 0.11 的源码里，所以我们的重点将不是分析它的源码，仅仅了解它的原理即可。&lt;/p></description></item><item><title>进程2的创建</title><link>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC4%E9%83%A8%E5%88%86/34.%E8%BF%9B%E7%A8%8B2%E7%9A%84%E5%88%9B%E5%BB%BA/</link><pubDate>Tue, 02 Jan 2024 18:45:22 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/%E4%BD%A0%E7%AE%A1%E8%BF%99%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%8F%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/%E7%AC%AC4%E9%83%A8%E5%88%86/34.%E8%BF%9B%E7%A8%8B2%E7%9A%84%E5%88%9B%E5%BB%BA/</guid><description>&lt;h1 id="进程2的创建">进程2的创建&lt;/h1>
&lt;p>书接上回，上回书咱们说到，进程 1 通过 open 函数建立了与外设交互的能力，具体其实就是打开了 tty0 这个设备文件，并绑定了标准输入 0，标准输出 1 和 标准错误输出 2 这三个文件描述符。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-43-36-e0b98961c24da1810a2e39fd02c53317.png" alt="图片">&lt;/p>
&lt;p>同时我们看到源码中用 printf 函数，调用 write 函数，向 1 号文件描述符输出了字符串的效果。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-43-44-0f6c62a12c3d9f28715d590a058daccd.png" alt="图片">&lt;/p>
&lt;p>到此为止，标志着进程 1 的工作基本结束了，准确说是能力建设的工作结束了，接下来就是&lt;strong>控制流程&lt;/strong>和&lt;strong>创建新的进程&lt;/strong>了，我们继续往下看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="cm">/* nothing */&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">setsid&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">child %d died with code %04x&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="cm">/* NOTE! _exit, not exit() */&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>别急，我们一点点看，我仍然是去掉了一些错误校验的旁路分支。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先看这个第一段，我们先尝试口述翻译一遍。&lt;/p>
&lt;p>&lt;strong>1.&lt;/strong> fork 一个新的子进程，此时就是进程 2 了。&lt;/p>
&lt;p>&lt;strong>2.&lt;/strong> 在进程 2 里&lt;strong>关闭（close）&lt;/strong> 0 号文件描述符。&lt;/p>
&lt;p>&lt;strong>3.&lt;/strong> 只读形式&lt;strong>打开（open）&lt;/strong> rc 文件。&lt;/p>
&lt;p>&lt;strong>4.&lt;/strong> 然后&lt;strong>执行（execve）&lt;/strong> sh 程序。&lt;/p>
&lt;p>听起来还蛮合逻辑的，创建进程（fork）、关闭（close）、打开（open）、执行（execve）四步走，接下来我们一点点拆解。&lt;/p>
&lt;p>&lt;strong>fork&lt;/strong>&lt;/p>
&lt;p>fork 前面讲过了，就是将进程的 task_struct 结构进行一下复制，比如进程 0 fork 出进程 1 的时候。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-43-52-39d869e0f173982712a007301c3d63d2.png" alt="图片">&lt;/p>
&lt;p>之后，新进程再重写一些基本信息，包括元信息和 tss 里的寄存器信息。再之后，用 copy_page_tables 复制了一下页表（这里涉及到写时复制的伏笔）。&lt;/p>
&lt;p>比如进程 0 复制出进程 1 的时候，页表是这样复制的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-00-405c831a3401a0a1ca067086ca02c0e8.png" alt="图片">&lt;/p>
&lt;p>而这里的进程 1 fork 出进程 2，也是同样的流程，不同之处在于两点细节：&lt;/p>
&lt;p>&lt;strong>第一点&lt;/strong>，进程 1 打开了三个文件描述符并指向了 tty0，那这个也被复制到进程 2 了，具体说来就是进程结构 task_struct 里的 flip[] 数组被复制了一份。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NR_OPEN&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而进程 0 fork 出进程 1 时是没有复制这部分信息的，因为进程 0 没有打开任何文件。这也是刚刚说的与外设交互能力的体现，即进程 0 没有与外设交互的能力，进程 1 有，哎，其实就是这个 flip 数组里有没有东西而已嘛~&lt;/p>
&lt;p>&lt;strong>第二点&lt;/strong>，进程 0 复制进程 1 时页表的复制只有 160 项，也就是映射 640K，而之后进程的复制，统统都是复制 1024 项，也就是映射 4M 空间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">from&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">to&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">nr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">from&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="mh">0xA0&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整体看就是如图所示。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-07-64e274fc81313e039e6e2d1364475387.png" alt="图片">&lt;/p>
&lt;p>除此之外，就没有别的区别了。&lt;/p>
&lt;p>&lt;strong>close&lt;/strong>&lt;/p>
&lt;p>好了，我们继续看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>fork 完之后，后面 if 里面的代码都是进程 2 在执行了。&lt;/p>
&lt;p>close(0) 就是&lt;strong>关闭 0 号文件描述符&lt;/strong>，也就是进程 1 复制过来的打开了 tty0 并作为标准输入的文件描述符，那么此时 0 号文件描述符就空出来了。&lt;/p>
&lt;p>下面是 close 对应的系统调用函数，很简单。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>       
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>open&lt;/strong>&lt;/p>
&lt;p>接下来 open 函数以只读形式打开了一个叫 /etc/rc 的文件，刚好占据了 0 号文件描述符的位置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 rc 文件表示配置文件，具体什么内容，取决于你的硬盘里这个位置处放了什么内容，与操作系统内核无关，所以我们暂且不用管。&lt;/p>
&lt;p>此时，进程 2 与进程 1 几乎完全一样，只不过进程 2 通过 close 和 open 操作，将原来进程 1 的指向标准输入的 0 号文件描述符，重新指向了 /etc/rc 文件。&lt;/p>
&lt;p>到目前为止，进程 2 与进程 1 的区别，仅仅是将 0 号文件描述符重新指向了 /etc/rc 文件，其他的没啥区别。&lt;/p>
&lt;p>而这个 rc 文件是干嘛的，现在还不用管，肯定是后面 sh 程序要用到的，到时候在说。&lt;/p>
&lt;p>&lt;strong>execve&lt;/strong>&lt;/p>
&lt;p>好，接下来进程 2 就将变得不一样了，会通过一个经典的，也是最难理解的 execve 函数调用，使自己摇身一变，成为 /bin/sh 程序继续运行，这就是下一章的重点！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里就包含着操作系统究竟是如何加载并执行一个程序的原理，包括如何从文件系统中找到这个文件，如何解析一个可执行文件（在现代的 Linux 里称作 ELF 可执行文件），如何讲可执行文件中的代码和数据加载到内存并运行。&lt;/p>
&lt;p>加载到内存并运行又包含着虚拟内存等相关的知识。所以这里面的水很深，了解了这个函数，再加上 fork 函数，基本就可以把操作系统全部核心逻辑都串起来了。&lt;/p></description></item></channel></rss>