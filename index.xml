<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 30 Apr 2022 17:04:39 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>CLOCK算法</title><link>https://justice.bj.cn/post/13.algorithm/clock%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/clock%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="clock算法">CLOCK算法&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>CLOCK算法(时钟置换算法)是一种LRU算法的一个变种，将LRU的链表缓存环形数组；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>即逐出的页面都是最近没有使用的那个。我们给每一个页面设置一个标记位u，u=1表示最近有使用u=0则表示该页面最近没有被使用，应该被逐出。&lt;/p>
&lt;p>capacity=4, &lt;code>1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/13-16-23-59-2022-01-13-16-23-53-image.png" alt="">&lt;/p>
&lt;p>时钟置换算法的基础上可以做一个改进，就是增加一个标记为m，修改过标记为1，没有修改过则标记为0。那么u和m组成了一个元组，有四种可能，其被逐出的优先顺序也不一样：&lt;/p>
&lt;ul>
&lt;li>(u=0, m=0) 没有使用也没有修改，被逐出的优先级最高；&lt;/li>
&lt;li>(u=1, m=0) 使用过，但是没有修改过，优先级第二；&lt;/li>
&lt;li>(u=0, m=1) 没有使用过，但是修改过，优先级第三；&lt;/li>
&lt;li>(u=1, m=1) 使用过也修改过，优先级第四。&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/wingsless/p/12295246.html">页面置换算法之Clock算法 - wingsless - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Jump一致性哈希算法</title><link>https://justice.bj.cn/post/13.algorithm/jumpconsistenthash%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/jumpconsistenthash%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="jump一致性哈希算法">Jump一致性哈希算法&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Jump consistent hash是一种一致性哈希算法,&lt;/p>
&lt;p>此算法&lt;strong>零内存消耗&lt;/strong>，&lt;strong>均匀分配&lt;/strong>，&lt;strong>快速&lt;/strong>，并且&lt;strong>只有5行代码&lt;/strong>。&lt;/p>
&lt;p>这个算法是 Google 的 John Lamping 和 Eric Veach 创造的。&lt;br>
他们为这个算法写了一篇论文：《A Fast, Minimal Memory, Consistent Hash Algorithm》。&lt;/p>
&lt;p>看了论文后，我才恍然大悟，原来是这样，果然是合理的。&lt;br>
如果你阅读原文论文，可以公众号后台回复“谷歌算法”获取论文。&lt;/p>
&lt;h2 id="算法原理">算法原理&lt;/h2>
&lt;p>一致性哈希算法有两个目标：&lt;/p>
&lt;ol>
&lt;li>平衡性。即把数据平均的分布在所有节点中。&lt;/li>
&lt;li>单调性。即节点的数量变化时，只需要把一部分数据从旧节点移动到新节点，不需要做其他的移动。&lt;/li>
&lt;/ol>
&lt;p>我们根据这个单调性可以推算出一些性质来。&lt;br>
这里先另&lt;code>f(key, n)&lt;/code>为一致性哈希算法，输出的为&lt;code>[0,n)&lt;/code>之间的数字，代表数据在对应的节点上。&lt;/p>
&lt;ol>
&lt;li>&lt;code>n=1&lt;/code> 时，对于任意的&lt;code>key&lt;/code>，输出应该都是&lt;code>0&lt;/code>。&lt;/li>
&lt;li>&lt;code>n=2&lt;/code> 时，为了保持均匀，应该有&lt;code>1/2&lt;/code>的结果保持为&lt;code>0&lt;/code>，&lt;code>1/2&lt;/code>的结果输出为&lt;code>1&lt;/code>。&lt;/li>
&lt;li>&lt;code>n=3&lt;/code> 时，应该有&lt;code>1/3&lt;/code>的结果保持为&lt;code>0&lt;/code>，&lt;code>1/3&lt;/code>的结果保持为&lt;code>1&lt;/code>，&lt;code>1/3&lt;/code>的结果保持为&lt;code>2&lt;/code>。&lt;/li>
&lt;li>依次递推，节点数由&lt;code>n&lt;/code>变为&lt;code>n+1&lt;/code>时，&lt;code>f(key, n)&lt;/code>里面应该有&lt;code>n/(n+1)&lt;/code>的结果不变，有&lt;code>1/(n+1)&lt;/code>的结果变为&lt;code>n&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>这个使用概率公式来表示，就是这样的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int32_t&lt;/span> &lt;span class="nf">JumpConsistentHash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">uint64_t&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int32_t&lt;/span> &lt;span class="n">num_buckets&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int64_t&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_buckets&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2862933555777941757ULL&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1LL&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">31&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="kt">double&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">33&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="算法优化">算法优化&lt;/h2>
&lt;p>除了复杂度是&lt;code>O(n)&lt;/code>外，我们还可以确定，循环越往后，结果改变的概率会越来越低。&lt;/p>
&lt;p>结果改变指的是，增加一个节点后，一个固定的&lt;code>key&lt;/code>输出的结果发生了改变。&lt;br>
如果我们能够快速计算出这个固定的&lt;code>key&lt;/code>在哪些节点下发生了改变，就可以快速计算出最终答案。&lt;/p>
&lt;p>假设某一次结果是&lt;code>b&lt;/code>，经过若干次概率测试，下一次改变为&lt;code>a&lt;/code>，则从&lt;code>b+1&lt;/code>到&lt;code>a-1&lt;/code>这中间，不管节点如何变化，这个&lt;code>key&lt;/code>的结果都是不会变化的。&lt;br>
根据上一小节的到的概率变化公式，新增一个节点数字不变化的概率是&lt;code>n/(n+1)&lt;/code>。&lt;br>
那从&lt;code>b+1&lt;/code>到&lt;code>i&lt;/code>不变化的概率就是&lt;code>(b+1)/i&lt;/code>（中间的抵消了）。&lt;/p>
&lt;p>如果我们有一个均匀的随机函数&lt;code>r&lt;/code>，可以确定当&lt;code>r&amp;lt;(b+1)/i&lt;/code>时，&lt;code>f(i)=f(b+1)&lt;/code>。&lt;br>
那么&lt;code>i&lt;/code>的上界就是&lt;code>(b+1)/r&lt;/code>向上取整。&lt;br>
这个上限也是下一次&lt;code>key&lt;/code>发生变化的节点数量。&lt;/p></description></item><item><title>KMP算法</title><link>https://justice.bj.cn/post/13.algorithm/kmp%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/kmp%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="kmp算法">KMP算法&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>KMP算法是一种改进的&lt;a href="https://link.jianshu.com?t=https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D">字符串匹配&lt;/a>算法，由D.E.Knuth，J.H.Morris和V.R.Pratt共同发明；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="核心思想">核心思想&lt;/h2>
&lt;p>kmp算法的核心：即是计算字符串f每一个位置之前的字符串的前缀和后缀公共部分的最大长度（不包括字符串本身，否则最大长度始终是字符串本身）。获得f每一个位置的最大公共长度之后，就可以利用该最大公共长度快速和字符串O比较。当每次比较到两个字符串的字符不同时，我们就可以根据最大公共长度将字符串f向前移动(已匹配长度-最大公共长度)位，接着继续比较下一个位置。&lt;/p>
&lt;h2 id="代码">代码&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">get_next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">[]){&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">next&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">StrLength&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">)){&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]){&lt;/span>
&lt;span class="n">next&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="n">next&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">KMP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">S&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">length_S&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">StrLength&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">length_T&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">StrLength&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">length_T&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">get_next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">length_T&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">length_S&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">S&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]){&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="n">length_T&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">length_T&lt;/span> &lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法 - 阮一峰的网络日志&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>SnowFlake 算法</title><link>https://justice.bj.cn/post/13.algorithm/snowflake%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/snowflake%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="snowflake-算法">SnowFlake 算法&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>Snowflake 算法是 Twitter 发明的一种算法，用于在分布式的高并发环境中，生成 64 位自增 ID。这种算法产生的背景是，Twitter 每秒钟能产生上万条信息，对算法的要求是：&lt;/p>
&lt;ol>
&lt;li>长度固定，不能太长。&lt;/li>
&lt;li>id 要能递增（方便客户端排序）&lt;/li>
&lt;li>在分布式环境中不能重复。&lt;/li>
&lt;/ol>
&lt;p>SnowFlake 算法生成 id 的结果是一个 64bit 大小的整数，它的结构如下图：&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Volumes/data/document/gitnote/img/2020-03-08-16-38-22-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>1位&lt;/code>，不用。二进制中最高位为 1 的都是负数，但是我们生成的 id 一般都使用整数，所以这个最高位固定是 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>41位&lt;/code>，用来记录时间戳（毫秒）。&lt;/p>
&lt;ul>
&lt;li>41 位可以表示个数字，&lt;/li>
&lt;li>如果只用来表示正整数（计算机中正数包含 0），可以表示的数值范围是：0 至  ，减 1 是因为可表示的数值范围是从 0 开始算的，而不是 1。&lt;/li>
&lt;li>也就是说 41 位可以表示个毫秒的值，转化成单位年则是年&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>10位&lt;/code>，用来记录工作机器 id。&lt;/p>
&lt;ul>
&lt;li>可以部署在个节点，包括&lt;code>5位datacenterId&lt;/code>和&lt;code>5位workerId&lt;/code>&lt;/li>
&lt;li>&lt;code>5位（bit）&lt;/code>可以表示的最大正整数是，即可以用 0、1、2、3、&amp;hellip;.31 这 32 个数字，来表示不同的 datecenterId 或 workerId&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>12位&lt;/code>，序列号，用来记录同毫秒内产生的不同 id。&lt;/p>
&lt;ul>
&lt;li>&lt;code>12位（bit）&lt;/code>可以表示的最大正整数是，即可以用 0、1、2、3、&amp;hellip;.4094 这 4095 个数字，来表示同一机器同一时间截（毫秒)内产生的 4095 个 ID 序号&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>由于在 Java 中 64bit 的整数是 long 类型，所以在 Java 中 SnowFlake 算法生成的 id 就是 long 来存储的。&lt;/p>
&lt;p>SnowFlake 可以保证：&lt;/p>
&lt;ul>
&lt;li>所有生成的 id 按时间趋势递增&lt;/li>
&lt;li>整个分布式系统内不会产生重复 id（因为有 datacenterId 和 workerId 来做区分）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>快（哈哈，天下武功唯快不破）。&lt;/li>
&lt;li>没有啥依赖，实现也特别简单。&lt;/li>
&lt;li>知道原理之后可以根据实际情况调整各各位段，方便灵活。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>只能趋势递增。（有些也不叫缺点，网上有些如果绝对递增，竞争对手中午下单，第二天在下单即可大概判断该公司的订单量，危险！！！）&lt;/li>
&lt;li>依赖机器时间，如果发生回拨会导致可能生成 id 重复。 下面重点讨论时间回拨问题。&lt;/li>
&lt;/ul>
&lt;h2 id="代码">代码&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt"> 10
&lt;/span>&lt;span class="lnt"> 11
&lt;/span>&lt;span class="lnt"> 12
&lt;/span>&lt;span class="lnt"> 13
&lt;/span>&lt;span class="lnt"> 14
&lt;/span>&lt;span class="lnt"> 15
&lt;/span>&lt;span class="lnt"> 16
&lt;/span>&lt;span class="lnt"> 17
&lt;/span>&lt;span class="lnt"> 18
&lt;/span>&lt;span class="lnt"> 19
&lt;/span>&lt;span class="lnt"> 20
&lt;/span>&lt;span class="lnt"> 21
&lt;/span>&lt;span class="lnt"> 22
&lt;/span>&lt;span class="lnt"> 23
&lt;/span>&lt;span class="lnt"> 24
&lt;/span>&lt;span class="lnt"> 25
&lt;/span>&lt;span class="lnt"> 26
&lt;/span>&lt;span class="lnt"> 27
&lt;/span>&lt;span class="lnt"> 28
&lt;/span>&lt;span class="lnt"> 29
&lt;/span>&lt;span class="lnt"> 30
&lt;/span>&lt;span class="lnt"> 31
&lt;/span>&lt;span class="lnt"> 32
&lt;/span>&lt;span class="lnt"> 33
&lt;/span>&lt;span class="lnt"> 34
&lt;/span>&lt;span class="lnt"> 35
&lt;/span>&lt;span class="lnt"> 36
&lt;/span>&lt;span class="lnt"> 37
&lt;/span>&lt;span class="lnt"> 38
&lt;/span>&lt;span class="lnt"> 39
&lt;/span>&lt;span class="lnt"> 40
&lt;/span>&lt;span class="lnt"> 41
&lt;/span>&lt;span class="lnt"> 42
&lt;/span>&lt;span class="lnt"> 43
&lt;/span>&lt;span class="lnt"> 44
&lt;/span>&lt;span class="lnt"> 45
&lt;/span>&lt;span class="lnt"> 46
&lt;/span>&lt;span class="lnt"> 47
&lt;/span>&lt;span class="lnt"> 48
&lt;/span>&lt;span class="lnt"> 49
&lt;/span>&lt;span class="lnt"> 50
&lt;/span>&lt;span class="lnt"> 51
&lt;/span>&lt;span class="lnt"> 52
&lt;/span>&lt;span class="lnt"> 53
&lt;/span>&lt;span class="lnt"> 54
&lt;/span>&lt;span class="lnt"> 55
&lt;/span>&lt;span class="lnt"> 56
&lt;/span>&lt;span class="lnt"> 57
&lt;/span>&lt;span class="lnt"> 58
&lt;/span>&lt;span class="lnt"> 59
&lt;/span>&lt;span class="lnt"> 60
&lt;/span>&lt;span class="lnt"> 61
&lt;/span>&lt;span class="lnt"> 62
&lt;/span>&lt;span class="lnt"> 63
&lt;/span>&lt;span class="lnt"> 64
&lt;/span>&lt;span class="lnt"> 65
&lt;/span>&lt;span class="lnt"> 66
&lt;/span>&lt;span class="lnt"> 67
&lt;/span>&lt;span class="lnt"> 68
&lt;/span>&lt;span class="lnt"> 69
&lt;/span>&lt;span class="lnt"> 70
&lt;/span>&lt;span class="lnt"> 71
&lt;/span>&lt;span class="lnt"> 72
&lt;/span>&lt;span class="lnt"> 73
&lt;/span>&lt;span class="lnt"> 74
&lt;/span>&lt;span class="lnt"> 75
&lt;/span>&lt;span class="lnt"> 76
&lt;/span>&lt;span class="lnt"> 77
&lt;/span>&lt;span class="lnt"> 78
&lt;/span>&lt;span class="lnt"> 79
&lt;/span>&lt;span class="lnt"> 80
&lt;/span>&lt;span class="lnt"> 81
&lt;/span>&lt;span class="lnt"> 82
&lt;/span>&lt;span class="lnt"> 83
&lt;/span>&lt;span class="lnt"> 84
&lt;/span>&lt;span class="lnt"> 85
&lt;/span>&lt;span class="lnt"> 86
&lt;/span>&lt;span class="lnt"> 87
&lt;/span>&lt;span class="lnt"> 88
&lt;/span>&lt;span class="lnt"> 89
&lt;/span>&lt;span class="lnt"> 90
&lt;/span>&lt;span class="lnt"> 91
&lt;/span>&lt;span class="lnt"> 92
&lt;/span>&lt;span class="lnt"> 93
&lt;/span>&lt;span class="lnt"> 94
&lt;/span>&lt;span class="lnt"> 95
&lt;/span>&lt;span class="lnt"> 96
&lt;/span>&lt;span class="lnt"> 97
&lt;/span>&lt;span class="lnt"> 98
&lt;/span>&lt;span class="lnt"> 99
&lt;/span>&lt;span class="lnt">100
&lt;/span>&lt;span class="lnt">101
&lt;/span>&lt;span class="lnt">102
&lt;/span>&lt;span class="lnt">103
&lt;/span>&lt;span class="lnt">104
&lt;/span>&lt;span class="lnt">105
&lt;/span>&lt;span class="lnt">106
&lt;/span>&lt;span class="lnt">107
&lt;/span>&lt;span class="lnt">108
&lt;/span>&lt;span class="lnt">109
&lt;/span>&lt;span class="lnt">110
&lt;/span>&lt;span class="lnt">111
&lt;/span>&lt;span class="lnt">112
&lt;/span>&lt;span class="lnt">113
&lt;/span>&lt;span class="lnt">114
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Twitter_Snowflake&amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * SnowFlake的结构如下(每部分用-分开):&amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)
&lt;/span>&lt;span class="cm"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &amp;lt;&amp;lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * 加起来刚好64位，为一个Long型。&amp;lt;br&amp;gt;
&lt;/span>&lt;span class="cm"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SnowflakeIdWorker&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">twepoch&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1420041600000L&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 开始时间截 (2015-01-01) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">workerIdBits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">5L&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 机器id所占的位数 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">datacenterIdBits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">5L&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 数据标识id所占的位数 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">maxWorkerId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1L&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="o">(-&lt;/span>&lt;span class="n">1L&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">workerIdBits&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="cm">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">maxDatacenterId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1L&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="o">(-&lt;/span>&lt;span class="n">1L&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">datacenterIdBits&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="cm">/** 支持的最大数据标识id，结果是31 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">sequenceBits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">12L&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 序列在id中占的位数 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">workerIdShift&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sequenceBits&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 机器ID向左移12位 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">datacenterIdShift&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sequenceBits&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">workerIdBits&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 数据标识id向左移17位(12+5) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">timestampLeftShift&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sequenceBits&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">workerIdBits&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">datacenterIdBits&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 时间截向左移22位(5+5+12) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">sequenceMask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1L&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="o">(-&lt;/span>&lt;span class="n">1L&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">sequenceBits&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="cm">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">workerId&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 工作机器ID(0~31) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">datacenterId&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 数据中心ID(0~31) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">sequence&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0L&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 毫秒内序列(0~4095) */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">lastTimestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1L&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="cm">/** 上次生成ID的时间截 */&lt;/span>
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 构造函数
&lt;/span>&lt;span class="cm"> * @param workerId 工作ID (0~31)
&lt;/span>&lt;span class="cm"> * @param datacenterId 数据中心ID (0~31)
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">SnowflakeIdWorker&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">workerId&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">datacenterId&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">workerId&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">maxWorkerId&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">workerId&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalArgumentException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;worker Id can&amp;#39;t be greater than %d or less than 0&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">maxWorkerId&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">datacenterId&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">maxDatacenterId&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">datacenterId&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalArgumentException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;datacenter Id can&amp;#39;t be greater than %d or less than 0&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">maxDatacenterId&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">workerId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">workerId&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">datacenterId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">datacenterId&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// ==============================Methods==========================================
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 获得下一个ID (该方法是线程安全的)
&lt;/span>&lt;span class="cm"> * @return SnowflakeId
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">synchronized&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">nextId&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timeGen&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">timestamp&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">lastTimestamp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Clock moved backwards. Refusing to generate id for %d milliseconds&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">lastTimestamp&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">timestamp&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//如果是同一时间生成的，则进行毫秒内序列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">lastTimestamp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">timestamp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">sequence&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">sequence&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">sequenceMask&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//毫秒内序列溢出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">sequence&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//阻塞到下一个毫秒,获得新的时间戳
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tilNextMillis&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">lastTimestamp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//时间戳改变，毫秒内序列重置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">sequence&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0L&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//上次生成ID的时间截
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">lastTimestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timestamp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//移位并通过或运算拼到一起组成64位的ID
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">timestamp&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">twepoch&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">timestampLeftShift&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">datacenterId&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">datacenterIdShift&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">workerId&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">workerIdShift&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">sequence&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 阻塞到下一个毫秒，直到获得新的时间戳
&lt;/span>&lt;span class="cm"> * @param lastTimestamp 上次生成ID的时间截
&lt;/span>&lt;span class="cm"> * @return 当前时间戳
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">tilNextMillis&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">lastTimestamp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timeGen&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">timestamp&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">lastTimestamp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timeGen&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">timestamp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 返回以毫秒为单位的当前时间
&lt;/span>&lt;span class="cm"> * @return 当前时间(毫秒)
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">timeGen&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//==============================Test=============================================
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="cm">/** 测试 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">SnowflakeIdWorker&lt;/span> &lt;span class="n">idWorker&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">SnowflakeIdWorker&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">1000&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">idWorker&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nextId&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="时间回拨问题">时间回拨问题&lt;/h2></description></item><item><title>一致性哈希算法</title><link>https://justice.bj.cn/post/13.algorithm/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="一致性哈希算法">一致性哈希算法&lt;/h1>
&lt;p>一致性哈希算法在 1997 年由麻省理工学院的 Karger 等人在解决分布式 Cache 中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和 CARP 十分类似。一致性哈希修正了 CARP 使用的简单哈希算法带来的问题，使得 DHT 可以在 P2P 环境中真正得到应用。&lt;/p>
&lt;p>但现在一致性 hash 算法在分布式系统中也得到了广泛应用，研究过 memcached 缓存数据库的人都知道，memcached 服务器端本身不提供分布式 cache 的一致性，而是由客户端来提供，具体在计算一致性 hash 时采用如下步骤：&lt;/p>
&lt;ol>
&lt;li>首先求出 memcached 服务器（节点）的哈希值，并将其配置到 0 ～ 232 的圆（continuum）上。&lt;/li>
&lt;li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。&lt;/li>
&lt;li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过 232 仍然找不到服务器，就会保存到第一台 memcached 服务器上。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffff01ae569b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">&lt;/p>
&lt;p>从上图的状态中添加一台 memcached 服务器。余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但 Consistent Hashing 中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffff01cb23ca9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">&lt;/p>
&lt;h2 id="一致性-hash-性质">一致性 Hash 性质&lt;/h2>
&lt;p>考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其 hash 值（通常与系统中的节点数目有关），由于 hash 值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性 hash 就显得至关重要，良好的分布式 cahce 系统中的一致性 hash 算法应该满足以下几个方面：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>平衡性(Balance)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>单调性(Monotonicity)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。简单的哈希算法往往不能满足单调性的要求，如最简单的线性哈希：x = (ax + b) mod (P)，在上式中，P 表示全部缓冲的大小。不难看出，当缓冲大小发生变化时(从 P1 到 P2)，原来所有的哈希结果均会发生变化，从而不满足单调性的要求。哈希结果的变化意味着当缓冲空间发生变化时，所有的映射关系需要在系统内全部更新。而在 P2P 系统内，缓冲的变化等价于 Peer 加入或退出系统，这一情况在 P2P 系统中会频繁发生，因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分散性(Spread)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>负载(Load)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>平滑性(Smoothness)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;h3 id="基本概念">基本概念&lt;/h3>
&lt;p>一致性哈希算法（Consistent Hashing）最早在论文《&lt;a href="http://dl.acm.org/citation.cfm?id=258660">Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web&lt;/a>》中被提出。简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2^32-1（即哈希值是一个 32 位无符号整形），整个哈希空间环如下：&lt;/p>
&lt;p>&lt;img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffff019d48ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">&lt;/p>
&lt;p>整个空间按顺时针方向组织。0 和 232-1 在零点中方向重合。&lt;/p>
&lt;p>下一步将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 ip 或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用 ip 地址哈希后在环空间的位置如下：&lt;/p>
&lt;p>&lt;img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffff019f1cecc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">&lt;/p>
&lt;p>接下来使用如下算法定位数据访问到相应服务器：将数据 key 使用相同的函数 Hash 计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。&lt;/p>
&lt;p>例如我们有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在环空间上的位置如下：&lt;/p>
&lt;p>![](data:image/svg+xml;utf8,&lt;?xml version="1.0"?>&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="746" height="775">&lt;/svg>)&lt;/p>
&lt;p>根据一致性哈希算法，数据 A 会被定为到 Node A 上，B 被定为到 Node B 上，C 被定为到 Node C 上，D 被定为到 Node D 上。&lt;/p>
&lt;p>下面分析一致性哈希算法的容错性和可扩展性。现假设 Node C 不幸宕机，可以看到此时对象 A、B、D 不会受到影响，只有 C 对象被重定位到 Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。&lt;/p>
&lt;p>下面考虑另外一种情况，如果在系统中增加一台服务器 Node X，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffff01dab936a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">&lt;/p>
&lt;p>此时对象 Object A、B、D 不受影响，只有对象 C 需要重定位到新的 Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。&lt;/p>
&lt;p>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。&lt;/p>
&lt;p>另外，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务器，其环分布如下，&lt;/p>
&lt;p>&lt;img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffff040ae43be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">&lt;/p>
&lt;p>此时必然造成大量数据集中到 Node A 上，而只有极少量会定位到 Node B 上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器 ip 或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：&lt;/p>
&lt;p>&lt;img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffff03ecc7be4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">&lt;/p>
&lt;p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到 Node A 上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为 32 甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。&lt;/p>
&lt;h2 id="java-代码实现">JAVA 代码实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt"> 10
&lt;/span>&lt;span class="lnt"> 11
&lt;/span>&lt;span class="lnt"> 12
&lt;/span>&lt;span class="lnt"> 13
&lt;/span>&lt;span class="lnt"> 14
&lt;/span>&lt;span class="lnt"> 15
&lt;/span>&lt;span class="lnt"> 16
&lt;/span>&lt;span class="lnt"> 17
&lt;/span>&lt;span class="lnt"> 18
&lt;/span>&lt;span class="lnt"> 19
&lt;/span>&lt;span class="lnt"> 20
&lt;/span>&lt;span class="lnt"> 21
&lt;/span>&lt;span class="lnt"> 22
&lt;/span>&lt;span class="lnt"> 23
&lt;/span>&lt;span class="lnt"> 24
&lt;/span>&lt;span class="lnt"> 25
&lt;/span>&lt;span class="lnt"> 26
&lt;/span>&lt;span class="lnt"> 27
&lt;/span>&lt;span class="lnt"> 28
&lt;/span>&lt;span class="lnt"> 29
&lt;/span>&lt;span class="lnt"> 30
&lt;/span>&lt;span class="lnt"> 31
&lt;/span>&lt;span class="lnt"> 32
&lt;/span>&lt;span class="lnt"> 33
&lt;/span>&lt;span class="lnt"> 34
&lt;/span>&lt;span class="lnt"> 35
&lt;/span>&lt;span class="lnt"> 36
&lt;/span>&lt;span class="lnt"> 37
&lt;/span>&lt;span class="lnt"> 38
&lt;/span>&lt;span class="lnt"> 39
&lt;/span>&lt;span class="lnt"> 40
&lt;/span>&lt;span class="lnt"> 41
&lt;/span>&lt;span class="lnt"> 42
&lt;/span>&lt;span class="lnt"> 43
&lt;/span>&lt;span class="lnt"> 44
&lt;/span>&lt;span class="lnt"> 45
&lt;/span>&lt;span class="lnt"> 46
&lt;/span>&lt;span class="lnt"> 47
&lt;/span>&lt;span class="lnt"> 48
&lt;/span>&lt;span class="lnt"> 49
&lt;/span>&lt;span class="lnt"> 50
&lt;/span>&lt;span class="lnt"> 51
&lt;/span>&lt;span class="lnt"> 52
&lt;/span>&lt;span class="lnt"> 53
&lt;/span>&lt;span class="lnt"> 54
&lt;/span>&lt;span class="lnt"> 55
&lt;/span>&lt;span class="lnt"> 56
&lt;/span>&lt;span class="lnt"> 57
&lt;/span>&lt;span class="lnt"> 58
&lt;/span>&lt;span class="lnt"> 59
&lt;/span>&lt;span class="lnt"> 60
&lt;/span>&lt;span class="lnt"> 61
&lt;/span>&lt;span class="lnt"> 62
&lt;/span>&lt;span class="lnt"> 63
&lt;/span>&lt;span class="lnt"> 64
&lt;/span>&lt;span class="lnt"> 65
&lt;/span>&lt;span class="lnt"> 66
&lt;/span>&lt;span class="lnt"> 67
&lt;/span>&lt;span class="lnt"> 68
&lt;/span>&lt;span class="lnt"> 69
&lt;/span>&lt;span class="lnt"> 70
&lt;/span>&lt;span class="lnt"> 71
&lt;/span>&lt;span class="lnt"> 72
&lt;/span>&lt;span class="lnt"> 73
&lt;/span>&lt;span class="lnt"> 74
&lt;/span>&lt;span class="lnt"> 75
&lt;/span>&lt;span class="lnt"> 76
&lt;/span>&lt;span class="lnt"> 77
&lt;/span>&lt;span class="lnt"> 78
&lt;/span>&lt;span class="lnt"> 79
&lt;/span>&lt;span class="lnt"> 80
&lt;/span>&lt;span class="lnt"> 81
&lt;/span>&lt;span class="lnt"> 82
&lt;/span>&lt;span class="lnt"> 83
&lt;/span>&lt;span class="lnt"> 84
&lt;/span>&lt;span class="lnt"> 85
&lt;/span>&lt;span class="lnt"> 86
&lt;/span>&lt;span class="lnt"> 87
&lt;/span>&lt;span class="lnt"> 88
&lt;/span>&lt;span class="lnt"> 89
&lt;/span>&lt;span class="lnt"> 90
&lt;/span>&lt;span class="lnt"> 91
&lt;/span>&lt;span class="lnt"> 92
&lt;/span>&lt;span class="lnt"> 93
&lt;/span>&lt;span class="lnt"> 94
&lt;/span>&lt;span class="lnt"> 95
&lt;/span>&lt;span class="lnt"> 96
&lt;/span>&lt;span class="lnt"> 97
&lt;/span>&lt;span class="lnt"> 98
&lt;/span>&lt;span class="lnt"> 99
&lt;/span>&lt;span class="lnt">100
&lt;/span>&lt;span class="lnt">101
&lt;/span>&lt;span class="lnt">102
&lt;/span>&lt;span class="lnt">103
&lt;/span>&lt;span class="lnt">104
&lt;/span>&lt;span class="lnt">105
&lt;/span>&lt;span class="lnt">106
&lt;/span>&lt;span class="lnt">107
&lt;/span>&lt;span class="lnt">108
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">org.java.base.hash&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.Collection&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.HashSet&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.Iterator&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.Set&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.SortedMap&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.SortedSet&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.TreeMap&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.TreeSet&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ConsistentHash&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">numberOfReplicas&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 节点的复制因子,实际节点个数 * numberOfReplicas =
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 虚拟节点个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">SortedMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">circle&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TreeMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>&lt;span class="c1">// 存储虚拟节点的hash值到真实节点的映射
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">ConsistentHash&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">numberOfReplicas&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="n">Collection&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">numberOfReplicas&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numberOfReplicas&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">){&lt;/span>
&lt;span class="n">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">numberOfReplicas&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++){&lt;/span>
&lt;span class="c1">// 对于一个实际机器节点 node, 对应 numberOfReplicas 个虚拟节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * 不同的虚拟节点(i不同)有不同的hash值,但都对应同一个实际机器node
&lt;/span>&lt;span class="cm"> * 虚拟node一般是均衡分布在环上的,数据存储在顺时针方向的虚拟node上
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">String&lt;/span> &lt;span class="n">nodestr&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">hashcode&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="n">nodestr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">hashCode&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;hashcode:&amp;#34;&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">hashcode&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">hashcode&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">remove&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">numberOfReplicas&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span>
&lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">hashCode&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * 获得一个最近的顺时针节点,根据给定的key 取Hash
&lt;/span>&lt;span class="cm"> * 然后再取得顺时针方向上最近的一个虚拟节点对应的实际节点
&lt;/span>&lt;span class="cm"> * 再从实际节点中取得 数据
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">hashCode&lt;/span>&lt;span class="o">();&lt;/span>&lt;span class="c1">// node 用String来表示,获得node在哈希环中的hashCode
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;hashcode-----&amp;gt;:&amp;#34;&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">containsKey&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//数据映射在两台虚拟机器所在环之间,就需要按顺时针方向寻找机器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">SortedMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">tailMap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">tailMap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tailMap&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">firstKey&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">tailMap&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">firstKey&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">getSize&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * 查看表示整个哈希环中各个虚拟节点位置
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">testBalance&lt;/span>&lt;span class="o">(){&lt;/span>
&lt;span class="n">Set&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">sets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">circle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">keySet&lt;/span>&lt;span class="o">();&lt;/span>&lt;span class="c1">//获得TreeMap中所有的Key
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">SortedSet&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">sortedSets&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TreeSet&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;(&lt;/span>&lt;span class="n">sets&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">//将获得的Key集合排序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Integer&lt;/span> &lt;span class="n">hashCode&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">sortedSets&lt;/span>&lt;span class="o">){&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">hashCode&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;----each location &amp;#39;s distance are follows: ----&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * 查看相邻两个hashCode的差值
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">Iterator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sortedSets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">iterator&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">Iterator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">it2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sortedSets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">iterator&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">it2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">hasNext&lt;/span>&lt;span class="o">())&lt;/span>
&lt;span class="n">it2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">keyPre&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">keyAfter&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">hasNext&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">it2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">hasNext&lt;/span>&lt;span class="o">()){&lt;/span>
&lt;span class="n">keyPre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">keyAfter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">it2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">keyAfter&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">keyPre&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Set&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HashSet&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;B&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;C&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">ConsistentHash&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">consistentHash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ConsistentHash&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;(&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">consistentHash&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;D&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;hash circle size: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">consistentHash&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getSize&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;location of each node are follows: &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">consistentHash&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">testBalance&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">String&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="n">consistentHash&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;apple&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;node-----------&amp;gt;:&amp;#34;&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="jump-一致性哈希算法">Jump 一致性哈希算法&lt;/h2>
&lt;p>jump consistent hash 是一种一致性哈希算法, 此算法&lt;strong>零内存消耗&lt;/strong>，&lt;strong>均匀分配&lt;/strong>，&lt;strong>快速&lt;/strong>，并且&lt;strong>只有 5 行代码&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int32_t&lt;/span> &lt;span class="nf">JumpConsistentHash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">uint64_t&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int32_t&lt;/span> &lt;span class="n">num_buckets&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int64_t&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_buckets&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2862933555777941757ULL&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1LL&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">31&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="kt">double&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">33&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="kademlia-算法">Kademlia 算法&lt;/h2>
&lt;p>Kademlia 算法在 2002 年由 Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点。Kademlia 后来被 eMule、BitTorrent 等 P2P 软件采用作为底层算法。&lt;/p>
&lt;ul>
&lt;li>对于任意一个有[ 2(n−1) ,2𝑛)个节点的网络，最多只需要 n 步搜索即可找到目标节点；&lt;/li>
&lt;li>K-bucket 的更新机制一定程度上保持了网络的活性和安全性。&lt;/li>
&lt;/ul></description></item><item><title>堆排序</title><link>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="堆排序">堆排序&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>堆排序是借助于堆这个数据结构来实现排序的一种算法。&lt;/p>
&lt;h3 id="堆heap的性质">堆(heap)的性质&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>堆&lt;/strong>是一个&lt;strong>完全二叉树&lt;/strong>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的每个非叶子结点值均大于(大顶堆)/小于(小顶堆)其左右子节点值；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的&lt;strong>根节点&lt;/strong>为所有节点中的最大值(大顶堆)/最小值(小顶堆)；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/05/22-20-35-03-2021-05-22-20-34-57-image.png" alt="">&lt;/p>
&lt;h2 id="堆排序-1">堆排序&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>堆排序利用堆节点的性质 2，每次从堆中排出堆顶元素，从而最终得到有序的序列；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于堆是一个完全二叉树，所以可以用数组来组织；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于完全二叉树性质，数组中根节点索引($i_o$)和其左右子节点($i_l,i_r$)满足如下关系：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>$$
i_l = 2 * i_o + 1 \&lt;br>
i_r = 2 * i_o + 2
$$&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp" alt="">&lt;/p>
&lt;h2 id="复杂性分析">复杂性分析&lt;/h2>
&lt;h3 id="时间复杂度">时间复杂度&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Avg: $O(nlogn)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Max: $O(n^2)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Min: $O(n)$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="空间复杂度">空间复杂度&lt;/h3>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">heap_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span class="s1"> 堆调整, 将nums数组从start开始,长度为length的数组调整为堆
&lt;/span>&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span>
&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">#初始化堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1"># 循环取出堆顶元素, 放到数组尾部, 并调整堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>并发</title><link>https://justice.bj.cn/post/13.algorithm/concurrent/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/concurrent/</guid><description>&lt;h1 id="并发">并发&lt;/h1>
&lt;h2 id="进程">进程&lt;/h2>
&lt;h3 id="进程间通信">进程间通信&lt;/h3>
&lt;ul>
&lt;li>管道(Pipe)&lt;/li>
&lt;li>共享内存(SharedMemory)&lt;/li>
&lt;li>消息队列(MQ)&lt;/li>
&lt;li>文件(File)&lt;/li>
&lt;li>socket&lt;/li>
&lt;/ul>
&lt;h2 id="线程">线程&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>线程间同步&lt;/p>
&lt;ul>
&lt;li>互斥量(mutex)&lt;/li>
&lt;li>条件变量(cond_var)&lt;/li>
&lt;li>读写锁(rw_lock)&lt;/li>
&lt;li>信号量(signal_var)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>经典多线程问题&lt;/p>
&lt;ul>
&lt;li>条件变量的虚假唤醒&lt;/li>
&lt;li>单例的双层锁 DCL 实现&lt;/li>
&lt;li>线程安全的单例模式&lt;/li>
&lt;li>RCU&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="协程">协程&lt;/h3>
&lt;ul>
&lt;li>协程&lt;/li>
&lt;/ul>
&lt;h3 id="greenlet">greenlet&lt;/h3>
&lt;h3 id="io-复用">IO 复用&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>select&lt;/p>
&lt;ul>
&lt;li>select()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>poll&lt;/p>
&lt;ul>
&lt;li>poll()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>epoll&lt;/p>
&lt;ul>
&lt;li>epoll_create(),epoll_ctl(), epoll_wait()&lt;/li>
&lt;li>LT(Level Trigle): 水平触发, 当数据未处理时触发&lt;/li>
&lt;li>ET(Edge Trigle): 边缘促发, 当事件发生时触发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="池">池&lt;/h3>
&lt;ul>
&lt;li>线程池&lt;/li>
&lt;li>连接池&lt;/li>
&lt;/ul>
&lt;h3 id="库">库&lt;/h3>
&lt;ul>
&lt;li>libevent&lt;/li>
&lt;li>libev2&lt;/li>
&lt;li>ACE&lt;/li>
&lt;li>libuv&lt;/li>
&lt;/ul></description></item><item><title>设计模式及准则</title><link>https://justice.bj.cn/post/13.algorithm/design_pattern/</link><pubDate>Sat, 30 Apr 2022 17:04:39 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/design_pattern/</guid><description>&lt;h1 id="设计模式及准则">设计模式及准则&lt;/h1>
&lt;h2 id="设计准则">设计准则&lt;/h2>
&lt;ol>
&lt;li>单一职责原则(SDP): 一个类自有一个引起变化的原因。&lt;/li>
&lt;li>开发封闭原则(ODP): 对扩展开发, 对修改封闭。&lt;/li>
&lt;li>依赖倒置原则(DIP): 具体依赖于抽象。&lt;/li>
&lt;li>里氏替换原则(LSP): 子类能够替换父类。&lt;/li>
&lt;li>接口隔离原则: 类间的依赖关系应该建立在最小的接口上，客户端不应该依赖它不需要的接口。&lt;/li>
&lt;li>迪米特法则: 如果不直接通信，那么两个类就不应当发生直接作用。&lt;/li>
&lt;li>RAII: 资源分配即初始化。&lt;/li>
&lt;li>PIMPL: 用声明代替头文件引用, 同时用指针代替对象定义。&lt;/li>
&lt;/ol>
&lt;h2 id="设计模式">设计模式&lt;/h2>
&lt;h3 id="创建型">创建型&lt;/h3>
&lt;ul>
&lt;li>简单工厂(Simple Factory)&lt;/li>
&lt;li>工厂方法(Factory Method)&lt;/li>
&lt;li>抽象工厂(Abstract Factory)&lt;/li>
&lt;li>建造器模式(Builder)&lt;/li>
&lt;li>原型模式(Prototype)&lt;/li>
&lt;li>单例模式(Singleton): 一个类只能有一个对象。&lt;/li>
&lt;/ul>
&lt;h3 id="结构型">结构型&lt;/h3>
&lt;ul>
&lt;li>适配器类(Adapter_Class)&lt;/li>
&lt;li>适配器对象(Adapter_Object)&lt;/li>
&lt;li>桥接模式(Bridge)&lt;/li>
&lt;li>组合器(Composite)&lt;/li>
&lt;li>装饰器模式(Decorator)&lt;/li>
&lt;li>外观模式(Facade)&lt;/li>
&lt;li>代理模式(Proxy)&lt;/li>
&lt;li>享元模式(Flyweight)&lt;/li>
&lt;/ul>
&lt;h3 id="行为型">行为型&lt;/h3>
&lt;ul>
&lt;li>职责链(Chain of Responsibility)&lt;/li>
&lt;li>命令(Command)&lt;/li>
&lt;li>解释器(Interpreter)&lt;/li>
&lt;li>迭代器(Iterator)&lt;/li>
&lt;li>中介者(Mediator)&lt;/li>
&lt;li>备忘录(Memento)&lt;/li>
&lt;li>观察者模式(Observer)&lt;/li>
&lt;li>状态模式(State)&lt;/li>
&lt;li>策略模式(Strategy)&lt;/li>
&lt;li>模板方法(Template Method)&lt;/li>
&lt;li>访问者模式(Visitor)&lt;/li>
&lt;/ul></description></item><item><title>恢复二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/doc/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Sat, 30 Apr 2022 15:21:08 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;h1 id="恢复二叉搜索树httpsleetcode-cncomproblemsrecover-binary-search-treedescription-httpsleetcode-cncomproblemsrecover-binary-search-treedescription">&lt;a href="https://leetcode-cn.com/problems/recover-binary-search-tree/description/" title="https://leetcode-cn.com/problems/recover-binary-search-tree/description/">恢复二叉搜索树&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Medium (60.48%)&lt;/td>
&lt;td>708&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree">&lt;code>tree&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search">&lt;code>depth-first-search&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>Unknown&lt;/code>&lt;/p>
&lt;p>给你二叉搜索树的根节点 &lt;code>root&lt;/code> ，该树中的 &lt;strong>恰好&lt;/strong> 两个节点的值被错误地交换。&lt;em>请在不改变其结构的情况下，恢复这棵树&lt;/em> 。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 &amp;gt; 1 。交换 1 和 3 使二叉搜索树有效。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 &amp;lt; 3 。交换 2 和 3 使二叉搜索树有效。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>树上节点的数目在范围 &lt;code>[2, 1000]&lt;/code> 内&lt;/li>
&lt;li>&lt;code>-231 &amp;lt;= Node.val &amp;lt;= 231 - 1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>**进阶：**使用 &lt;code>O(n)&lt;/code> 空间复杂度的解法很容易实现。你能想出一个只使用 &lt;code>O(1)&lt;/code> 空间的解决方案吗？&lt;/p>
&lt;hr>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/recover-binary-search-tree/comments/" title="https://leetcode-cn.com/problems/recover-binary-search-tree/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/" title="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="cm">/* 递归遍历时的环境变量 */&lt;/span>
&lt;span class="n">TreeNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">prev&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//当前节点前一个节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">node1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//逆序开始节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">node2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//逆序最后节点
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * ## 解题思路
&lt;/span>&lt;span class="cm"> * 1. 中序遍历二叉搜索树，正常的二叉搜索树为有序递增序列；
&lt;/span>&lt;span class="cm"> * 2. 乱序的两个节点之间的所有节点为逆序排列；
&lt;/span>&lt;span class="cm"> * 3. 遍历时，根据当前节点和前一个节点的大小关系，判断是否逆序；
&lt;/span>&lt;span class="cm"> * 4. 使用两个临时节点变量分别记录逆序的开始和结束；
&lt;/span>&lt;span class="cm"> * 5. 遍历完成后，交换逆序开始和结束节点；
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="n">recoverTree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">inorder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node1&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 中序遍历二叉树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">inorder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//节点为nil，结束遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//递归中序遍历左子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">inorder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//处理当前节点
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 如果当前节点和前一个节点逆序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">prev&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">prev&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">node1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//第一个逆序节点为开始节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">node1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">prev&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">node2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//逆序结束节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">//当前节点处理完后，保存当前节点为上一个节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//递归中序遍历右子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">inorder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">a&lt;/span> &lt;span class="o">^=&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">b&lt;/span> &lt;span class="o">^=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">a&lt;/span> &lt;span class="o">^=&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Disruptor(高效无锁内存队列)</title><link>https://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</guid><description>&lt;h1 id="disruptor高效无锁内存队列">Disruptor(高效无锁内存队列)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Disruptor 是 LMAX 公司开源的一个高效的内存无锁队列。&lt;/p></description></item><item><title>Kafka时间轮算法</title><link>https://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</guid><description>&lt;h1 id="kafka时间轮算法">Kafka时间轮算法&lt;/h1>
&lt;p>Kafka 中存在一些定时任务(DelayedOperation)，如 DelayedFetch、DelayedProduce、DelayedHeartbeat 等，在 Kafka 中，定时任务的添加、轮转、执行、消亡等是通过时间轮来实现的。(时间轮并不是 Kafka 独有的设计，而是一种通用的实现方式，Netty 中也有用到时间轮的方式)&lt;/p>
&lt;h2 id="1-时间轮是什么">1.  时间轮是什么&lt;/h2>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/36/36293d8f2a75cd09852f9189092cbe9e.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/cb/cb615fcfbc43cd42a73b65644701d2a2.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;p>Kafka 时间轮由多个环形数组组成，每个环形数组包含 20 个时间单位，表示一个时间维度（一轮），如：第一层时间轮，数组中的每个元素代表 1ms，一圈就是 20ms，当延迟时间大于 20ms 时，就“进位”到第二层时间轮，第二层中，每“一格”表示 20ms，依此类推…&lt;/p>
&lt;p>对于一个延迟任务，大体包含三个过程：进入时间轮、降级和到期执行。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>进入时间轮&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>根据延迟时间计算对应的时间轮“层次”（如钟表中的“小时级”还是“分钟级”还是“秒级”，实际上是一个不断“升级”的过程，直到找到合适的“层次”）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算在该轮中的位置，并插入该位置（每个 bucket 是一个双向链表，可能包含多个延迟任务，这也是时间轮提高效率的一大原因，后面会提到）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若该 bucket 是首次插入，需要将该 bucket 加入 DelayQueue 中（DelayQueue 的引入是为了解决“空推进”，后面会提到）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/7b/7b74698c1815c0f86af8d1820da6b838.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降级&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>当时间“推进”到某个 bucket 时，说明该 bucket 中的任务在当前时间轮中的时间已经走完，需要进行“降级”，即进入更小粒度的时间轮中，reinsert 的过程和进入时间轮是类似的&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/d4/d4af2f2054bf00f89bcbf4e36044aa56.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>到期执行&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>在 reinsert 的过程中，若发现已经到期，则执行这些任务&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/19/19bb4299ca84652634ea5eade9471905.png" alt="">&lt;/p>
&lt;p>整体过程大致如下：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/e9/e901a56d80092cda0bdbb4260ed21a91.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;h2 id="2-时间的推进">2.  时间的“推进”&lt;/h2>
&lt;p>一种直观的想法是，像现实中的钟表一样，“一格一格”地走，这样就需要有一个线程一直不停的执行，而大多数情况下，时间轮中的 bucket 大部分是空的，指针的“推进”就没有实质作用，因此，为了减少这种“空推进”，Kafka 引入了 DelayQueue，以 bucket 为单位入队，每当有 bucket 到期，即 queue.poll 能拿到结果时，才进行时间的“推进”，减少了 ExpiredOperationReaper 线程空转的开销。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/5e/5e190488738e81a0ab996eb2c155e54f.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;h2 id="3-为什么要用时间轮">3.  为什么要用时间轮&lt;/h2>
&lt;p>用到延迟任务时，比较直接的想法是 DelayQueue、ScheduledThreadPoolExecutor 这些，而时间轮相比之下，最大的优势是在时间复杂度上：&lt;/p>
&lt;p>时间复杂度对比：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/cc/ccc843d13e25a1fec3e375b14e6658ac.png" alt="">&lt;/p>
&lt;p>因此，理论上，当任务较多时，TimingWheel 的时间性能优势会更明显&lt;/p>
&lt;p>总结一下 Kafka 时间轮性能高的几个主要原因：&lt;/p>
&lt;p>（1）时间轮的结构+双向列表 bucket，使得插入操作可以达到 O(1)的时间复杂度&lt;/p>
&lt;p>（2）Bucket 的设计让多个任务“合并”，使得同一个 bucket 的多次插入只需要在 delayQueue 中入队一次，同时减少了 delayQueue 中元素数量，堆的深度也减小，delayqueue 的插入和弹出操作开销也更小&lt;/p></description></item><item><title>RoaringBitmap</title><link>https://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</guid><description>&lt;h1 id="roaringbitmap">RoaringBitmap&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>RoaringBitmap（简称为 RBM）是 2016 年由 S. Chambi、D. Lemire、O. Kaser 等人在论文中提出的一种高效位图压缩算法;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用于解决稀疏位图空间占用效率问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="主要思想">主要思想&lt;/h2>
&lt;p>将 32 位无符号整数按照高 16 位分桶，即最多可能有 216=65536 个桶，称为&lt;code>container&lt;/code>。存储数据时，按照数据的高 16 位找到 container（找不到就会新建一个），再将低 16 位放入 container 中。也就是说，一个 RBM 就是很多 container 的集合。如下所示。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/195230-7b71d0d9abe6e906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp" alt="">&lt;/p>
&lt;p>图中示出了三个 container：&lt;/p>
&lt;ul>
&lt;li>高 16 位为 0000H 的 container，存储有前 1000 个 62 的倍数。&lt;/li>
&lt;li>高 16 位为 0001H 的 container，存储有[216, 216+100)区间内的 100 个数。&lt;/li>
&lt;li>高 16 位为 0002H 的 container，存储有[2×216, 3×216)区间内的所有偶数，共 215 个。&lt;/li>
&lt;/ul>
&lt;p>container 是 RBM 新创造的概念，自然也是提高效率的核心。为了更高效地存储和查询数据，不同情况下会采用不同类型的 container，下面深入讲解一下 container 的细节。&lt;/p>
&lt;h3 id="container">Container&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>ArrayContainer: 当桶内数据的基数不大于 4096 时，会采用它来存储，其本质上是一个 unsigned short 类型的有序数组。数组初始长度为 4，随着数据的增多会自动扩容（但最大长度就是 4096）。另外还维护有一个计数器，用来实时记录基数。上图中的前两个 container 基数都没超过 4096，所以均为 ArrayContainer。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BitmapContainer: 当桶内数据的基数大于 4096 时，会采用它来存储，其本质就是上一节讲过的普通位图，用长度固定为 1024 的 unsigned long 型数组表示，亦即位图的大小固定为 216 位（8KB）。它同样有一个计数器。上图中的第三个 container 基数远远大于 4096，所以要用 BitmapContainer 存储。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RunContainer: RunContainer 在图中并未示出，初始的 RBM 实现中也没有它，而是在本节开头的第二篇论文中新加入的。它使用可变长度的 unsigned short 数组存储用行程长度编码（RLE）压缩后的数据。举个例子，连续的整数序列&lt;code>11, 12, 13, 14, 15, 27, 28, 29&lt;/code>会被 RLE 压缩为两个二元组&lt;code>11, 4, 27, 2&lt;/code>，表示 11 后面紧跟着 4 个连续递增的值，27 后面跟着 2 个连续递增的值。由此可见，RunContainer 的压缩效果可好可坏。考虑极端情况：如果所有数据都是连续的，那么最终只需要 4 字节；如果所有数据都不连续（比如全是奇数或全是偶数），那么不仅不会压缩，还会膨胀成原来的两倍大。所以，RBM 引入 RunContainer 是作为其他两种 container 的折衷方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>来简要看看它们的复杂度和转换方法。&lt;/p>
&lt;h2 id="时空分析">时空分析&lt;/h2>
&lt;p>增删改查的时间复杂度方面，BitmapContainer 只涉及到位运算，显然为 O(1)。而 ArrayContainer 和 RunContainer 都需要用二分查找在有序数组中定位元素，故为 O(logN)。&lt;/p>
&lt;p>空间占用（即序列化时写出的字节流长度）方面，BitmapContainer 是恒定为 8192B 的。ArrayContainer 的空间占用与基数（c）有关，为(2 + 2c)B；RunContainer 的则与它存储的连续序列数（r）有关，为(2 + 4r)B。以上节图中的 RBM 为例，它一共存储了 33868 个 unsigned int，只占用了 10396 个字节的空间，可以说是非常高效了。&lt;/p>
&lt;h4 id="container-的创建与转换">Container 的创建与转换&lt;/h4>
&lt;p>在创建一个新 container 时，如果只插入一个元素，RBM 默认会用 ArrayContainer 来存储。如果插入的是元素序列的话，则会先根据上面的方法计算 ArrayContainer 和 RunContainer 的空间占用大小，并选择较小的那一种进行存储。&lt;/p>
&lt;p>当 ArrayContainer 的容量超过 4096 后，会自动转成 BitmapContainer 存储。4096 这个阈值很聪明，低于它时 ArrayContainer 比较省空间，高于它时 BitmapContainer 比较省空间。也就是说 ArrayContainer 存储稀疏数据，BitmapContainer 存储稠密数据，可以最大限度地避免内存浪费。&lt;/p>
&lt;p>RBM 还可以通过调用特定的 API（名为 optimize）比较 ArrayContainer/BitmapContainer 与等价的 RunContainer 的内存占用情况，一旦 RunContainer 占用较小，就转换之。也就是说，上图例子中的第二个 ArrayContainer 可以转化为只有一个二元组&lt;code>0, 100&lt;/code>的 RunContainer，占用空间进一步下降到 10200 字节。&lt;/p>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;p>官方提供了 RBM 的多种语言实现，Java、C/C++、Python、Go、C#等等一应俱全。Java 版本的 GitHub repo 见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Flemire%2FRoaringBitmap">这里&lt;/a>。代码比较多，但思路很清晰，看官如果对位运算比较熟悉的话读起来不难，故本文就不再长篇大论地讲源码了。值得注意的几点如下：&lt;/p>
&lt;ul>
&lt;li>两个 RBM 做集合操作时，不同种类 container 之间位运算的处理方式，如 ArrayContainer AND BitmapContainer，BitmapContainer OR RunContainer 等；&lt;/li>
&lt;li>对 64 位整数的支持（32 位有时会不够用哈）；&lt;/li>
&lt;li>能够将 RBM 数据写到堆外，即内存映射；&lt;/li>
&lt;li>支持 Kryo 序列化方式。&lt;/li>
&lt;/ul>
&lt;p>RBM 的应用范围极广，下面只简单列举几个有代表性的应用，并给出 reference。&lt;/p>
&lt;h4 id="lucene">Lucene&lt;/h4>
&lt;p>为了加速搜索，Lucene 会将常用的查询过滤条件产生的结果集缓存到内存中，方便复用，称为 filter cache。结果集其实就是文档 ID（整形数）的集合。从 Lucene 5 开始，使用了 RBM 优化过的文档 ID 集合 RoaringDocIdSet 作为 filter cache，详情可以参见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fblog%2Fframe-of-reference-and-roaring-bitmaps">《Frame of Reference and Roaring Bitmaps》&lt;/a>。该文除了介绍 RBM 外，还介绍了压缩倒排索引的 Frame of Reference（FOR）编码，值得一读。&lt;/p>
&lt;h4 id="spark">Spark&lt;/h4>
&lt;p>在 Spark Core 的 MapStatus 组件（用来跟踪 ShuffleMapTask 的输出结果块）中，利用了 RBM 来存储块是否非空的状态。今后会在 Spark 连载里讲到它，所以现在看看&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fapache%2Fspark%2Fblob%2Fmaster%2Fcore%2Fsrc%2Fmain%2Fscala%2Forg%2Fapache%2Fspark%2Fscheduler%2FMapStatus.scala">该类的源码&lt;/a>就可以了，不难理解。&lt;/p>
&lt;h4 id="greenplum">Greenplum&lt;/h4>
&lt;p>我司是 Greenplum 大户，虽然本鶸现在不负责数仓相关的事情了，但是偶尔还是要向 GP 提供一些数据。GP 配合 RoaringBitmap 非常适合做海量用户的近实时画像，每个 RBM 代表一维标签即可，根据标签圈选用户也很方便。GP 原生并未支持 RBM 类型数据，需要安装一个扩展插件，见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fzeromax007%2Fgpdb-roaringbitmap%3Fspm%3Da2c4e.10696291.0.0.a68919a4RFqCuW">这里&lt;/a>。关于 GP 与 RBM 的整合与使用，有两篇不错的参考文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F405191">https://yq.aliyun.com/articles/405191&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://links.jianshu.com/go?to=http%3A%2F%2Fmysql.taobao.org%2Fmonthly%2F2018%2F08%2F09">http://mysql.taobao.org/monthly/2018/08/09&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="redis">Redis&lt;/h4>
&lt;p>我们在 Redis 里经常使用位图存储数据（Redis 原生以字符串的形式支持位图），当然也就会遇到稀疏位图浪费存储空间的问题。但要让 Redis 支持 RBM，需要引入专门的 module，项目地址见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Faviggiano%2Fredis-roaring">这里&lt;/a>。它的设计思想与 Java 版 RBM 几乎相同，不再废话了。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://roaringbitmap.org/">https://roaringbitmap.org/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1402.6407.pdf">《Better bitmap performance with Roaring bitmaps》&lt;/a>与&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1603.06549.pdf">《Consistently faster and smaller compressed bitmaps with Roaring》&lt;/a>中提出，&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>树状数组(BIT)</title><link>https://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid><description>&lt;h1 id="树状数组bit">树状数组(BIT)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>树状数组&lt;/strong>或&lt;strong>二元索引树&lt;/strong>（英语：Binary Indexed Tree），又以其发明者命名为 FenwickFenwick 树。最早由 PeterM.FenwickPeterM.Fenwick 于 1994 年以 《A New Data Structure for Cumulative Frequency Tables&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84#cite_note-1">[1]&lt;/a>》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以 (logn)O(log⁡n) 的时间&lt;strong>得到任意前缀和（区间和）&lt;/strong>。&lt;/p>
&lt;h2 id="问题引入">问题引入&lt;/h2>
&lt;p>数组的单点修改&lt;code>update&lt;/code>和区间求和&lt;code>range_sum&lt;/code>问题。&lt;/p>
&lt;p>使用普通数组，&lt;code>update&lt;/code>时间复杂度为$O(1)$,&lt;code>range_sum&lt;/code>时间复杂度为$O(n)$.&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-26-2020-11-23-10-34-42-image.png" alt="">&lt;/p>
&lt;p>使用前缀和数组，&lt;code>update&lt;/code>时间复杂度为 O(n),&lt;code>range_sum&lt;/code>时间复杂度为$O(1)$.&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-52-2020-11-23-10-36-20-image.png" alt="">&lt;/p>
&lt;p>树状数组是上述方法的一个折中，&lt;code>update&lt;/code>和&lt;code>range_sum&lt;/code>时间复杂度均为$O(log_2n)$。&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>树状数组就是这样一种结构，它巧妙地利用了&lt;strong>二进制&lt;/strong>（实际上，树状数组的英文名 BIT，直译过来就是&lt;strong>二进制下标树&lt;/strong>）。例如 11，转化为二进制数就是$(1011)_2$ ，如果我们要求前 11 项和，可以分别查询 $ ((0000)_2, (1000)_2] $ , $ ( (1000)_2, (1010)_2 ] $, $ ( (1010)_2, (1101)_2 ] $ 的和再相加。这三个区间怎么来的呢？其实就是&lt;strong>不断地去掉二进制数最右边的一个 1&lt;/strong>的过程（如下图）。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-37-2020-11-23-10-53-33-image.png" alt="">&lt;/p>
&lt;p>二进制数最右边的一个 1，连带着它之后的 0 为&lt;code>lowbit(x)&lt;/code>（稍后再来看如何实现）。那么我们用$C_i$维护区间$ (A_i - lowbit(A_i), A_i] $ 的区间和，这样显然查询前 n 项和时需要合并的区间数是少于 $ log_2n $的。树状数组的结构大概像下面这样：&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-30-2020-11-23-10-56-25-image.png" alt="">&lt;/p>
&lt;p> 可用如下公式表示：&lt;/p>
&lt;p>$$
C[i] = A[i - 2^k+1] + A[i - 2^k+2] + &amp;hellip; + A[i]
$$&lt;/p>
&lt;p>其中: $k$表示 i 的二进制中从最低位到高位连续零的长度。&lt;/p>
&lt;h2 id="lowbit">lowbit&lt;/h2>
&lt;p>一个数的二进制表示中最低的一位&lt;code>1&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="优缺点">优缺点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>优点：修改和查询的复杂度都是$O(logN)$，相比线段树系数要少很多，比传统数组要快，而且容易写。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>缺点：是遇到复杂的区间问题还是不能解决，功能还是有限。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;p>一般用于解决大部分基于区间上的更新以及求和问题。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="cp">#define low(i) ((i)&amp;amp;(-i))
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">low&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//单点修改
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-=&lt;/span>&lt;span class="n">low&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">res&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//询问区间[1,pos]的权值和
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">range_query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">树状数组（BIT）—— 一篇就够了 - Last_Whisper - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/93795692">https://zhuanlan.zhihu.com/p/93795692&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>跳表(skiplist)</title><link>https://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</guid><description>&lt;h1 id="跳表skiplist">跳表(skiplist)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>跳表&lt;/code>(SkipList)由 William Pugh 于 1990 年发明。他在 Communications of the ACM June 1990, 33(6) 668-676 上发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了跳表的数据结构和插入删除操作。&lt;/p>
&lt;p>跳表是平衡树的一种替代的数据结构，和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法，跳表的插入和删除的工作是比较简单的。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-04-2020-03-06-11-41-30-image.png" alt="">&lt;/p>
&lt;h2 id="核心思想">核心思想&lt;/h2>
&lt;ul>
&lt;li>在普通链表中增加层级指针，实现节点的快速访问。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-11-image-20190504154638969.png" alt="image-20190504154638969">&lt;/p>
&lt;h2 id="实现要点">实现要点&lt;/h2>
&lt;ol>
&lt;li>新增节点通过随机数决定指针的层级；&lt;/li>
&lt;li>通过调节因子决定随机层级，从而控制层级指针的疏密；&lt;/li>
&lt;/ol>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// member 对象
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">robj&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 分值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 后退指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">backward&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 层
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistLevel&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 前进指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">forward&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 这个层跨越的节点数量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">span&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">[];&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zskiplistNode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html">跳跃表 — Redis 设计与实现&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>k8s Volume实现原理</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s-volume/</link><pubDate>Sat, 30 Apr 2022 09:23:49 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s-volume/</guid><description>&lt;h1 id="k8s-volume实现原理">k8s Volume实现原理&lt;/h1>
&lt;p>在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消息队列等等。&lt;/p>
&lt;p>然而 Kuberentes 中的每一个容器随时都可能因为某些原因而被删除和重启，容器中的文件也会随着它的删除而丢失，所以我们需要对集群中的某些文件和数据进行『持久化』；除此之外，由于同一个 Pod 中的多个 Container 可能也会有共享文件的需求，比如通过共享文件目录的方式为 nginx 生成需要代理的静态文件，所以我们需要一种方式来解决这两个问题。&lt;/p>
&lt;p>作为 Kubernetes 集群中除了 Pod 和 Service 之外最常见的基本对象，Volume 不仅能够解决 Container 中文件的临时性问题，也能够让同一个 Pod 中的多个 Container 共享文件。&lt;/p>
&lt;blockquote>
&lt;p>这篇文章并不会介绍 Kubernetes 中 Volume 的使用方法和 API，而是会着重介绍 Volume 的工作原理，包含其创建过程、多种 Volume 实现的异同以及如何与云服务提供商进行适配。&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>Kubernetes 中的 Volume 种类非常多，它不仅要支持临时的、易失的磁盘文件，还需要解决持久存储的问题；第一个问题往往都比较容易解决，后者作为持久存储在很多时候都需要与云服务商提供的存储方案打交道，如果是 Kubernetes 中已经支持的存储类型倒是还好，遇到不支持的类型还是比较麻烦的。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-storage.png" alt="kubernetes-storage">&lt;/p>
&lt;p>除了卷和持久卷之外，Kubernetes 还有另外一种更加复杂的概念 - 动态存储供应，它能够允许存储卷按需进行创建，不再需要集群的管理员手动调用云服务商提供的接口或者界面创建新的存储卷。&lt;/p>
&lt;p>集群中的每一个卷在被 Pod 使用时都会经历四个操作，也就是附着（Attach）、挂载（Mount）、卸载（Unmount）和分离（Detach）。&lt;/p>
&lt;p>如果 Pod 中使用的是 EmptyDir、HostPath 这种类型的卷，那么这些卷并不会经历附着和分离的操作，它们只会被挂载和卸载到某一个的 Pod 中，不过如果使用的云服务商提供的存储服务，这些持久卷只有附着到某一个节点之后才可以被挂在到相应的目录下，不过在其他节点使用这些卷时，该存储资源也需要先与当前的节点分离。&lt;/p>
&lt;p>如果 pod&lt;/p>
&lt;h3 id="卷">卷&lt;/h3>
&lt;p>在这一节中提到的卷（Volume）其实是一个比较特定的概念，它并不是一个持久化存储，可能会随着 Pod 的删除而删除，常见的卷就包括 EmptyDir、HostPath、ConfigMap 和 Secret，这些卷与所属的 Pod 具有相同的生命周期，它们可以通过如下的方式挂载到 Pod 下面的某一个目录中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.gcr.io/busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/cache&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/hostpath&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">config-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/configmap&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">special-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hostpath-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/hostpath&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Directory&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">config-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">configMap&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">special-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要注意的是，当我们将 ConfigMap 或者 Secret 『包装』成卷并挂载到某个目录时，我们其实创建了一些新的 Volume，这些 Volume 并不是 Kubernetes 中的对象，它们只存在于当前 Pod 中，随着 Pod 的删除而删除，但是需要注意的是这些『临时卷』的删除并不会导致相关  &lt;code>ConfigMap&lt;/code>  或者  &lt;code>Secret&lt;/code>  对象的删除。&lt;/p>
&lt;p>从上面我们其实可以看出 Volume 没有办法脱离 Pod 而生存，它与 Pod 拥有完全相同的生命周期，而且它们也不是 Kubernetes 对象，所以 Volume 的主要作用还是用于跨节点或者容器对数据进行同步和共享。&lt;/p>
&lt;h3 id="持久卷">持久卷&lt;/h3>
&lt;p>临时的卷没有办法解决数据持久存储的问题，想要让数据能够持久化，首先就需要将 Pod 和卷的声明周期分离，这也就是引入持久卷  &lt;code>PersistentVolume(PV)&lt;/code>  的原因。我们可以将  &lt;code>PersistentVolume&lt;/code>  理解为集群中资源的一种，它与集群中的节点 Node 有些相似，PV 为 Kubernete 集群提供了一个如何提供并且使用存储的抽象，与它一起被引入的另一个对象就是  &lt;code>PersistentVolumeClaim(PVC)&lt;/code>，这两个对象之间的关系与节点和 Pod 之间的关系差不多：&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-pv-and-pvc.png" alt="kubernetes-pv-and-pvc">&lt;/p>
&lt;p>&lt;code>PersistentVolume&lt;/code>  是集群中的一种被管理员分配的存储资源，而  &lt;code>PersistentVolumeClaim&lt;/code>  表示用户对存储资源的申请，它与 Pod 非常相似，PVC 消耗了持久卷资源，而 Pod 消耗了节点上的 CPU 和内存等物理资源。&lt;/p>
&lt;p>因为 PVC 允许用户消耗抽象的存储资源，所以用户需要不同类型、属性和性能的 PV 就是一个比较常见的需求了，在这时我们可以通过  &lt;code>StorageClass&lt;/code>  来提供不同种类的 PV 资源，上层用户就可以直接使用系统管理员提供好的存储类型。&lt;/p>
&lt;h4 id="访问模式">访问模式&lt;/h4>
&lt;p>Kubernetes 中的 PV 提供三种不同的访问模式，分别是  &lt;code>ReadWriteOnce&lt;/code>、&lt;code>ReadOnlyMany&lt;/code>  和  &lt;code>ReadWriteMany&lt;/code>，这三种模式的含义和用法我们可以通过它们的名字推测出来：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ReadWriteOnce&lt;/code>  表示当前卷可以被一个节点使用读写模式挂载；&lt;/li>
&lt;li>&lt;code>ReadOnlyMany&lt;/code>  表示当前卷可以被多个节点使用只读模式挂载；&lt;/li>
&lt;li>&lt;code>ReadWriteMany&lt;/code>  表示当前卷可以被多个节点使用读写模式挂载；&lt;/li>
&lt;/ul>
&lt;p>不同的卷插件对于访问模式其实有着不同的支持，AWS 上的  &lt;code>AWSElasticBlockStore&lt;/code>  和 GCP 上的  &lt;code>GCEPersistentDisk&lt;/code>  就只支持  &lt;code>ReadWriteOnce&lt;/code>  方式的挂载，不能同时挂载到多个节点上，但是  &lt;code>CephFS&lt;/code>  就同时支持这三种访问模式。&lt;/p>
&lt;h4 id="回收策略">回收策略&lt;/h4>
&lt;p>当某个服务使用完某一个卷之后，它们会从 apiserver 中删除 PVC 对象，这时 Kubernetes 就需要对卷进行回收（Reclaim），持久卷也同样包含三种不同的回收策略，这三种回收策略会指导 Kubernetes 选择不同的方式对使用过的卷进行处理。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-pv-reclaiming-strategy.png" alt="kubernetes-pv-reclaiming-strategy">&lt;/p>
&lt;p>第一种回收策略就是保留（Retain）PV 中的数据，如果希望 PV 能够被重新使用，系统管理员需要删除被使用的  &lt;code>PersistentVolume&lt;/code>  对象并手动清除存储和相关存储上的数据。&lt;/p>
&lt;p>另一种常见的回收策略就是删除（Delete），当 PVC 被使用者删除之后，如果当前卷支持删除的回收策略，那么 PV 和相关的存储会被自动删除，如果当前 PV 上的数据确实不再需要，那么将回收策略设置成 Delete 能够节省手动处理的时间并快速释放无用的资源。&lt;/p>
&lt;h4 id="存储供应">存储供应&lt;/h4>
&lt;p>Kubernetes 集群中包含了很多的 PV 资源，而 PV 资源有两种供应的方式，一种是静态的，另一种是动态的，静态存储供应要求集群的管理员预先创建一定数量的 PV，然后使用者通过 PVC 的方式对 PV 资源的使用进行声明和申请；但是当系统管理员创建的 PV 对象不能满足使用者的需求时，就会进入动态存储供应的逻辑，供应的方式是基于集群中的  &lt;code>StorageClass&lt;/code>  对象，当然这种动态供应的方式也可以通过配置进行关闭。&lt;/p>
&lt;h2 id="管理">管理&lt;/h2>
&lt;p>Volume 的创建和管理在 Kubernetes 中主要由卷管理器  &lt;code>VolumeManager&lt;/code>  和  &lt;code>AttachDetachController&lt;/code>  和  &lt;code>PVController&lt;/code>  三个组件负责。其中卷管理器会负责卷的创建和管理的大部分工作，而  &lt;code>AttachDetachController&lt;/code>  主要负责对集群中的卷进行 Attach 和 Detach，&lt;code>PVController&lt;/code>  负责处理持久卷的变更，&lt;/p>
&lt;p>文章接下来的内容会详细介绍这几部分之间的关系、工作原理以及它们是如何协作的。&lt;/p>
&lt;h3 id="kubelet">kubelet&lt;/h3>
&lt;p>作者在  &lt;a href="https://draveness.me/kubernetes-pod">详解 Kubernetes Pod 的实现原理&lt;/a>  一文中曾简单介绍过 kubelet 和 Pod 的关系，&lt;/p>
&lt;p>前者会负责后者的创建和管理，kubelet 中与 Pod 相关的信息都是从 apiserver 中获取的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
apiserver-.-&amp;gt;u
u((updates))-.-&amp;gt;kubelet
kubelet-.-&amp;gt;podWorkers
podWorkers-.-&amp;gt;worker1
podWorkers-.-&amp;gt;worker2
style u fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>两者的通信会使用一个  &lt;code>kubetypes.PodUpdate&lt;/code>  类型的 Channel，kubelet 从 apiserver 中获取 Pod 时也会通过字段过滤器  &lt;code>fields.OneTermEqualSelector(api.PodHostField, string(nodeName))&lt;/code>  仅选择被调度到 kubelet 所在节点上的 Pod：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewSourceApiserver&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span> &lt;span class="nx">clientset&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Interface&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">nodeName&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NodeName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">updates&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">lw&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewListWatchFromClient&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CoreV1&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">RESTClient&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="s">&amp;#34;pods&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NamespaceAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fields&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">OneTermEqualSelector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">api&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodHostField&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nodeName&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="nf">newSourceApiserverFromLW&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">lw&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">updates&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所有对 Pod 的变更最终都会通知给具体的 PodWorker，这些 Worker 协程会调用 kubelet &lt;code>syncPod&lt;/code>  函数完成对 Pod 的同步：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant PW as PodWorker
participant K as Kubelet
participant VL as VolumeManager
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
PW-&amp;gt;&amp;gt;+K: syncPod
K-&amp;gt;&amp;gt;+VL: WaitForAttachAndMount
VL-xDSOWP: ReprocessPod
loop verifyVolumesMounted
VL-&amp;gt;&amp;gt;+ASOW: getUnmountedVolumes
ASOW--&amp;gt;&amp;gt;-VL: Volumes
end
VL--&amp;gt;&amp;gt;-K: Attached/Timeout
K--&amp;gt;&amp;gt;-PW: return
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在一个 100 多行的  &lt;code>syncPod&lt;/code>  方法中，kubelet 会调用  &lt;code>WaitForAttachAndMount&lt;/code>  方法，等待某一个 Pod 中的全部卷已经被成功地挂载：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">kl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Kubelet&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">o&lt;/span> &lt;span class="nx">syncPodOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">o&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">podIsTerminated&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumeManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WaitForAttachAndMount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法会将当前的 Pod 加入需要重新处理卷挂载的队列并在循环中持续调用  &lt;code>verifyVolumesMounted&lt;/code>  方法来比较期望挂载的卷和实际挂载卷的区别，这个循环会等待两者变得完全相同或者超时后才会返回，当前方法的返回一般也意味着 Pod 中的全部卷已经挂载成功了。&lt;/p>
&lt;h3 id="卷管理器">卷管理器&lt;/h3>
&lt;p>当前节点卷的管理就都是由  &lt;code>VolumeManager&lt;/code>  来负责了，在 Kubernetes 集群中的每一个节点（Node）上的 kubelet 启动时都会运行一个  &lt;code>VolumeManager&lt;/code> Goroutine，它会负责在当前节点上的 Pod 和 Volume 发生变动时对 Volume 进行挂载和卸载等操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph TD
subgraph Node
VolumeManager-.-&amp;gt;Kubelet
DesiredStateOfWorldPopulator-.-&amp;gt;VolumeManager
Reconciler-.-&amp;gt;VolumeManager
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个组件会在运行时启动两个 Goroutine 来管理节点中的卷，其中一个是  &lt;code>DesiredStateOfWorldPopulator&lt;/code>，另一个是  &lt;code>Reconciler&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
VM(VolumeManager)-. run .-&amp;gt;R(Reconciler)
VM-. run .-&amp;gt;DSWP(DesiredStateOfWorldPopulator)
DSWP-. update .-&amp;gt;DSW[DesiredStateOfWorld]
ASW[ActualStateOfWorld]-. get .-&amp;gt;DSWP
DSW-. get .-&amp;gt;R
R-. update .-&amp;gt;ASW
DSWP-. getpods .-&amp;gt;PodManager
style ASW fill:#fffede,stroke:#ebebb7
style DSW fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如上图所示，这里的  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  和  &lt;code>Reconciler&lt;/code>  两个 Goroutine 会通过图中两个的  &lt;code>XXXStateOfWorld&lt;/code>  状态进行通信，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  主要负责从 Kubernetes 节点中获取新的 Pod 对象并更新  &lt;code>DesiredStateOfWorld&lt;/code>  结构；而后者会根据实际状态和当前状态的区别对当前节点的状态进行迁移，也就是通过  &lt;code>DesiredStateOfWorld&lt;/code>  中状态的变更更新  &lt;code>ActualStateOfWorld&lt;/code>  中的内容。&lt;/p>
&lt;p>卷管理器中的两个 Goroutine，一个根据工程师的需求更新节点的期望状态  &lt;code>DesiredStateOfWorld&lt;/code>，另一个 Goroutine 保证节点向期望状态『迁移』，也就是说  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  是卷管理器中的生产者，而  &lt;code>Reconciler&lt;/code>  是消费者，接下来我们会分别介绍这两个 Goroutine 的工作和实现。&lt;/p>
&lt;h4 id="desiredstateofworldpopulator">DesiredStateOfWorldPopulator&lt;/h4>
&lt;p>作为卷管理器中的消费者，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  会根据工程师的请求不断修改当前节点的期望状态，我们可以通过以下的时序图来了解它到底做了哪些工作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant PM as PodManager
participant VPM as VolumePluginManager
loop populatorLoop
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndAddNewPods
DSOWP-&amp;gt;&amp;gt;+ASOW: GetMountedVolumes
ASOW--&amp;gt;&amp;gt;-DSOWP: mountedVolume
DSOWP-&amp;gt;&amp;gt;+PM: GetPods
PM--&amp;gt;&amp;gt;-DSOWP: pods
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+DSOW: AddPodToVolume
DSOW-&amp;gt;&amp;gt;+VPM: FindPluginBySpec
VPM--&amp;gt;&amp;gt;-DSOW: volumePlugin
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeName
end
deactivate DSOWP
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndRemoveDeletedPods
DSOWP-&amp;gt;&amp;gt;+DSOW: GetVolumesToMount
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeToMount
loop Every Volume
DSOWP-&amp;gt;&amp;gt;+PM: GetPodByUID
PM--&amp;gt;&amp;gt;-DSOWP: pods
DSOWP-&amp;gt;&amp;gt;DSOW: DeletePodFromVolume
end
deactivate DSOWP
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整个  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  运行在一个大的循环  &lt;code>populatorLoop&lt;/code>  中，当前循环会通过两个方法  &lt;code>findAndAddNewPods&lt;/code>  和  &lt;code>findAndRemoveDeletedPods&lt;/code>  分别获取节点中被添加的新 Pod 或者已经被删除的老 Pod，获取到 Pod 之后会根据当前的状态修改期望状态：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dswp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">desiredStateOfWorldPopulator&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">findAndAddNewPods&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">mountedVolumesForPod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">volumetypes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UniquePodName&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">processedVolumesForFSResize&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewString&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetPods&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">isPodTerminated&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">continue&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">processPodVolumes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountedVolumesForPod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">processedVolumesForFSResize&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就像时序图和代码中所描述的，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  会从  &lt;code>PodManager&lt;/code>  中获取当前节点中的 Pod，随后调用  &lt;code>processPodVolumes&lt;/code>  方法为将所有的 Pod 对象加入  &lt;code>DesiredStateOfWorld&lt;/code>  结构中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dswp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">desiredStateOfWorldPopulator&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">processPodVolumes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountedVolumesForPod&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">volumetypes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UniquePodName&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">processedVolumesForFSResize&lt;/span> &lt;span class="nx">sets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">uniquePodName&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">util&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetUniquePodName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">podPreviouslyProcessed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">mountsMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">devicesMap&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">makeVolumeMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podVolume&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Volumes&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pvc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeGidValue&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">createVolumeSpec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountsMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">devicesMap&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">desiredStateOfWorld&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddPodToVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podVolume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeGidValue&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">markPodProcessed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">actualStateOfWorld&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MarkRemountRequired&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>findAndAddNewPods&lt;/code>  方法做的主要就是将节点中加入的新 Pod 添加到  &lt;code>DesiredStateOfWorld&lt;/code>  中，而另一个方法  &lt;code>findAndRemoveDeletedPods&lt;/code>  其实也做着类似的事情，它会将已经被删除的节点从  &lt;code>DesiredStateOfWorld&lt;/code>  中剔除，总而言之  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  就是将当前节点的期望状态同步到  &lt;code>DesiredStateOfWorld&lt;/code>  中，等待消费者的处理。&lt;/p>
&lt;h4 id="reconciler">Reconciler&lt;/h4>
&lt;p>&lt;code>VolumeManager&lt;/code>  持有的另一个 Goroutine &lt;code>Reconciler&lt;/code>  会负责对当前节点上的 Volume 进行管理，它在正常运行时会启动  &lt;code>reconcile&lt;/code>  循环，在这个方法中会分三次对当前状态和期望状态不匹配的卷进行卸载、挂载等操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant R as Reconciler
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant OE as OperationExecutor
loop reconcile
R-&amp;gt;&amp;gt;+ASOW: GetMountedVolumes
activate R
ASOW--&amp;gt;&amp;gt;-R: MountedVolumes
R-&amp;gt;&amp;gt;DSOW: PodExistsInVolume
R-&amp;gt;&amp;gt;OE: UnmountVolume
deactivate R
R-&amp;gt;&amp;gt;+DSOW: GetVolumesToMount
activate R
DSOW--&amp;gt;&amp;gt;-R: volumeToMount
R-&amp;gt;&amp;gt;ASOW: PodExistsInVolume
R-&amp;gt;&amp;gt;OE: AttachVolume/MountVolume
deactivate R
R-&amp;gt;&amp;gt;+ASOW: GetUnmountedVolumes
activate R
R-&amp;gt;&amp;gt;DSOW: VolumeExists
R-&amp;gt;&amp;gt;OE: UnmountDevice/DetachVolume
deactivate R
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在当前的循环中首先会保证应该被卸载但是仍然在节点中存在的卷被卸载，然后将应该挂载的卷挂载到合适的位置，最后将设备与节点分离或者卸载，所有挂载和卸载的操作都是通过  &lt;code>OperationExecutor&lt;/code>  完成的，这个结构体负责调用相应的插件执行操作，我们会在文章的后面展开进行介绍。&lt;/p>
&lt;h3 id="附着分离控制器">附着分离控制器&lt;/h3>
&lt;p>除了  &lt;code>VolumeManager&lt;/code>  之外，另一个负责管理 Kubernetes 卷的组件就是  &lt;code>AttachDetachController&lt;/code>  了，引入这个组件的目的主要是：&lt;/p>
&lt;ol>
&lt;li>让卷的挂载和卸载能够与节点的可用性脱离；
&lt;ul>
&lt;li>一旦节点或者 kubelet 宕机，附着（Attach）在当前节点上的卷应该能够被分离（Detach），分离之后的卷就能够再次附着到其他节点上；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>保证云服务商秘钥的安全；
&lt;ul>
&lt;li>如果每一个 kubelet 都需要触发卷的附着和分离逻辑，那么每一个节点都应该有操作卷的权限，但是这些权限应该只由主节点掌握，这样能够降低秘钥泄露的风险；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>提高卷附着和分离部分代码的稳定性；&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>这些内容都是在 Kubernetes 官方项目的 GitHub issue &lt;a href="https://github.com/kubernetes/kubernetes/issues/20262">Detailed Design for Volume Attach/Detach Controller #20262&lt;/a>  中讨论的，想要了解  &lt;code>AttachDetachController&lt;/code>  出现的原因可以阅读相关的内容。&lt;/p>
&lt;/blockquote>
&lt;p>每一个  &lt;code>AttachDetachController&lt;/code>  其实也包含  &lt;code>Reconciler&lt;/code>  和  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  两个组件，这两个组件虽然与  &lt;code>VolumeManager&lt;/code>  中的两个组件重名，实现的功能也非常类似，与  &lt;code>VolumeManager&lt;/code>  具有几乎相同的数据流向，但是这两个 Goroutine 是跑在 Kubernetes 主节点中的，所以实现上可能一些差异：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
ADC(AttachDetachController)-. run .-&amp;gt;R(Reconciler)
ADC-. run .-&amp;gt;DSWP(DesiredStateOfWorldPopulator)
DSWP-. update .-&amp;gt;DSW[DesiredStateOfWorld]
ASW[ActualStateOfWorld]-. get .-&amp;gt;DSWP
DSW-. get .-&amp;gt;R
R-. update .-&amp;gt;ASW
DSWP-. getpods .-&amp;gt;PodManager
style ASW fill:#fffede,stroke:#ebebb7
style DSW fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，无论是  &lt;code>Reconciler&lt;/code>  还是  &lt;code>DesiredStateOfWorldPopulator&lt;/code>，它们同步的就不再只是某个节点上 Pod 的信息了，它们需要对整个集群中的 Pod 对象负责，相关数据也不再是通过 apiserver 拉取了，而是使用  &lt;code>podInformer&lt;/code>  在 Pod 对象发生变更时调用相应的方法。&lt;/p>
&lt;h4 id="desiredstateofworldpopulator-1">DesiredStateOfWorldPopulator&lt;/h4>
&lt;p>作为  &lt;code>AttachDetachController&lt;/code>  启动的 Goroutine，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  的主要作用是从当前集群的状态中获取 Pod 对象并修改  &lt;code>DesiredStateOfWorld&lt;/code>  结构，与  &lt;code>VolumeManager&lt;/code>  中的同名 Goroutine 起到相同的作用，作为整个链路的生产者，它们只是在实现上由于处理 Pod 范围的不同有一些区别：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant PL as PodLister
participant VPM as VolumePluginManager
loop populatorLoopFunc
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndRemoveDeletedPods
DSOWP-&amp;gt;&amp;gt;+DSOW: GetPodToAdd
DSOW--&amp;gt;&amp;gt;-DSOWP: podsToAdd
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+PL: GetPod
alt PodNotFound
PL--&amp;gt;&amp;gt;-DSOWP: return
DSOWP-&amp;gt;&amp;gt;DSOW: DeletePod
else
end
end
deactivate DSOWP
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndAddActivePods
DSOWP-&amp;gt;&amp;gt;+PL: List
PL--&amp;gt;&amp;gt;-DSOWP: pods
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+VPM: FindAttachablePluginBySpec
VPM--&amp;gt;&amp;gt;-DSOW: attachableVolumePlugin
DSOWP-&amp;gt;&amp;gt;+DSOW: AddPod/DeletePod
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeName
end
deactivate DSOWP
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>AttachDetachController&lt;/code>  中的  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  协程就主要会先处理 Pod 的删除逻辑，添加 Pod 的逻辑都是根据  &lt;code>listPodsRetryDuration&lt;/code>  的设置周期性被触发的，所以从这里我们就能看到  &lt;code>AttachDetachController&lt;/code>  其实主要还是处理被删除 Pod 中 Volume 的分离工作，当节点或者 kubelet 宕机时能够将节点中的卷进行分离，保证 Pod 在其他节点重启时不会出现问题。&lt;/p>
&lt;h4 id="reconciler-1">Reconciler&lt;/h4>
&lt;p>另一个用于调节当前状态与期望状态的 Goroutine 在执行它内部的循环时，也会优先处理分离卷的逻辑，后处理附着卷的工作，整个时序图与  &lt;code>VolumeManager&lt;/code>  中的  &lt;code>Reconciler&lt;/code>  非常相似：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant R as Reconciler
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant OE as OperationExecutor
loop reconcile
R-&amp;gt;&amp;gt;+ASOW: GetAttachedVolumes
activate R
ASOW--&amp;gt;&amp;gt;-R: attachedVolumes
R-&amp;gt;&amp;gt;+DSOW: VolumeExists
alt VolumeNotExists
DSOW--&amp;gt;&amp;gt;-R: return
R-&amp;gt;&amp;gt;OE: DetachVolume
deactivate R
else
end
R-&amp;gt;&amp;gt;+DSOW: GetVolumesToAttach
activate R
DSOW--&amp;gt;&amp;gt;-R: volumeToAttach
R-&amp;gt;&amp;gt;+ASOW: VolumeNodeExists
alt VolumeNotExists
ASOW--&amp;gt;&amp;gt;-R: return
R-&amp;gt;&amp;gt;OE: AttachVolume
else
end
deactivate R
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里处理的工作其实相对更少一些，&lt;code>Reconciler&lt;/code>  会将期望状态中的卷与实际状态进行比较，然后分离需要分离的卷、附着需要附着的卷，逻辑非常的清晰和简单。&lt;/p>
&lt;h3 id="持久卷控制器">持久卷控制器&lt;/h3>
&lt;p>作为集群中与 PV 和 PVC 打交道的控制器，持久卷控制器同时运行着三个 Goroutine 用于处理相应的逻辑，其中  &lt;code>Resync&lt;/code>  协程负责从 Kubernetes 集群中同步 PV 和 PVC 的信息，而另外两个工作协程主要负消费队列中的任务：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
PVC(PVController)-.-&amp;gt;R(Resync)
PVC-.-&amp;gt;VW(VolumeWorker)
R-. enqueue .-&amp;gt;VQ(VolumeQueue)
R-. enqueue .-&amp;gt;CQ(ClaimQueue)
VQ-. dequeue .-&amp;gt;VW
CQ-. dequeue .-&amp;gt;CW
PVC-.-&amp;gt;CW(ClaimWorker)
style VQ fill:#fffede,stroke:#ebebb7
style CQ fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这两个工作协程主要负责对需要绑定或者解绑的 PV 和 PVC 进行处理，例如，当用户创建了新的 PVC 对象时，从集群中查找该 PVC 选择的 PV 并绑定到当前的 PVC 上。&lt;/p>
&lt;h4 id="volumeworker">VolumeWorker&lt;/h4>
&lt;p>&lt;code>VolumeWorker&lt;/code>  协程中执行的最重要的方法其实就是  &lt;code>syncVolume&lt;/code>，在这个方法中会根据当前 PV 对象的规格对 PV 和 PVC 进行绑定或者解绑：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>
&lt;span class="nx">claimName&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">claimrefToClaimKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">claims&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claimName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">claim&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">claim&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">reclaimVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">claimQueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">claimToClaimKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HasAnnotation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">annDynamicallyProvisioned&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeReclaimPolicy&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeReclaimDelete&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">reclaimVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">unbindVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果当前 PV 没有绑定的 PVC 对象，那么这里的  &lt;code>reclaimVolume&lt;/code>  可能会将当前的 PV 对象根据回收策略将其放回资源池等待重用、回收或者保留；而  &lt;code>unbindVolume&lt;/code>  会删除 PV 与 PVC 之间的关系并更新 apiserver 中保存的 Kubernetes 对象数据。&lt;/p>
&lt;h4 id="claimworker">ClaimWorker&lt;/h4>
&lt;p>&lt;code>ClaimWorker&lt;/code>  就是控制器用来决定如何处理一个 PVC 对象的方法了，它会在一个 PVC 对象被创建、更新或者同步时被触发，&lt;code>syncClaim&lt;/code>  会根据当前对象中的注解决定调用  &lt;code>syncUnboundClaim&lt;/code>  或者  &lt;code>syncBoundClaim&lt;/code>  方法来处理相应的逻辑：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HasAnnotation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">annBindCompleted&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">syncUnboundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">syncBoundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>syncUnboundClaim&lt;/code>  会处理绑定没有结束的 PVC 对象，如果当前 PVC 对象没有对应合适的 PV 存在，那么就会调用  &lt;code>provisionClaim&lt;/code>  尝试从集群中获取新的 PV 供应，如果能够找到 PV 对象，就会通过  &lt;code>bind&lt;/code>  方法将两者绑定：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncUnboundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">shouldDelayBinding&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">findBestMatchForClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">v1helper&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetPersistentVolumeClaimClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">provisionClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">found&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">store&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">found&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nf">isVolumeBoundToClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>绑定的过程其实就是将 PV 和 PVC 之间建立起新的关系，更新 Spec 中的数据让两者能够通过引用 Ref 找到另一个对象并将更新后的 Kubernetes 对象存储到 apiserver 中。&lt;/p>
&lt;p>另一个用于绑定 PV 和 PVC 对象的方法就是  &lt;code>syncBoundClaim&lt;/code>  了，相比于  &lt;code>syncUnboundClaim&lt;/code>  方法，该方法的实现更为简单，直接从缓存中尝试获取对应的 PV 对象：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncBoundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">found&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">store&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">found&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果找到了 PV 对象并且该对象没有绑定的 PVC 或者当前 PV 和 PVC 已经存在了引用就会调用  &lt;code>bind&lt;/code>  方法对两者进行绑定。&lt;/p>
&lt;h4 id="小结">小结&lt;/h4>
&lt;p>无论是  &lt;code>VolumeWorker&lt;/code>  还是  &lt;code>ClaimWorker&lt;/code>  最终都可能会通过 apiserver 更新集群中 etcd 的数据，当然它们也会调用一些底层的插件获取新的存储供应、删除或者重用一些持久卷，我们会在下面介绍插件的工作原理。&lt;/p>
&lt;h2 id="插件">插件&lt;/h2>
&lt;p>Kubernetes 中的所有对卷的操作最终基本都是通过  &lt;code>OperationExecutor&lt;/code>  来完成的，这个组件包含了用于附着、挂载、卸载和分离几个常见的操作以及对设备进行操作的一些方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">OperationExecutor&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">AttachVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToAttach&lt;/span> &lt;span class="nx">VolumeToAttach&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldAttacherUpdater&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">DetachVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToDetach&lt;/span> &lt;span class="nx">AttachedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">verifySafeToDetach&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldAttacherUpdater&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">MountVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">waitForAttachTimeout&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeToMount&lt;/span> &lt;span class="nx">VolumeToMount&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldMounterUpdater&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">isRemount&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">UnmountVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToUnmount&lt;/span> &lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldMounterUpdater&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podsDir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实现  &lt;code>OperationExecutor&lt;/code>  接口的私有结构体会通过  &lt;code>OperatorGenerator&lt;/code>  来生成一个用于挂载和卸载卷的方法，并将这个方法包装在一个  &lt;code>GeneratedOperations&lt;/code>  结构中，在这之后操作执行器会启动一个新的 Goroutine 用于执行生成好的方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
OE(OperationExexutor)-. 1. 获取相关方法 .-&amp;gt;OG(OperationGenerator)
OG-. 2. 根据 Spec 获取插件 .-&amp;gt;VM(VolumePluginManager)
VM-. 3. 返回 VolumePlugin .-&amp;gt;OG
OG-. 4. 构建方法 .-&amp;gt;OG
OG-. 5. 生成一个 Operation 结构 .-&amp;gt;OE
OE-. 6. 运行 Operation .-&amp;gt;NPO(NestedPendingOperations)
NPO-. 7. 启动 Goroutine 运行生成的方法 .-&amp;gt;Goroutine
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>VolumePluginManager&lt;/code>  和  &lt;code>VolumePlugin&lt;/code>  这两个组件在整个流程中帮我们屏蔽了底层不同类型卷的实现差异，我们能直接在上层调用完全相同的接口，剩下的逻辑都由底层的插件来负责。&lt;/p>
&lt;p>Kubernetes 提供了插件的概念，通过  &lt;code>Volume&lt;/code>  和  &lt;code>Mounter&lt;/code>  两个接口支持卷类型的扩展，作为存储提供商或者不同类型的文件系统，我们都可以通过实现以上的两个接口成为 Kubernetes 存储系统中一个新的存储类型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">VolumePlugin&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">Init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">host&lt;/span> &lt;span class="nx">VolumeHost&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">GetPluginName&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nf">GetVolumeName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">NewMounter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podRef&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">opts&lt;/span> &lt;span class="nx">VolumeOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">Mounter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Mounter&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Volume&lt;/span>
&lt;span class="nf">CanMount&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">SetUp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">GetAttributes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">Attributes&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这一节中我们将介绍几种不同卷插件的实现，包括最常见的 EmptyDir、ConfigMap、Secret 和 Google 云上的 GCEPersistentDisk，这一节会简单介绍不同卷插件的实现方式，想要了解详细实现的读者可以阅读相关的源代码。&lt;/p>
&lt;h3 id="emptydir">EmptyDir&lt;/h3>
&lt;p>EmptyDir 是 Kubernetes 中最简单的卷了，当我们为一个 Pod 设置一个 EmptyDir 类型的卷时，其实就是在当前 Pod 对应的目录创建了一个空的文件夹，这个文件夹会随着 Pod 的删除而删除。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">emptyDir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">setupDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetVolumeOwnership&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volumeutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetReady&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getMetaDir&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">emptyDir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">setupDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MkdirAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">perm&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>SetUpAt&lt;/code>  方法其实就实现了对这种类型卷的创建工作，每当 Pod 被分配到了某个节点上，对应的文件目录就会通过  &lt;code>MkdirAl&lt;/code>  方法创建，如果使用者配置了 medium 字段，也会选择使用相应的文件系统挂载到当前目录上，例如：tmpfs、nodev 等。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.gcr.io/test-webserver&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/cache&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们经常会使用 EmptyDir 类型的卷在多个容器之间共享文件、充当缓存或者保留一些临时的日志，总而言之，这是一种经常被使用的卷类型。&lt;/p>
&lt;h3 id="configmap-和-secret">ConfigMap 和 Secret&lt;/h3>
&lt;p>另一种比较常见的卷就是 ConfigMap 了，首先，ConfigMap 本身就是 Kubernetes 中常见的对象了，其中的  &lt;code>data&lt;/code>  就是一个存储了从文件名到文件内容的字段，这里的 ConfigMap 对象被挂载到文件目录时就会创建一个名为  &lt;code>redis-config&lt;/code>  的文件，然后将文件内容写入该文件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ConfigMap&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">redis-config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maxmemory 2mb maxmemory-policy allkeys-lru&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在对 ConfigMap 类型的卷进行挂载时，总共需要完成三部分工作，首先从 apiserver 中获取当前 ConfigMap 对象，然后根据当前的 ConfigMap 生成一个从文件名到文件内容的键值对，最后构造一个 Writer 并执行  &lt;code>Write&lt;/code>  方法写入内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">configMapVolumeMounter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">configMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getConfigMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">totalBytes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">totalBytes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">configMap&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">payload&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">MakePayload&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">configMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultMode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writerContext&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;pod %v/%v volume %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">volumeutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewAtomicWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">writerContext&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">payload&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在涉及挂载的函数几个中，作者想要着重介绍的也就是在底层直接与文件系统打交道的  &lt;code>writePayloadToDir&lt;/code>  方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">AtomicWriter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">writePayloadToDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">payload&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">FileProjection&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">userVisiblePath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fileProjection&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">payload&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">content&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">fileProjection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Data&lt;/span>
&lt;span class="nx">mode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">FileMode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fileProjection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">fullPath&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">path&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">userVisiblePath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">baseDir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MkdirAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">baseDir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ModePerm&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">content&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Chmod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法使用了  &lt;code>os&lt;/code>  包提供的接口完成了拼接文件名、创建相应文件目录、写入文件并且修改文件模式的工作，将 ConfigMap &lt;code>data&lt;/code>  中的数据映射到了一个文件夹中，达到了让 Pod 中的容器可以直接通过文件系统获取内容的目的。&lt;/p>
&lt;p>对于另一个非常常见的卷类型 Secret，Kubernetes 其实也做了几乎完全相同的工作，也是先获取 Secret 对象，然后构建最终写入到文件的键值对，最后初始化一个 Writer 并调用它的  &lt;code>Write&lt;/code>  方法，从这里我们也能看出在卷插件这一层对于 ConfigMap 和 Secret 的处理几乎完全相同，并没有出现需要对 Secret 对象中的内容进行解密的工作。&lt;/p>
&lt;h3 id="gcepersistentdisk">GCEPersistentDisk&lt;/h3>
&lt;p>最后一个要介绍的卷与上面的几种都非常的不同，它在底层使用的是云服务商提供的网络磁盘，想要在一个节点上使用云磁盘其实总共需要两个步骤，首先是要将云磁盘附着到当前的节点上，这部分的工作其实就是由  &lt;code>gcePersistentDiskAttacher&lt;/code>  完成的，每当调用  &lt;code>AttachDisk&lt;/code>  方法时，最终都会执行云服务商提供的接口，将磁盘附着到相应的节点实例上：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant GPDA as gcePersistentDiskAttacher
participant C as Cloud
participant GCESM as gceServiceManager
participant I as GCEInstances
GPDA-&amp;gt;&amp;gt;+C: DiskIsAttached
alt NotAttached
C--&amp;gt;&amp;gt;-GPDA: return NotAttached
GPDA-&amp;gt;&amp;gt;+C: AttachDisk
C-&amp;gt;&amp;gt;+GCESM: AttachDiskOnCloudProvider
GCESM-&amp;gt;&amp;gt;+I: AttachDisk
I--&amp;gt;&amp;gt;-GCESM: return
GCESM--&amp;gt;&amp;gt;-C: return
C--&amp;gt;&amp;gt;-GPDA: return
else
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在方法的的最后会将该请求包装成一个 HTTP 的方法调用向  &lt;code>https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{resourceId}/attachDisk&lt;/code>  链接发出一个 POST 请求，这个请求会将某个 GCE 上的磁盘附着到目标实例上，详细的内容可以阅读  &lt;a href="https://cloud.google.com/compute/docs/reference/rest/v1/instances/attachDisk">相关文档&lt;/a>。&lt;/p>
&lt;p>一旦当前的磁盘被附着到了当前节点上，我们就能跟使用其他的插件一样，把磁盘挂载到某个目录上，完成从附着到挂载的全部操作。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Volume 和存储系统是 Kubernetes 非常重要的一部分，它能够帮助我们在多个容器之间共享文件，同时也能够为集群提供持久存储的功能，假如 Kubernetes 没有用于持久存储的对象，我们也很难在集群中运行有状态的服务，例如：消息队列、分布式存储等。&lt;/p>
&lt;p>对于刚刚使用 Kubernetes 的开发者来说，Volume、PV 和 PVC 确实是比较难以理解的概念，但是这却是深入使用 Kubernetes 必须要了解和掌握的，希望这篇文章能够帮助各位读者更好地理解存储系统底层的实现原理。&lt;/p>
&lt;h2 id="相关文章">相关文章&lt;/h2>
&lt;p>{% include related/distributed-system.md %}&lt;/p>
&lt;h2 id="referenece">Referenece&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/volumes/">Volumes · Kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/issues/20262">Detailed Design for Volume Attach/Detach Controller #20262&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/issues/21931">Detailed Design for Volume Mount/Unmount Redesign #21931&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/issues/18333">Kubernetes Volume System Redesign Proposal #18333&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface (CSI)&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>