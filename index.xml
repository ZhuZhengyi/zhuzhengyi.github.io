<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 22 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>堆排序</title><link>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="堆排序">堆排序&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>堆排序是借助于堆这个数据结构来实现排序的一种算法。&lt;/p>
&lt;h3 id="堆heap的性质">堆(heap)的性质&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>堆&lt;/strong>是一个&lt;strong>完全二叉树&lt;/strong>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的每个非叶子结点值均大于(大顶堆)/小于(小顶堆)其左右子节点值；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的&lt;strong>根节点&lt;/strong>为所有节点中的最大值(大顶堆)/最小值(小顶堆)；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/05/22-20-35-03-2021-05-22-20-34-57-image.png" alt="">&lt;/p>
&lt;h2 id="堆排序-1">堆排序&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>堆排序利用堆节点的性质 2，每次从堆中排出堆顶元素，从而最终得到有序的序列；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于堆是一个完全二叉树，所以可以用数组来组织；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于完全二叉树性质，数组中根节点索引($i_o$)和其左右子节点($i_l,i_r$)满足如下关系：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>$$
i_l = 2 * i_o + 1 \&lt;br>
i_r = 2 * i_o + 2
$$&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp" alt="">&lt;/p>
&lt;h2 id="复杂性分析">复杂性分析&lt;/h2>
&lt;h3 id="时间复杂度">时间复杂度&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Avg: $O(nlogn)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Max: $O(n^2)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Min: $O(n)$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="空间复杂度">空间复杂度&lt;/h3>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">heap_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">True&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span class="s1"> 堆调整, 将nums数组从start开始,长度为length的数组调整为堆
&lt;/span>&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span>
&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">#初始化堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1"># 循环取出堆顶元素, 放到数组尾部, 并调整堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>排序算法总结</title><link>https://justice.bj.cn/post/13.algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/13.algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="排序算法总结">排序算法总结&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>排序是最基础算法之一。&lt;/p>
&lt;h3 id="分类">分类&lt;/h3>
&lt;p>十种常见排序算法可以分为两大类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>比较类排序&lt;/strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(nlogn)$，因此也称为非线性时间比较类排序。&lt;/li>
&lt;li>&lt;strong>非比较类排序&lt;/strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-32-59-849589-20190306165258970-1789860540.png" alt="">&lt;/p>
&lt;h3 id="复杂度">复杂度&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>排序方法&lt;/th>
&lt;th>时间复杂度(Avg)&lt;/th>
&lt;th>时间复杂度(Max)&lt;/th>
&lt;th>时间复杂度(Min)&lt;/th>
&lt;th>空间复杂度&lt;/th>
&lt;th>稳定性&lt;/th>
&lt;th>分类&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>冒泡排序&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n)$&lt;/td>
&lt;td>$O(1)$&lt;/td>
&lt;td>稳定&lt;/td>
&lt;td>比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>插入排序&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n)$&lt;/td>
&lt;td>$O(1)$&lt;/td>
&lt;td>稳定&lt;/td>
&lt;td>比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>选择排序&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(1)$&lt;/td>
&lt;td>不稳定&lt;/td>
&lt;td>比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>希尔排序&lt;/td>
&lt;td>$O(n^{1.3})$&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n)$&lt;/td>
&lt;td>$O(1)$&lt;/td>
&lt;td>不稳定&lt;/td>
&lt;td>比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>归并排序&lt;/td>
&lt;td>$O(nlog{{_2}{n}})$&lt;/td>
&lt;td>$O(nlog{{_2}{n}})$&lt;/td>
&lt;td>$O(nlog{{_2}{n}})$&lt;/td>
&lt;td>$O(n)$&lt;/td>
&lt;td>稳定&lt;/td>
&lt;td>比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>堆排序&lt;/td>
&lt;td>$O(n{log_2}n)$&lt;/td>
&lt;td>$O(nlog{{_2}{n}})$&lt;/td>
&lt;td>$O(nlog{{_2}{n}})$&lt;/td>
&lt;td>$O(1)$&lt;/td>
&lt;td>不稳定&lt;/td>
&lt;td>比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>快速排序&lt;/td>
&lt;td>$O(n{log_2}n)$&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(nlog_2n)$&lt;/td>
&lt;td>$O(nlog_2n)$&lt;/td>
&lt;td>不稳定&lt;/td>
&lt;td>比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>基数排序&lt;/td>
&lt;td>$O(n*k)$&lt;/td>
&lt;td>$O(n*k)$&lt;/td>
&lt;td>$O(n*k)$&lt;/td>
&lt;td>$O(n+k)$&lt;/td>
&lt;td>稳定&lt;/td>
&lt;td>非比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>计数排序&lt;/td>
&lt;td>$O(n+k)$&lt;/td>
&lt;td>$O(n+k)$&lt;/td>
&lt;td>$O(n+k)$&lt;/td>
&lt;td>$O(n+k)$&lt;/td>
&lt;td>稳定&lt;/td>
&lt;td>非比较&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>桶排序&lt;/td>
&lt;td>$O(n+k)$&lt;/td>
&lt;td>$O(n^2)$&lt;/td>
&lt;td>$O(n)$&lt;/td>
&lt;td>$O(n+k)$&lt;/td>
&lt;td>稳定&lt;/td>
&lt;td>非比较&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="相关概念">相关概念&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>稳定性&lt;/strong>：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面，则为稳定排序，否则未不稳定。&lt;/li>
&lt;li>&lt;strong>时间复杂度&lt;/strong>：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。&lt;/li>
&lt;li>&lt;strong>空间复杂度&lt;/strong>： 是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。&lt;/li>
&lt;/ul>
&lt;h2 id="基础比较排序算法">基础比较排序算法&lt;/h2>
&lt;h3 id="冒泡排序bubble-sort">冒泡排序（Bubble Sort）&lt;/h3>
&lt;p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/p>
&lt;h4 id="算法描述">算法描述&lt;/h4>
&lt;ul>
&lt;li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；&lt;/li>
&lt;li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；&lt;/li>
&lt;li>针对所有的元素重复以上的步骤，除了最后一个；&lt;/li>
&lt;li>重复步骤 1~3，直到排序完成。&lt;/li>
&lt;/ul>
&lt;h4 id="动图演示">动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-33-20-849589-20171015223238449-2146169197.png" alt="">&lt;/p>
&lt;h4 id="实现">实现&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="双向冒泡排序">双向冒泡排序（）&lt;/h3>
&lt;p>双向冒泡排序（Bidirectional Bubble Sort），又叫鸡尾酒排序。这是冒泡排序的一种变体。不同之处在于，冒泡排序是从低到高比较序列里的每个元素，而鸡尾酒排序从两个方向（低到高、高到低）来回排序，效率更高。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-33-32-640" alt="">&lt;/p>
&lt;h3 id="选择排序selection-sort">选择排序（Selection Sort）&lt;/h3>
&lt;p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p>
&lt;h4 id="描述">描述&lt;/h4>
&lt;p>n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：&lt;/p>
&lt;ul>
&lt;li>初始状态：无序区为 R[1..n]，有序区为空；&lt;/li>
&lt;li>第 i 趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为 R[1..i-1]和 R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i]和 R[i+1..n)分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；&lt;/li>
&lt;li>n-1 趟结束，数组有序化了。&lt;/li>
&lt;/ul>
&lt;h4 id="动图演示-1">动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-34-51-849589-20171015224719590-1433219824.png" alt="">&lt;/p>
&lt;h4 id="实现-1">实现&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="算法分析">算法分析&lt;/h4>
&lt;p>表现最稳定的排序算法之一，因为无论什么数据进去都是$O(^2)$的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。&lt;/p>
&lt;h3 id="插入排序insertion-sort">插入排序（Insertion Sort）&lt;/h3>
&lt;p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。&lt;/p>
&lt;h4 id="算法描述-1">算法描述&lt;/h4>
&lt;p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：&lt;/p>
&lt;ul>
&lt;li>从第一个元素开始，该元素可以认为已经被排序；&lt;/li>
&lt;li>取出下一个元素，在已经排序的元素序列中从后向前扫描；&lt;/li>
&lt;li>如果该元素（已排序）大于新元素，将该元素移到下一位置；&lt;/li>
&lt;li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；&lt;/li>
&lt;li>将新元素插入到该位置后；&lt;/li>
&lt;li>重复步骤 2~5。&lt;/li>
&lt;/ul>
&lt;h4 id="动图演示-2">动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-34-32-849589-20171015225645277-1151100000.png" alt="">&lt;/p>
&lt;h4 id="代码实现">代码实现&lt;/h4>
&lt;h4 id="算法分析-1">算法分析&lt;/h4>
&lt;p>插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;/p>
&lt;h2 id="高级比较排序算法">高级比较排序算法&lt;/h2>
&lt;h3 id="希尔排序shell-sort">希尔排序（Shell Sort）&lt;/h3>
&lt;p>1959 年 Shell 发明，第一个突破$O(n^2)$的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫&lt;strong>缩小增量排序&lt;/strong>。&lt;/p>
&lt;h4 id="算法描述-2">算法描述&lt;/h4>
&lt;p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：&lt;/p>
&lt;ul>
&lt;li>选择一个增量序列 t1，t2，…，tk，其中 ti&amp;gt;tj，tk=1；&lt;/li>
&lt;li>按增量序列个数 k，对序列进行 k 趟排序；&lt;/li>
&lt;li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。&lt;/li>
&lt;/ul>
&lt;h4 id="动图演示-3">动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-34-40-849589-20180331170017421-364506073.png" alt="">&lt;/p>
&lt;h4 id="代码实现-1">代码实现&lt;/h4>
&lt;h4 id="算法分析-2">算法分析&lt;/h4>
&lt;p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第 4 版）》的合著者 Robert Sedgewick 提出的。&lt;/p>
&lt;h3 id="归并排序merge-sort">归并排序（Merge Sort）&lt;/h3>
&lt;p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。&lt;/p>
&lt;h4 id="算法描述-3">算法描述&lt;/h4>
&lt;ul>
&lt;li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；&lt;/li>
&lt;li>对这两个子序列分别采用归并排序；&lt;/li>
&lt;li>将两个排序好的子序列合并成一个最终的排序序列。&lt;/li>
&lt;/ul>
&lt;h4 id="动图演示-4">动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-34-22-849589-20171015230557043-37375010.png" alt="">&lt;/p>
&lt;h4 id="代码实现-2">代码实现&lt;/h4>
&lt;h4 id="算法分析-3">算法分析&lt;/h4>
&lt;p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn）的时间复杂度。代价是需要额外的内存空间。&lt;/p>
&lt;h3 id="快速排序quick-sort">快速排序（Quick Sort）&lt;/h3>
&lt;p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。&lt;/p>
&lt;h4 id="算法描述-4">算法描述&lt;/h4>
&lt;p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：&lt;/p>
&lt;ul>
&lt;li>从数列中挑出一个元素，称为 “基准”（pivot）；&lt;/li>
&lt;li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；&lt;/li>
&lt;li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。&lt;/li>
&lt;/ul>
&lt;h4 id="62-动图演示">6.2 动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-33-40-849589-20171015230936371-1413523412.png" alt="">&lt;/p>
&lt;h4 id="代码实现-3">代码实现&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="堆排序heap-sort">堆排序（Heap Sort）&lt;/h3>
&lt;p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;/p>
&lt;h4 id="算法描述-5">算法描述&lt;/h4>
&lt;ul>
&lt;li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；&lt;/li>
&lt;li>将堆顶元素 R[1]与最后一个元素 R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足 R[1,2…n-1]&amp;lt;=R[n]；&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h4 id="72-动图演示">7.2 动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-34-14-849589-20171015231308699-356134237.png" alt="loading-ag-1822">&lt;/p>
&lt;h4 id="代码实现-4">代码实现&lt;/h4>
&lt;h2 id="非比较排序">非比较排序&lt;/h2>
&lt;h3 id="计数排序counting-sort">计数排序（Counting Sort）&lt;/h3>
&lt;p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。&lt;/p>
&lt;h4 id="算法描述-6">算法描述&lt;/h4>
&lt;ul>
&lt;li>找出待排序的数组中最大和最小的元素；&lt;/li>
&lt;li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；&lt;/li>
&lt;li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；&lt;/li>
&lt;li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i)项，每放一个元素就将 C(i)减去 1。&lt;/li>
&lt;/ul>
&lt;h4 id="动图演示-5">动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-33-57-849589-20171015231740840-6968181.png" alt="">&lt;/p>
&lt;h4 id="代码实现-5">代码实现&lt;/h4>
&lt;h4 id="算法分析-4">算法分析&lt;/h4>
&lt;p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。&lt;/p>
&lt;h3 id="桶排序bucket-sort">桶排序（Bucket Sort）&lt;/h3>
&lt;p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。&lt;/p>
&lt;h4 id="算法描述-7">算法描述&lt;/h4>
&lt;ul>
&lt;li>设置一个定量的数组当作空桶；&lt;/li>
&lt;li>遍历输入数据，并且把数据一个一个放到对应的桶里去；&lt;/li>
&lt;li>对每个不是空的桶进行排序；&lt;/li>
&lt;li>从不是空的桶里把排好序的数据拼接起来。&lt;/li>
&lt;/ul>
&lt;h4 id="图片演示">图片演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-33-48-849589-20171015232107090-1920702011.png" alt="">&lt;/p>
&lt;h4 id="代码实现-6">代码实现&lt;/h4>
&lt;h4 id="算法分析-5">算法分析&lt;/h4>
&lt;p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。&lt;/p>
&lt;h3 id="基数排序radix-sort">基数排序（Radix Sort）&lt;/h3>
&lt;p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。&lt;/p>
&lt;h4 id="算法描述-8">算法描述&lt;/h4>
&lt;ul>
&lt;li>取得数组中的最大数，并取得位数；&lt;/li>
&lt;li>arr 为原始数组，从最低位开始取每个位组成 radix 数组；&lt;/li>
&lt;li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；&lt;/li>
&lt;/ul>
&lt;h4 id="动图演示-6">动图演示&lt;/h4>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-32-46-849589-20171015232453668-1397662527.png" alt="">&lt;/p>
&lt;h4 id="代码实现-7">代码实现&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="算法分析-6">算法分析&lt;/h4>
&lt;p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n)的时间复杂度。假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n，因此基本上还是线性级别的。&lt;/p>
&lt;p>基数排序的空间复杂度为 O(n+k)，其中 k 为桶的数量。一般来说 n&amp;raquo;k，因此额外空间需要大概 n 个左右。&lt;/p></description></item><item><title>红黑树</title><link>https://justice.bj.cn/post/12.data_struct/tree/rb-tree/</link><pubDate>Fri, 10 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/rb-tree/</guid><description>&lt;h1 id="红黑树rb-tree">红黑树(RB-Tree)&lt;/h1>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>红黑树是一种二叉平衡树。&lt;/p>
&lt;h2 id="性质">性质&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个节点要么是黑色，要么是红色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Root 节点是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个叶子节点（NIL）是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个红色结点的两个子结点一定都是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="旋转">旋转&lt;/h2>
&lt;ul>
&lt;li>右旋&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-07-rbtree-right-rotate.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>左旋&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-29-rbtree-left-rotate.webp" alt="loading-ag-18088">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/63272157">https://zhuanlan.zhihu.com/p/63272157&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/92761639">https://zhuanlan.zhihu.com/p/92761639&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>LSMTree日志结构合并树</title><link>https://justice.bj.cn/post/12.data_struct/tree/lsm-tree/</link><pubDate>Thu, 09 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/lsm-tree/</guid><description>&lt;h1 id="日志结构合并树lsm-tree">日志结构合并树(LSM-Tree)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>LSM-Tree&lt;/code>全称Log Structured Merge Tree，是Google在2006年开源其BigTable中引入的一种数据结构。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种分层，有序，面向磁盘的数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其核心思想是充分了利用了磁盘批量的顺序写要远比随机写性能高出很多的特性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LSM-Tree大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于写多读少的场景;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sstable">SSTable&lt;/h2>
&lt;p>LSM-Tree核心的数据结构是SSTable，全称是Sorted String Table；&lt;/p>
&lt;p>SSTable是一种拥有持久化，有序且不可变的的键值存储结构，它的key和value都是任意的字节数组，并且了提供了按指定key查找和指定范围的key区间迭代遍历的功能。SSTable内部包含了一系列可配置大小的Block块，典型的大小是64KB，关于这些Block块的index存储在SSTable的尾部，&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-12-38-2021-09-04-10-12-33-image.png" alt="">&lt;/p>
&lt;h2 id="整体结构">整体结构&lt;/h2>
&lt;p>LSM-Tree里，SSTable有一份在内存里面，其他的多级在磁盘上，如下图是一份完整的LSM-Tree图示&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-08-25-2021-09-04-10-08-20-image.png" alt="">&lt;/p>
&lt;h2 id="写流程">写流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>当收到一个写请求时，会先把该条数据记录在WAL Log里面，用作故障恢复；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当写完WAL Log后，会把该条数据写入内存的SSTable里面（删除是墓碑标记，更新是新记录一条的数据），也称Memtable。注意为了维持有序性在内存里面可以采用红黑树或者跳跃表相关的数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当Memtable超过一定的大小后，会在内存里面冻结，变成不可变的Memtable，同时为了不阻塞写操作需要新生成一个Memtable继续提供服务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把内存里面不可变的Memtable给dump到到硬盘上的SSTable层中，此步骤也称为Minor Compaction，这里需要注意在L0层的SSTable是没有进行合并的，所以这里的key range在多个SSTable中可能会出现重叠，在层数大于0层之后的SSTable，不存在重叠key；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当每层的磁盘上的SSTable的体积超过一定的大小或者个数，也会周期的进行合并。此步骤也称为Major Compaction，这个阶段会真正 的清除掉被标记删除掉的数据以及多版本数据的合并，避免浪费空间，注意由于SSTable都是有序的，我们可以直接采用merge sort进行高效合并。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="读流程">读流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>当收到一个读请求的时候，会直接先在内存里面查询，如果查询到就返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果没有查询到就会依次下沉，知道把所有的Level层查询一遍得到最终结果。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="优化">优化&lt;/h2>
&lt;h3 id="压缩">压缩&lt;/h3>
&lt;p>SSTable 是可以启用压缩功能的，并且这种压缩不是将整个 SSTable 一起压缩，而是根据 locality 将数据分组，每个组分别压缩，这样的好处当读取数据的时候，我们不需要解压缩整个文件而是解压缩部分 Group 就可以读取。&lt;/p>
&lt;h3 id="缓存">缓存&lt;/h3>
&lt;p>因为SSTable在写入磁盘后，除了Compaction之外，是不会变化的，所以我可以将Scan的Block进行缓存，从而提高检索的效率&lt;/p>
&lt;h2 id="索引bloom-filters">索引，Bloom filters&lt;/h2>
&lt;p>正常情况下，一个读操作是需要读取所有的 SSTable 将结果合并后返回的，但是对于某些 key 而言，有些 SSTable 是根本不包含对应数据的，因此，我们可以对每一个 SSTable 添加 Bloom Filter，因为布隆过滤器在判断一个SSTable不存在某个key的时候，那么就一定不会存在，利用这个特性可以减少不必要的磁盘扫描。&lt;/p>
&lt;h3 id="合并">合并&lt;/h3>
&lt;p>这个在前面的写入流程中已经介绍过，通过定期合并瘦身， 可以有效的清除无效数据，缩短读取路径，提高磁盘利用空间。但Compaction操作是非常消耗CPU和磁盘IO的，尤其是在业务高峰期，如果发生了Major Compaction，则会降低整个系统的吞吐量，这也是一些NoSQL数据库，比如Hbase里面常常会禁用Major Compaction，并在凌晨业务低峰期进行合并的原因。&lt;/p>
&lt;h2 id="lsm-tree-vs-btree">LSM-Tree vs B+Tree&lt;/h2>
&lt;p>传统关系型数据采用的底层数据结构是B+树，那么同样是面向磁盘存储的数据结构LSM-Tree相比B+树有什么异同之处呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LSM-Tree的设计思路是，将数据拆分为几百M大小的Segments，并是顺序写入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>B+Tree则是将数据拆分为固定大小的Block或Page, 一般是4KB大小，和磁盘一个扇区的大小对应，Page是读写的最小单位。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在数据的更新和删除方面，B+Tree可以做到原地更新和删除，这种方式对数据库事务支持更加友好，因为一个key只会出现一个Page页里面，但由于LSM-Tree只能追加写，并且在L0层key的rang会重叠，所以对事务支持较弱，只能在Segment Compaction的时候进行真正地更新和删除。&lt;/p>
&lt;p>因此LSM-Tree的优点是支持高吞吐的写（可认为是O（1）），这个特点在分布式系统上更为看重，当然针对读取普通的LSM-Tree结构，读取是O（N）的复杂度，在使用索引或者缓存优化后的也可以达到O（logN）的复杂度。&lt;/p>
&lt;p>而B+tree的优点是支持高效的读（稳定的OlogN），但是在大规模的写请求下（复杂度O(LogN)），效率会变得比较低，因为随着insert的操作，为了维护B+树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。&lt;/p>
&lt;p>还有一点需要提到的是基于LSM-Tree分层存储能够做到写的高吞吐，带来的副作用是整个系统必须频繁的进行compaction，写入量越大，Compaction的过程越频繁。而compaction是一个compare &amp;amp; merge的过程，非常消耗CPU和存储IO，在高吞吐的写入情形下，大量的compaction操作占用大量系统资源，必然带来整个系统性能断崖式下跌，对应用系统产生巨大影响，当然我们可以禁用自动Major Compaction，在每天系统低峰期定期触发合并，来避免这个问题。&lt;/p>
&lt;p>阿里为了优化这个问题，在X-DB引入了异构硬件设备FPGA来代替CPU完成compaction操作，使系统整体性能维持在高水位并避免抖动，是存储引擎得以服务业务苛刻要求的关键。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/developer/article/1441835">深入理解什么是LSM-Tree - 云+社区 - 腾讯云&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>BIT-树状数组</title><link>https://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid><description>&lt;h1 id="树状数组bit">树状数组(BIT)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>树状数组&lt;/strong>或&lt;strong>二元索引树&lt;/strong>（英语：Binary Indexed Tree），又以其发明者命名为 FenwickFenwick 树。最早由 PeterM.FenwickPeterM.Fenwick 于 1994 年以 《A New Data Structure for Cumulative Frequency Tables&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84#cite_note-1">[1]&lt;/a>》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以 (logn)O(log⁡n) 的时间&lt;strong>得到任意前缀和（区间和）&lt;/strong>。&lt;/p>
&lt;h2 id="问题引入">问题引入&lt;/h2>
&lt;p>数组的单点修改&lt;code>update&lt;/code>和区间求和&lt;code>range_sum&lt;/code>问题。&lt;/p>
&lt;p>使用普通数组，&lt;code>update&lt;/code>时间复杂度为$O(1)$,&lt;code>range_sum&lt;/code>时间复杂度为$O(n)$.&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-26-2020-11-23-10-34-42-image.png" alt="">&lt;/p>
&lt;p>使用前缀和数组，&lt;code>update&lt;/code>时间复杂度为 O(n),&lt;code>range_sum&lt;/code>时间复杂度为$O(1)$.&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-52-2020-11-23-10-36-20-image.png" alt="">&lt;/p>
&lt;p>树状数组是上述方法的一个折中，&lt;code>update&lt;/code>和&lt;code>range_sum&lt;/code>时间复杂度均为$O(log_2n)$。&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>树状数组就是这样一种结构，它巧妙地利用了&lt;strong>二进制&lt;/strong>（实际上，树状数组的英文名 BIT，直译过来就是&lt;strong>二进制下标树&lt;/strong>）。例如 11，转化为二进制数就是$(1011)_2$ ，如果我们要求前 11 项和，可以分别查询 $ ((0000)_2, (1000)_2] $ , $ ( (1000)_2, (1010)_2 ] $, $ ( (1010)_2, (1101)_2 ] $ 的和再相加。这三个区间怎么来的呢？其实就是&lt;strong>不断地去掉二进制数最右边的一个 1&lt;/strong>的过程（如下图）。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-37-2020-11-23-10-53-33-image.png" alt="">&lt;/p>
&lt;p>二进制数最右边的一个 1，连带着它之后的 0 为&lt;code>lowbit(x)&lt;/code>（稍后再来看如何实现）。那么我们用$C_i$维护区间$ (A_i - lowbit(A_i), A_i] $ 的区间和，这样显然查询前 n 项和时需要合并的区间数是少于 $ log_2n $的。树状数组的结构大概像下面这样：&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-30-2020-11-23-10-56-25-image.png" alt="">&lt;/p>
&lt;p> 可用如下公式表示：&lt;/p>
&lt;p>$$
C[i] = A[i - 2^k+1] + A[i - 2^k+2] + &amp;hellip; + A[i]
$$&lt;/p>
&lt;p>其中: $k$表示 i 的二进制中从最低位到高位连续零的长度。&lt;/p>
&lt;h2 id="lowbit">lowbit&lt;/h2>
&lt;p>一个数的二进制表示中最低的一位&lt;code>1&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="优缺点">优缺点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>优点：修改和查询的复杂度都是$O(logN)$，相比线段树系数要少很多，比传统数组要快，而且容易写。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>缺点：是遇到复杂的区间问题还是不能解决，功能还是有限。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;p>一般用于解决大部分基于区间上的更新以及求和问题。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="cp">#define low(i) ((i)&amp;amp;(-i))
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">low&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//单点修改
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-=&lt;/span>&lt;span class="n">low&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">res&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//询问区间[1,pos]的权值和
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">range_query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">树状数组（BIT）—— 一篇就够了 - Last_Whisper - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/93795692">https://zhuanlan.zhihu.com/p/93795692&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>B树</title><link>https://justice.bj.cn/post/12.data_struct/tree/b-tree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/b-tree/</guid><description>&lt;h1 id="b-tree">B-Tree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>B 树又叫平衡多路查找树。主要应用于数据库，文件等&lt;/p>
&lt;p>一棵 m 阶的 B 树 (m 叉树)的特性如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>树中每个结点最多含有 m 个孩子（m&amp;gt;=2）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中 ceil(x)是一个取上限的函数）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为 null)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个非终端结点中包含有 n 个关键字信息： (P1，K1，P2，K2，P3，&amp;hellip;&amp;hellip;，Kn，Pn+1)。其中：
       a)   Ki (i=1&amp;hellip;n)为关键字，且关键字按顺序升序排序 K(i-1)&amp;lt; Ki。 
       b)   Pi 为指向子树根的接点，且指针 P(i)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。 
       c)   关键字的个数 n 必须满足： [ceil(m / 2)-1]&amp;lt;= n &amp;lt;= m-1。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-56-17-2020-04-21-13-16-05-image.png" alt="">&lt;/p>
&lt;p>来模拟下查找文件 29 的过程：&lt;/p>
&lt;p>(1) 根据根结点指针找到文件目录的根磁盘块 1，将其中的信息导入内存。【磁盘 IO 操作 1 次】&lt;/p>
&lt;p>(2) 此时内存中有两个文件名 17，35 和三个存储其他磁盘页面地址的数据。根据算法我们发现 17&amp;lt;29&amp;lt;35，因此我们找到指针 p2。&lt;/p>
&lt;p>(3) 根据 p2 指针，我们定位到磁盘块 3，并将其中的信息导入内存。【磁盘 IO 操作 2 次】&lt;/p>
&lt;p>(4) 此时内存中有两个文件名 26，30 和三个存储其他磁盘页面地址的数据。根据算法我们发现 26&amp;lt;29&amp;lt;30，因此我们找到指针 p2。&lt;/p>
&lt;p>(5) 根据 p2 指针，我们定位到磁盘块 8，并将其中的信息导入内存。【磁盘 IO 操作 3 次】&lt;/p>
&lt;p>(6) 此时内存中有两个文件名 28，29。根据算法我们查找到文件 29，并定位了该文件内存的磁盘地址。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md">The-Art-Of-Programming-By-July/03.02.md at master · julycoding/The-Art-Of-Programming-By-July · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Disruptor</title><link>https://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</guid><description>&lt;h1 id="disruptor-一种高效无锁内存队列">Disruptor: 一种高效无锁内存队列&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Disruptor 是 LMAX 公司开源的一个高效的内存无锁队列。&lt;/p></description></item><item><title>kafka时间轮算法</title><link>https://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</guid><description>&lt;h1 id="kafka-时间轮算法">Kafka 时间轮算法&lt;/h1>
&lt;p>Kafka中存在一些定时任务(DelayedOperation)，如DelayedFetch、DelayedProduce、DelayedHeartbeat等，在Kafka中，定时任务的添加、轮转、执行、消亡等是通过时间轮来实现的。(时间轮并不是Kafka独有的设计，而是一种通用的实现方式，Netty中也有用到时间轮的方式)&lt;/p>
&lt;h2 id="1时间轮是什么">1. 时间轮是什么&lt;/h2>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/36/36293d8f2a75cd09852f9189092cbe9e.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/cb/cb615fcfbc43cd42a73b65644701d2a2.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;p>Kafka时间轮由多个环形数组组成，每个环形数组包含20个时间单位，表示一个时间维度（一轮），如：第一层时间轮，数组中的每个元素代表1ms，一圈就是20ms，当延迟时间大于20ms时，就“进位”到第二层时间轮，第二层中，每“一格”表示20ms，依此类推…&lt;/p>
&lt;p>对于一个延迟任务，大体包含三个过程：进入时间轮、降级和到期执行。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>进入时间轮&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>根据延迟时间计算对应的时间轮“层次”（如钟表中的“小时级”还是“分钟级”还是“秒级”，实际上是一个不断“升级”的过程，直到找到合适的“层次”）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算在该轮中的位置，并插入该位置（每个bucket是一个双向链表，可能包含多个延迟任务，这也是时间轮提高效率的一大原因，后面会提到）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若该bucket是首次插入，需要将该bucket加入DelayQueue中（DelayQueue的引入是为了解决“空推进”，后面会提到）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/7b/7b74698c1815c0f86af8d1820da6b838.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降级&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>当时间“推进”到某个bucket时，说明该bucket中的任务在当前时间轮中的时间已经走完，需要进行“降级”，即进入更小粒度的时间轮中，reinsert的过程和进入时间轮是类似的&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/d4/d4af2f2054bf00f89bcbf4e36044aa56.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>到期执行&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>在reinsert的过程中，若发现已经到期，则执行这些任务&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/19/19bb4299ca84652634ea5eade9471905.png" alt="">&lt;/p>
&lt;p>整体过程大致如下：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/e9/e901a56d80092cda0bdbb4260ed21a91.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;h2 id="2时间的推进">2. 时间的“推进”&lt;/h2>
&lt;p>一种直观的想法是，像现实中的钟表一样，“一格一格”地走，这样就需要有一个线程一直不停的执行，而大多数情况下，时间轮中的bucket大部分是空的，指针的“推进”就没有实质作用，因此，为了减少这种“空推进”，Kafka引入了DelayQueue，以bucket为单位入队，每当有bucket到期，即queue.poll能拿到结果时，才进行时间的“推进”，减少了 ExpiredOperationReaper 线程空转的开销。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/5e/5e190488738e81a0ab996eb2c155e54f.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;h2 id="3为什么要用时间轮">3. 为什么要用时间轮&lt;/h2>
&lt;p>用到延迟任务时，比较直接的想法是DelayQueue、ScheduledThreadPoolExecutor 这些，而时间轮相比之下，最大的优势是在时间复杂度上：&lt;/p>
&lt;p>时间复杂度对比：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/cc/ccc843d13e25a1fec3e375b14e6658ac.png" alt="">&lt;/p>
&lt;p>因此，理论上，当任务较多时，TimingWheel的时间性能优势会更明显&lt;/p>
&lt;p>总结一下Kafka时间轮性能高的几个主要原因：&lt;/p>
&lt;p>（1）时间轮的结构+双向列表bucket，使得插入操作可以达到O(1)的时间复杂度&lt;/p>
&lt;p>（2）Bucket的设计让多个任务“合并”，使得同一个bucket的多次插入只需要在delayQueue中入队一次，同时减少了delayQueue中元素数量，堆的深度也减小，delayqueue的插入和弹出操作开销也更小&lt;/p></description></item><item><title>MassTree</title><link>https://justice.bj.cn/post/12.data_struct/tree/masstree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/masstree/</guid><description>&lt;h1 id="masstree">MassTree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>masstree 来源于 2012 年发表的论文(&lt;a href="https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf">Cache craftiness for fast multicore key-value storage&lt;/a>)，&lt;strong>可以理解为 B+ Tree 和 Radix Tree 的混合体&lt;/strong>，即将键切分成多个部分，每个部分为一个节点；每个节点内部又是一个 B+ Tree，兼顾空间和性能。&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>Masstree 将变长键划分成多个固长部分，每个固长部分可以通过 int 类型表示，而不是 char 类型。由于处理器处理 int 类型比较操作的速度远远快于 char 数组的比较，因此 Masstree 通过 int 类型的比较进一步加速了查找过程。固定长度可以设置为 CPU 缓存行长度，以增加 CPU 缓存效率。&lt;/li>
&lt;li>每个节点是一个 B+ Tree，因此 CPU 在查询的时候可以将节点所代表的 B+ Tree 加载到 CPU 缓存中，以增加 CPU 缓存命中率。&lt;/li>
&lt;li>其并发控制用到了 Read-Copy-Update(RCU)。读不因任何数据更新而阻塞，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据。因此读不会造成 CPU 缓存无效。&lt;/li>
&lt;/ul>
&lt;h2 id="结构">结构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-10-57-34-image-20190528102500578-9312132.png" alt="image-20190528102500578">&lt;/p>
&lt;h2 id="mass-tree-算法">&lt;strong>Mass Tree 算法&lt;/strong>&lt;/h2>
&lt;h2 id="并发策略">&lt;strong>并发策略&lt;/strong>&lt;/h2>
&lt;p>Mass Tree 的并发策略和 OLFIT Tree 是相似的：&lt;/p>
&lt;ol>
&lt;li>fine-grained locking，即节点锁，解决 write-write 竞争，同一时刻只有一个线程可以对当前节点进行写操作&lt;/li>
&lt;li>optimistic concurrency control，即节点  &lt;code>version&lt;/code> (uint32_t)，解决 read-write 竞争，读开始前和读结束后都需要获取当前节点的最新 version，来判断在读过程中当前节点是否发生了写操作（插入或分裂），同时对节点的写操作都需要先修改 version，在插入 key 之前需要设置  &lt;code>inserting&lt;/code>  标记，插入完成之后将 insert 的 vinsert + 1；在分裂之前需要设置  &lt;code>splitting&lt;/code>  标记，分裂完成之后将 split 的 vsplit + 1。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-00-01-2020-11-14-10-59-56-image.png" alt="">&lt;/p>
&lt;p>和  &lt;code>permutation&lt;/code>  一样，&lt;code>version&lt;/code>  也被划分成了多个域，除了带有 insert 和 split 信息之外，还包含一个 lock bit，用于加锁；一个 root bit，用于指示否是根节点；一个 border bit，用于指示是否是 border node；一位 deleted 位，用于指示这个节点是否被标记为删除。&lt;/p>
&lt;h2 id="下降流程">&lt;strong>下降流程&lt;/strong>&lt;/h2>
&lt;p>对于每次插入，获取，删除操作，都需要从 root（可能是整棵树的根节点，也可能是某棵子树的根节点） 下降到对应的叶节点（border node）。&lt;/p>
&lt;p>首先，在开始读取节点之前，必须获得节点的 stable version（图中橙色方块），即  &lt;code>version&lt;/code>  中的  &lt;code>inserting&lt;/code>  和  &lt;code>splitting&lt;/code>  位都为 0。&lt;/p>
&lt;p>其次，在下降之前，需要获取最新的 root，因为在开始下降前，根节点可能分裂了，导致其发生了改变（图中蓝色方块）。&lt;/p>
&lt;p>最后，如果当前节点已经是叶节点，那么可以返回，否则需要进行下降，读取内部结点根据  &lt;code>key[x, x+8)&lt;/code>(8 字节) 获得下降节点之后，分为 3 种情况处理：&lt;/p>
&lt;ol>
&lt;li>case 1 那行伪代码可以这样用 C 语言表示：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">uint32_t&lt;/span> &lt;span class="n">before&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node_get_stable_version&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// read node here
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">uint32_t&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node_get_version&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// no need to be stable, just latest version
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">before&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">LOCK_BIT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">before&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1">// neither insert nor split happened
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>节点在我们读取期间没有发生任何变化，我们可以安全地进行下降；&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>节点发生了变化，而且是分裂，那么我们需要从根节点重新进行下降（内部节点没有相互连接起来，所以不能像 Blink Tree 那样获取右节点）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点发生了变化，但只是插入，只需要重新对当前节点进行下降&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>注意第二个黄色方块，这一行非常关键，如果你细看下的话，它似乎可以挪到 case 1 的 if 语句里面，但实际上不能这样做。因为如果当前节点的孩子节点发生了分裂，但是还没来得及将新节点插入到当前节点，对调这两行代码，可能会导致下降到错误的节点。&lt;/p>
&lt;/blockquote>
&lt;h2 id="插入流程">&lt;strong>插入流程&lt;/strong>&lt;/h2>
&lt;p>作者只给出了读取伪代码，这里给出插入伪代码。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-02-06-2020-11-14-11-01-59-image.png" alt="">&lt;/p>
&lt;p>当我们通过  &lt;code>findborder&lt;/code>  下降到叶节点后，需要对其加锁（图中蓝色方块），但是此时并不能直接将 key 进行插入，当两个写线程同时下降到同一个叶节点时，只有一个线程可以进行写入，所以加锁后需要查看在加锁前是否有其他线程对这个节点进行了写入，如果有的话需要查看是否需要右移，这里的逻辑和 Blink Tree 是一样的。&lt;/p>
&lt;p>当我们成功加锁并且定位到正确的叶节点之后，可以进行写入，结果有 4 种：&lt;/p>
&lt;ol>
&lt;li>插入 key 成功或 key 已经存在；&lt;/li>
&lt;li>需要下降到下一层，同时需要增加索引的偏移；&lt;/li>
&lt;li>存在索引冲突，比如 &amp;ldquo;12345678AA&amp;rdquo; 和 &amp;ldquo;12345678BB&amp;rdquo;，此时需要创建一棵子树，存放 &amp;ldquo;AA&amp;rdquo; 和 &amp;ldquo;BB&amp;rdquo;，同时需要把原来存放 &amp;ldquo;AA&amp;rdquo; 的地方替换成这棵子树的根节点&lt;/li>
&lt;li>节点已满，需要分裂之后再次插入（见下一小节）&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>橙色方块在下面删除流程中介绍&lt;/p>
&lt;/blockquote>
&lt;h2 id="实现">实现&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/UncP/aili">UncP/aili&lt;/a>，没有实现删除操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/rmind/masstree">https://github.com/rmind/masstree&lt;/a>，采用了激进生成子树的策略，缺点就是 cache locality 在有些情况下不好。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>论文作者的实现：&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/kohler/masstree-beta">https://github.com/kohler/masstree-beta&lt;/a>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="总结">&lt;strong>总结&lt;/strong>&lt;/h2>
&lt;ol>
&lt;li>Trie 和 B+ 两种索引树的结合，使得在下降过程中的重试不需要从整棵树的根节点开始，同时加快拥有相同前缀的 key 的处理速度&lt;/li>
&lt;li>具体的内部结点与外部节点的结构&lt;/li>
&lt;li>fine-grained locking 写以及 lock-free 读&lt;/li>
&lt;li>比较具体的节点删除机制&lt;/li>
&lt;li>较小的节点减少了线程的竞争&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>需要指出的是这个算法不支持性能线性扩展，不过这并不是问题。&lt;/p>
&lt;/blockquote>
&lt;p>这个算法实现起来很有&lt;strong>挑战性&lt;/strong>，个人认为主要有两个方面，第一个是对于&lt;strong>树结构的把握&lt;/strong>，Mass Tree 是 Trie 和 B+ 树的结合。第二个是对于&lt;strong>并发下可见性的理解&lt;/strong>，”先改哪个域后改哪个域“，”谁先可见谁后可见“，”谁何时可见“，“在哪加以及加不加 memory barrier”等等这样的问题需要花很多时间考虑，而且出现 bug 非常难调试。&lt;/p>
&lt;p>Mass Tree 性能比我预想中要好很多，对于均匀分布的 10 字节 key 随机插入，数据量 1000 万，在我的机器上 4 个线程可以到 500 万以上的 tps；对于分布集中的测试数据，可以到 1000 万以上。其实&lt;strong>对于内存索引来说，cache miss 对性能造成的影响有时候是远远大于线程竞争的&lt;/strong>，所以尽管数据分布非常集中（线程竞争更多），仍然可以获得更高的性能。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf">https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kohler/masstree-beta">https://github.com/kohler/masstree-beta&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/52624601">https://zhuanlan.zhihu.com/p/52624601&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>MerkleTree</title><link>https://justice.bj.cn/post/12.data_struct/tree/merkle-tree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/merkle-tree/</guid><description>&lt;h1 id="merkle-tree">Merkle Tree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Merkle Tree 是一种 Hash Tree，由 Ralph Merkle 在 1979 年发明。&lt;/p>
&lt;p>Merkle Tree 的每个非叶节点通过其子节点的标记或者值（子节点为叶节点）的哈希值来进行标注，为大型的数据结构提供了高效安全的验证手段。&lt;/p>
&lt;p>Merkle Tree 可以理解为哈希列表和哈希链表的泛化产物。&lt;/p>
&lt;h2 id="结构">结构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/05-20-37-06-2020-12-05-20-34-44-image.png" alt="">&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>MT 是一种树，大多数是二叉树，也可以多叉树；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Merkle Tree 的叶子节点的 value 是数据集合的单元数据或者单元数据 HASH。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非叶子节点的 value 是根据它下面所有的叶子节点值，然后按照 Hash 算法计算而得出的；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>数字签名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>P2P 网络&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可信计算&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPFS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BitCoin/Ethereum&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/fengzhiwu/p/5524324.html">Merkle Tree 学习&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>ProtoBuf</title><link>https://justice.bj.cn/post/12.data_struct/protobuf/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/protobuf/</guid><description>&lt;h1 id="protobuf">ProtoBuf&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>语言无关、平台无关&lt;/strong>。即 ProtoBuf 支持 Java、C++、Python 等多种语言，支持多个平台&lt;/li>
&lt;li>&lt;strong>高效&lt;/strong>。即比 XML 更小（3 ~ 10 倍）、更快（20 ~ 100 倍）、更为简单&lt;/li>
&lt;li>&lt;strong>扩展性、兼容性好&lt;/strong>。你可以更新数据结构，而不影响和破坏原有的旧程序&lt;/li>
&lt;/ul>
&lt;h2 id="编码结构">编码结构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/03-12-46-03-2020-12-03-12-45-56-image.png" alt="">&lt;/p>
&lt;h2 id="使用">使用&lt;/h2>
&lt;ol>
&lt;li>创建 .proto 文件，定义数据结构&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="c1">// 例1: 在 xxx.proto 文件中定义 Example1 message
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">message&lt;/span> &lt;span class="nc">Example1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">optional&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">stringVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">optional&lt;/span> &lt;span class="kt">bytes&lt;/span> &lt;span class="n">bytesVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kd">message&lt;/span> &lt;span class="nc">EmbeddedMessage&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">int32Val&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">stringVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">optional&lt;/span> &lt;span class="n">EmbeddedMessage&lt;/span> &lt;span class="n">embeddedExample1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="n">repeatedInt32Val&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">repeated&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">repeatedStringVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>&lt;strong>protoc 编译 .proto 文件生成读写接口&lt;/strong>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">$ protoc -I&lt;span class="o">=&lt;/span>&lt;span class="nv">$SRC_DIR&lt;/span> --cpp_out&lt;span class="o">=&lt;/span>&lt;span class="nv">$DST_DIR&lt;/span> &lt;span class="nv">$SRC_DIR&lt;/span>/xxx.proto
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="3">
&lt;li>
&lt;p>&lt;strong>调用接口实现序列化、反序列化以及读写&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Radix Tree</title><link>https://justice.bj.cn/post/12.data_struct/tree/radixtree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/radixtree/</guid><description>&lt;h1 id="基数树radix-tree">基数树(Radix Tree)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Radix tree(也被称为 radix trie，或者 compact prefix tree)是一种空间优化的前缀树(prefix tree)数据结构。&lt;/p>
&lt;p>针对这对这样的稀疏长整型数据查找，能高速且节省空间地完成映射&lt;/p>
&lt;img title="" src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-32-55-2021-09-04-10-32-52-image.png" alt="" data-align="left">
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>IP 路由；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>倒排索引；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IDR（ID Radix）机制；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Linux 基数树（radix tree），内存管理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Redis Radix tree；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://ivanzz1001.github.io/records/post/data-structure/2018/11/18/ds-radix-tree" title="数据结构之Radix Tree">数据结构之 Radix Tree&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://sourcelink.top/2019/09/26/linux-kernel-radix-tree-analysis/">详解 Linux 内核 Radix 树算法的实现 - 黎棉麒的独立博客&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/developer/article/1597128">图解 Redis 中的 Radix 树 - 云+社区 - 腾讯云&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>RoaringBitmap</title><link>https://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</guid><description>&lt;h1 id="roaringbitmap高效压缩位图的原理与应用">RoaringBitmap:高效压缩位图的原理与应用&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>RoaringBitmap（简称为 RBM）是 2016 年由 S. Chambi、D. Lemire、O. Kaser 等人在论文中提出的一种高效位图压缩算法，用于解决稀疏位图空间占用效率问题。&lt;/p>
&lt;h2 id="主要思想">主要思想&lt;/h2>
&lt;p>将 32 位无符号整数按照高 16 位分桶，即最多可能有 216=65536 个桶，称为&lt;code>container&lt;/code>。存储数据时，按照数据的高 16 位找到 container（找不到就会新建一个），再将低 16 位放入 container 中。也就是说，一个 RBM 就是很多 container 的集合。如下所示。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/195230-7b71d0d9abe6e906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp" alt="">&lt;/p>
&lt;p>图中示出了三个 container：&lt;/p>
&lt;ul>
&lt;li>高 16 位为 0000H 的 container，存储有前 1000 个 62 的倍数。&lt;/li>
&lt;li>高 16 位为 0001H 的 container，存储有[216, 216+100)区间内的 100 个数。&lt;/li>
&lt;li>高 16 位为 0002H 的 container，存储有[2×216, 3×216)区间内的所有偶数，共 215 个。&lt;/li>
&lt;/ul>
&lt;p>container 是 RBM 新创造的概念，自然也是提高效率的核心。为了更高效地存储和查询数据，不同情况下会采用不同类型的 container，下面深入讲解一下 container 的细节。&lt;/p>
&lt;h3 id="container">Container&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>ArrayContainer: 当桶内数据的基数不大于 4096 时，会采用它来存储，其本质上是一个 unsigned short 类型的有序数组。数组初始长度为 4，随着数据的增多会自动扩容（但最大长度就是 4096）。另外还维护有一个计数器，用来实时记录基数。上图中的前两个 container 基数都没超过 4096，所以均为 ArrayContainer。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BitmapContainer: 当桶内数据的基数大于 4096 时，会采用它来存储，其本质就是上一节讲过的普通位图，用长度固定为 1024 的 unsigned long 型数组表示，亦即位图的大小固定为 216 位（8KB）。它同样有一个计数器。上图中的第三个 container 基数远远大于 4096，所以要用 BitmapContainer 存储。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RunContainer: RunContainer 在图中并未示出，初始的 RBM 实现中也没有它，而是在本节开头的第二篇论文中新加入的。它使用可变长度的 unsigned short 数组存储用行程长度编码（RLE）压缩后的数据。举个例子，连续的整数序列&lt;code>11, 12, 13, 14, 15, 27, 28, 29&lt;/code>会被 RLE 压缩为两个二元组&lt;code>11, 4, 27, 2&lt;/code>，表示 11 后面紧跟着 4 个连续递增的值，27 后面跟着 2 个连续递增的值。由此可见，RunContainer 的压缩效果可好可坏。考虑极端情况：如果所有数据都是连续的，那么最终只需要 4 字节；如果所有数据都不连续（比如全是奇数或全是偶数），那么不仅不会压缩，还会膨胀成原来的两倍大。所以，RBM 引入 RunContainer 是作为其他两种 container 的折衷方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>来简要看看它们的复杂度和转换方法。&lt;/p>
&lt;h2 id="时空分析">时空分析&lt;/h2>
&lt;p>增删改查的时间复杂度方面，BitmapContainer 只涉及到位运算，显然为 O(1)。而 ArrayContainer 和 RunContainer 都需要用二分查找在有序数组中定位元素，故为 O(logN)。&lt;/p>
&lt;p>空间占用（即序列化时写出的字节流长度）方面，BitmapContainer 是恒定为 8192B 的。ArrayContainer 的空间占用与基数（c）有关，为(2 + 2c)B；RunContainer 的则与它存储的连续序列数（r）有关，为(2 + 4r)B。以上节图中的 RBM 为例，它一共存储了 33868 个 unsigned int，只占用了 10396 个字节的空间，可以说是非常高效了。&lt;/p>
&lt;h4 id="container-的创建与转换">Container 的创建与转换&lt;/h4>
&lt;p>在创建一个新 container 时，如果只插入一个元素，RBM 默认会用 ArrayContainer 来存储。如果插入的是元素序列的话，则会先根据上面的方法计算 ArrayContainer 和 RunContainer 的空间占用大小，并选择较小的那一种进行存储。&lt;/p>
&lt;p>当 ArrayContainer 的容量超过 4096 后，会自动转成 BitmapContainer 存储。4096 这个阈值很聪明，低于它时 ArrayContainer 比较省空间，高于它时 BitmapContainer 比较省空间。也就是说 ArrayContainer 存储稀疏数据，BitmapContainer 存储稠密数据，可以最大限度地避免内存浪费。&lt;/p>
&lt;p>RBM 还可以通过调用特定的 API（名为 optimize）比较 ArrayContainer/BitmapContainer 与等价的 RunContainer 的内存占用情况，一旦 RunContainer 占用较小，就转换之。也就是说，上图例子中的第二个 ArrayContainer 可以转化为只有一个二元组&lt;code>0, 100&lt;/code>的 RunContainer，占用空间进一步下降到 10200 字节。&lt;/p>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;p>官方提供了 RBM 的多种语言实现，Java、C/C++、Python、Go、C#等等一应俱全。Java 版本的 GitHub repo 见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Flemire%2FRoaringBitmap">这里&lt;/a>。代码比较多，但思路很清晰，看官如果对位运算比较熟悉的话读起来不难，故本文就不再长篇大论地讲源码了。值得注意的几点如下：&lt;/p>
&lt;ul>
&lt;li>两个 RBM 做集合操作时，不同种类 container 之间位运算的处理方式，如 ArrayContainer AND BitmapContainer，BitmapContainer OR RunContainer 等；&lt;/li>
&lt;li>对 64 位整数的支持（32 位有时会不够用哈）；&lt;/li>
&lt;li>能够将 RBM 数据写到堆外，即内存映射；&lt;/li>
&lt;li>支持 Kryo 序列化方式。&lt;/li>
&lt;/ul>
&lt;p>RBM 的应用范围极广，下面只简单列举几个有代表性的应用，并给出 reference。&lt;/p>
&lt;h4 id="lucene">Lucene&lt;/h4>
&lt;p>为了加速搜索，Lucene 会将常用的查询过滤条件产生的结果集缓存到内存中，方便复用，称为 filter cache。结果集其实就是文档 ID（整形数）的集合。从 Lucene 5 开始，使用了 RBM 优化过的文档 ID 集合 RoaringDocIdSet 作为 filter cache，详情可以参见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fblog%2Fframe-of-reference-and-roaring-bitmaps">《Frame of Reference and Roaring Bitmaps》&lt;/a>。该文除了介绍 RBM 外，还介绍了压缩倒排索引的 Frame of Reference（FOR）编码，值得一读。&lt;/p>
&lt;h4 id="spark">Spark&lt;/h4>
&lt;p>在 Spark Core 的 MapStatus 组件（用来跟踪 ShuffleMapTask 的输出结果块）中，利用了 RBM 来存储块是否非空的状态。今后会在 Spark 连载里讲到它，所以现在看看&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fapache%2Fspark%2Fblob%2Fmaster%2Fcore%2Fsrc%2Fmain%2Fscala%2Forg%2Fapache%2Fspark%2Fscheduler%2FMapStatus.scala">该类的源码&lt;/a>就可以了，不难理解。&lt;/p>
&lt;h4 id="greenplum">Greenplum&lt;/h4>
&lt;p>我司是 Greenplum 大户，虽然本鶸现在不负责数仓相关的事情了，但是偶尔还是要向 GP 提供一些数据。GP 配合 RoaringBitmap 非常适合做海量用户的近实时画像，每个 RBM 代表一维标签即可，根据标签圈选用户也很方便。GP 原生并未支持 RBM 类型数据，需要安装一个扩展插件，见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fzeromax007%2Fgpdb-roaringbitmap%3Fspm%3Da2c4e.10696291.0.0.a68919a4RFqCuW">这里&lt;/a>。关于 GP 与 RBM 的整合与使用，有两篇不错的参考文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F405191">https://yq.aliyun.com/articles/405191&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://links.jianshu.com/go?to=http%3A%2F%2Fmysql.taobao.org%2Fmonthly%2F2018%2F08%2F09">http://mysql.taobao.org/monthly/2018/08/09&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="redis">Redis&lt;/h4>
&lt;p>我们在 Redis 里经常使用位图存储数据（Redis 原生以字符串的形式支持位图），当然也就会遇到稀疏位图浪费存储空间的问题。但要让 Redis 支持 RBM，需要引入专门的 module，项目地址见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Faviggiano%2Fredis-roaring">这里&lt;/a>。它的设计思想与 Java 版 RBM 几乎相同，不再废话了。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://roaringbitmap.org/">https://roaringbitmap.org/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1402.6407.pdf">《Better bitmap performance with Roaring bitmaps》&lt;/a>与&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1603.06549.pdf">《Consistently faster and smaller compressed bitmaps with Roaring》&lt;/a>中提出，&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>TAILQ-双向有尾队列</title><link>https://justice.bj.cn/post/12.data_struct/tailq/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tailq/</guid><description>&lt;h1 id="tailq-双向有尾队列">TAILQ: 双向有尾队列&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>TAILQ&lt;/strong>(双向有尾队列)是 FreeBSD/linux 内核对双向队列操作的一种抽象，在/usr/include/sys/queue.h 文件中实现各种定义。&lt;/p>
&lt;p>尾队列能实现操作队列需要的各种操作：插入元素，删除元素，遍历队列等。优点是插入元素很快。&lt;/p>
&lt;p>在一些著名的开源库中(如&lt;strong>DPDK&lt;/strong>,&lt;strong>libevent&lt;/strong>)有广泛的应用&lt;/p>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>双向有尾队列有一个表头和表尾，表头指向节点 1 和尾节点&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/06/03-10-55-36-2021-06-03-10-55-30-image.png" alt="">&lt;/p>
&lt;p>&lt;strong>TAILQ&lt;/strong>队列有&lt;strong>HEAD&lt;/strong>和&lt;strong>ENTRY&lt;/strong>两种基本的数据结构：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// 队列元素
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define TAILQ_ENTRY(type) \
&lt;/span>&lt;span class="cp">struct { \
&lt;/span>&lt;span class="cp"> struct type *tqe_next; \
&lt;/span>&lt;span class="cp"> struct type **tqe_prev; \
&lt;/span>&lt;span class="cp">}
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tailq_entry&lt;/span> &lt;span class="p">{&lt;/span>
　　&lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">;&lt;/span>
　　&lt;span class="n">TAILQ_ENTRY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">int_node&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="c1">// 队列头
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define TAILQ_HEAD(name, type) \
&lt;/span>&lt;span class="cp">struct name { \
&lt;/span>&lt;span class="cp"> struct type *tqh_first; &lt;/span>&lt;span class="cm">/*队列第一个元素的地址*/&lt;/span>&lt;span class="cp"> \
&lt;/span>&lt;span class="cp"> struct type **tqh_last; &lt;/span>&lt;span class="cm">/**/&lt;/span>&lt;span class="cp"> \
&lt;/span>&lt;span class="cp">}
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="n">STAILQ_HEAD&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_tailq&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tailq_entry&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">queue_head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意：数据结构中的&lt;strong>filed&lt;/strong>都是&lt;strong>type&lt;/strong>类型的指针(或者是二级指针)，这里的&lt;strong>type&lt;/strong>是用户的队列元素类型，&lt;/p>
&lt;p>将&lt;strong>ENTRY&lt;/strong>结构内嵌到用户的&lt;strong>QUEUE_ITEM&lt;/strong>结构中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">struct&lt;/span> &lt;span class="nc">QUEUE_ITEM&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="和-linux-list-区别">和 linux list 区别&lt;/h2>
&lt;p>和&lt;strong>Linux&lt;/strong>中&lt;strong>list&lt;/strong>的组织方式不一样，后者是单纯地将&lt;strong>struct list_head&lt;/strong>作为链表的一个挂接点，并没有用户的信息，具体差别可以看下图：&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/18-12-06-33-2020-11-18-12-04-56-image.png" alt="">&lt;/p>
&lt;h2 id="tailq-队列的操作">TAILQ 队列的操作&lt;/h2>
&lt;p>&lt;strong>TAILQ&lt;/strong>提供了多种操作队列的&lt;strong>API&lt;/strong>,比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">TAILQ_HEAD&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">type&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_ENTRY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_FIRST&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_FOREACH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">field&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_INIT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_INSERT_AFTER&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">listelm&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">elm&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">field&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_INSERT_BEFORE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">listelm&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">elm&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">field&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TAILQ_INSERT_TAIL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">elm&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">field&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">.....&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="tailq队列中为什么tqh_prev和tqh_last要使用二级指针">*&lt;strong>*TAILQ&lt;/strong>队列中为什么&lt;strong>tqh_prev&lt;/strong>和&lt;strong>tqh_last&lt;/strong>要使用二级指针**&lt;/h3>
&lt;p>要搞清楚这个问题，我们可以考虑如果不使用二级指针会怎么样？ 就像定义成下面这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define FAKE_TAILQ_HEAD(name, type) \
&lt;/span>&lt;span class="cp">struct name { \
&lt;/span>&lt;span class="cp"> struct type *tqh_first; &lt;/span>&lt;span class="cm">/* first element */&lt;/span>&lt;span class="cp"> \
&lt;/span>&lt;span class="cp"> struct type *tqh_last; &lt;/span>&lt;span class="cm">/* last element */&lt;/span>&lt;span class="cp"> \
&lt;/span>&lt;span class="cp">}
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#define FAKE_TAILQ_ENTRY(type) \
&lt;/span>&lt;span class="cp">struct { \
&lt;/span>&lt;span class="cp"> struct type *tqe_next; &lt;/span>&lt;span class="cm">/* next element */&lt;/span>&lt;span class="cp"> \
&lt;/span>&lt;span class="cp"> struct type *tqe_prev; &lt;/span>&lt;span class="cm">/* previous element*/&lt;/span>&lt;span class="cp"> \
&lt;/span>&lt;span class="cp">}
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/18-12-08-55-2020-11-18-12-08-37-image.png" alt="">&lt;/p>
&lt;p>如果我们想要删除队列的任意一个元素，对&lt;strong>FAKE_TAILQ&lt;/strong>，我们需要特殊处理该元素是第一个元素的情况(第一个元素的&lt;strong>tqe_prev&lt;/strong>指针为空)，而&lt;strong>TAILQ&lt;/strong>就没有这个烦恼！&lt;/p>
&lt;p>*&lt;strong>*TAILQ&lt;/strong>队列的遍历性能**&lt;/p>
&lt;p>&lt;strong>Linux&lt;/strong>中的&lt;strong>list&lt;/strong>只将&lt;strong>struct list_head&lt;/strong>作为用户元素的挂接点，因此在正向遍历链表时，需要使用&lt;strong>container_of&lt;/strong>这类接口才能获取用户的数据，而&lt;strong>TAILQ&lt;/strong>由于&lt;strong>tqe_next&lt;/strong>指针直接指向用户元素的类型，所以理论上，正向遍历&lt;strong>TAILQ&lt;/strong>比&lt;strong>list&lt;/strong>更快.但逆向遍历时,由于&lt;strong>TAILQ&lt;/strong>的取用&lt;strong>prev&lt;/strong>元素的操作比&lt;strong>next&lt;/strong>麻烦的多，因此逆向遍历是比正向慢的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define TAILQ_PREV(elm, headname, field) \
&lt;/span>&lt;span class="cp"> (*(((struct headname *)((elm)-&amp;gt;field.tqe_prev))-&amp;gt;tqh_last))
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.sunxidong.com/260.html">https://www.sunxidong.com/260.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/fuzidage/p/14482501.html">TAILQ 队列实现原理 - fuzidage - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>分布式哈希表</title><link>https://justice.bj.cn/post/12.data_struct/40.%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8dht/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/40.%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8dht/</guid><description>&lt;h1 id="分布式哈希表dht">分布式哈希表(DHT)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>分布式哈希表(DHT, Distributed Hash Table)是分布式系统中，用来将一个键（key）的集合分散到所有节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。&lt;/p>
&lt;h2 id="dht">DHT&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-49-2020-03-08-15-47-23-image.png" alt="">&lt;/p>
&lt;p>分布式哈希表的用于发点对点系统(P2P)，像是 Napster、Gnutella、BitTorrent 及 Freenet。这些系统使用分散在互联网上的各项资源以提供文件分享服务，特别在带宽及硬盘存储空间上受益良多。&lt;/p>
&lt;p>这些系统使用不同的方法来解决如何找到拥有某数据的节点的问题。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Napster 使用中央的索引服务器：每个节点加入网络的同时，会将他们所拥有的文件列表发送给服务器，这使得服务器可以进行搜索并将结果回传给进行查询的节点。但中央索引服务器让整个系统易受攻击，且可能造成法律问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Gnutella 和相似的网络改用大量查询模式（flooding query model）：每次搜索都会把查询消息广播给网络上的所有节点。虽然这个方式能够防止单点故障（single point of failure），但比起 Napster 来说却极没效率；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Freenet 使用了完全分布式的系统，但它建置了一套使用经验法则的基于键的路由方法（key based routing）。在这个方法中，每个文件与一个键相结合，而拥有相似键的文件会倾向被相似的节点构成的集合所保管。于是查询消息就可以根据它所提供的键被路由到该集合，而不需要经过所有的节点。然而，Freenet 并不保证存在网络上的数据在查询时一定会被找到。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>分布式哈希表为了达到 Gnutella 与 Freenet 的分散性（decentralization）以及 Napster 的效率与正确结果，使用了较为结构化的基于键的路由方法。不过分布式哈希表也有个 Freenet 有的缺点，就是只能作精确搜索，而不能只提供部分的关键字；但这个功能可以在分布式哈希表的上层实现。&lt;/p>
&lt;p>最初的四项分布式哈希表技术——内容可定址网络（Content addressable network，CAN）、Chord（Chord project）、Pastry（Pastry (DHT)），以及 Tapestry (DHT)（Tapestry (DHT)）皆同时于 2001 年发表。从那时开始，相关的研究便一直十分活跃。在学术领域以外，分布式哈希表技术已经被应用在 BitTorrent 及 CoralCDN（Coral Content Distribution Network）等。&lt;/p>
&lt;p>分布式散列表本质上强调以下特性：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>离散性&lt;/strong>：构成系统的节点并没有任何中央式的协调机制。&lt;/li>
&lt;li>&lt;strong>伸缩性&lt;/strong>：即使有成千上万个节点，系统仍然应该十分有效率。&lt;/li>
&lt;li>&lt;strong>容错性&lt;/strong>：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度。&lt;/li>
&lt;/ul>
&lt;p>要达到以上的目标，有一个关键的技术：任一个节点只需要与系统中的部分节点沟通，当成员改变的时候，只有一部分的工作（例如数据或键的发送，哈希表的改变等）必须要完成。&lt;/p>
&lt;p>分布式散列表的结构可以分成几个主要的组件。其基础是一个抽象的&lt;code>键空间&lt;/code>（keyspace），例如说所有&lt;strong>160&lt;/strong>位长的字符串集合。&lt;code>键空间分区&lt;/code>（keyspace partitioning）将&lt;code>键空间&lt;/code>分区成数个，并指定到在此系统的节点中。而&lt;code>延展网络&lt;/code>则连接这些节点，并让他们能够借由在&lt;code>键空间&lt;/code>内的任一值找到拥有该值的节点。&lt;/p>
&lt;p>假设&lt;code>键空间&lt;/code>是一个 160 位长的字符串集合。为了在分布式散列表中存储一个文件，名称为&lt;code>filename&lt;/code>且内容为&lt;code>data&lt;/code>，我们计算出&lt;code>filename&lt;/code>的 SHA1 散列值——一个 160 位的键&lt;code>k&lt;/code>——并将消息&lt;code>put(k,data)&lt;/code>送给分布式散列表中的任意参与节点。此消息在延展网络中被路由，直到抵达在键空间分区中被指定负责存储关键值&lt;code>k&lt;/code>的节点。而&lt;code>(k,data)&lt;/code>即存储在该节点。其他的节点只需要重新计算&lt;code>filename&lt;/code>的散列值&lt;code>k&lt;/code>，然后提交消息&lt;code>get(k)&lt;/code>给分布式哈希表中的任意参与节点，以此来找与&lt;code>k&lt;/code>相关的数据。此消息也会在延展网络中被路由到负责存储&lt;code>k&lt;/code>的节点。而此节点则会负责传回存储的数据&lt;code>data&lt;/code>。&lt;/p>
&lt;p>基本上，就是一种映射 key 和节点的算法以及路由的算法。&lt;/p>
&lt;p>其一为保证任何的路由路径长度必须尽量短，因而请求能快速地被完成；&lt;br>
其二为任一节点的邻近节点数目（又称最大节点度（Degree (graph theory)））必须尽量少，因此维护的花费不会过多。&lt;/p>
&lt;h2 id="分布式哈希与一致性哈希">分布式哈希与一致性哈希&lt;/h2>
&lt;p>分布式哈希和一致性哈希有什么区别呢？lintong 的&lt;a href="https://www.jianshu.com/p/7beeb52376cc">分布式哈希与一致性哈希&lt;/a>  一文对它做了清晰而简洁的解释。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分布式哈希&lt;/strong>: 将哈希表分散在不同的节点上，并且能提供相应的方法来查找， 比如 DHT 算法；&lt;/li>
&lt;li>&lt;strong>一致性哈希&lt;/strong>: 当节点宕机或者扩容的时候，需要重新哈希，一致性哈希实现的 DHT 避免对大量的数据重新哈希, 比如&lt;a href="https://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord DHT&lt;/a>. 所以一致性哈希是 DHT 的一种实现，避免在节点变化的时候出现的全部重新哈希的现象.&lt;/li>
&lt;/ul>
&lt;p>其它的 DHT 的分区实现(Keyspace partitioning)还有:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Rendezvous hashing&lt;/strong>: 最高随机权重哈希。每个 client 都会获得服务节点相同的指示符&lt;code>{S1, S2, ..., Sn }&lt;/code>， 对于键&lt;code>k&lt;/code>, client 使用相同的哈希函数计算服务节点的权重&lt;code>w1 = h(S1, k), w2 = h(S2, k), ..., wn = h(Sn, k)&lt;/code>，然后总是选择最高权重的节点。&lt;/li>
&lt;li>&lt;strong>Locality-preserving hashing&lt;/strong>: 相近的键总是指派给相近的对象。&lt;/li>
&lt;/ul>
&lt;h2 id="kademlia-算法">Kademlia 算法&lt;/h2>
&lt;p>&lt;strong>Kademlia&lt;/strong>是一种通过 DHT 的协议算法，它是由 Petar 和 David 在 2002 年为 P2P 网络而设计的。Kademlia 规定了网络的结构，也规定了通过节点查询进行信息交换的方式。&lt;br>
Kademlia 网络节点之间使用&lt;strong>UDP&lt;/strong>进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点 ID）来进行身份标识。节点 ID 不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。&lt;/p>
&lt;p>当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia 算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的 ID 与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点 ID 的时候搜索便会停止。&lt;/p>
&lt;p>这种搜索值的方法是非常高效的：与其他的分布式哈希表的实现类似，在一个包含 n 个节点的系统的值的搜索中，Kademlia 仅访问&lt;code>O(log(n))&lt;/code>个节点。&lt;/p>
&lt;p>&lt;code>Kademlia&lt;/code>简称为&lt;code>Kad&lt;/code>,它使用了一个精妙的算法，来计算节点之间的&amp;quot;距离&amp;quot; (这里的距离不是地理空间的距离，而是路由的跳数)，这个算法就是&lt;code>XOR&lt;/code>操作(异或)，因为这个操作和距离的计算类似：&lt;/p>
&lt;ul>
&lt;li>&lt;code>(A ⊕ B) == (B ⊕ A)&lt;/code>: XOR 符合“交换律”，具备对称性。A 和 B 的距离从哪一个节点计算都是相同的。&lt;/li>
&lt;li>&lt;code>(A ⊕ A) == 0&lt;/code>: 反身性，自己和自己的距离为零。&lt;/li>
&lt;li>&lt;code>(A ⊕ B) &amp;gt; 0&lt;/code>: 两个不同的 key 之间的距离必大于零。&lt;/li>
&lt;li>&lt;code>(A ⊕ B) + (B ⊕ C) &amp;gt;= (A ⊕ C)&lt;/code>: 三角不等式, A 经过 B 到 C 的距离总是大于 A 直接到 C 的距离。&lt;/li>
&lt;/ul>
&lt;p>(精妙啊!是如何想起和距离计算联系在一起的？)&lt;/p>
&lt;p>Kad 使用 160 位的哈希算法（比如 SHA1），完整的 key 用二进制表示有 160 位，这样可以容纳 2160 个节点，可以说是不计其数了。&lt;/p>
&lt;p>Kad 把 key 映射到一个二叉树，每一个 key 都是这个二叉树的&lt;code>叶子&lt;/code>。&lt;/p>
&lt;h3 id="映射规则">&lt;strong>映射规则&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>先把 key 以二进制形式表示，然后从高位到低位依次处理。&lt;/li>
&lt;li>二进制的第 n 个位就对应了二叉树的第 n 层&lt;/li>
&lt;li>如果该位是 1，进入左子树，是 0 则进入右子树（这只是人为约定，反过来处理也可以）&lt;/li>
&lt;li>全部位都处理完后，这个 key 就对应了二叉树上的某个叶子&lt;/li>
&lt;/ol>
&lt;h3 id="二叉树的拆分规则">&lt;strong>二叉树的拆分规则&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-21-16-2020-03-08-15-50-47-image.png" alt="">&lt;/p>
&lt;p>对每一个节点，都可以&lt;strong>按照自己的视角&lt;/strong>对整个二叉树进行拆分成最多 160 个子树。&lt;/p>
&lt;p>拆分的规则是：先从根节点开始，把&lt;strong>不包含&lt;/strong>自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的第二层子树；以此类推，直到最后只剩下自己。&lt;/p>
&lt;p>Kad 默认的散列值空间是  &lt;code>m=160&lt;/code>（散列值有 160 bit），因此拆分出来的子树&lt;strong>最多&lt;/strong>有 160 个（考虑到实际的节点数&lt;strong>远远小于&lt;/strong>2160，子树的个数会明显小于 160）。&lt;/p>
&lt;p>对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的&lt;strong>任何一个&lt;/strong>节点。&lt;/p>
&lt;h3 id="拆子树">&lt;strong>拆子树&lt;/strong>&lt;/h3>
&lt;p>每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（节点可能宕机或者退出），光知道&lt;strong>一个&lt;/strong>显然是不够的，需要知道&lt;strong>多个&lt;/strong>才比较保险。&lt;/p>
&lt;p>所以 Kad 论文中给出了一个&lt;code>K-桶（K-bucket）&lt;/code>的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的  &lt;code>K&lt;/code>  个节点。这里所说的  &lt;code>K&lt;/code>  值是一个&lt;strong>系统级&lt;/strong>的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 8）。&lt;/p>
&lt;p>&lt;strong>K 桶&lt;/strong>其实就是&lt;strong>路由表&lt;/strong>。对于某个节点而言，如果&lt;strong>以它自己为视角&lt;/strong>拆分了  &lt;strong>n&lt;/strong>  个子树，那么它就需要维护  &lt;strong>n&lt;/strong>  个路由表，并且每个路由表的&lt;strong>上限&lt;/strong>是 K。&lt;/p>
&lt;p>说 K 只是一个&lt;strong>上限&lt;/strong>，是因为有两种情况使得 K 桶的尺寸会小于 K:&lt;/p>
&lt;ol>
&lt;li>距离越近的子树就越小。如果整个子树&lt;strong>可能存在的&lt;/strong>节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。(这是由于 K 桶对应的距离越近，节点数越少)&lt;/li>
&lt;li>有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。&lt;/li>
&lt;/ol>
&lt;p>如果选择这 K 个节点呢？&lt;br>
Kademlia 选择把那些长时间在线的节点存入 K 桶，这一方法增长了未来某一时刻有效节点的数量，同时也提供了更为稳定的网络。当某个 K 桶已满，而又发现了相应于该桶的新节点的时候，那么，就首先检查 K 桶中最早访问的节点，假如该节点仍然存活，那么新节点就被安排到一个附属列表中（作为一个替代缓存）.只有当 K 桶中的某个节点停止响应的时候，替代 cache 才被使用。换句话说，新发现的节点只有在老的节点消失后才被使用。&lt;/p>
&lt;h3 id="kademlia-协议">&lt;strong>Kademlia 协议&lt;/strong>&lt;/h3>
&lt;p>Kademlia 协议共有四种消息。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>PING&lt;/strong>消息: 用来测试节点是否仍然在线。&lt;/li>
&lt;li>&lt;strong>STORE&lt;/strong>消息: 在某个节点中存储一个键值对。&lt;/li>
&lt;li>&lt;strong>FIND_NODE&lt;/strong>消息: 消息请求的接收者将返回自己桶中离请求键值最近的 K 个节点。&lt;/li>
&lt;li>&lt;strong>FIND_VALUE&lt;/strong>消息: 与 FIND_NODE 一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。&lt;/li>
&lt;/ul>
&lt;p>每一个 RPC 消息中都包含一个发起者加入的随机值，这一点确保响应消息在收到的时候能够与前面发送的请求消息匹配。&lt;/p>
&lt;h3 id="定位节点">&lt;strong>定位节点&lt;/strong>&lt;/h3>
&lt;p>节点查询可以异步进行，也可以同时进行，同时查询的数量由 α 表示，一般是 3。&lt;/p>
&lt;ol>
&lt;li>由查询发起者从自己的 k-桶中筛选出若干距离目标 ID 最近的节点，并向这些节点同时发送异步查询请求；&lt;/li>
&lt;li>被查询节点收到请求之后，将从自己的 k-桶中找出自己所知道的距离查询目标 ID 最近的若干个节点，并返回给发起者；&lt;/li>
&lt;li>发起者在收到这些返回信息之后，更新自己的结果列表，再次从自己所有已知的距离目标较近的节点中挑选出若干没有请求过的，并重复步骤 1；&lt;/li>
&lt;li>上述步骤不断重复，直至无法获得比查询者当前已知的 k 个节点更接近目标的活动节点为止。&lt;/li>
&lt;li>在查询过程中，没有及时响应的节点将立即被排除；查询者必须保证最终获得的 k 个最节点都是活动的。&lt;/li>
&lt;/ol>
&lt;h3 id="定位资源">&lt;strong>定位资源&lt;/strong>&lt;/h3>
&lt;p>通过把资源信息与键进行映射，资源即可进行定位，杂凑表是典型的用来映射的手段。由于以前的 STORE 消息，存储节点将会有对应 STORE 所存储的相关资源的信息。定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，定位资源与定位离键最近的节点的过程相似。&lt;/p>
&lt;p>考虑到节点未必都在线的情况，资源的值被存在多个节点上（节点中的 K 个），并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的 K 个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。&lt;/p>
&lt;h3 id="加入网络">&lt;strong>加入网络&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>新节点 A 必须知道某个引导节点 B，并把它加入到自己相应的 K-桶中&lt;/li>
&lt;li>生成一个随机的节点 ID,直到离开网络，该节点会一直使用该 ID 号&lt;/li>
&lt;li>向 B（A 目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的 ID 是自己（就是查询自己）&lt;/li>
&lt;li>B 收到该请求之后，会先把 A 的 ID 加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B 会找到 K 个最接近 A 的节点，并返回给 A&lt;/li>
&lt;li>A 收到这 K 个节点的 ID 之后，把他们加入自己的 K-桶&lt;/li>
&lt;li>然后 A 会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至 A 建立了足够详细的路由表。&lt;/li>
&lt;li>这种“自我定位”将使得 Kad 的其他节点（收到请求的节点）能够使用 A 的 ID 填充他们的 K-桶，同时也能够使用那些查询过程的中间节点来填充 A 的 K-桶。这已过程既让 A 获得了详细的路由表，也让其它节点知道了 A 节点的加入&lt;/li>
&lt;/ol>
&lt;h2 id="kad-在-p2p-网络中的应用">kad 在 p2p 网络中的应用&lt;/h2>
&lt;p>Kademlia 可在文件分享网络中使用，通过制作 Kademlia 关键字搜索，我们能够在文件分享网络中找到我们需要的文件以供我们下载。由于没有中央服务器存储文件的索引，这部分工作就被平均地分配到所有的客户端中去：&lt;/p>
&lt;p>假如一个节点希望分享某个文件，它先根据文件的内容来处理该文件，通过运算，把文件的内容散列成一组数字，该数字在文件分享网络中可被用来标识文件。这组散列数字必须和节点 ID 有同样的长度，&lt;br>
然后，该节点便在网络中搜索 ID 值与文件的散列值相近的节点，并把它自己的 IP 地址存储在那些搜索到的节点上，也就是说，它把自己作为文件的源进行了发布。正在进行文件搜索的客户端将使用 Kademlia 协议来寻找网络上 ID 值与希望寻找的文件的散列值最近的那个节点，然后取得存储在那个节点上的文件源列表。&lt;br>
由于一个键可以对应很多值，即同一个文件可以有多个源，每一个存储源列表的节点可能有不同的文件的源的信息，这样的话，源列表可以从与键值相近的 K 个节点获得。&lt;/p>
&lt;p>文件的散列值通常可以从其他的一些特别的 Internet 链接的地方获得，或者被包含在从其他某处获得的索引文件中。&lt;br>
文件名的搜索可以使用关键词来实现，文件名可以分割成连续的几个关键词，这些关键词都可以散列并且可以和相应的文件名和文件散列储存在网络中。搜索者可以使用其中的某个关键词，联系 ID 值与关键词散列最近的那个节点，取得包含该关键词的文件列表。由于在文件列表中的文件都有相关的散列值，通过该散列值就可利用上述通常取文件的方法获得要搜索的文件。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E9%9B%9C%E6%B9%8A%E8%A1%A8">https://zh.wikipedia.org/wiki/分散式雜湊表&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Distributed_hash_table">https://en.wikipedia.org/wiki/Distributed_hash_table&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://baike.baidu.com/item/DHT/1007999">DHT（一种分布式存储方法）_百度百科&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/7beeb52376cc">分布式哈希与一致性哈希 - 简书&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html">https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://colobu.com/2018/03/26/distributed-hash-table/">https://colobu.com/2018/03/26/distributed-hash-table/&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>跳表</title><link>https://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</link><pubDate>Tue, 07 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</guid><description>&lt;h1 id="跳表skiplist">跳表(skiplist)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>跳表&lt;/code>(SkipList)由 William Pugh 于 1990 年发明。他在 Communications of the ACM June 1990, 33(6) 668-676 上发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了跳表的数据结构和插入删除操作。&lt;/p>
&lt;p>跳表是平衡树的一种替代的数据结构，和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法，跳表的插入和删除的工作是比较简单的。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-04-2020-03-06-11-41-30-image.png" alt="">&lt;/p>
&lt;h2 id="核心思想">核心思想&lt;/h2>
&lt;p>通过对普通有序链表扩充层级指针，实现节点的快速访问。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-11-image-20190504154638969.png" alt="image-20190504154638969">&lt;/p>
&lt;h2 id="实现要点">实现要点&lt;/h2>
&lt;ol>
&lt;li>新增节点通过随机数决定指针的层级；&lt;/li>
&lt;li>通过调节因子决定随机层级，从而控制层级指针的疏密；&lt;/li>
&lt;/ol>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// member 对象
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">robj&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 分值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 后退指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">backward&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 层
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistLevel&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 前进指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">forward&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 这个层跨越的节点数量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">span&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">[];&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zskiplistNode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html">跳跃表 — Redis 设计与实现&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title/><link>https://justice.bj.cn/post/12.data_struct/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/12.data_struct/readme/</guid><description>&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="./00.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md">基础数据结构&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="./01.%E6%AF%94%E7%89%B9.md">比特/字节&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="./%E6%95%B0%E7%BB%84.md">数组&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="./05.%E6%A0%91.md">树&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="./Tree/B-Tree.md">B 树&lt;/a>&lt;/li>
&lt;li>&lt;a href="./Tree/RB-Tree.md">红黑树&lt;/a>&lt;/li>
&lt;li>&lt;a href="./Tree/TrieTree.md">字典树&lt;/a>&lt;/li>
&lt;li>&lt;a href="./Tree/Segment-Tree.md">线段树&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title/><link>https://justice.bj.cn/post/12.data_struct/tree/segment-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/segment-tree/</guid><description>&lt;h1 id="线段树segment-tree">线段树(Segment-Tree)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>线段树（Segment Tree）是一种二叉树形数据结构，1977 年由 Jon Louis Bentley 发明，用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间。是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与&lt;a href="https://www.jianshu.com/p/5b209c029acd">树状数组（binary indexed tree）&lt;/a>相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。&lt;/p>
&lt;p>与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询。&lt;/p>
&lt;p>对应于树状数组，线段树进行更新（update）的操作为&lt;code>O(logn)&lt;/code>，进行区间查询（range query）的操作也为&lt;code>O(logn)&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-19-14-43-segment_tree.png" alt="线段树结构示意，其存储的线段显示在图片的下方。">&lt;/p>
&lt;h6 id="线段树结构示意其存储的线段显示在图片的下方">线段树结构示意（其存储的线段显示在图片的下方）&lt;/h6>
&lt;p>一个包含 nn 个区间的线段树，空间复杂度为 $O(n)$，查询的时间复杂度则为 $O(log{n}+k)$，其中 k 是符合条件的区间数量。&lt;/p>
&lt;p>此数据结构亦可推广到高维度。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2></description></item><item><title/><link>https://justice.bj.cn/post/12.data_struct/tree/trietree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/trietree/</guid><description>&lt;h1 id="trietree字典树">TrieTree(字典树)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>Trie Tree&lt;/code>前缀树或字典树，是一种有序树，用于保存关联数组。&lt;/p>
&lt;p>其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。Trie树的名称来源于搜索引擎中的专有名词的retrieval&lt;/p>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>搜索引擎的suggest功能;&lt;/li>
&lt;/ul>
&lt;p>比如包含6个单词的Trie树：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">- `(&amp;#34;abc&amp;#34;)`
- `(&amp;#34;xy&amp;#34;)`
- `(&amp;#34;xyz&amp;#34;)`
- `(&amp;#34;abb&amp;#34;)`
- `(&amp;#34;xyzb&amp;#34;),`
- `(&amp;#34;word&amp;#34;)`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-26-31-2021-09-04-10-26-27-image.png" alt="">&lt;/p>
&lt;p>Trie树有两种实现策略，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一种使用数组存储所有的可能性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二种是使用的Map存储所有的可能性，&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;li>
&lt;p>使用数组的方式需要对存储的字符和数组的index之间要有明确的映射规则，这样便于查询，比如如果想做中文的suggest&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzAxMzE4MDI0NQ==&amp;amp;mid=2650336593&amp;amp;idx=1&amp;amp;sn=8b3e6225876757485fa6d8299abd0095&amp;amp;chksm=83aac16bb4dd487dae3d69d11808f9a850a0d6e9494b24607f4610c51fbe6c02845eb3d072ef&amp;amp;scene=21#wechat_redirect">深入理解Trie树&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title/><link>https://justice.bj.cn/post/13.algorithm/kademlia%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/13.algorithm/kademlia%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="kademlia算法">Kademlia算法&lt;/h1>
&lt;hr>
&lt;p>Kademlia算法是一种分布式存储及路由的算法。&lt;/p>
&lt;p>什么是分布式存储？试想一下，一所1000人的学校，现在学校突然决定拆掉图书馆（不设立中心化的服务器），将图书馆里所有的书都分发到每位学生手上（所有的文件分散存储在各个节点上）。即是所有的学生，共同组成了一个分布式的图书馆。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-795f3af7231108b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="">&lt;/p>
&lt;p>由中心图书馆到分布式图书馆&lt;/p>
&lt;p>在这种场景下，有几个关键的问题需要回答。&lt;/p>
&lt;h3 id="1关键问题">1）关键问题&lt;/h3>
&lt;ol>
&lt;li>每个同学手上都分配哪些书。即如何分配存储内容到各个节点，新增/删除内容如何处理。&lt;/li>
&lt;li>当你需要找到一本书，譬如《分布式算法》的时候，如何知道哪位同学手上有《分布式算法》（对1000个人挨个问一遍，“你有没有《分布式算法》？”，显然是个不经济的做法），又如何联系上这位同学。即一个节点如果想获取某个特定的文件，如何找到存储文件的节点/地址/路径。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-8b12f9959fa3144f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/358/format/webp" alt="">&lt;/p>
&lt;p>如何寻找需要的书籍？&lt;/p>
&lt;p>接下来，让我们来看看Kademlia算法如何巧妙地解决这些问题。&lt;/p>
&lt;h3 id="2节点的要素">2）节点的要素&lt;/h3>
&lt;p>首先我们来看看每个同学（节点）都有哪些属性：&lt;/p>
&lt;ul>
&lt;li>学号（Node ID，2进制，160位）&lt;/li>
&lt;li>手机号码（节点的IP地址及端口）&lt;/li>
&lt;/ul>
&lt;p>每个同学会维护以下内容：&lt;/p>
&lt;ul>
&lt;li>从图书馆分发下来的书本（被分配到需要存储的内容），每本书当然都有书名和书本内容（内容以&amp;lt;key, value&amp;gt;对的形式存储，可以理解为文件名和文件内容）；&lt;/li>
&lt;li>一个通讯录，包含一小部分其他同学的学号和手机号，通讯录按学号分层（一个路由表，称为“k-bucket”，按Node ID分层，记录有限个数的其他节点的ID和IP地址及端口）。&lt;/li>
&lt;/ul>
&lt;p>根据上面那个类比，可以看看这个表格：&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-ac0338100a380c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/601/format/webp" alt="">&lt;/p>
&lt;p>概念对比&lt;/p>
&lt;p>&lt;em>（Hash的概念解释，可参见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%2593%2588%25E5%25B8%258C%25E7%25AE%2597%25E6%25B3%2595%2F4960188">百度百科-哈希算法&lt;/a>）&lt;/em>&lt;/p>
&lt;p>&lt;em>关于为什么不是每个同学都有全量通讯录（每个节点都维护全量路由信息）：其一，分布式系统中节点的进入和退出是相当频繁的，每次有变动时都全网广播通讯录更新，通讯量会很大；其二，一旦任意一个同学被坏人绑架了（节点被黑客攻破），则坏人马上就拥有了所有人的手机号码，这并不安全。&lt;/em>&lt;/p>
&lt;h3 id="3文件的存储及查找">3）文件的存储及查找&lt;/h3>
&lt;p>原来收藏在图书馆里，按索引号码得整整齐齐的书，以一种什么样的方式分发到同学们手里呢？大致的原则，包括：1）书本能够比较均衡地分布在同学们的手里，不会出现部分同学手里书特别多、而大部分同学连一本书都没有的情况；2）同学想找一本特定的书的时候，能够一种相对简单的索引方式找到这本书。&lt;br>
Kademlia作了下面这种安排：&lt;br>
假设《分布式算法》这本书的书名的hash值是 &lt;em>00010000&lt;/em>，那么这本书就会被要求存在学号为&lt;em>00010000&lt;/em>的同学手上。（这要求hash算法的值域与node ID的值域一致。Kademlia的Node ID是160位2进制。这里的示例对Node ID进行了简略）&lt;br>
但还得考虑到会有同学缺勤。万一&lt;em>00010000&lt;/em>今天没来上学（节点没有上线或彻底退出网络），那《分布式算法》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求同时存储在学号最接近&lt;em>00010000&lt;/em>的k位同学手上，即&lt;em>00010001&lt;/em>、&lt;em>00010010&lt;/em>、&lt;em>00010011&lt;/em>…等同学手上都会有这本书。&lt;/p>
&lt;p>同样地，当你需要找《分布式算法》这本书时，将书名hash一下，得到 &lt;em>00010000&lt;/em>，这个便是索书号，你就知道该找哪（几）位同学了。剩下的问题，就是找到这（几）位同学的手机号。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-54dfcb165392638e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp" alt="">&lt;/p>
&lt;p>书籍搜索定位&lt;/p>
&lt;h3 id="4节点的异或距离">4）节点的异或距离&lt;/h3>
&lt;p>由于你手上只有一部分同学的通讯录，你很可能并没有&lt;em>00010000&lt;/em>的手机号（IP地址）。那如何联系上目标同学呢？&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-41d8839bc652fea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/338/format/webp" alt="">&lt;/p>
&lt;p>通讯录上并没有目标同学的情况&lt;/p>
&lt;p>一个可行的思路就是在你的通讯录里找到一位拥有目标同学的联系方式的同学。前面提到，每位同学手上的通讯录都是按距离分层的。算法的设计是，如果一个同学离你越近，你手上的通讯录里存有ta的手机号码的概率越大。而算法的核心的思路就可以是：当你知道目标同学Z与你之间的距离，你可以在你的通讯录上先找到一个你认为与同学Z最相近的同学B，请同学B再进一步去查找同学Z的手机号。&lt;/p>
&lt;p>上文提到的距离，是学号（Node ID）之间的异或距离(XOR distance）。异或是针对yes/no或者二进制的运算.&lt;/p>
&lt;blockquote>
&lt;p>异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）&lt;br>
&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%25BC%2582%25E6%2588%2596%2F10993677%3Ffr%3Daladdin">百度百科-异或&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>举2个例子：&lt;br>
&lt;em>01010000&lt;/em>与&lt;em>01010010&lt;/em>距离（即是2个ID的异或值）为&lt;em>00000010&lt;/em>（换算为十进制即为2）；&lt;br>
&lt;em>01000000&lt;/em>与&lt;em>00000001&lt;/em>距离为&lt;em>01000001&lt;/em>（换算为十进制即为26+1，即65）；&lt;br>
如此类推。&lt;/p>
&lt;p>那通讯录是如何按距离分层呢？下面的示例会告诉你，按异或距离分层，基本上可以理解为按位数分层。设想以下情景：&lt;br>
以&lt;em>0000110&lt;/em>为基础节点，如果一个节点的ID，前面所有位数都与它相同，只有最后1位不同，这样的节点只有1个——&lt;em>0000111&lt;/em>，与基础节点的异或值为&lt;em>0000001&lt;/em>，即距离为1；对于&lt;em>0000110&lt;/em>而言，这样的节点归为**“k-bucket 1”**；&lt;br>
如果一个节点的ID，前面所有位数相同，从倒数第2位开始不同，这样的节点只有2个：*0000101*、*0000100*，与基础节点的异或值为*0000011*和*0000010*，即距离范围为3和2；对于*0000110*而言，这样的节点归为**“k-bucket 2”**；&lt;br>
……&lt;br>
如果一个节点的ID，前面所有位数相同，从倒数第n位开始不同，这样的节点只有2(i-1)个，与基础节点的距离范围为[2(i-1), 2i）；对于*0000110*而言，这样的节点归为**“k-bucket i”**；&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-6bdd6e96a80d0780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/430/format/webp" alt="">&lt;/p>
&lt;p>按位数区分k-bucket&lt;/p>
&lt;p>对上面描述的另一种理解方式：如果将整个网络的节点梳理为一个按节点ID排列的二叉树，树最末端的每个叶子便是一个节点，则下图就比较直观的展现出，节点之间的距离的关系。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-c12846900b0525db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/913/format/webp" alt="">&lt;/p>
&lt;p>k-bucket示意图：右下角的黑色实心圆，为基础节点（按wiki百科的配图修改）&lt;/p>
&lt;p>回到我们的类比。每个同学只维护一部分的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中只记录k位同学的手机号（k个节点的地址与端口，这里的k是一个可调节的常量参数）。&lt;br>
由于学号（节点的ID）有160位，所以每个同学的通讯录中共分160层（节点共有160个k-bucket）。整个网络最多可以容纳2^160个同学（节点），但是每个同学（节点）最多只维护160 * k 行通讯录（其他节点的地址与端口）。&lt;/p>
&lt;h3 id="5节点定位">5）节点定位&lt;/h3>
&lt;p>我们现在来阐述一个完整的索书流程。&lt;/p>
&lt;p>A同学（学号&lt;em>00000110&lt;/em>）想找《分布式算法》，A首先需要计算书名的哈希值，hash(《分布式算法》) = &lt;em>00010000&lt;/em>。那么A就知道ta需要找到&lt;em>00010000&lt;/em>号同学（命名为Z同学）或学号与Z邻近的同学。&lt;br>
Z的学号&lt;em>00010000&lt;/em>与自己的异或距离为 &lt;em>00010110&lt;/em>，距离范围在[24, 25)，所以这个Z同学可能在k-bucket 5中（或者说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。&lt;br>
然后A同学看看自己的k-bucket 5有没有Z同学：&lt;/p>
&lt;ul>
&lt;li>如果有，那就直接联系Z同学要书；&lt;/li>
&lt;li>如果没有，在k-bucket 5里随便找一个B同学（注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于24，相当于比Z、A之间的距离缩短了一半以上），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：&lt;br>
&amp;ndash; 如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；&lt;br>
&amp;ndash; 如果B也不知道Z同学，那B按同样的搜索方法，可以在自己的通讯录里找到一个离Z更近的C同学（Z、C之间距离小于23），把C同学推荐给A；A同学请求C同学进行下一步查找。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-1396765e4e0afb12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/866/format/webp" alt="">&lt;/p>
&lt;p>查询方式示意&lt;/p>
&lt;p>Kademlia的这种查询机制，有点像是将一张纸不断地对折来收缩搜索范围，保证对于任意n个学生，最多只需要查询log2(n)次，即可找到获得目标同学的联系方式（即在对于任意一个有[2(n−1), 2n)个节点的网络，最多只需要n步搜索即可找到目标节点）。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-1143169c8318a2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp" alt="">&lt;/p>
&lt;p>每次搜索都将距离至少收缩一半&lt;/p>
&lt;p>以上便是Kademlia算法的基本原理。以下再简要介绍协议中的技术细节。&lt;/p>
&lt;h3 id="6算法的三个参数keyspacek和α">6）算法的三个参数：keyspace，k和α&lt;/h3>
&lt;ul>
&lt;li>keyspace&lt;br>
&amp;ndash; 即ID有多少位&lt;br>
&amp;ndash; 决定每个节点的通讯录有几层&lt;/li>
&lt;li>k&lt;br>
&amp;ndash; 每个一层k-bucket里装k个node的信息，即&amp;lt;node ID, IP Adress, port&amp;gt;&lt;br>
&amp;ndash; 每次查找node时，返回k个node的信息&lt;br>
&amp;ndash; 对于某个特定的data，离其key最近的k个节点被会要求存储这个data&lt;/li>
&lt;li>α&lt;br>
&amp;ndash; 每次向其他node请求查找某个node时，会向α个node发出请求&lt;/li>
&lt;/ul>
&lt;h3 id="7节点的指令">7）节点的指令&lt;/h3>
&lt;p>Kademlia算法中，每个节点只有4个指令&lt;/p>
&lt;ul>
&lt;li>PING&lt;br>
&amp;ndash; 测试一个节点是否在线&lt;/li>
&lt;li>STORE&lt;br>
&amp;ndash; 要求一个节点存储一份数据&lt;/li>
&lt;li>FIND_NODE&lt;br>
&amp;ndash; 根据节点ID查找一个节点&lt;/li>
&lt;li>FIND_VALUE&lt;br>
&amp;ndash; 根据KEY查找一个数据，实则上跟FIND_NODE非常类似&lt;/li>
&lt;/ul>
&lt;h3 id="8k-bucket的维护及更新机制">8)k-bucket的维护及更新机制&lt;/h3>
&lt;ul>
&lt;li>每个bucket里的节点都按最后一次接触的时间倒序排列&lt;/li>
&lt;li>每次执行四个指令中的任意一个都会触发更新&lt;/li>
&lt;li>当一个节点与自己接触时，检查它是否在K-bucket中&lt;br>
&amp;ndash; 如果在，那么将它挪到k-bucket列表的最底（最新）&lt;br>
&amp;ndash; 如果不在，PING一下列表最上面（最旧）的一个节点&lt;br>
&amp;ndash; a) 如果PING通了，将旧节点挪到列表最底，并丢弃新节点&lt;br>
&amp;ndash; b) 如果PING不通，删除旧节点，并将新节点加入列表&lt;/li>
&lt;/ul>
&lt;p>该机制保证了任意节点加入和离开都不影响整体网络。&lt;/p>
&lt;h3 id="9总结">9）总结&lt;/h3>
&lt;p>Kademlia是分布式哈希表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。在这类系统中，每个节点（node）分别维护一部分的存储内容以及其他节点的路由/地址，使得网络中任何参与者（即节点）发生变更（进入/退出）时，对整个网络造成的影响最小。DHT可以用于构建更复杂的应用，包括分布式文件系统、点对点技术文件分享系统、合作的网页高速缓存、域名系统以及实时通信等。&lt;br>
Kademlia算法在2002年由Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点。Kademlia后来被eMule、BitTorrent等P2P软件采用作为底层算法。Kademlia可以作为信息安全技术的奠基之一。&lt;br>
Kademlia的优点在于：&lt;/p>
&lt;ul>
&lt;li>对于任意一个有[ 2(n−1) ,2𝑛)个节点的网络，最多只需要n步搜索即可找到目标节点；&lt;/li>
&lt;li>K-bucket的更新机制一定程度上保持了网络的活性和安全性。&lt;/li>
&lt;/ul>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDistributed_hash_table">wiki百科-分布式哈希表&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FKademlia">wiki百科-Kademlia&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=http%3A%2F%2Fpdos.csail.mit.edu%2F%7Epetar%2Fpapers%2Fmaymounkov-kademlia-lncs.pdf">Kademlia: A Peer-to-peer information system based on the XOR Metric&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000000351815">王子亭的Kademlia笔记&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>