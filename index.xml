<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 13 Jun 2022 16:32:28 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Rust模块及包管理</title><link>https://justice.bj.cn/post/14.language/rust/80.rust%E5%8C%85%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 13 Jun 2022 16:32:28 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/80.rust%E5%8C%85%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="rust模块及包管理">Rust模块及包管理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Rust程序代码组织分为三个层级：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>项目(package)&lt;/strong>：一个项目工程，一个项目通常由一个&lt;code>cargo.toml&lt;/code>定义，可包含多个crate；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>包(crate)&lt;/strong>：是一个独立的可编译单元成二进制的单元，可分为bin和lib两种类型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>模块(mod)&lt;/strong>：是包内代码组织单元，用于实现命名空间；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="项目package">项目(Package)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>项目是由cargo.toml定义的一个rust源码编译目录结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个项目由一个或多个crate组成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>项目可由cargo命令进行管理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="p">[&lt;/span>&lt;span class="nx">package&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;crate-name&amp;#34;&lt;/span>
&lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.1.0&amp;#34;&lt;/span>
&lt;span class="nx">authors&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;xxx&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">edition&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;2018&amp;#34;&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#xxx&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">features&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#default = [&amp;#34;test&amp;#34;]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="包crate">包(Crate)&lt;/h2>
&lt;p>包(&lt;code>crate&lt;/code>)是rust可独立编译的单元，包要点如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>包&lt;code>crate&lt;/code> 由一个或一批文件组成，可独立编译为二进制文件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>包分为两种类型：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>库(lib):&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可执行二进制文件(bin):&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>同一个crate的文件一般放在同一个目录下；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个crate有一个入口文件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>二进制包入口为&lt;code>main.rs&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>库的入口文件是&lt;code>lib.rs&lt;/code>;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>引入外部crate：&lt;code>extern crate xxx;&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用未发布的本地crate, 在&lt;code>Cargo.toml&lt;/code> &lt;code>dependencies&lt;/code>中声明；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="c">#... &lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#xxx&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">features&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#default = [&amp;#34;test&amp;#34;]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="模块module">模块（module）&lt;/h2>
&lt;p>模块(&lt;code>mod&lt;/code>)是包内部代码组织单元，模块要点如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>模块由关键字&lt;code>mod&lt;/code>定义：&lt;code>mod XXX { ... } &lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块的命名风格是 &lt;code>lower_snake_case&lt;/code>，跟其它的 Rust 的标识符一样；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块可以嵌套；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块中可以写任何合法的 Rust 代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个包默认实现了一个隐式的 &lt;code>根模块（root module）&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个文件就是一个mod, mod名就是文件名，main.rs, lib.rs, mod.rs文件除外；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mod.rs&lt;/code>的模块名是其所在目录的名字；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>main.rs&lt;/code>, &lt;code>lib.rs&lt;/code> 的模块名是其目录结构，如：&lt;code>exp/src/main.rs&lt;/code>或 &lt;code>lip/src/lib.rs&lt;/code> 的mod名分别是exp和lip；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mod foo;&lt;/code> 告诉编译器找寻./foo.rs或者./foo/mod.rs，并且将找寻到的文件内容作为module foo的内容;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文件和文件夹内的mod及其内部定义的函数默认都是private的，除非pub声明公开；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>private元素只有本模块内的元素以及它的子模块可以访问；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>public元素上一层的模块就有权访问它；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果存在与文件&lt;code>foo.rs&lt;/code>同名的目录&lt;code>foo/&lt;/code>， 则在该目录&lt;code>foo/*.rs&lt;/code>下定义的模块都是该文件的子模块；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>子模块必须在父模块在**声明(**mod child)，不然它们就不会存在。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">foo&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//声明mod
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//是将一个模块加进当前的scope。
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Rust 的多层模块遵循如下两条规则：&lt;/p>
&lt;ol>
&lt;li>优先查找&lt;code>xxx.rs&lt;/code> 文件
&lt;ol>
&lt;li>&lt;code>main.rs&lt;/code>、&lt;code>lib.rs&lt;/code>、&lt;code>mod.rs&lt;/code>中的&lt;code>mod xxx;&lt;/code> 默认优先查找同级目录下的 &lt;code>xxx.rs&lt;/code> 文件；&lt;/li>
&lt;li>其他文件&lt;code>yyy.rs&lt;/code>中的&lt;code>mod xxx;&lt;/code>默认优先查找同级目录的&lt;code>yyy&lt;/code>目录下的 &lt;code>xxx.rs&lt;/code> 文件；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>如果 &lt;code>xxx.rs&lt;/code> 不存在，则查找 &lt;code>xxx/mod.rs&lt;/code> 文件，即 &lt;code>xxx&lt;/code> 目录下的 &lt;code>mod.rs&lt;/code> 文件。&lt;/li>
&lt;/ol>
&lt;p>上述两种情况，加载成模块后，效果是相同的。Rust 就凭这两条规则，通过迭代使用，结合 &lt;code>pub&lt;/code> 关键字，实现了对深层目录下模块的加载；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">src
├── a
│ ├── b
│ │ ├── c
│ │ │ ├── d.rs
│ │ │ └── mod.rs
│ │ └── mod.rs
│ └── mod.rs
└── main.rs
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// a/b/c/d.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">print_ddd&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;i am ddd.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/b/c/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">d&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//声明mode
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/b/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">c&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">b&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">a&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>::&lt;span class="n">b&lt;/span>::&lt;span class="n">c&lt;/span>::&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">d&lt;/span>::&lt;span class="n">print_ddd&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="模块路径">模块路径&lt;/h3>
&lt;p>想要调用一个函数，就需要知道它的路径，在 Rust 中，这种路径有两种形式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>绝对路径&lt;/strong>，从包根开始，路径名以包名或者 &lt;code>crate&lt;/code> 作为开头&lt;/li>
&lt;li>&lt;strong>相对路径&lt;/strong>，从当前模块开始，以 &lt;code>self&lt;/code>，&lt;code>super&lt;/code> 或当前模块的标识符作为开头&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// src/lib.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">front_of_house&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">hosting&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">add_to_waitlist&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">eat_at_restaurant&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 绝对路径
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">crate&lt;/span>::&lt;span class="n">front_of_house&lt;/span>::&lt;span class="n">hosting&lt;/span>::&lt;span class="n">add_to_waitlist&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 相对路径
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">front_of_house&lt;/span>::&lt;span class="n">hosting&lt;/span>::&lt;span class="n">add_to_waitlist&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="模块系统">模块系统&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>单文件rust 中称为&lt;code>mod&lt;/code>，模块的名称就是文件的名称。&lt;/p>
&lt;p>模块内部的函数，只能在模块内部使用，如果要在模块外调用，需要用&lt;code>pub&lt;/code>关键词，显式声明函数可在外部使用。&lt;/p>
&lt;p>使用时，使用mod声明引入，mod name::&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//file: rustmod/src/functions.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 嵌套子模块
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">util&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rust/src/main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">functions&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//声明模块
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">functions&lt;/span>::&lt;span class="n">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">functions&lt;/span>::&lt;span class="n">util&lt;/span>::&lt;span class="n">hello2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用mod.rs, mod 会去对应目录下mod.rs中导入该目录下声明的mod&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//file: rustmod/src/util/functions.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rustmod/src/util/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">functions&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rustmod/src/main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">util&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">util&lt;/span>::&lt;span class="n">functions&lt;/span>::&lt;span class="n">util&lt;/span>::&lt;span class="n">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在同一层级不能同时存在文件夹和文件类型的模块，否则会名字冲突。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="典型rust项目结构">典型rust项目结构&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">.
├── Cargo.toml &lt;span class="c1">## cargo配置文件&lt;/span>
├── Cargo.lock
├── src
│ ├── main.rs &lt;span class="c1">## 默认二进制包入口&lt;/span>
│ ├── lib.rs &lt;span class="c1">## 默认lib包入口&lt;/span>
│ └── bin
│ └── main1.rs &lt;span class="c1">## 二进制可执行文件main1&lt;/span>
│ └── main2.rs &lt;span class="c1">## 二进制可执行文件main2&lt;/span>
├── tests
│ └── some_integration_tests.rs &lt;span class="c1">## 集成测试&lt;/span>
├── benches
│ └── simple_bench.rs &lt;span class="c1">## 性能测试&lt;/span>
└── examples
└── simple_example.rs &lt;span class="c1">## example&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://course.rs/basic/crate-module/intro.html#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97">Rust语言圣经(Rust Course)-包和模块&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Substrate</title><link>https://justice.bj.cn/post/60.blockchain/substrate/</link><pubDate>Mon, 13 Jun 2022 16:32:28 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/substrate/</guid><description>&lt;h1 id="substrate">Substrate&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2></description></item><item><title>区块链UTXO模型</title><link>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BEutxo%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 13 Jun 2022 16:32:28 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/%E5%8C%BA%E5%9D%97%E9%93%BEutxo%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="区块链utxo模型">区块链UTXO模型&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>UTXO(Unspent Transaction Output)是区块链中用来保存区块账户记录的方式之一。&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>基本计算器</title><link>https://justice.bj.cn/post/leetcode/doc/224.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</link><pubDate>Mon, 13 Jun 2022 16:32:28 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/224.%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</guid><description>&lt;h1 id="基本计算器httpsleetcodecnproblemsbasic-calculatordescription-httpsleetcodecnproblemsbasic-calculatordescription">&lt;a href="https://leetcode.cn/problems/basic-calculator/description/" title="https://leetcode.cn/problems/basic-calculator/description/">基本计算器&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Hard (41.92%)&lt;/td>
&lt;td>777&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/math" title="https://leetcode.com/tag/math">&lt;code>math&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/stack" title="https://leetcode.com/tag/stack">&lt;code>stack&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>google&lt;/code>&lt;/p>
&lt;p>给你一个字符串表达式 &lt;code>s&lt;/code> ，请你实现一个基本计算器来计算并返回它的值。&lt;/p>
&lt;p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 &lt;code>eval()&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;1 + 1&amp;#34;
输出：2
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34; 2-1 + 2 &amp;#34;
输出：3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;(1+(4+5+2)-3)+(6+8)&amp;#34;
输出：23
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= s.length &amp;lt;= 3 * 105&lt;/code>&lt;/li>
&lt;li>&lt;code>s&lt;/code> 由数字、&lt;code>'+'&lt;/code>、&lt;code>'-'&lt;/code>、&lt;code>'('&lt;/code>、&lt;code>')'&lt;/code>、和 &lt;code>' '&lt;/code> 组成&lt;/li>
&lt;li>&lt;code>s&lt;/code> 表示一个有效的表达式&lt;/li>
&lt;li>&amp;lsquo;+&amp;rsquo; 不能用作一元运算(例如， &amp;ldquo;+1&amp;rdquo; 和 &lt;code>&amp;quot;+(2 + 3)&amp;quot;&lt;/code> 无效)&lt;/li>
&lt;li>&amp;lsquo;-&amp;rsquo; 可以用作一元运算(即 &amp;ldquo;-1&amp;rdquo; 和 &lt;code>&amp;quot;-(2 + 3)&amp;quot;&lt;/code> 是有效的)&lt;/li>
&lt;li>输入中不存在两个连续的操作符&lt;/li>
&lt;li>每个数字和运行的计算将适合于一个有符号的 32位 整数&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode.cn/problems/basic-calculator/comments/" title="https://leetcode.cn/problems/basic-calculator/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode.cn/problems/basic-calculator/solution/" title="https://leetcode.cn/problems/basic-calculator/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> ## 解题思路
&lt;/span>&lt;span class="cm"> * 对于表达式： 1+(4—(5+2))-3+(6+8)-(10-(19-3))
&lt;/span>&lt;span class="cm"> = 1 + 4 + (-5) + (-2) + (-3) + 6 + 8 + (-10) + (--19) + (---3)
&lt;/span>&lt;span class="cm"> * 可以看出, 结果 = 各个数字与其前面的符号 的 和 组成
&lt;/span>&lt;span class="cm"> * 各个数字前面的符号由嵌套括号决定，每多一层括号，
&lt;/span>&lt;span class="cm"> * 如果括号前为+, 则括号中的各个数字符号不变；
&lt;/span>&lt;span class="cm"> * 如果括号前符号为-, 则括号中各个数字的符号取反；
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">calculate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//每个操作数的符号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//符号
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//空格，跳过
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;+&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//+, 上级符号不编号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;-&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//-，上级符号变相反；
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;(&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//左括号, 符号入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sign&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;)&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//右括号，符号出栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="c1">//数字，计算累加和
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="sc">&amp;#39;9&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">num&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ret&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>blockchain_rust</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Bblockchain/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Bblockchain/</guid><description>&lt;h1 id="blockchain_rust">blockchain_rust&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>blockchain_rust是github上一个基于rust的blockchain实现；&lt;/p>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;ul>
&lt;li>block：&lt;/li>
&lt;/ul>
&lt;h2 id="操作">操作&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ mkdir -p data/node&lt;span class="o">{&lt;/span>1,2,3&lt;span class="o">}&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ &lt;span class="nb">cd&lt;/span> data/node1
&lt;span class="c1">## 创建wallet&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 13teoDGrDNhMrgGHHRESv7bhcnJoXnicqE
&lt;span class="c1">## 创建block0&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createblockchain 13teoDGrDNhMrgGHHRESv7bhcnJoXnicqE
Mining the block
00518dae1ee13a19da96d24f865654eed74dfb3188f4ae0fe56616c03535acb9
Done!
&lt;span class="c1">## 手动同步创世区块数据&lt;/span>
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span> &lt;span class="nb">cd&lt;/span> data/node2&lt;span class="p">;&lt;/span> cp -rf ../node1/data .
&lt;span class="o">[&lt;/span>node3&lt;span class="o">]&lt;/span> &lt;span class="nb">cd&lt;/span> data/node3&lt;span class="p">;&lt;/span> cp -rf ../node1/data .
&lt;span class="c1">## node2创建钱包&lt;/span>
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1JvjDQGrmzVLLAo9dPsXYNNednuNZrGrAm
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1JvjDQGrmzVLLAo9dPsXYNNednuNZrGrAm
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1FztXwduMcABm6x2yxRWgozqT8g1dgeiFS
&lt;span class="c1">## 转账&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>IPFS(星际文件系统)</title><link>https://justice.bj.cn/post/60.blockchain/ipfs%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/60.blockchain/ipfs%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="ipfs星际文件系统">IPFS(星际文件系统)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>IPFS&lt;/code>(InterPlanetary File System，星际文件系统), 是一个对等的分布式文件系统，用于存储和访问文件、网站、应用程序和数据。IPFS 旨在为分布式 Web——DWeb 提供动力；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPFS项目通过整合已有的技术（BitTorrent、DHT、Git和SFS），创建一种点对点超媒体协议，试图打造一个更加快速、安全、开放的下一代互联网，实现互联网中永久可用、数据可以永久保存的全球文件存储系统。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时，该协议有内容寻址、版本化特性，尝试补充甚至最终取代伴随了我们20多年的超文本传输协议（即HTTP协议）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPFS是一个协议，也是一个P2P网络，它类似于现在的BT网络，只是拥有更强大的功能，使得IPFS拥有可以取代HTTP的潜力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可防止&lt;a href="https://zh.m.wikipedia.org/wiki/DDoS" title="DDoS">DDoS&lt;/a>攻击；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="基本原理">基本原理&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>IPFS先将文件分成一个个block，每个block通过hash得到blockid；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个文件的所有blockid组成一个&lt;code>merkledag&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不同block通过&lt;code>KAD算法&lt;/code>分发到不同的节点上；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为保证可靠性，同一个block 可能有多个copy, 分别存储在不同的网络节点上；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="filecoin">Filecoin&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Filecoin是运行在IPFS上的一个激励层，是一个基于区块链的分布式存储网络，它把云存储变为一个算法市场，代币（FIL）在这里起到了很重要的作用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代币是沟通资源（存储和检索）使用者（IPFS用户）和资源的提供者（Filecoin矿工）之间的中介桥梁，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Filecoin协议拥有两个交易市场—数据检索和数据存储，交易双方在市场里面提交自己的需求，达成交易。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="get">Get&lt;/h2>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/06/12-18-52-38-ipfs_get.gif" alt="loading-ag-185">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zh.m.wikipedia.org/zh-hans/%E6%98%9F%E9%99%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">星际文件系统 - 维基百科，自由的百科全书&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://developer.aliyun.com/article/726565">https://developer.aliyun.com/article/726565&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.jianshu.com/p/3f7cc1ee9ec4">IPFS原理初探 - 简书&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.pseudoyu.com/zh/2021/03/25/blockchain_ipfs_structure/">IPFS 分布式存储协议分析与思考 · Pseudoyu&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Kademlia算法</title><link>https://justice.bj.cn/post/13.algorithm/kademlia%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/kademlia%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="kademlia算法">Kademlia算法&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Kademlia算法是2002年由Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kademlia后来被eMule、BitTorrent等P2P软件采用作为底层算法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kademlia可以作为信息安全技术的奠基之一。&lt;br>
Kademlia的优点在于：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>对于任意一个有[ 2(n−1) ,2𝑛)个节点的网络，最多只需要n步搜索即可找到目标节点；&lt;/li>
&lt;li>K-bucket的更新机制一定程度上保持了网络的活性和安全性。&lt;/li>
&lt;/ul>
&lt;p>Kademlia算法是一种分布式存储及路由的算法。&lt;/p>
&lt;p>什么是分布式存储？试想一下，一所1000人的学校，现在学校突然决定拆掉图书馆（不设立中心化的服务器），将图书馆里所有的书都分发到每位学生手上（所有的文件分散存储在各个节点上）。即是所有的学生，共同组成了一个分布式的图书馆。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-795f3af7231108b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="">&lt;/p>
&lt;p>由中心图书馆到分布式图书馆&lt;/p>
&lt;p>在这种场景下，有几个关键的问题需要回答。&lt;/p>
&lt;h3 id="1关键问题">1）关键问题&lt;/h3>
&lt;ol>
&lt;li>每个同学手上都分配哪些书。即如何分配存储内容到各个节点，新增/删除内容如何处理。&lt;/li>
&lt;li>当你需要找到一本书，譬如《分布式算法》的时候，如何知道哪位同学手上有《分布式算法》（对1000个人挨个问一遍，“你有没有《分布式算法》？”，显然是个不经济的做法），又如何联系上这位同学。即一个节点如果想获取某个特定的文件，如何找到存储文件的节点/地址/路径。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-8b12f9959fa3144f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/358/format/webp" alt="">&lt;/p>
&lt;p>如何寻找需要的书籍？&lt;/p>
&lt;p>接下来，让我们来看看Kademlia算法如何巧妙地解决这些问题。&lt;/p>
&lt;h3 id="2节点的要素">2）节点的要素&lt;/h3>
&lt;p>首先我们来看看每个同学（节点）都有哪些属性：&lt;/p>
&lt;ul>
&lt;li>学号（Node ID，2进制，160位）&lt;/li>
&lt;li>手机号码（节点的IP地址及端口）&lt;/li>
&lt;/ul>
&lt;p>每个同学会维护以下内容：&lt;/p>
&lt;ul>
&lt;li>从图书馆分发下来的书本（被分配到需要存储的内容），每本书当然都有书名和书本内容（内容以&amp;lt;key, value&amp;gt;对的形式存储，可以理解为文件名和文件内容）；&lt;/li>
&lt;li>一个通讯录，包含一小部分其他同学的学号和手机号，通讯录按学号分层（一个路由表，称为“k-bucket”，按Node ID分层，记录有限个数的其他节点的ID和IP地址及端口）。&lt;/li>
&lt;/ul>
&lt;p>根据上面那个类比，可以看看这个表格：&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-ac0338100a380c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/601/format/webp" alt="">&lt;/p>
&lt;p>概念对比&lt;/p>
&lt;p>&lt;em>（Hash的概念解释，可参见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%2593%2588%25E5%25B8%258C%25E7%25AE%2597%25E6%25B3%2595%2F4960188">百度百科-哈希算法&lt;/a>）&lt;/em>&lt;/p>
&lt;p>&lt;em>关于为什么不是每个同学都有全量通讯录（每个节点都维护全量路由信息）：其一，分布式系统中节点的进入和退出是相当频繁的，每次有变动时都全网广播通讯录更新，通讯量会很大；其二，一旦任意一个同学被坏人绑架了（节点被黑客攻破），则坏人马上就拥有了所有人的手机号码，这并不安全。&lt;/em>&lt;/p>
&lt;h3 id="3文件的存储及查找">3）文件的存储及查找&lt;/h3>
&lt;p>原来收藏在图书馆里，按索引号码得整整齐齐的书，以一种什么样的方式分发到同学们手里呢？&lt;/p>
&lt;p>大致的原则，包括：&lt;/p>
&lt;p>    1）书本能够比较均衡地分布在同学们的手里，不会出现部分同学手里书特别多、而大部分同学连一本书都没有的情况；&lt;/p>
&lt;p>    2）同学想找一本特定的书的时候，能够一种相对简单的索引方式找到这本书。&lt;br>
Kademlia作了下面这种安排：&lt;br>
假设《分布式算法》这本书的书名的hash值是 &lt;em>00010000&lt;/em>，那么这本书就会被要求存在学号为&lt;em>00010000&lt;/em>的同学手上。（这要求hash算法的值域与node ID的值域一致。Kademlia的Node ID是160位2进制。这里的示例对Node ID进行了简略）&lt;br>
但还得考虑到会有同学缺勤。万一&lt;em>00010000&lt;/em>今天没来上学（节点没有上线或彻底退出网络），那《分布式算法》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求同时存储在学号最接近&lt;em>00010000&lt;/em>的k位同学手上，即&lt;em>00010001&lt;/em>、&lt;em>00010010&lt;/em>、&lt;em>00010011&lt;/em>…等同学手上都会有这本书。&lt;/p>
&lt;p>同样地，当你需要找《分布式算法》这本书时，将书名hash一下，得到 &lt;em>00010000&lt;/em>，这个便是索书号，你就知道该找哪（几）位同学了。剩下的问题，就是找到这（几）位同学的手机号。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-54dfcb165392638e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp" alt="">&lt;/p>
&lt;p>书籍搜索定位&lt;/p>
&lt;h3 id="4节点的异或距离">4）节点的异或距离&lt;/h3>
&lt;p>由于你手上只有一部分同学的通讯录，你很可能并没有&lt;em>00010000&lt;/em>的手机号（IP地址）。那如何联系上目标同学呢？&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-41d8839bc652fea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/338/format/webp" alt="">&lt;/p>
&lt;p>通讯录上并没有目标同学的情况&lt;/p>
&lt;p>一个可行的思路就是在你的通讯录里找到一位拥有目标同学的联系方式的同学。前面提到，每位同学手上的通讯录都是按距离分层的。算法的设计是，如果一个同学离你越近，你手上的通讯录里存有ta的手机号码的概率越大。而算法的核心的思路就可以是：当你知道目标同学Z与你之间的距离，你可以在你的通讯录上先找到一个你认为与同学Z最相近的同学B，请同学B再进一步去查找同学Z的手机号。&lt;/p>
&lt;p>上文提到的距离，是学号（Node ID）之间的异或距离(XOR distance）。异或是针对yes/no或者二进制的运算.&lt;/p>
&lt;blockquote>
&lt;p>异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）&lt;br>
&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%25BC%2582%25E6%2588%2596%2F10993677%3Ffr%3Daladdin">百度百科-异或&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>举2个例子：&lt;br>
&lt;em>01010000&lt;/em>与&lt;em>01010010&lt;/em>距离（即是2个ID的异或值）为&lt;em>00000010&lt;/em>（换算为十进制即为2）；&lt;br>
&lt;em>01000000&lt;/em>与&lt;em>00000001&lt;/em>距离为&lt;em>01000001&lt;/em>（换算为十进制即为26+1，即65）；&lt;br>
如此类推。&lt;/p>
&lt;p>那通讯录是如何按距离分层呢？下面的示例会告诉你，按异或距离分层，基本上可以理解为按位数分层。设想以下情景：&lt;br>
以&lt;em>0000110&lt;/em>为基础节点，如果一个节点的ID，前面所有位数都与它相同，只有最后1位不同，这样的节点只有1个——&lt;em>0000111&lt;/em>，与基础节点的异或值为&lt;em>0000001&lt;/em>，即距离为1；对于&lt;em>0000110&lt;/em>而言，这样的节点归为**“k-bucket 1”**；&lt;br>
如果一个节点的ID，前面所有位数相同，从倒数第2位开始不同，这样的节点只有2个：*0000101*、*0000100*，与基础节点的异或值为*0000011*和*0000010*，即距离范围为3和2；对于*0000110*而言，这样的节点归为**“k-bucket 2”**；&lt;br>
……&lt;br>
如果一个节点的ID，前面所有位数相同，从倒数第n位开始不同，这样的节点只有2(i-1)个，与基础节点的距离范围为[2(i-1), 2i）；对于*0000110*而言，这样的节点归为**“k-bucket i”**；&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-6bdd6e96a80d0780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/430/format/webp" alt="">&lt;/p>
&lt;p>按位数区分k-bucket&lt;/p>
&lt;p>对上面描述的另一种理解方式：如果将整个网络的节点梳理为一个按节点ID排列的二叉树，树最末端的每个叶子便是一个节点，则下图就比较直观的展现出，节点之间的距离的关系。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-c12846900b0525db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/913/format/webp" alt="">&lt;/p>
&lt;p>k-bucket示意图：右下角的黑色实心圆，为基础节点（按wiki百科的配图修改）&lt;/p>
&lt;p>回到我们的类比。每个同学只维护一部分的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中只记录k位同学的手机号（k个节点的地址与端口，这里的k是一个可调节的常量参数）。&lt;br>
由于学号（节点的ID）有160位，所以每个同学的通讯录中共分160层（节点共有160个k-bucket）。整个网络最多可以容纳2^160个同学（节点），但是每个同学（节点）最多只维护160 * k 行通讯录（其他节点的地址与端口）。&lt;/p>
&lt;h3 id="5节点定位">5）节点定位&lt;/h3>
&lt;p>我们现在来阐述一个完整的索书流程。&lt;/p>
&lt;p>A同学（学号&lt;em>00000110&lt;/em>）想找《分布式算法》，&lt;/p>
&lt;p>A首先需要计算书名的哈希值，hash(《分布式算法》) = &lt;em>00010000&lt;/em>。那么A就知道ta需要找到&lt;em>00010000&lt;/em>号同学（命名为Z同学）或学号与Z邻近的同学。&lt;br>
Z的学号&lt;em>00010000&lt;/em>与自己的异或距离为 &lt;em>00010110&lt;/em>，距离范围在[24, 25)，所以这个Z同学可能在k-bucket 5中（或者说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。&lt;br>
然后A同学看看自己的k-bucket 5有没有Z同学：&lt;/p>
&lt;ul>
&lt;li>如果有，那就直接联系Z同学要书；&lt;/li>
&lt;li>如果没有，在k-bucket 5里随便找一个B同学（注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于24，相当于比Z、A之间的距离缩短了一半以上），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：&lt;br>
&amp;ndash; 如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；&lt;br>
&amp;ndash; 如果B也不知道Z同学，那B按同样的搜索方法，可以在自己的通讯录里找到一个离Z更近的C同学（Z、C之间距离小于23），把C同学推荐给A；A同学请求C同学进行下一步查找。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-1396765e4e0afb12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/866/format/webp" alt="">&lt;/p>
&lt;p>查询方式示意&lt;/p>
&lt;p>Kademlia的这种查询机制，有点像是将一张纸不断地对折来收缩搜索范围，保证对于任意n个学生，最多只需要查询log2(n)次，即可找到获得目标同学的联系方式（即在对于任意一个有[2(n−1), 2n)个节点的网络，最多只需要n步搜索即可找到目标节点）。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/947209-1143169c8318a2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp" alt="">&lt;/p>
&lt;p>每次搜索都将距离至少收缩一半&lt;/p>
&lt;p>以上便是Kademlia算法的基本原理。&lt;/p>
&lt;p>以下再简要介绍协议中的技术细节。&lt;/p>
&lt;h3 id="6算法的三个参数keyspacek和α">6）算法的三个参数：keyspace，k和α&lt;/h3>
&lt;ul>
&lt;li>keyspace&lt;br>
&amp;ndash; 即ID有多少位&lt;br>
&amp;ndash; 决定每个节点的通讯录有几层&lt;/li>
&lt;li>k&lt;br>
&amp;ndash; 每个一层k-bucket里装k个node的信息，即&amp;lt;node ID, IP Adress, port&amp;gt;&lt;br>
&amp;ndash; 每次查找node时，返回k个node的信息&lt;br>
&amp;ndash; 对于某个特定的data，离其key最近的k个节点被会要求存储这个data&lt;/li>
&lt;li>α&lt;br>
&amp;ndash; 每次向其他node请求查找某个node时，会向α个node发出请求&lt;/li>
&lt;/ul>
&lt;h3 id="7节点的指令">7）节点的指令&lt;/h3>
&lt;p>Kademlia算法中，每个节点只有4个指令&lt;/p>
&lt;ul>
&lt;li>PING&lt;br>
&amp;ndash; 测试一个节点是否在线&lt;/li>
&lt;li>STORE&lt;br>
&amp;ndash; 要求一个节点存储一份数据&lt;/li>
&lt;li>FIND_NODE&lt;br>
&amp;ndash; 根据节点ID查找一个节点&lt;/li>
&lt;li>FIND_VALUE&lt;br>
&amp;ndash; 根据KEY查找一个数据，实则上跟FIND_NODE非常类似&lt;/li>
&lt;/ul>
&lt;h3 id="8k-bucket的维护及更新机制">8)k-bucket的维护及更新机制&lt;/h3>
&lt;ul>
&lt;li>每个bucket里的节点都按最后一次接触的时间倒序排列&lt;/li>
&lt;li>每次执行四个指令中的任意一个都会触发更新&lt;/li>
&lt;li>当一个节点与自己接触时，检查它是否在K-bucket中&lt;br>
&amp;ndash; 如果在，那么将它挪到k-bucket列表的最底（最新）&lt;br>
&amp;ndash; 如果不在，PING一下列表最上面（最旧）的一个节点&lt;br>
&amp;ndash; a) 如果PING通了，将旧节点挪到列表最底，并丢弃新节点&lt;br>
&amp;ndash; b) 如果PING不通，删除旧节点，并将新节点加入列表&lt;/li>
&lt;/ul>
&lt;p>该机制保证了任意节点加入和离开都不影响整体网络。&lt;/p>
&lt;h3 id="9总结">9）总结&lt;/h3>
&lt;p>Kademlia是分布式哈希表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。&lt;/p>
&lt;p>在这类系统中，每个节点（node）分别维护一部分的存储内容以及其他节点的路由/地址，使得网络中任何参与者（即节点）发生变更（进入/退出）时，对整个网络造成的影响最小。&lt;/p>
&lt;p>DHT可以用于构建更复杂的应用，包括分布式文件系统、点对点技术文件分享系统、合作的网页高速缓存、域名系统以及实时通信等。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDistributed_hash_table">wiki百科-分布式哈希表&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FKademlia">wiki百科-Kademlia&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=http%3A%2F%2Fpdos.csail.mit.edu%2F%7Epetar%2Fpapers%2Fmaymounkov-kademlia-lncs.pdf">Kademlia: A Peer-to-peer information system based on the XOR Metric&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000000351815">王子亭的Kademlia笔记&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Rust特性(trait)</title><link>https://justice.bj.cn/post/14.language/rust/20.rust%E7%89%B9%E6%80%A7trait/</link><pubDate>Sun, 12 Jun 2022 20:44:24 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/20.rust%E7%89%B9%E6%80%A7trait/</guid><description>&lt;h1 id="rust特性trait">Rust特性(trait)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>trait&lt;/code>(特性) 是一组方法的集合，实现trait的类型可以访问该 trait 中定义的其他方法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何类型都可以实现 trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="要点">要点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Trait&lt;/code>必须声明可见后才能使用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Trait本身并没有固定的大小，不能直接声明和使用Trait类型的变量，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>某个实现该Trait类型的实例的有效引用称为&lt;code>Trait Object&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有trait都有一个隐藏的类型&lt;code>Self&lt;/code>，代表当前实现此Trait的具体类型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数&lt;u>第一个参数&lt;/u>是&lt;code>self&lt;/code>且为&lt;code>Self&lt;/code>相关类型(&lt;code>Self, &amp;amp;Self, &amp;amp;mut Self, Box&amp;lt;Self&amp;gt;&lt;/code>)，则函数为&lt;strong>方法&lt;/strong>(method)，&lt;code>self&lt;/code>称为&lt;code>receiver&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有receiver参数的函数为&lt;strong>静态方法&lt;/strong>，可通过&lt;code>Type::Function()&lt;/code>方式调用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>匿名Trait无须名字，可直接在impl中实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以在trait的声明中定义默认方法；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展trait(extension trait), 可以为其它trait类型扩展出自定义trait的接口，impl块必须与trait或struct声明在同一个crate中（孤儿规则）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>继承：凡是实现了Subtrait(&lt;code>Creature&lt;/code>)的类型, 也必须实现父Trait(&lt;code>Visible&lt;/code>)的&lt;strong>所有方法&lt;/strong>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="孤儿规则orphan-rule">孤儿规则(orphan rule)&lt;/h2>
&lt;ul>
&lt;li>如果要实现外部定义的 &lt;code>trait&lt;/code> 需要先将其导入作用域；&lt;/li>
&lt;li>不允许对外部类型实现外部 &lt;code>trait&lt;/code>；&lt;/li>
&lt;li>可以对外部类型实现自定义的 &lt;code>trait&lt;/code>；&lt;/li>
&lt;li>可以对自定义类型上实现外部 &lt;code>trait&lt;/code>；&lt;/li>
&lt;/ul>
&lt;h2 id="示例">示例&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// trait声明
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//method1(self: Self);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//area(self: &amp;amp;Self);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">larger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>: &lt;span class="kt">f64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// trait 实现
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="kt">f64&lt;/span>::&lt;span class="n">consts&lt;/span>::&lt;span class="n">PI&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 匿名trait
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">get_radius&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="trait-泛型">Trait 泛型&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// where 从句
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>: &lt;span class="nc">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>: &lt;span class="nc">K&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>: &lt;span class="nb">Clone&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">K&lt;/span>: &lt;span class="nb">Clone&lt;/span> &lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Debug&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{:?}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="trait对象trait-object">Trait对象(Trait object)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>指向trait的指针就是&lt;code>Trait Object&lt;/code>，比如 &lt;code>&amp;amp;SomeTrait&lt;/code> 和 &lt;code>Box&amp;lt;SomeTrait&amp;gt;&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>&amp;amp;SomeTrait&lt;/code> 类型和普通的指针类型不同, 不仅包括指向真实对象的指针，还包括一个指向虚函数表的指针;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rust通过&lt;code>TraitObject&lt;/code>用来实现动态分发；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Trait Object&lt;/code>实际是一个胖指针&lt;code>fat pointer&lt;/code>, 占用两个机器字字节, 一个指向实际的实例对象, 一个指向虚基表&lt;code>vtable&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::raw
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">TraitObject&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>: &lt;span class="o">*&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vtable&lt;/span>: &lt;span class="o">*&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="supertrait">Supertrait&lt;/h2>
&lt;h2 id="关联类型">关联类型&lt;/h2>
&lt;p>关联类型是一个将类型占位符与trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>关联类型类似泛型，不同之处关联类型，无需标注类型，无须多次实现trait；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Iterator&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span> &lt;span class="nc">Item&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//关联类型
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Self&lt;/span>::&lt;span class="n">Item&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Iterator&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Counter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span> &lt;span class="nc">Item&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Self&lt;/span>::&lt;span class="n">Item&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// --snip--
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="常用trait">常用Trait&lt;/h2>
&lt;h3 id="default">Default&lt;/h3>
&lt;p>Default trait是针对无参构造函数的抽象&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::default::Default
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">default&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// Vec default
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">default&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="derive">Derive&lt;/h3>
&lt;p>Rust提供了一个特殊属性，以自动impl某些trait，编译阶段会自动展开为相应的impl块：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="cp">#[derive(Copy, Clone, Default)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Foo&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Rust支持自动derive的trait有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Debug&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Clone/Copy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hash&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PartialEq/Eq/PartialOrd/Ord&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Send/Sync&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Default&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FromPrimitive&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RustcEncodable/RustcDecodable&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="displaydebug">Display/Debug&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>实现&lt;code>Display&lt;/code>特性的类型，可用&lt;code>{}&lt;/code>格式控制打印；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现&lt;code>Debug&lt;/code>特性的类型，可用&lt;code>{:?},{:#?}&lt;/code>格式控制打印；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Display&lt;/code>一般给最终用户显示的，通常用utf-8格式字符输出；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Debug&lt;/code>特性主要用于调试，一般为byte字符，编译器提供自动derive功能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现&lt;code>Dispaly&lt;/code>特性的类型都自动实现了&lt;code>ToString&lt;/code>特性，可直接通过&lt;code>to_string()&lt;/code>格式化字符串；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::fmt::Display
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Display&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">fmt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Formatter&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//std::fmt::Debug
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Debug&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">fmt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Formatter&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="派生derive">派生(derive)&lt;/h2>
&lt;p>通过 &lt;code>#[derive]&lt;/code> &lt;a href="https://rustwiki.org/zh-CN/rust-by-example/attribute.html">属性&lt;/a>，编译器能够提供某些 trait 的基本实现。如果 需要更复杂的行为，这些 trait 也可以手动实现。&lt;/p>
&lt;p>下面是可以自动派生的 trait：&lt;/p>
&lt;ul>
&lt;li>比较 trait: &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html">&lt;code>Eq&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialEq.html">&lt;code>PartialEq&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html">&lt;code>Ord&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialOrd.html">&lt;code>PartialOrd&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html">&lt;code>Clone&lt;/code>&lt;/a>, 用来从 &lt;code>&amp;amp;T&lt;/code> 创建副本 &lt;code>T&lt;/code>。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/core/marker/trait.Copy.html">&lt;code>Copy&lt;/code>&lt;/a>，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/hash/trait.Hash.html">&lt;code>Hash&lt;/code>&lt;/a>，从 &lt;code>&amp;amp;T&lt;/code> 计算哈希值（hash）。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/default/trait.Default.html">&lt;code>Default&lt;/code>&lt;/a>, 创建数据类型的一个空实例。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/fmt/trait.Debug.html">&lt;code>Debug&lt;/code>&lt;/a>，使用 &lt;code>{:?}&lt;/code> formatter 来格式化一个值。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="cp">#[derive(PartialEq, PartialOrd)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">f64&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// `Inches`，可以打印的元组结构体
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#[derive(Debug)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Inches&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Inches&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">to_centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Centimeters&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">Inches&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inches&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inches&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">f64&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mf">2.54&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="ordpartialordeqpartialeq">Ord/PartialOrd/Eq/PartialEq&lt;/h3>
&lt;h2 id="标签trait">标签Trait&lt;/h2>
&lt;h3 id="sized">Sized&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Sized&lt;/code>是一种&lt;code>maker trait&lt;/code>，表示类型size是固定的 , 没有任何方法和联合类型，无法实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rust不能在变量里保存&lt;em>unsized&lt;/em>的值, 也不能把&lt;em>unsize&lt;/em>的值作为参数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有固定大小的类型都实现里&lt;code>std::marker::Sized&lt;/code>trait；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Sized trait只能用于绑定到类型参数, 也就是用于参数的类型声明(及检查), 例如 &lt;code>T: Sized&lt;/code>不能用于其它用途；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>?Sized&lt;/code>叫 &lt;em>questionably sized&lt;/em>, 允许固定大小, 也允许非固定大小类型.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>struct的最后一个字段允许是&lt;code>?Sized&lt;/code>类型, 但如果这样, struct本身就变为了unsized.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但如果写成泛型, 并传入一个Sized类型, 那么这个类型的struct仍然是Sized. 大小取决于泛型的参数类型:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="copyclone">Copy/Clone&lt;/h3>
&lt;p>Copy:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果一个类型 impl 了 Copy trait，意味着任何时候，我们可以通过简单的内存拷贝实现该类型的复制，而不会产生任何问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦一个类型实现了 Copy trait，那么它在变量绑定、函数参数传递、函数返回值传递等场景下，它都是 copy 语义，而不再是默认的 move 语义；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只有所有的成员都实现了 Copy trait，这个类型才有资格实现 Copy trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Clone:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Clone&lt;/code>是&lt;code>Sized&lt;/code>的sub-trait, 所以Self类型必须是Sized；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>clone&lt;/code>方法必须返回和&lt;code>self&lt;/code>独立无关的一份拷贝；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果所有的字段都实现了Clone, 那么&lt;code>struct&lt;/code>可以加上属性: &lt;code>#[derive(Clone)]&lt;/code>自动实现Clone trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>通常情况下clone的成本比较高, 但是对于&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code>和&lt;code>Arc&amp;lt;T&amp;gt;&lt;/code>这类的类型, Rust的对它们的clone只是简单的增加计数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通常尽可能使用&lt;code>clone_from&lt;/code>来减少clone开销, 这会允许一些优化. 例如, String的clone, 被赋值的String如果capacity够大, 可以不需要释放内存, 直接把源的内容拷贝过来.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果所有的字段都实现了Clone, 那么&lt;code>struct&lt;/code>可以加上属性: &lt;code>#[derive(Clone)]&lt;/code>自动实现Clone trait&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>clone&lt;/code>方法不能失败(&lt;em>infallible&lt;/em>), 对于&lt;code>std::fs::File&lt;/code>这样的类型, 有&lt;code>try_clone&lt;/code>方法, 返回&lt;code>std::io::Result&amp;lt;File&amp;gt;&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Clone&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">clone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">clone_from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">source&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">Self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="frominto">From/Into&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>From&lt;/code>: 对于类型为 &lt;code>U&lt;/code> 的对象 &lt;code>foo&lt;/code>，如果它实现了 &lt;code>From&amp;lt;T&amp;gt;&lt;/code>，那么，可以通过 &lt;code>let foo = U::from(bar)&lt;/code> 来生成自己&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Into&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">into&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">T&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">From&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 静态方法
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// as_ref和Borrow的区别 ?
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// as_ref 是转引用函数, 将具有所有权对象转换成引用对象,
&lt;/span>&lt;span class="c1">// 不改变被转换对象的基础上产生一个引用对象.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// as_ref 并不是所有类型都默认支持, 很多时候都需要自己去声明.
&lt;/span>&lt;span class="c1">// as_ref 是AsRef trait 的公共接口方法.
&lt;/span>&lt;span class="c1">// 只有那些实现了 as_ref 公共接口方法的类型才能使用as_ref.
&lt;/span>&lt;span class="c1">// 目前: Option, Box, Result 这三种类型默认提供支持as_ref.
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://wiki.jikexueyuan.com/project/rust-primer/">https://wiki.jikexueyuan.com/project/rust-primer/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://unpluggedcoder.me/2019/08/31/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BTraits&amp;amp;Generics/">https://unpluggedcoder.me/2019/08/31/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BTraits&amp;amp;Generics/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/21730929">https://zhuanlan.zhihu.com/p/21730929&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://unpluggedcoder.me/2019/09/01/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BUtility%20Traits/">https://unpluggedcoder.me/2019/09/01/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BUtility%20Traits/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://wiki.jikexueyuan.com/project/rust-primer/trait/trait-object.html">https://wiki.jikexueyuan.com/project/rust-primer/trait/trait-object.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/23791817">https://zhuanlan.zhihu.com/p/23791817&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Linux系统调用之Futex</title><link>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</guid><description>&lt;h1 id="linux系统调用之futex">Linux系统调用之Futex&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Futex（Fast Userspace muTexes）的缩写，由Hubertus Franke, Matthew Kirkwood, Ingo Molnar and Rusty Russell共同设计完成，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Futex是一种用户态和内核态混合的同步机制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>同步的进程间通过mmap共享一段内存，futex变量就位于这段共享 的内存中且操作是原子的，&lt;/li>
&lt;li>当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，
3. 如果没有竞争发生，则只修改futex,而不 用再执行系统调用了。
4. 如果futex变量告诉进程有竞争发生，则执行系统调用去完成相应的处理(wait 或者 wake up)。&lt;/li>
&lt;/ol>
&lt;p>futex 函数：&lt;/p>
&lt;ol>
&lt;li>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;/li>
&lt;li>不加timeout参数，它会一直被阻塞，直到FUTEX_WAKE:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/futex.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/time.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">futex&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">timespec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cp">#define __NR_futex 240
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;br>
FUTEX_WAKE: 最多唤醒val个等待在uaddr上进程。&lt;/p>
&lt;p>可见FUTEX_WAIT和FUTEX_WAKE只是用来挂起或者唤醒进程，当然这部分工作也只能在内核态下完成。有些人尝试着直接使用futex系统调 用来实现进程同步，并寄希望获得futex的性能优势，这是有问题的。应该区分futex同步机制和futex系统调用。futex同步机制还包括用户态 下的操作，我们将在下节提到。&lt;/p>
&lt;h2 id="futex同步机制">Futex同步机制&lt;/h2>
&lt;p>所有的futex同步操作都应该从用户空间开始，首先创建一个futex同步变量，也就是位于共享内存的一个整型计数器。&lt;br>
当 进程尝试持有锁或者要进入互斥区的时候，对futex执行&amp;quot;down&amp;quot;操作，即原子性的给futex同步变量减1。如果同步变量变为0，则没有竞争发生， 进程照常执行。如果同步变量是个负数，则意味着有竞争发生，需要调用futex系统调用的futex_wait操作休眠当前进程。&lt;br>
当进程释放锁或 者要离开互斥区的时候，对futex进行&amp;quot;up&amp;quot;操作，即原子性的给futex同步变量加1。如果同步变量由0变成1，则没有竞争发生，进程照常执行。如 果加之前同步变量是负数，则意味着有竞争发生，需要调用futex系统调用的futex_wake操作唤醒一个或者多个等待进程。&lt;/p>
&lt;p>这里的原子性加减通常是用CAS(Compare and Swap)完成的，与平台相关。CAS的基本形式是：CAS(addr,old,new),当addr中存放的值等于old时，用new对其替换。在x86平台上有专门的一条指令来完成它: cmpxchg。&lt;/p>
&lt;p>可见: futex是从用户态开始，由用户态和核心态协调完成的。&lt;/p>
&lt;h2 id="进线程利用futex同步">进/线程利用futex同步&lt;/h2>
&lt;p>进程或者线程都可以利用futex来进行同步。&lt;br>
对于线程，情况比较简单，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量。&lt;br>
对 于进程，情况相对复杂，因为进程有独立的虚拟内存空间，只有通过mmap()让它们共享一段地址空间来使用futex变量。每个进程用来访问futex的 虚拟地址可以是不一样的，只要系统知道所有的这些虚拟地址都映射到同一个物理内存地址，并用物理内存地址来唯一标识futex变量。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.shuzhiduo.com/A/rV57P2rLdP/">linux内核级同步机制&amp;ndash;futex&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/farmerjohngit/myblog/issues/6">关于同步的一点思考-上 · Issue #6 · farmerjohngit/myblog · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>ToyDB</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Btoydb/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Btoydb/</guid><description>&lt;h1 id="toydb">ToyDB&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>&lt;code>toydb&lt;/code>是&lt;code>Erik Grinaker&lt;/code>为学习&lt;code>rust&lt;/code>语言而开发的分布式sql数据库，支持分布式事务模型;&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;code>toydb&lt;/code>主要由3部分组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>sqlengine&lt;/code>: 负责sql语句的解析、执行计划；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>raftengine&lt;/code>: 负责存储层的数据副本同步；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>storage&lt;/code>: 负责提供kv及mvcc存储；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/10/07-18-54-21-2021-10-07-18-54-16-image.png" alt="">&lt;/p>
&lt;h2 id="sql层">SQL层&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>SQL层主要负责将输入的sql语句字符串转化为执行计划，并通过raft交给各个副本的mvcc存储引擎执行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SQL主要分为两个阶段：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>词法分析：sql语句&amp;mdash;&amp;mdash;-&amp;gt;token&amp;mdash;-&amp;gt;AST；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>生成执行计划：AST&amp;mdash;&amp;ndash;&amp;gt;planner&amp;mdash;&amp;ndash;&amp;gt;优化&amp;mdash;&amp;ndash;&amp;gt;执行；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL语句 &amp;ndash;&amp;gt; 词法分析 &amp;mdash;-&amp;gt; 语法分析&amp;mdash;&amp;gt;生成执行计划&amp;mdash;&amp;gt;&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-16-00-47-2021-06-18-16-00-44-image.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-15-38-36-2021-06-18-15-38-32-image.png" alt="">&lt;/p>
&lt;h3 id="词法分析lexer">词法分析(Lexer)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Lexer 也称为分词，从左向右扫描SQL，将其分割成一个个的toke(词元)，在将token组装为AST(Abstract Tree);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Lexer的实现一般都是构造DFA(确定性有限状态自动机)来实现的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>状态转移图如下，这是一个能够识别标识符，数字和一般运算符的词法解析器。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-14-44-04-2021-06-18-14-44-00-image.png" alt="">&lt;/p>
&lt;h3 id="语法分析parser">语法分析(Parser)&lt;/h3>
&lt;p>Parser阶段有两种类型方法来实现:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是自顶向下分析法，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一种是自底向上分析法，&lt;/p>
&lt;p>简单介绍一下两种类型分析法的处理思路。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="执行计划">执行计划&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">SQL String ---词法分析&amp;lt;Lexer&amp;gt;--&amp;gt; Token --&amp;lt;语法分析&amp;gt;--&amp;gt; AST Statement
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="sql-engine">Sql Engine&lt;/h2>
&lt;h3 id="parser解释器">Parser(解释器)&lt;/h3>
&lt;h3 id="planner">Planner&lt;/h3>
&lt;h3 id="executor">Executor&lt;/h3>
&lt;h2 id="storage存储">Storage(存储)&lt;/h2>
&lt;h3 id="memory">Memory&lt;/h3>
&lt;h2 id="mvcc">MVCC&lt;/h2>
&lt;h2 id="raft-engine">Raft Engine&lt;/h2>
&lt;p>&lt;code>toydb&lt;/code> 通过raft来实现各节点间数据的一致性，其自带的raft模块由rust语言提供的一个简单的实现。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/10/08-13-34-25-2021-10-08-13-34-19-image.png" alt="">&lt;/p>
&lt;p>Raft内部有2个状态机：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>复制状态机(): 主要用于日志复制，保证各个副本日志的落盘及一致；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指令状态机(&lt;code>State&lt;/code>): 主要作用是根据日志执行指令；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>由于复制状态机的Raft协议可以保证日志序列的唯一性，所以由日志驱动的不同副本的指令状态机将拥有相同的输入指令序列，在初始状态相同的情况下，指令状态机将会得到相同的输出，以此就保证了各个副本外部最终状态的一致性；&lt;/p>
&lt;ul>
&lt;li>
&lt;p>复制状态机是raft协议的核心；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指令状态机由raft日志驱动来改变外界状态，是raft协议和外界交互的接口；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="evenloop">EvenLoop&lt;/h2>
&lt;p>&lt;code>Raft&lt;/code> 的主驱动是&lt;code>EvenLoop&lt;/code>。节点启动时，会开启一个&lt;code>evenloop&lt;/code>后台异步任务，持续监听&lt;code>tick&lt;/code>, &lt;code>tcp_in_tx&lt;/code>, &lt;code>client_rx&lt;/code>, &lt;code>node_rx&lt;/code>这4个事件源上的消息&lt;code>Msg&lt;/code>，以此来驱动整个状态机的运行：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>tick&lt;/code>事件由定时器产生，转入相应rolenode的&lt;code>tick&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>tcp_in_tx&lt;/code>事件由其他节点peer产生，交由&lt;code>raft&lt;/code> 状态机&lt;code>step&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>node_rx&lt;/code>事件由节点内部产生，需根据事件消息的接收对象(&lt;code>to&lt;/code>)分别处理；&lt;/p>
&lt;ul>
&lt;li>发往副本（&lt;code>to&lt;/code>为&lt;code>Address::Peer&lt;/code>, &lt;code>Address::Peers&lt;/code>）的消息，放入&lt;code>tcp_tx&lt;/code>交由&lt;code>TcpSender&lt;/code>进行发送；&lt;/li>
&lt;li>发往&lt;code>Client&lt;/code>（&lt;code>Address::Client&lt;/code>） 且事件类型为&lt;code>Event::ClientResponse&lt;/code>的消息, 根据&lt;code>id&lt;/code>从&lt;code>requests&lt;/code>表中找到该消息响应rx&lt;code>response_tx&lt;/code>，通过&lt;code>response_tx&lt;/code>将消息响应回复给&lt;code>Client&lt;/code>;&lt;/li>
&lt;li>其他消息为非法消息, 报错并退出；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>client_rx&lt;/code>事件由客户端产生，处理如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>先为事件生成uuid作为唯一id；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以id为key, 将消息响应rx&lt;code>request_rx&lt;/code>放入&lt;code>requests&lt;/code> 哈希表中，该表用于后续消息响应时处理消息返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>生成一个&lt;code>ClientRequest&lt;/code>类型的消息 ，交由&lt;code>Rolenode&lt;/code>的&lt;code>step&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Evenloop&lt;/code>接收到消息后，通过&lt;code>tick()&lt;/code>, &lt;code>step()&lt;/code>来驱动复制状态机执行日志复制操作。&lt;/p>
&lt;p>各节点收到&lt;code>ClientRequest&lt;/code>后处理流程&lt;code>Step()&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>将&lt;code>ClientRequest&lt;/code>消息放入&lt;code>queued_reqs&lt;/code>队列中进行缓存，等待变为&lt;code>Leader&lt;/code>后，再依次处理；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果没有&lt;code>Leader&lt;/code>， 则也将消息放入&lt;code>queued_reqs&lt;/code>中缓存；// queud_reqs 后续处理?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果有&lt;code>Leader&lt;/code>, 则将消息(id, from)放入&lt;code>proxied_reqs&lt;/code>中记录下来，然后转发到&lt;code>Leader&lt;/code>，由&lt;code>Leader&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Leader&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Request::Query&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过&lt;code>state_tx&lt;/code>，向状态机发送&lt;code>Instruction::Query&lt;/code>指令，状态机将指令插入到&lt;code>queries&lt;/code>中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>state_tx&lt;/code>, 向状态机发送&lt;code>Instruction::Vote&lt;/code>指令, 统计；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若存在副本，则向副本发送&lt;code>Event::Heartbeat&lt;/code>消息，和&lt;code>Follower&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Request::Mutate&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将消息记录到本地log中;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制log到各个Follower；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接收到多数&lt;code>Follower&lt;/code>的确认消息后，commit消息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>给状态机发送&lt;code>Instruction::Notify&lt;/code>指令；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>peers&lt;/code>为空，提交；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Request::Status&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>根据当前节点状态，生成&lt;code>Instruction::Status&lt;/code>，通过&lt;code>state_tx&lt;/code>交由状态机执行；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="指令状态机">指令状态机&lt;/h3>
&lt;p>指令状态机由&lt;code>Driver::drive()&lt;/code>驱动。每个Raft Node新建时，会开启一个driver后台任务，该任务从&lt;code>state_rx&lt;/code>接收指令，交由&lt;code>execute&lt;/code>处理，各指令处理流程如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Instruction::Abort&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Apply&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Notify&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果指令&lt;code>index&lt;/code>大于状态机已经&lt;code>applied_index&lt;/code>, 将(index, (address, id))插入到状态机&lt;code>notify&lt;/code>哈希表中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>否则指令已被应用过，通过&lt;code>node_tx&lt;/code>给Raft Node 发送&lt;code>ClientResponse&lt;/code>消息，由Raft Node将错误消息返回给客户端；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Query&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Status&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Vote&lt;/code>:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="源码">源码&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Log&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Log&lt;/code>(日志)是Raft状态机&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="sd">/// The replicated Raft log
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">store&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">dyn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">log&lt;/span>::&lt;span class="n">Store&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commit_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commit_term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Driver&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//状态机接口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">State&lt;/span>: &lt;span class="nb">Send&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">applied_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">u64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">mutate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//修改状态机状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//查询状态机
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//状态机驱动
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Driver&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">state_rx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedReceiver&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Instruction&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//状态机指令输入口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//raft协议消息输出口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">applied_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">notify&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//通知客户端更改被采用
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queries&lt;/span>: &lt;span class="nc">BTreeMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BTreeMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//等待处理的客户端查询指令，
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 状态机指令
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">enum&lt;/span> &lt;span class="nc">Instruction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Abort&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//取消
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Apply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">entry&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//应用
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Notify&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span> &lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//通知
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">quorum&lt;/span>: &lt;span class="kt">u64&lt;/span> &lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//查询
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Status&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">status&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Status&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//状态机状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Vote&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//投票
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="raft角色">Raft角色&lt;/h3>
&lt;h4 id="leader">Leader&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// 节点共有属性
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">RoleNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//节点id
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peers&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">log&lt;/span>: &lt;span class="nc">Log&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pre_vote&lt;/span>: &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//和node之间发送Msg通道
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">state_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Instruction&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//节点往状态机驱动发送状态机指令通道
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queued_reqs&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Event&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">proxied_reqs&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">role&lt;/span>: &lt;span class="nc">R&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// leader专有属性字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Leader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">heartbeat_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//心跳计数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peer_next_index&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//复制到副本的下一个index
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peer_last_index&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//已知复制到副本的最后index
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// follower专有字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Follower&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader&lt;/span>: &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader_seen_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader_seen_timeout&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">voted_for&lt;/span>: &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// candidate专有字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Candidate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">election_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">election_timeout&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">votes&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/erikgrinaker/toydb">GitHub - erikgrinaker/toydb: Distributed SQL database in Rust, written as a learning project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/erikgrinaker/toydb/blob/master/docs/architecture.md">toydb/architecture.md at master · erikgrinaker/toydb · GitHub&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>AF_XDP</title><link>https://justice.bj.cn/post/21.linux/af_xdp/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/af_xdp/</guid><description>&lt;h1 id="af_xdp">AF_XDP&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>AF_XDP&lt;/strong>是一种用于高性能包处理的地址簇(Address Family)。&lt;/p>
&lt;p>使用XDP程序中的&lt;strong>XDP_REDIRECT&lt;/strong>操作，可以使用&lt;code>bpf_redirect_map（）&lt;/code>函数将入口帧重定向到其他启用XDP的网络设备。 AF_XDP套接字使XDP程序可以将帧重定向到用户空间应用程序中的内存缓冲区。&lt;/p>
&lt;p>可以通过&lt;code>socket()&lt;/code>系统调用创建AF_XDP socket (XSK)。每个XSK涉及两个ring：RX ring和TX ring。一个socket可以从RX ring上接收报文，并发送到TX ring。这两个rings分别通过socket选项&lt;code>XDP_RX_RING&lt;/code> 和&lt;code>XDP_TX_RING&lt;/code>进行注册。每个socket必须至少具有其中一个ring。RX或TX ring描述符指向内存域中的data buffer，称为UMEM。RX和TX可以共享相同的UMEM，这样一个报文无需在RX和TX之间进行拷贝。此外，如果一个报文由于重传需要保留一段时间，则指向该报文的描述符可以指向另外一个报文，这样就避免了数据的拷贝。基本流程&lt;a href="https://www.dpdk.org/wp-content/uploads/sites/35/2018/10/pm-06-DPDK-PMD-for-AF_XDP.pdf">如下&lt;/a>：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-39-2020-09-30-17-18-13-image.png" alt="">&lt;/p>
&lt;p>UMEM包含一系列大小相同的chunks，ring中的描述符通过引用帧的地址来引用该帧，该地址为整个UMEM域的偏移量。用户空间会使用合适的方式(malloc，mmap，大页内存等)为UMEM分配内存，然后使用使用新的socket选项&lt;code>XDP_UMEM_REG&lt;/code>将内存域注册到内核中。UMEM也包含两个ring：FILL ring和COMPLETION ring。应用会使用FILL ring下发addr，让内核填写RX包数据。一旦接收到报文，RX ring会引用这些帧。COMPLETION ring包含内核传输完的帧地址，且可以被用户空间使用，用于TX或RX。因此COMPLETION ring中的帧地址为先前使用TX ring传输的地址。总之，RX和FILL ring用于RX路径，TX和COMPLETION ring用于TX路径。&lt;/p>
&lt;p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。&lt;/p>
&lt;p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。&lt;/p>
&lt;p>可以在多个进程间共享UMEM 。如果一个进程需要更新UMEM，则会跳过注册UMEM和其对应的两个ring的过程。在bind调用中设置&lt;code>XDP_SHARED_UMEM&lt;/code> 标志，并提交该进程期望共享UMEM的XSK，以及新创建的XSK socket。新进程会在其共享UMEM的RX ring中接收到帧地址引用。注意，由于ring的结构是单生产者/单消费者的，新的进程的socket必须创建独立的RX和TX ring。同样的原因，每个UMEM也只能有一个FILL和COMPLETION ring。每个进程都需要正确地处理好UMEM。&lt;/p>
&lt;p>那么报文是怎么从XDP程序分发到XSKs的呢？通过名为&lt;code>XSKMAP&lt;/code>(完整名为BPF_MAP_TYPE_XSKMAP`) BPF map。用户空间的应用可以将一个XSK放到该map的任意位置，然后XDP程序就可以将一个报文重定向到该map中指定的索引中，此时XDP会校验map中的XSK确实绑定到该设备和ring号。如果没有，则会丢弃该报文。如果map中的索引为空，也会丢弃该报文。因此，当前的实现中强制要求必须加载一个XDP程序(以及保证XSKMAP存在一个XSK)，这样才能通过XSK将流量传送到用户空间。&lt;/p>
&lt;p>AF_XDP可以运行在两种模式上：&lt;code>XDP_SKB&lt;/code>和&lt;code>XDP_DRV&lt;/code>。如果驱动不支持XDP，则在加载XDP程序是需要明确指定使用XDP_SKB，&lt;code>XDP_SKB&lt;/code>模式使用SKB和通用的XDP功能，并将数据复制到用户空间，是一种适用于任何网络设备的回退模式。 如果驱动支持XDP，将使用AF_XDP代码提供更好的性能，但仍然会将数据拷贝到用户空间的操作。&lt;/p>
&lt;h5 id="术语">术语&lt;/h5>
&lt;h6 id="umem-umem是一个虚拟的连续内存域分割为相同大小的帧">UMEM: UMEM是一个虚拟的连续内存域，分割为相同大小的帧。&lt;/h6>
&lt;p>一个UMEM会关联一个netdev以及该netdev的队列id。通过&lt;code>XDP_UMEM_REG&lt;/code> socket选项进行创建和配置(chunk大小，headroom，开始地址和大小)。通过&lt;code>bind()&lt;/code>系统调用将一个UMEM绑定到一个netdev和队列id。umem的基本结构如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-49-1334952-20200807102005413-1869804955.png" alt="">&lt;/p>
&lt;p>一个AF_XDP为一个链接到一个独立的UMEM的socket，但一个UMEM可以有多个AF_XDP socket。为了共享一个通过socket A创建的UMEM，socket B可以将结构体&lt;code>sockaddr_xdp&lt;/code>中的成员sxdp_flags设置为&lt;code>XDP_SHARED_UMEM&lt;/code>，并将A的文件描述符传递给结构体&lt;code>sockaddr_xdp&lt;/code>的成员&lt;code>sxdp_shared_umem_fd&lt;/code>。&lt;/p>
&lt;p>UMEM有两个单生产者/单消费者ring，用于在内核和用户空间应用程序之间转移UMEM帧。&lt;/p>
&lt;h6 id="rings">Rings&lt;/h6>
&lt;p>有4类不同类型的ring：FILL, COMPLETION, RX 和TX，所有的ring都是单生产者/单消费者，因此用户空间的程序需要显示地同步对这些rings进行读/写的多进程/线程。&lt;/p>
&lt;p>UMEM使用2个ring：FILL和COMPLETION。每个关联到UMEM的socket必须有1个RX队列，1个TX队列或同时拥有2个队列。如果配置了4个socket(同时使用TX和RX)，那么此时会有1个FILL ring，1个COMPLETION ring，4个TX ring和4个RX ring。&lt;/p>
&lt;p>ring是基于首(生产者)尾(消费者)的结构。一个生产者会在结构体xdp_ring的producer成员指出的ring索引处写入数据，并增加生产者索引；一个消费者会结构体xdp_ring的consumer成员指出的ring索引处读取数据，并增加消费者索引。&lt;/p>
&lt;p>可以通过_RING setsockopt系统调用配置和创建ring，使用mmap()，并结合合适的偏移量，将其映射到用户空间&lt;/p>
&lt;p>ring的大小需要是2次幂。&lt;/p>
&lt;h6 id="umem-fill-ring">UMEM Fill Ring&lt;/h6>
&lt;p>FILL ring用于将UMEM帧从用户空间传递到内核空间，同时将UMEM地址传递给ring。例如，如果UMEM的大小为64k，且每个chunk的大小为4k，那么UMEM包含16个chunk，可以传递的地址为0到64k。&lt;/p>
&lt;p>传递给内核的帧用于ingress路径(RX rings)。&lt;/p>
&lt;p>用户应用也会在该ring中生成UMEM地址。注意，如果以对齐的chunk模式运行应用，则内核会屏蔽传入的地址。即，如果一个chunk大小为2k，则会屏蔽掉log2(2048) LSB的地址，意味着2048, 2050 和3000都将引用相同的chunk。如果用户应用使用非对其的chunk模式运行，那么传入的地址将保持不变。&lt;/p>
&lt;h6 id="umem-completion-ring">UMEM Completion Ring&lt;/h6>
&lt;p>COMPLETION Ring用于将UMEM帧从内核空间传递到用户空间，与FILL ring相同，使用了UMEM索引。&lt;/p>
&lt;p>已经发送的从内核空间传递到用户空间的帧还可以被用户空间使用。&lt;/p>
&lt;p>用户应用会消费该ring种的UMEM地址。&lt;/p>
&lt;h6 id="rx-ring">RX Ring&lt;/h6>
&lt;p>RX ring位于socket的接收侧，ring中的每个表项都是一个&lt;code>xdp_desc&lt;/code> 结构的描述符。该描述符包含UMEM偏移量(地址)以及数据的长度。&lt;/p>
&lt;p>如果没有帧从FILL ring传递给内核，则RX ring中不会出现任何描述符。&lt;/p>
&lt;p>用户程序会消费该ring中的&lt;code>xdp_desc&lt;/code>描述符。&lt;/p>
&lt;h6 id="tx-ring">TX Ring&lt;/h6>
&lt;p>TX Ring用于发送帧。在填充&lt;code>xdp_desc&lt;/code>(索引，长度和偏移量)描述符后传递给该ring。&lt;/p>
&lt;p>如果要启动数据传输，则必须调用&lt;code>sendmsg()&lt;/code>，未来可能会放宽这种限制。&lt;/p>
&lt;p>用户程序会给TX ring生成&lt;code>xdp_desc&lt;/code> 描述符。&lt;/p>
&lt;h5 id="xskmap--bpf_map_type_xskmap">XSKMAP / BPF_MAP_TYPE_XSKMAP&lt;/h5>
&lt;p>在XDP侧会用到类型为&lt;code>BPF_MAP_TYPE_XSKMAP&lt;/code> 的BPF map，并结合&lt;code>bpf_redirect_map()&lt;/code>将ingress帧传递给socket。&lt;/p>
&lt;p>用户应用会通过&lt;code>bpf()&lt;/code>系统调用将socket插入该map。&lt;/p>
&lt;p>注意，如果一个XDP程序尝试将帧重定向到一个与队列配置和netdev不匹配的socket时，会丢弃该帧。即，如果一个AF_XDP socket绑定到一个名为eth0，队列为17的netdev上时，只有当XDP程序指定到eth0且队列为17时，才会将数据传递给该socket。参见&lt;code>samples/bpf/&lt;/code>获取例子&lt;/p>
&lt;h5 id="配置标志位和socket选项">配置标志位和socket选项&lt;/h5>
&lt;h6 id="xdp_copy-和xdp_zero_copy-bind标志">XDP_COPY 和XDP_ZERO_COPY bind标志&lt;/h6>
&lt;p>当绑定到一个socket时，内核会首先尝试使用零拷贝进行拷贝。如果不支持零拷贝，则会回退为使用拷贝模式。即，将所有的报文拷贝到用户空间。但如果想强制指定一种特定的模式，则可以使用如下标志：如果给bind调用传递了&lt;code>XDP_COPY&lt;/code>，则内核将强制进入拷贝模式；如果没有使用拷贝模式，则bind调用会失败，并返回错误。相反地，&lt;code>XDP_ZERO_COPY&lt;/code> 将强制socket使用零拷贝或调用失败。&lt;/p>
&lt;h6 id="xdp_shared_umem-bind-标志">XDP_SHARED_UMEM bind 标志&lt;/h6>
&lt;p>该表示可以使多个socket绑定到系统的UMEM，但仅能使用系统的队列id。这种模式下，每个socket都有其各自的RX和TX ring，但UMEM只能有一个FILL ring和一个COMPLETION ring。为了使用这种模式，需要创建第一个socket，并使用正常模式进行绑定。然后创建第二个socket，含一个RX和一个TX(或二者之一)，但不会创建FILL 或COMPLETION ring(与第一个socket共享)。在bind调用中，设置&lt;code>XDP_SHARED_UMEM&lt;/code>选项，并在sxdp_shared_umem_fd中提供初始socket的fd。以此类推。&lt;/p>
&lt;p>那么当接收到一个报文后，应该上送到那个socket呢？答案是由XDP程序来决定。将所有的socket放到XDP_MAP中，然后将报文发送给数组中索引对应的socket。下面展示了一个简单的以轮询方式分发报文的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/bpf.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;bpf_helpers.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#define MAX_SOCKS 16
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BPF_MAP_TYPE_XSKMAP&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">max_entries&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MAX_SOCKS&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">xsks_map&lt;/span> &lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;.maps&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">rr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;xdp_sock&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">xdp_sock_prog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">xdp_md&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">rr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAX_SOCKS&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">bpf_redirect_map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">xsks_map&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">XDP_DROP&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，由于只有一个FILL和一个COMPLETION ring，且是单生产者单消费者的ring，需要确保多处理器或多线程不会同时使用这些ring。libbpf没有提供原子同步功能。&lt;/p>
&lt;p>当多个socket绑定到相同的umem时，libbpf会使用这种模式。然而，需要注意的是，需要在&lt;code>xsk_socket__create&lt;/code>调用中提供&lt;code>XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD&lt;/code> libbpf_flag，然后将其加载到自己的XDP程序中(因为libbpf没有内置路由流量功能)。&lt;/p>
&lt;h6 id="xdp_use_need_wakeup-bind标志">XDP_USE_NEED_WAKEUP bind标志&lt;/h6>
&lt;p>该选择支持在FILL ring和TX ring中设置一个名为&lt;code>need_wakeup&lt;/code>的标志，用户空间作为这些ring的生产者。当在bind调用中设置了该选项，如果需要明确地通过系统调用唤醒内核来继续处理报文时，会设置&lt;code>need_wakeup&lt;/code> 标志。&lt;/p>
&lt;p>如果将该标志设置给FILL ring，则应用需要调用&lt;code>poll()&lt;/code>，以便在RX ring上继续接收报文。如，当内核检测到FILL ring中没有足够的buff，且NIC的RX HW RING中也没有足够的buffer时会发生这种情况。此时会关中断，这样NIC就无法接收到任何报文(由于没有足够的buffer)，由于设置了need_wakeup，这样用户空间就可以在FILL ring上增加buffer，然后调用&lt;code>poll()&lt;/code>，这样内核驱动就可以将这些buffer添加到HW ring上继续接收报文。&lt;/p>
&lt;p>如果将该标志设置给TX ring，意味着应用需要明确地通知内核发送位于TX ring上的报文。可以通过调用&lt;code>poll()&lt;/code>，或调用&lt;code>sendto()&lt;/code>完成。&lt;/p>
&lt;p>可以在&lt;em>samples/bpf/xdpsock_user.c&lt;/em>中找到例子。在TX路径上使用libbpf辅助函数的例子如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">xsk_ring_prod__needs_wakeup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">my_tx_ring&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">sendto&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xsk_socket__fd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xsk_handle&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MSG_DONTWAIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>建议启用该模式，由于减少了TX路径上的系统调用的数目，因此可以在应用和驱动运行在同一个(或不同)core的情况下提升性能。&lt;/p>
&lt;h6 id="xdp_rxtxumem_fillumem_completion_ring-setsockopts">XDP_{RX|TX|UMEM_FILL|UMEM_COMPLETION}_RING setsockopts&lt;/h6>
&lt;p>这些socket选项分别设置RX, TX, FILL和COMPLETION ring的描述符数量(必须至少设置RX或TX ring的描述符大小)。如果同时设置了RX和TX，就可以同时接收和发送来自应用的流量；如果仅设置了其中一个，就可以节省相应的资源。如果需要将一个UMEM绑定到socket，需要同时设置FILL ring和COMPLETION ring。如果使用了&lt;code>XDP_SHARED_UMEM&lt;/code>标志，无需为除第一个socket之外的socket创建单独的UMEM，所有的socket将使用共享的UMEM。注意ring为单生产者单消费者结构，因此多进程无法同时访问同一个ring。参见&lt;code>XDP_SHARED_UMEM&lt;/code>章节。&lt;/p>
&lt;p>使用libbpf时，可以通过给&lt;code>xsk_socket__create&lt;/code>函数的rx和tx参数设置NULL来创建Rx-only和Tx-only的socket。&lt;/p>
&lt;p>如果创建了一个Tx-only的socket，建议不要在FILL ring中放入任何报文，否则，驱动可能会认为需要接收数据(但实际上并不是这样的)，进而影响性能。&lt;/p>
&lt;h6 id="xdp_umem_reg-setsockopt">XDP_UMEM_REG setsockopt&lt;/h6>
&lt;p>该socket选项会给一个socket注册一个UMEM，其对应的区域包含了可以容纳报文的buffer。该调用会使用一个指向该区域开始处的指针，以及该区域的大小。此外，还有一个UMEM可以切分的chunk大小参数(目前仅支持2K或4K)。如果一个UMEM区域的大小为128K，且chunk大小为2K，意味着该UMEM域最大可以有128K / 2K = 64个报文，且最大的报文大小为2K。&lt;/p>
&lt;p>还有一个选项可以在UMEM中设置每个buffer的headroom。如果设置为N字节，意味着报文会从buffer的第N个字节开始，为应用保留前N个字节。最后一个选项为标志位字段，会在每个UMEM标志中单独处理。&lt;/p>
&lt;h6 id="xdp_statistics-getsockopt">XDP_STATISTICS getsockopt&lt;/h6>
&lt;p>获取一个socket丢弃信息，用于调试。支持的信息为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">xdp_statistics&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">rx_dropped&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped for reasons other than invalid desc */&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">rx_invalid_descs&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped due to invalid descriptor */&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">tx_invalid_descs&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped due to invalid descriptor */&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h6 id="xdp_options-getsockopt">XDP_OPTIONS getsockopt&lt;/h6>
&lt;p>获取一个XDP socket的选项。目前仅支持&lt;code>XDP_OPTIONS_ZEROCOPY&lt;/code>，用于检查是否使用了零拷贝。&lt;/p>
&lt;blockquote>
&lt;p>从AF_XDP的特性上可以看到其&lt;a href="https://pantheon.tech/what-is-af_xdp/">局限性&lt;/a>：不能使用XDP将不同的流量重定向的多个AF_XDP socket上，原因是每个AF_XDP socket必须绑定到物理接口的TX队列上。大多数的物理和仿真HW的每个接口仅支持一个RX/TX队列，因此当该接口上绑定了一个AF_XDP后，后续的绑定操作都将失败。仅有少数HW支持多RX/TX队列，且通常仅有2/4/8个队列，无法扩展给cloud中的上百个容器使用。&lt;/p>
&lt;/blockquote>
&lt;p>更多细节参见AF_XDP&lt;a href="https://www.kernel.org/doc/html/latest/networking/af_xdp.html">官方文档&lt;/a>以及这篇&lt;a href="http://vger.kernel.org/lpc_net2018_talks/lpc18_paper_af_xdp_perf-v2.pdf">论文&lt;/a>。&lt;/p>
&lt;h2 id="tchttpsdocsciliumioenlatestbpftc-traffic-control">&lt;a href="https://docs.cilium.io/en/latest/bpf/#tc-traffic-control">TC&lt;/a>&lt;/h2>
&lt;p>除了XDP，BPF还可以在网络数据路径的内核tc(traffic control)层之外使用。上文已经给出了XDP和TC的区别。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>ingress&lt;/code> hook：&lt;code>__netif_receive_skb_core() -&amp;gt; sch_handle_ingress()&lt;/code>&lt;/li>
&lt;li>&lt;code>egress&lt;/code> hook：&lt;code>__dev_queue_xmit() -&amp;gt; sch_handle_egress()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-12-21-1334952-20200809204246404-1470995812.png" alt="">&lt;/p>
&lt;/blockquote>
&lt;p>运行在tc层的BPF程序使用的是 &lt;code>cls_bpf&lt;/code> (cls即Classifiers的简称)分类器。在tc中，将BPF的附着点描述为一个&amp;quot;分类器&amp;quot;，这个词有点误导，因此它少描述了&lt;code>cls_bpf&lt;/code>的所支持的功能。即一个完整的可编程的报文处理器不仅可以读取&lt;code>skb&lt;/code>的元数据和报文数据，还可以对其进行任意修改，最后终止tc的处理，并返回裁定的action(见下)。&lt;code>cls_bpf&lt;/code>可以认为是一个自包含的，可以管理和执行tc BPF程序的实体。&lt;/p>
&lt;p>&lt;code>cls_bpf&lt;/code>可以包含一个或多个tc BPF程序。通常，在传统的tc方案中，分类器和action模块是分开的，每个分类器可以附加一个或多个action，一旦匹配到分类器时就会执行action。但在现代软件数据路径中使用这种模式的tc处理复杂的报文时会遇到扩展性问题。由于附加到cls_bpf的tc BPF程序是完全自包含的，因此可以有效地将解析和操作过程融合到一个单元中。幸好有了&lt;code>cls_bpf&lt;/code>的&lt;code>direct-action&lt;/code>模式，该模式下，仅需要返回tc action裁定结果并立即结束处理流即可，可以在网络数据流中实现可扩展的可编程报文处理流程，同时避免了action的线性迭代。&lt;code>cls_bpf&lt;/code>是tc层中唯一能够实现这种快速路径的“分类器”模块。&lt;/p>
&lt;p>与XDP BPF程序类似，tc BPF程序可以在运行时通过cls_bpf自动更新，而不会中断任何网络流或重启服务。&lt;/p>
&lt;p>&lt;code>cls_bpf&lt;/code>可以附加的tc ingress和egree钩子都通过一个名为&lt;code>sch_clsact&lt;/code>的伪qdisc进行管理。由于该伪qdisc可以同时管理ingress和egress的tc钩子，因此它是ingress qdisc的超集(也可直接替换)。对于&lt;code>__dev_queue_xmit()&lt;/code>中的tc的egress钩子，需要注意的是，它不是在内核的qdisc root锁下运行的。因此，tc ingress和egress钩子都以无锁的方式运行在快速路径中，且这两个钩子都禁用了抢占，并运行在RCU读取侧。&lt;/p>
&lt;p>通常在egress上会存在附着到网络设备上的qdisc，如&lt;code>sch_mq&lt;/code>，&lt;code>sch_fq&lt;/code>，&lt;code>sch_fq_codel&lt;/code>或&lt;code>sch_htb&lt;/code>，其中有些是可分类的qdisc(包含子类)，因此会要求一个报文分类机制来决定在哪里解复用数据包。该过程通过调用&lt;code>tcf_classify()&lt;/code>进行处理，进而调用tc分类器(如果存在)。&lt;code>cls_bpf&lt;/code>也可以附加并用于如下场景：一些在qdisc root锁下的操作可能会收到锁竞争的影响。&lt;code>sch_clsact&lt;/code> qdisc的egress钩子出现在更早的时间点，但它不属于这个锁的范围，因此作完全独立于常规的egress qdiscs。因此，对于&lt;code>sch_htb&lt;/code>这样的情况，&lt;code>sch_clsact&lt;/code> qdisc可以通过qdisc root锁之外的tc BPF执行繁重的包分类工作，通过在这些 tc BPF 程序中设置 &lt;code>skb-&amp;gt;mark&lt;/code> 或 &lt;code>skb-&amp;gt;priority&lt;/code> ，这样 &lt;code>sch_htb&lt;/code> 只需要一个简单的映射即可，不需要在root锁下执行代价高昂的报文分类工作，通过这种方式可以减少锁竞争。&lt;/p>
&lt;p>在sch_clsact结合cls_bpf的场景下支持offloaded tc BPF程序，这种情况下，先前加载的BPF程序是从SmartNIC驱动程序jit生成的，以便在NIC上以本机方式运行。只有在&lt;code>direct-action&lt;/code>模式下运行的&lt;code>cls_bpf&lt;/code>程序才支持offloaded。&lt;code>cls_bpf&lt;/code>仅支持offload一个单独的程序(无法offload多个程序)，且只有ingress支持offload BPF程序。&lt;/p>
&lt;p>一个&lt;code>cls_bpf&lt;/code>实例可以包含多个tc BPF程序，如果是这种情况，那么&lt;code>TC_ACT_UNSPEC&lt;/code>程序返回码可以继续执行列表中的下一个tc BPF程序。然而，这样做的缺点是，多个程序需要多次解析相同的报文，导致性能下降。&lt;/p>
&lt;h3 id="返回码">返回码&lt;/h3>
&lt;p>tc的ingress和egress钩子共享相同的action来返回tc BPF程序使用的裁定结果，定义在 &lt;code>linux/pkt_cls.h&lt;/code>系统头文件中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define TC_ACT_UNSPEC (-1)
&lt;/span>&lt;span class="cp">#define TC_ACT_OK 0
&lt;/span>&lt;span class="cp">#define TC_ACT_SHOT 2
&lt;/span>&lt;span class="cp">#define TC_ACT_STOLEN 4
&lt;/span>&lt;span class="cp">#define TC_ACT_REDIRECT 7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>系统头文件中还有一些以&lt;code>TC_ACT_*&lt;/code>开头的action变量，可以被两个钩子使用。但它们与上面的语义相同。即，从tc BPF的角度来看&lt;code>TC_ACT_OK&lt;/code>和&lt;code>TC_ACT_RECLASSIFY&lt;/code>的语义相同，三个&lt;code>TC_ACT_stelled&lt;/code>、&lt;code>TC_ACT_QUEUED&lt;/code>和&lt;code>TC_ACT_TRAP&lt;/code>操作码的语义也是相同的。因此，对于这些情况，我们只描述 &lt;code>TC_ACT_OK&lt;/code> 和 &lt;code>TC_ACT_STOLEN&lt;/code> 操作码。&lt;/p>
&lt;p>从&lt;code>TC_ACT_UNSPEC&lt;/code>开始，表示&amp;quot;未指定的action&amp;quot;，用于以下三种场景：i)当一个offloaded tc程序的tc ingress钩子运行在&lt;code>cls_bpf&lt;/code>的位置，则该offloaded程序将返回&lt;code>TC_ACT_UNSPEC&lt;/code>；ii)为了在多程序场景下继续执行&lt;code>cls_bpf&lt;/code>中的下一个BPF程序，后续的程序需要与步骤i中的offloaded tc BPF程序配合使用，但出现了一个非offloaded场景下运行的tc BPF程序；iii)&lt;code>TC_ACT_UNSPEC&lt;/code>还可以用于单个程序场景，用于告诉内核继续使用skb，不会产生其他副作用。&lt;code>TC_ACT_UNSPEC&lt;/code>与&lt;code>TC_ACT_OK&lt;/code>类似，两者都会将skb通过ingress向上传递到网络栈的上层，或者通过egress向下传递到网络设备驱动程序，以便在egress进行传输。与&lt;code>TC_ACT_OK&lt;/code>的唯一不同之处是，&lt;code>TC_ACT_OK&lt;/code>基于tc BPF程序设定的classid来设置&lt;code>skb-&amp;gt;tc_index&lt;/code>，而 &lt;code>TC_ACT_UNSPEC&lt;/code> 是通过 tc BPF 程序之外的 BPF上下文中的 &lt;code>skb-&amp;gt;tc_classid&lt;/code> 进行设置。&lt;/p>
&lt;p>&lt;code>TC_ACT_SHOT&lt;/code>通知内核丢弃报文，即网络栈上层将不会在ingress的skb中看到该报文，类似地，这类报文也不会在egress中发送。&lt;code>TC_ACT_SHOT&lt;/code>和&lt;code>TC_ACT_STOLEN&lt;/code>本质上是相似的，仅存在部分差异：&lt;code>TC_ACT_SHOT&lt;/code>会通知内核已经通过&lt;code>kfree_skb()&lt;/code>释放skb，且会立即给调用者返回&lt;code>NET_XMIT_DROP&lt;/code>；而TC_ACT_STOLEN会通过&lt;code>consume_skb()&lt;/code>释放skb,并给上层返回&lt;code>NET_XMIT_SUCCESS&lt;/code>，假装传输成功。perf的报文丢弃监控会记录&lt;code>kfree_skb()&lt;/code>的操作，因此不会记录任何因为&lt;code>TC_ACT_STOLEN&lt;/code>丢弃的报文，因为从语义上说，这些 &lt;code>skb&lt;/code> 是被消费或排队的而不是被丢弃的。&lt;/p>
&lt;p>最后&lt;code>TC_ACT_REDIRECT&lt;/code> action允许tc BPF程序通过&lt;code>bpf_redirect()&lt;/code>辅助函数将skb重定向到相同或不同的设备ingress或egress路径上。通过将报文导入其他设备的ingress或egress方向，可以最大化地实现BPF的报文转发功能。使用该方式不需要对目标网络设备做任何更改，也不需要在目标设备上运行另外一个&lt;code>cls_bpf&lt;/code>实例。&lt;/p>
&lt;h3 id="加载tc-bpf程序">加载tc BPF程序&lt;/h3>
&lt;p>假设有一个名为&lt;code>prog.o&lt;/code>的tc BPF程序，可以通过tc命令将该程序加载到网络设备山。与XDP不同，它不需要依赖驱动将BPF程序附加到设备上，下面会用到一个名为&lt;code>em1&lt;/code>的网络设备，并将程序附加到&lt;code>em1&lt;/code>的&lt;code>ingress&lt;/code>报文路径上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter add dev em1 ingress bpf da obj prog.o&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一步首先配置一个&lt;code>clsact&lt;/code> qdisc。如上文所述，clsact是一个伪造的qdisc，与&lt;code>ingress&lt;/code> qdisc类似，仅包含分类器和action，但不会提供实际的队列功能，它是附加bpf分类器所必需的。&lt;code>clsact&lt;/code> 提供了两个特殊的钩子，称为&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>，分类器可以附加到这两个钩子上。&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>钩子都位于网络数据路径的中央接收和发送位置，每个经过设备的报文都会经过此处。&lt;code>ingees&lt;/code>钩子通过内核的&lt;code>__netif_receive_skb_core() -&amp;gt; sch_handle_ingress()&lt;/code>进行调用，&lt;code>egress&lt;/code>钩子通过&lt;code>__dev_queue_xmit() -&amp;gt; sch_handle_egress()&lt;/code>进行调用。&lt;/p>
&lt;p>将程序附加到&lt;code>egress&lt;/code>钩子上的操作为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 egress bpf da obj prog.o&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>clsact&lt;/code> qdisc以无锁的方式处理来自&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>方向的报文，且可以附加到一个无队列虚拟设备上，如连接到容器的&lt;code>veth&lt;/code>设备。&lt;/p>
&lt;p>在钩子之后，&lt;code>tc filter&lt;/code>命令选择使用&lt;code>bpf&lt;/code>的&lt;code>da&lt;/code>(direct-action)模式。推荐使用并指定da&lt;code>模式&lt;/code>，基本上意味着bpf分类器不再需要调用外部tc action模块，所有报文的修改，转发或其他action都可以通过附加的BPF程序来实现，因此处理速度更快。&lt;/p>
&lt;p>到此位置，已经附加bpf程序，一旦有报文传输到该设备后就会执行该程序。与XDP相同，如果不使用默认的section名称，则可以在加载期间进行指定，例如，下面指定的section名为&lt;code>foobar&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 egress bpf da obj prog.o sec foobar&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>iptables2的BPF加载器允许跨程序类型使用相同的命令行语法。&lt;/p>
&lt;p>附加的程序可以使用如下命令列出：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>ingress&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">1&lt;/span> tag c5f7825e5dac396f
&lt;span class="c1"># tc filter show dev em1 egress&lt;/span>
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>egress&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">2&lt;/span> tag b2fd5adc0f262714
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>prog.o:[ingress]&lt;/code>的输出说明程序段&lt;code>ingress&lt;/code>通过文件&lt;code>prog.o&lt;/code>进行加载，且&lt;code>bpf&lt;/code>运行在&lt;code>direct-action&lt;/code>模式下。上面两种情况附加了程序&lt;code>id&lt;/code>和&lt;code>tag&lt;/code>，其中后者表示对指令流的hash，该hash可以与目标文件或带有堆栈跟踪的perf report等相关。最后，&lt;code>id&lt;/code>表示系统范围内的BPF程序的唯一标识符，可以使用&lt;code>bpftool&lt;/code>来查看或dump附加的BPF程序。&lt;/p>
&lt;p>tc可以附加多个BPF程序，它提供了其他可以链接在一起的分类器。但附加一个BPF程序已经可以完全满足需求，因为通过&lt;code>da&lt;/code>(&lt;code>direct-action&lt;/code>)模式可以在一个程序中实现所有的报文操作，意味着BPF程序将返回tc action裁定结果，如&lt;code>TC_ACT_OK&lt;/code>, &lt;code>TC_ACT_SHOT&lt;/code>等。为了获得最佳性能和灵活性，推荐使用这种方式。&lt;/p>
&lt;p>在上述&lt;code>show&lt;/code>命令中，在BPF的相关输出旁显示了&lt;code>pref 49152&lt;/code> 和&lt;code>handle 0x1&lt;/code>。如果没有通过命令行显式地提供，会自动生成的这两个输出。&lt;code>perf&lt;/code>表明了一个优先级数字，即当附加了多个分类器时，将会按照优先级上升的顺序执行这些分类器。&lt;code>handle&lt;/code>表示一个标识符，当一个&lt;code>perf&lt;/code>加载了系统分类器的多个实例时起作用。由于在BPF场景下，一个程序足矣，&lt;code>perf&lt;/code>和&lt;code>handle&lt;/code>通常可以忽略。&lt;/p>
&lt;p>只有在需要自动替换附加的BPF程序的情况下，才会推荐在初始化加载前指定&lt;code>pref&lt;/code>和&lt;code>handle&lt;/code>，这样在以后执行&lt;code>replace&lt;/code>操作时就不必在进行查询。创建方式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar&lt;/span>
&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">1&lt;/span> bpf
filter protocol all pref &lt;span class="m">1&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>foobar&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">1&lt;/span> tag c5f7825e5dac396f
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于原子替换，可以使用(来自文件&lt;code>prog.o&lt;/code>中的&lt;code>foobar&lt;/code> section的BPF程序)如下命令来更新现有的&lt;code>ingress&lt;/code>钩子上的程序&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，为了移除所有ingress和egress上附加的程序，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter del dev em1 ingress&lt;/span>
&lt;span class="c1"># tc filter del dev em1 egress&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了移除网络设备上的整个&lt;code>clsact&lt;/code> qdisc，即移除掉ingress和egress钩子上附加的所有程序，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc del dev em1 clsact&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果NIC和驱动也像XDP BPF程序一样支持offloaded，则tc BPF程序也可以是offloaded的。Netronome的nfp同时支持两种类型的BPF offload。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o&lt;/span>
Error: TC offload is disabled on net device.
We have an error talking to the kernel
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果出现了如上错误，则表示首先需要通过ethtool的&lt;code>hw-tc-offload&lt;/code>来启动tc硬件offload：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># ethtool -K em1 hw-tc-offload on&lt;/span>
&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o&lt;/span>
&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">1&lt;/span> bpf
filter protocol all pref &lt;span class="m">1&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>classifier&lt;span class="o">]&lt;/span> direct-action skip_sw in_hw id &lt;span class="m">19&lt;/span> tag 57cd311f2e27366b
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>in_hw&lt;/code>标志表示程序已经offload到了NIC中。&lt;/p>
&lt;p>注意不能同时offload tc和XDP BPF，必须且只能选择其中之一。&lt;/p></description></item><item><title>eBPF简史(转)</title><link>https://justice.bj.cn/post/21.linux/ebpf%E7%AE%80%E5%8F%B2/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/ebpf%E7%AE%80%E5%8F%B2/</guid><description>&lt;h1 id="ebpf简史转">eBPF简史(转)&lt;/h1>
&lt;h2 id="源头一篇-1992-年的论文">源头：一篇 1992 年的论文&lt;/h2>
&lt;p>考虑到 BPF 的知名度，在介绍 eBPF 之前，笔者自觉还是有必要先来回答另一个问题：&lt;/p>
&lt;h2 id="什么是-bpf">什么是 BPF?&lt;/h2>
&lt;p>笔者在前文中说过了，BPF 的全称是 Berkeley Packet Filter，顾名思义，这是一个用于过滤(filter)网络报文(packet)的架构。&lt;/p>
&lt;p>其实 BPF 可谓是名气不大，作用不小的典范：如果笔者一开始提出 BPF 的同时还捎带上大名鼎鼎的 tcpdump 或 wireshark，估计绝大部分读者都会了然了：BPF 即为 tcpdump 抑或 wireshark 乃至网络监控(Network Monitoring)领域的基石。&lt;/p>
&lt;p>今天我们看到的 BPF 的设计，最早可以追溯到 1992 年刊行在 USENIX conference 上的一篇论文：The BSD Packet Filter: A New Architecture for User-level Packet Capture。由于最初版本的 BPF 是实现于 BSD 系统之上的，于是在论文中作者称之为&amp;quot;BSD Packet Filter&amp;quot;；后来由于 BPF 的理念渐成主流，为各大操作系统所接受，B 所代表的 BSD 便也渐渐淡去，最终演化成了今天我们眼中的 Berkeley Packet Filter。&lt;/p>
&lt;p>诚然，无论 BSD 和 Berkeley 如何变换，其后的 Packet Filter 总是不变的，这两个单词也基本概括了 BPF 的两大核心功能：&lt;/p>
&lt;ul>
&lt;li>过滤(Filter): 根据外界输入的规则过滤报文；&lt;/li>
&lt;li>复制(Copy)：将符合条件的报文由内核空间复制到用户空间；&lt;/li>
&lt;/ul>
&lt;p>以 tcpdump 为例：熟悉网络监控(network monitoring)的读者大抵都知道 tcpdump 依赖于 pcap 库，tcpdump 中的诸多核心功能都经由后者实现，其整体工作流程如下图所示：&lt;/p>
&lt;p>图 1. Tcpdump 工作流程&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-22-55-epbf-image001.png" alt="">&lt;/p>
&lt;p>由图 1 不难看出，位于内核之中的 BPF 模块是整个流程之中最核心的一环：它一方面接受 tcpdump 经由 libpcap 转码而来的滤包条件(Pseudo Machine Language) ，另一方面也将符合条件的报文复制到用户空间最终经由 libpcap 发送给 tcpdump。&lt;/p>
&lt;p>读到这里，估计有经验的读者已经能够在脑海里大致勾勒出一个 BPF 实现的大概了，图 2 引自文献 1，读者们可以管窥一下当时 BPF 的设计：&lt;/p>
&lt;p>图 2. BPF Overview&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-01-epbf002.png" alt="">&lt;/p>
&lt;p>时至今日，传统 BPF 仍然遵循图 2 的路数：途经网卡驱动层的报文在上报给协议栈的同时会多出一路来传送给 BPF，再经后者过滤后最终拷贝给用户态的应用。除开本文提及的 tcpdump，当时的 RARP 协议也可以利用 BPF 工作(Linux 2.2 起，内核开始提供 rarp 功能，因此如今的 RARP 已经不再需要 BPF 了)。&lt;/p>
&lt;p>整体来说，BPF 的架构还是相对浅显易懂的，不过要是深入细节的话就没那么容易了：因为其中的 filter 的设计（也是文献 1 中着墨最多的地方）要复杂那么一点点。&lt;/p>
&lt;h3 id="pseudo-machine-language">Pseudo Machine Language&lt;/h3>
&lt;p>估计在阅读本文之前，相当数量的读者都会误以为所谓的 Filter&lt;/p>
&lt;p>的是挂在 tcpdump 末尾处的 expression 吧，类似于图 1 中的&amp;quot;tcp and dst port 7070&amp;quot;这样。但倘若我们如下文这样在 tcpdump 的调用中加入一个-d，还会发现其中大有乾坤：&lt;/p>
&lt;p>清单 1 tcpdump -d&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">#以下代码可以在任意支持 tcpdump 的类 Unix 平台上运行，输出大同小异
bash-3.2$ sudo tcpdump -d -i lo tcp and dst port 7070
(000) ldh [12]
(001) jeq #0x86dd jt 2 jf 6 #检测是否为 ipv6 报文，若为假(jf)则按照 ipv4 报文处理(L006)
(002) ldb [20]
(003) jeq #0x6 jt 4 jf 15 #检测是否为 tcp 报文
(004) ldh [56]
(005) jeq #0x1b9e jt 14 jf 15 #检测是否目标端口为 7070(0x1b9e)，若为真(jt)则跳转 L014
(006) jeq #0x800 jt 7 jf 15 #检测是否为 ipv4 报文
(007) ldb [23]
(008) jeq #0x6 jt 9 jf 15 #检测是否为 tcp 报文
(009) ldh [20]
(010) jset #0x1fff jt 15 jf 11 #检测是否为 ip 分片(IP fragmentation)报文
(011) ldxb 4*([14]&amp;amp;0xf)
(012) ldh [x + 16] #找到 tcp 报文中 dest port 的所在位置
(013) jeq #0x1b9e jt 14 jf 15 #检测是否目标端口为 7070(0x1b9e)，若为真(jt)则跳转 L014
(014) ret #262144 #该报文符合要求
(015) ret #0 #该报文不符合要求
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 man page，tcpdump 的-d 会将输入的 expression 转义为一段&amp;quot;human readable&amp;quot;的&amp;quot;compiled packet-matching code&amp;quot;。当然，如清单 1 中的内容，对于很多道行不深的读者来说，基本是&amp;quot;human unreadable&amp;quot;的，于是笔者专门加入了一些注释加以解释，但是相较于-dd 和-ddd 反人类的输出，这确可以称得上是&amp;quot;一目了然&amp;quot;的代码了。&lt;/p>
&lt;p>这段看起来类似于汇编的代码，便是 BPF 用于定义 Filter 的伪代码，亦即图 1 中 libpcap 和内核交互的 pseudo machine language(也有一种说法是，BPF 伪代码设计之初参考过当时大行其道的 RISC 令集的设计理念)，当 BPF 工作时，每一个进出网卡的报文都会被这一段代码过滤一遍，其中符合条件的(ret #262144)会被复制到用户空间，其余的(ret #0)则会被丢弃。&lt;/p>
&lt;p>BPF 采用的报文过滤设计的全称是 CFG(Computation Flow Graph)，顾名思义是将过滤器构筑于一套基于 if-else 的控制流(flow graph)之上，例如清单 1 中的 filter 就可以用图 3 来表示：&lt;/p>
&lt;p>图 3 基于 CFG 实现的 filter 范例&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-07-epbf003.png" alt="">&lt;/p>
&lt;p>CFG 模型最大的优势是快，参考文献 1 中就比较了 CFG 模型和基于树型结构构建出的 CSPF 模型的优劣，得出了基于 CFG 模型需要的运算量更小的结论；但从另一个角度来说，基于伪代码的设计却也增加了系统的复杂性：一方面伪指令集已经足够让人眼花缭乱的了；另一方面为了执行伪代码，内核中还需要专门实现一个虚拟机(pseudo-machine)，这也在一定程度上提高了开发和维护的门槛。&lt;/p>
&lt;p>当然，或许是为了提升系统的易用性，一方面 BPF 设计者们又额外在 tcpdump 中设计了我们今天常见的过滤表达式(实际实现于 libpcap，当然两者也都源于 Lawrence Berkeley Lab)，令过滤器真正意义上&amp;quot;Human Readable&amp;quot;了起来；另一方面，由于设计目标只是过滤字节流形式的报文，虚拟机及其伪指令集的设计相对会简单不少：整个虚拟机只实现了两个 32 位的寄存器，分别是用于运算的累加器 A 和通用寄存器 X；且指令集也只有寥寥 20 来个，如表 1 所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Category&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Opcodes&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Address modes&lt;/strong>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Load Instructions&lt;/strong>&lt;/td>
&lt;td>ldb&lt;/td>
&lt;td>[k]&lt;/td>
&lt;td>[x+k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ldh&lt;/td>
&lt;td>[k]&lt;/td>
&lt;td>[x+k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ld&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>#len&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>[k]&lt;/td>
&lt;td>[x+k]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ldx&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>#len&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>4 * ([k] &amp;amp; 0xf)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Store Instructions&lt;/strong>&lt;/td>
&lt;td>st&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>stx&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>ALU Instruction&lt;/strong>&lt;/td>
&lt;td>add&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>sub&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>mul&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>div&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>and&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>or&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>lsh&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>rsh&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Branch Instruction&lt;/strong>&lt;/td>
&lt;td>jmp&lt;/td>
&lt;td>L&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jeq&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jgt&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jge&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jset&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Misc Instruction&lt;/strong>&lt;/td>
&lt;td>tax&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>txa&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Return Instruction&lt;/strong>&lt;/td>
&lt;td>ret&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>a&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>易用性方面的提升很大程度上弥补了 BPF 本身的复杂度带来的缺憾，很大程度上推动了 BPF 的发展，此后数年，BPF 逐渐称为大众所认同，包括 Linux 在内的众多操作系统都开始将 BPF 引入了内核。&lt;/p>
&lt;p>鉴于 Linux 上 BPF 如火如荼的大好形势，本文余下的部分笔者将基于 Linux 上的 BPF 实现进行展开。&lt;/p>
&lt;h3 id="lsf-linux-下的-bpf-实现">LSF: Linux 下的 BPF 实现&lt;/h3>
&lt;p>BPF 是在 1997 年首次被引入 Linux 的，当时的内核版本尚为 2.1.75。准确的说，Linux 内核中的报文过滤机制其实是有自己的名字的：Linux Socket Filter，简称 LSF。但也许是因为 BPF 名声太大了吧，连&lt;a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">内核文档&lt;/a>都不大买这个帐，直言 LSF 其实就是(aka)BPF。&lt;/p>
&lt;p>当然，LSF 和 BPF 除了名字上的差异以外，还是有些不同的，首当其冲的分歧就是接口：传统的 BSD 开启 BPF 的方式主要是靠打开(open)/dev/bpfX 设备，之后利用 ioctl 来进行控制；而 linux 则选择了利用套接字选项(sockopt)SO_ATTACH_FILTER/SO_DETACH_FILTER 来执行系统调用，篇幅所限，这部分内容笔者就不深入了，有兴趣的读者可以通过移步&lt;a href="http://man7.org/linux/man-pages/man7/socket.7.html">socket 的 manual page&lt;/a>或&lt;a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">内核 filter 文档&lt;/a>深入了解。这里笔者只给出一个例子来让读者们对 Linux 下的 BPF 的开发有一个直观的感受：&lt;/p>
&lt;h5 id="清单-2-bpf-sample">清单 2 BPF Sample&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;……&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// tcpdump -dd 生成出的伪代码块
&lt;/span>&lt;span class="c1">// instruction format:
&lt;/span>&lt;span class="c1">// opcode: 16bits; jt: 8bits; jf: 8bits; k: 32bits
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sock_filter&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">{&lt;/span> &lt;span class="mh">0x28&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x0000000c&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (000) ldh [12]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x000086dd&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (001) jeq #0x86dd jt 2 jf 6
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x30&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000014&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (002) ldb [20]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000006&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (003) jeq #0x6 jt 4 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x28&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000038&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (004) ldh [56]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000438&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (005) jeq #0x438 jt 14 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000800&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (006) jeq #0x800 jt 7 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x30&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000017&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (007) ldb [23]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000006&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (008) jeq #0x6 jt 9 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x28&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000014&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (009) ldh [20]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x45&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00001fff&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (010) jset #0x1fff jt 15 jf 11
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0xb1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x0000000e&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (011) ldxb 4*([14]&amp;amp;0xf)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x48&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000010&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (012) ldh [x + 16]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000438&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (013) jeq #0x438 jt 14 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00040000&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (014) ret #262144
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000000&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (015) ret #0
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sock_fprog&lt;/span> &lt;span class="n">bpf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sock_filter&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">code&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 1. 创建 raw socket
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AF_PACKET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SOCK_RAW&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">htons&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ETH_P_ALL&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 2. 将 socket 绑定给指定的 ethernet dev
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// ethernet dev 由 arg 1 传入
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">addr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sll_ifindex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">if_nametoindex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 3. 利用 SO_ATTACH_FILTER 将 bpf 代码块传入内核
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">setsockopt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SOL_SOCKET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SO_ATTACH_FILTER&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">bpf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bpf&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(;&lt;/span> &lt;span class="p">;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">recv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 4. 利用 recv()获取符合条件的报文
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ip_header&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">iphdr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">buf&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">ether_header&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">inet_ntop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AF_INET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">saddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">src_addr_str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">src_addr_str&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">inet_ntop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AF_INET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">daddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dst_addr_str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dst_addr_str&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;IPv%d proto=%d src=%s dst=%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">version&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">protocol&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">src_addr_str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dst_addr_str&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>篇幅所限，清单 2 中笔者只列出了部分代码，代码分析也以注释为主。有兴趣的读者可以移步&lt;a href="https://raw.githubusercontent.com/windywolf/example/master/eBPF/bpfsample.c">这&lt;/a>&lt;a href="https://raw.githubusercontent.com/windywolf/example/master/eBPF/bpfsample.c">里&lt;/a>阅读完全版。&lt;/p>
&lt;p>由于主要是和过滤报文打交道，内核中(before 3.18)的 BPF 的绝大部分实现都被放在了&lt;a href="http://elixir.free-electrons.com/linux/v2.6.39.4/source/net/core/filter.c">net/core/filter.c&lt;/a>下，篇幅原因笔者就不对代码进行详述了，文件不长，600 来行(v2.6)，比较浅显易懂，有兴趣的读者可以移步品评一下。值得留意的函数有两个，sk_attach_filter()和sk_run_filter()：前者将 filter 伪代码由用户空间复制进内核空间；后者则负责在报文到来时执行伪码解析。&lt;/p>
&lt;h3 id="演进jit-for-bpf">演进：JIT For BPF&lt;/h3>
&lt;p>BPF 被引入 Linux 之后，除了一些小的性能方面的调整意外，很长一段时间都没有什么动静。直到 3.0 才首次迎来了比较大的革新：在一些特定硬件平台上，BPF 开始有了用于提速的 JIT(Just-In-Time) Compiler。&lt;/p>
&lt;p>最先实现 JIT 的是&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net">x&lt;/a>&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net">8&lt;/a>&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net">6&lt;/a>平台，其后包括&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/arm/net">arm&lt;/a>、&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/powerpc/net">ppc&lt;/a>、&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/390/net">S390&lt;/a>、&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/mips/net">mips&lt;/a>等一众平台纷纷跟进，到今天 Linux 的主流平台中支持 JIT For BPF 的已经占了绝大多数了。&lt;/p>
&lt;p>BPF JIT 的接口还是简单清晰的：各平台的 JIT 编译函数都实现于&lt;a href="http://elixir.free-electrons.com/linux/v3.10.107/source/arch/x86/net/bpf_jit_comp.c#L147">bpf_jit_compile()&lt;/a>之中(3.16 之后，开始逐步改为&lt;a href="http://elixir.free-electrons.com/linux/v3.16/source/arch/x86/net/bpf_jit_comp.c#L869">bpf_int_jit_compile()&lt;/a>)，如果 CONFIG_BPF_JIT 被打开，则传入的 BPF 伪代码就会被传入该函数加以编译，编译结果被拿来替换掉默认的处理函数 sk_run_filter()。JIT 的实现不在本文讨论之列，其代码基本位于 arch/&lt;platform>/net 之下，有致力于优化的同学可以尝试学习一下。&lt;/p>
&lt;p>打开 BPF 的 JIT 很简单，只要向/proc/sys/net/core/bpf_jit_enable 写入 1 即可；对于有调试需求的开发者而言，如果写入 2 的话，还可以在内核 log 中看到载入 BPF 代码时候 JIT 生成的优化代码，内核开发者们还提供了一个更加方便的工具&lt;a href="http://elixir.free-electrons.com/linux/v4.12.8/source/tools/net">bpf_jit_disam&lt;/a>，可以将内核 log 中的二进制转换为汇编以便阅读。&lt;/p>
&lt;p>JIT Compiler 之后，针对 BPF 的小改进不断：如将 BPF 引入 seccomp(3.4)；添加一些 debug 工具如 bpf_asm 和 bpf_dbg(3.14)。不过比较革命性的大动作就要等到 3.17 了，这次的改进被称为 extended BPF，即 eBPF。&lt;/p>
&lt;h2 id="进化extended-bpf">进化：extended BPF&lt;/h2>
&lt;p>自 3.15 伊始，一个套源于 BPF 的全新设计开始逐渐进入人们的视野，并最终(3.17)被添置到了 kernel/bpf 下。这一全新设计最终被命名为了 extended BPF(eBPF)：顾名思义，有全面扩充既有 BPF 功能之意；而相对应的，为了后向兼容，传统的 BPF 仍被保留了下来，并被重命名为 classical BPF(cBPF)。&lt;/p>
&lt;p>相对于 cBPF，eBPF 带来的改变可谓是革命性的：一方面，它已经为内核追踪(Kernel Tracing)、应用性能调优/监控、流控(Traffic Control)等领域带来了激动人心的变革；另一方面，在接口的设计以及易用性上，eBPF 也有了较大的改进。&lt;/p>
&lt;p>Linux 内核代码的 samples 目录下有大量前人贡献的&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf">eBPF sample&lt;/a>，这里笔者先挑选其中相对简单的 sockex1 来帮助读者们建立一个 eBPF 的初步印象：&lt;/p>
&lt;h5 id="清单-3-sockex1_userc">清单 3 sockex1_user.c&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;…&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// 篇幅所限，清单 3 和 4 都只罗列出部分关键代码，有兴趣一窥全貌的读者可以移步 http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf深入学习
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">ac&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// 1. eBPF 的伪代码位于 sockex1_kern.o 中，这是一个由 llvm 生成的 elf 格式文件，指令集为 bpf;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">snprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;%s_kern.o&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">load_bpf_file&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// load_bpf_file()定义于 bpf_load.c，利用 libelf 来解析 sockex1_kern.o
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 并利用 bpf_load_program 将解析出的伪代码 attach 进内核;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 2. 因为 sockex1_kern.o 中 bpf 程序的类型为 BPF_PROG_TYPE_SOCKET_FILTER
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 所以这里需要用用 SO_ATTACH_BPF 来指明程序的 sk_filter 要挂载到哪一个套接字上
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open_raw_sock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;lo&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">setsockopt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SOL_SOCKET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SO_ATTACH_BPF&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">prog_fd&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">prog_fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]))&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 3. 利用 map 机制获取经由 lo 发出的 tcp 报文的总长度
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">IPPROTO_TCP&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bpf_map_lookup_elem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map_fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tcp_cnt&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>清单 4 sockex1_kern.c&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;……&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// 预先定义好的 map 对象
&lt;/span>&lt;span class="c1">// 这里要注意好其实 map 是需要由用户空间程序调用 bpf_create_map()进行创建的
&lt;/span>&lt;span class="c1">// 在这里定义的 map 对象，实际上会在 load_bpf_file()解析 ELF 文件的同时被解析和创建出来
&lt;/span>&lt;span class="c1">// 这里的 SEC(NAME)宏表示在当前 obj 文件中新增一个段(section)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">bpf_map_def&lt;/span> &lt;span class="nf">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;maps&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">my_map&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BPF_MAP_TYPE_ARRAY&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">key_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">value_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">max_entries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">256&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;socket1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bpf_prog1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">__sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// 这个例子比较简单，仅仅是读取输入报文的包头中的协议位而已
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这里的 load_byte 实际指向了 llvm 的 built-in 函数 asm(llvm.bpf.load.byte)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 用于生成 eBPF 指令 BPF_LD_ABS 和 BPF_LD_IND
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">load_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ETH_HLEN&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">offsetof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">iphdr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">protocol&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 根据 key(&amp;amp;index，注意这是一个指向函数的引用)获取对应的 value
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bpf_map_lookup_elem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">my_map&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">__sync_fetch_and_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//这里的__sync_fetch_and_add 是 llvm 中的内嵌函数，表示 atomic 加操作
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 为了满足 GPL 毒药的需求，所有会注入内核的 BPF 代码都须显式的支持 GPL 协议
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">_license&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;license&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;GPL&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对比一下清单 3&amp;amp;4 以及清单 2 的代码片段，很容易看出一些 eBPF 显而易见的革新：&lt;/p>
&lt;ul>
&lt;li>用 C 写成的 BPF 代码(sockex1_kern.o)；&lt;/li>
&lt;li>基于 map 的内核与用户空间的交互方式；&lt;/li>
&lt;li>全新的开发接口；&lt;/li>
&lt;/ul>
&lt;p>除此之外，还有一些不那么明显的改进隐藏在内核之中：&lt;/p>
&lt;ul>
&lt;li>全新的伪指令集设计；&lt;/li>
&lt;li>In-kernel verifier;&lt;/li>
&lt;/ul>
&lt;p>由一个文件(net/core/filter.c)进化到一个目录(kernel/bpf)，eBPF 的蜕变三言两语间很难交代清楚，下面笔者就先基于上述的几点变化来帮助大家入个门，至于个中细节，就只能靠读者以后自己修行了。&lt;/p>
&lt;h3 id="再见了汇编">再见了汇编&lt;/h3>
&lt;p>利用高级语言书写 BPF 逻辑并经由编译器生成出伪代码来并不是什么新鲜的尝试，比如 libpcap 就是在代码中内嵌了一个小型编译器来分析 tcpdump 传入的 filter expression 从而生成 BPF 伪码的。只不过长久以来该功能一直没有能被独立出来或者做大做强，究其原因，主要还是由于传统的 BPF 所辖领域狭窄，过滤机制也不甚复杂，就算是做的出来，估计也不堪大用。&lt;/p>
&lt;p>然而到了 eBPF 的时代，情况终于发生了变化：现行的伪指令集较之过去已经复杂太多，再用纯汇编的开发方式已经不合时宜，于是，自然而然的，利用 C 一类的高级语言书写 BPF 伪代码的呼声便逐渐高涨了起来。&lt;/p>
&lt;p>目前，支持生成 BPF 伪代码的编译器只有 llvm 一家，即使是通篇使用 gcc 编译的 Linux 内核，samples 目录下的 bpf 范例也要借用 llvm 来编译完成。还是以 sockex1 为例，用户态下的代码 sockex_user.c 是利用 HOSTCC 定义的编译器编译的；但 sockex_kern.c 就需要用到 clang 和 llvm 了。在&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf/Makefile">samples/bpf/Makefile&lt;/a>中，可以看到：&lt;/p>
&lt;h5 id="清单-5-samplesbpfmakefile">清单 5 samples/bpf/Makefile&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-makefile" data-lang="makefile">&lt;span class="c"># ......
&lt;/span>&lt;span class="c"># List of programs to build
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">hostprogs-y&lt;/span> &lt;span class="o">:=&lt;/span> test_lru_dist
&lt;span class="nv">hostprogs-y&lt;/span> &lt;span class="o">+=&lt;/span> sockex1
&lt;span class="c"># ……
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">sockex1-objs&lt;/span> &lt;span class="o">:=&lt;/span> bpf_load.o &lt;span class="k">$(&lt;/span>LIBBPF&lt;span class="k">)&lt;/span> sockex1_user.o
&lt;span class="c"># ……
&lt;/span>&lt;span class="c"># 注意，这里有一个小 tip，就是如果在内核的 Makefile 中，
&lt;/span>&lt;span class="c"># 有某一个目标文件你不希望使用内核的通用编译规则的话(类似于本文的 sockex1_kern.o)，
&lt;/span>&lt;span class="c"># 可以像这里一样，并不把该文件加入任何 xxxprogs 或 xxx-objs，
&lt;/span>&lt;span class="c"># 而是直接放入 always，这样内核就会在本地 Makefile 中搜索编译规则了。
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">always&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">$(&lt;/span>hostprogs-y&lt;span class="k">)&lt;/span>
&lt;span class="err">&amp;lt;strong&amp;gt;always&lt;/span> &lt;span class="err">&amp;lt;/strong&amp;gt;&amp;lt;strong&amp;gt;+=&lt;/span> &lt;span class="err">sockex1_kern.o&amp;lt;/strong&amp;gt;&lt;/span>
&lt;span class="c"># ……
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">LLC&lt;/span> &lt;span class="o">?=&lt;/span> llc
&lt;span class="nv">CLANG&lt;/span> &lt;span class="o">?=&lt;/span> clang
&lt;span class="c"># ……
&lt;/span>&lt;span class="c"># sockex1_kern.o 就是使用了下述规则编译为 BPF 代码的，请注意笔者加粗的部分
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nf">$(obj)/%.o&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">src&lt;/span>&lt;span class="k">)&lt;/span>/%.&lt;span class="n">c&lt;/span>
&lt;span class="k">$(&lt;/span>&lt;span class="nv">CLANG&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">NOSTDINC_FLAGS&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">LINUXINCLUDE&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">EXTRA_CFLAGS&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-D__KERNEL__&lt;/span> &lt;span class="err">-D__ASM_SYSREG_H&lt;/span> &lt;span class="err">-Wno-unused-value&lt;/span> &lt;span class="err">-Wno-pointer-sign&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-compare-distinct-pointer-types&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-gnu-variable-sized-type-not-at-end&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-address-of-packed-member&lt;/span> &lt;span class="err">-Wno-tautological-compare&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-unknown-warning-option&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-O2&lt;/span> &lt;span class="err">-emit-llvm&lt;/span> &lt;span class="err">-c&lt;/span> &lt;span class="k">$&amp;lt;&lt;/span> &lt;span class="err">-o&lt;/span> &lt;span class="err">-|&lt;/span>
&lt;span class="k">$(&lt;/span>&lt;span class="nv">LLC&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="nv">-march&lt;/span>&lt;span class="o">=&lt;/span>bpf -filetype&lt;span class="o">=&lt;/span>obj -o
&lt;span class="k">$@&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>能用 C 书写 BPF 自然是便利了许多，但也不代表余下的开发工作就是一片坦途了：首先 llvm 的输出是 elf 文件，这也意味着想要获取能传入内核的代码，我们还需要额外做一段解析 elf 的工作，这也是为什么 Sample 下的范例几乎无一例外地都链接了 libelf 库；其次，同时也是比较重要的一点，不要忘记 BPF 的代码是跑在内核空间中的，因此书写时必得煞费苦心一番才好，以防一个不小心就做出个把内核干趴下的漏洞来：下文中提及的 verifier 就是为了这一点而生，每一个被放进内核的 BPF 代码，都须要经过它的检验才行。&lt;/p>
&lt;h3 id="bpf-程序的类别以及-map-机制">BPF 程序的类别以及 Map 机制&lt;/h3>
&lt;p>清单 3 中我们看到 sockex1_kern.o 是由 load_bpf_file()函数载入内存的，但实际上 eBPF 提供用来将 BPF 代码载入内核的正式接口函数其实是 bpf_load_program()，该接口负责通过参数向内核提供三类信息：&lt;/p>
&lt;ul>
&lt;li>BPF 程序的类型、&lt;/li>
&lt;li>BPF 代码&lt;/li>
&lt;li>代码运行时所需要的存放 log 的缓存地址(位于用户空间)；&lt;/li>
&lt;/ul>
&lt;p>有意思的是，目前所有注入内核的 BPF 程序都需要附带 GPL 协议支持信息，bpf_load_program()的 license 参数就是用来载入协议字串的。&lt;/p>
&lt;p>由 eBPF 伊始，BPF 程序开始有分类了，通过 bpf_load_program 的参数 bpf_prog_type，我们可以看到 eBPF 支持的程序类型。这里笔者将一些常用的类型罗列于下表之中供读者参考：&lt;/p>
&lt;h4 id="表-2-常见-bpf_prog_type-定义">表 2 常见 bpf_prog_type 定义&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>bpf_prog_type&lt;/strong>&lt;/th>
&lt;th>&lt;strong>BPF prog 入口参数(R1)&lt;/strong>&lt;/th>
&lt;th>&lt;strong>程序类型&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_SOCKET_FILTER&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct __sk_buff&lt;/strong>&lt;/td>
&lt;td>用于过滤进出口网络报文，功能上和 cBPF 类似。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_KPROBE&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct pt_regs&lt;/strong>&lt;/td>
&lt;td>用于 kprobe 功能的 BPF 代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_TRACEPOINT&lt;/strong>&lt;/td>
&lt;td>这类 BPF 的参数比较特殊，根据 tracepoint 位置的不同而不同。&lt;/td>
&lt;td>用于在各个 tracepoint 节点运行。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_XDP&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct xdp_md&lt;/strong>&lt;/td>
&lt;td>用于控制 XDP(eXtreme Data Path)的 BPF 代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_PERF_EVENT&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct bpf_perf_event_data&lt;/strong>&lt;/td>
&lt;td>用于定义 perf event 发生时回调的 BPF 代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_CGROUP_SKB&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct __sk_buff&lt;/strong>&lt;/td>
&lt;td>用于在 network cgroup 中运行的 BPF 代码。功能上和 Socket_Filter 近似。具体用法可以参考范例 test_cgrp2_attach。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_CGROUP_SOCK&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct bpf_sock&lt;/strong>&lt;/td>
&lt;td>另一个用于在 network cgroup 中运行的 BPF 代码，范例 test_cgrp2_sock2 中就展示了一个利用 BPF 来控制 host 和 netns 间通信的例子。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>深入对比清单 3(eBPF)和清单 2(cBPF)的实现的差异，还会发现一个比较明显的不同之处：BPF 代码进内核之后，cBPF 和内核通讯的方式是 recv()；而 eBPF 则将 socket 丢到一边，使用一种名为 map 的全新机制和内核通讯，其大致原理下图所示：&lt;/p>
&lt;h4 id="图-4-ebpf-的-map-机制">图 4 eBPF 的 map 机制&lt;/h4>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-22-epbf004.png" alt="">&lt;/p>
&lt;p>从图上看，这套设计本身不复杂：位于用户空间中的应用在内核中辟出一块空间建立起一个数据库用以和 eBPF 程序交互(bpf_create_map())；数据库本身以 Key-Value 的形式进行组织，无论是从用户空间还是内核空间都可以对其进行访问，两边有着相似的接口，最终在逻辑上也都殊途同归。&lt;/p>
&lt;p>不难发现，map 带来的最大优势是效率：相对于 cBPF 一言不合就把一个通信报文从内核空间丢出来的豪放，map 机制下的通讯耗费就要小家碧玉的多了：还是以 sockex1 为例，一次通信从内核中仅仅复制 4 个字节，而且还是已经处理好了可以直接拿来就用的，做过内核开发的人都知道这对于性能意味着什么。&lt;/p>
&lt;p>map 机制解决的另一个问题是通信数据的多样性问题。cBPF 所覆盖的功能范围很简单，无外乎是网络监控和 seccomp 两块，数据接口设计的粗放一点也就算了；而 eBPF 的利用范围则要广的多，性能调优、内核监控、流量控制什么的应有尽有，数据接口的多样性设计就显得很必要了。下表中就列出了现有 eBPF 中的 map 机制中常见的数据类型：&lt;/p>
&lt;h5 id="表-3-map-机制下的常见数据类型">表 3. map 机制下的常见数据类型&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Category&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Source&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Bpf_map_type&lt;/strong>&lt;/th>
&lt;th>&lt;strong>用途&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Array&lt;/strong>&lt;/td>
&lt;td>Arraymap.c&lt;/td>
&lt;td>BPF_MAP_TYPE_ARRAY BPF_MAP_TYPE_CGROUP_ARRAY BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF_MAP_TYPE_PERCPU_ARRAY BPF_MAP_TYPE_ARRAY_OF_MAPS&lt;/td>
&lt;td>实际就是数组，所以所有的 key 必须是整数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>BPF_MAP_TYPE_PROG_ARRAY&lt;/td>
&lt;td>该类型是一个特例，主要用于自定义函数，利用 JUMP_TAIL_CALL令跳转&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Hash&lt;/strong>&lt;/td>
&lt;td>Hashmap.c&lt;/td>
&lt;td>BPF_MAP_TYPE_HASH BPF_MAP_TYPE_PERCPU_HASH BPF_MAP_TYPE_LRU_HASH BPF_MAP_TYPE_LRU_PERCPU_HASH BPF_MAP_TYPE_HASH_OF_MAPS&lt;/td>
&lt;td>真正意义上的 map 数据类型，如果 key 值为整数以外的类型必须使用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Stack Trace&lt;/strong>&lt;/td>
&lt;td>Stackmap.c&lt;/td>
&lt;td>BPF_MAP_TYPE_STACK_TRACE&lt;/td>
&lt;td>真正意义上的 map 数据类型，如果 key 值为整数以外的类型必须使用存储特定应用在某一特定时间点的栈状态(包括内核态和用户态)，key 只有两个：分别为内核栈 id 和用户栈 id，利用 bpf_get_stackid()获取;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Longest Prefix Match Trie&lt;/strong>&lt;/td>
&lt;td>Lpm_trie.c&lt;/td>
&lt;td>BPF_MAP_TYPE_LPM_TRIE&lt;/td>
&lt;td>基于 Longest Prefix Match 前缀树实现，适宜处理以 CIBR 为键值时的情况&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="新的指令集">新的指令集&lt;/h3>
&lt;p>eBPF 对于既有 cBPF 令集的改动量之大，以至于基本上不能认为两者还是同一种语言了。个中变化，我们可以通过反汇编清单 4 的源代码(llvm-objdump &amp;ndash;disassemble)略知一二：&lt;/p>
&lt;p>清单 6 Disassemble of sockex1_kern.o&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-objectivec" data-lang="objectivec">&lt;span class="n">sockex1_kern&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">o&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="n">format&lt;/span> &lt;span class="n">ELF64&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">BPF&lt;/span>
&lt;span class="n">Disassembly&lt;/span> &lt;span class="n">of&lt;/span> &lt;span class="n">section&lt;/span> &lt;span class="nl">socket1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nl">bpf_prog1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">bf&lt;/span> &lt;span class="mi">16&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r6&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r1&lt;/span>
&lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">30&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mi">17&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u8&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">23&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="mi">2&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">63&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="n">fc&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r10&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r0&lt;/span>
&lt;span class="mi">3&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mo">04&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">4&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">55&lt;/span> &lt;span class="mo">01&lt;/span> &lt;span class="mi">08&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">04&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="k">goto&lt;/span> &lt;span class="mi">8&lt;/span>
&lt;span class="mi">5&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">bf&lt;/span> &lt;span class="n">a2&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r10&lt;/span>
&lt;span class="mi">6&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mo">07&lt;/span> &lt;span class="mo">02&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">fc&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="n">r2&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">4&lt;/span>
&lt;span class="mi">7&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">18&lt;/span> &lt;span class="mo">01&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0ll&lt;/span>
&lt;span class="mi">9&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">85&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">01&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">call&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="mi">10&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">02&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">r0&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">goto&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;span class="mi">11&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">12&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">db&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u64&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r0&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">r1&lt;/span>
&lt;span class="nl">LBB0_3&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="mi">13&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">b7&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="mi">14&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">95&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">exit&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们不用管这段汇编写了点儿什么，先跟清单 2 开头的那段 cBPF 代码对比一下两者的异同：&lt;/p>
&lt;ul>
&lt;li>寄存器：eBPF 支持更多的寄存器；
&lt;ul>
&lt;li>cBPF：A, X + stack, 32bit;&lt;/li>
&lt;li>eBPF：R1~R10 + stack, 64bit，显然，如此的设计主要针对现在大行其道的 64 位硬件，同时更多的寄存器设计也便于运行时和真实环境下的寄存器进行对应，以提高效率；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>opcode：两者的格式不同；
&lt;ul>
&lt;li>cBPF: op 16b, jt 8b, jf 8b, K 32b;&lt;/li>
&lt;li>eBPF: op 8b, dstReg 4b, srcReg 4b, off 16b, imm 32b;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他：sockex1_kern.o 设计的比较简单，但还是可以从中看出 eBPF 的一大改进：可以调用内核中预设好的函数（Call 1，这里指向的函数是 bpf_map_lookup_elem()，如果需要比较全的预设函数索引的话可以移步&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/include/uapi/linux/bpf.h#L494">这里&lt;/a>）。除此之外，eBPF 命令集中比较重要的新晋功能还有：
&lt;ul>
&lt;li>load/store 多样化：
&lt;ul>
&lt;li>cBPF：仅可以读 packet(即 skb)以及读写 stack；&lt;/li>
&lt;li>eBPF：可以读写包括 stack/map/context，也即 BPF prog 的传入参数可读写。换句话说，任意传入 BPF 代码的数据流均可以被修改；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>除开预设函数外，开发者还可以自定义 BPF 函数(JUMP_TAIL_CALL)；&lt;/li>
&lt;li>除了前向跳转外(Jump Forward，cBPF 支持)，还可以后向跳转(Jump Backword)；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>至于 eBPF 具体的指令表，因为过于庞杂这里笔者就不作文抄公了。不过 eBPF 中的几个寄存器的利用规则这里还是可以有的，否则要读懂清单 6 中的代码略有困难：&lt;/p>
&lt;ul>
&lt;li>R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；&lt;/li>
&lt;li>R1~R5：一般用于表示内核预设函数的参数；&lt;/li>
&lt;li>R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；&lt;/li>
&lt;li>R10：只读，用作栈指针(SP)；&lt;/li>
&lt;/ul>
&lt;h3 id="in-kernel-verifier">In-kernel Verifier&lt;/h3>
&lt;p>其实结合前面那么多的内容看下来不难发现 eBPF 其实近似于一种改头换面后的内核模块，只不过它比内核模块更短小精干，实现的功能也更新颖一些罢了，但无论是什么样的架构，只要存在注入的代码就会有安全隐患，eBPF 也不外如是——毕竟注入的代码是要在内核中运行的。&lt;/p>
&lt;p>为了最大限度的控制这些隐患，cBPF 时代就开始加入了&lt;a href="http://elixir.free-electrons.com/linux/v2.6.39.4/source/net/core/filter.c#L498">代码检查机制&lt;/a>以防止不规范的注入代码；到了 eBPF 时代则在载入程序(bpf_load_program())时加入了更复杂的&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L3544">verifier 机制&lt;/a>，在运行注入程序之前，先进行一系列的安全检查，最大限度的保证系统的安全。具体来说，verifier 机制会对注入的程序做两轮检查：&lt;/p>
&lt;ul>
&lt;li>首轮检查(First pass，实现于&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L2586">check_cfg()&lt;/a>)可以被认为是一次深度优先搜索，主要目的是对注入代码进行一次 DAG(Directed Acyclic Graph，有向无环图)检测，以保证其中没有循环存在；除此之外，一旦在代码中发现以下特征，verifier 也会拒绝注入：
&lt;ul>
&lt;li>代码长度超过上限，目前(内核版本 4.12)eBPF 的代码长度上限为 4K 条指令——这在 cBPF 时代很难达到，但别忘了 eBPF 代码是可以用 C 实现的；&lt;/li>
&lt;li>存在可能会跳出 eBPF 代码范围的 JMP，这主要是为了防止恶意代码故意让程序跑飞；&lt;/li>
&lt;li>存在永远无法运行(unreachable)的 eBPF 令，例如位于 exit 之后的指令；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>次轮检查(Second pass，实现于&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L2896">do_check()&lt;/a>)较之于首轮则要细致很多：在本轮检测中注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，所有的指令的参数（寄存器）、访问的内存、调用的函数都会被仔细的捋一遍，任何的错误都会导致注入程序被退货。由于过分细致，本轮检查对于注入程序的复杂度也有所限制：首先程序中的分支(branch)不允许超过 1024 个；其次经检测的指令数也必须在 96K 以内。&lt;/li>
&lt;/ul>
&lt;h3 id="overview-ebpf-的架构">Overview: eBPF 的架构&lt;/h3>
&lt;p>诚然，eBPF 设计的复杂程度已是超越 cBPF 太多太多，笔者罗里吧嗦了大半天，其实也就是将将领着大家入门的程度而已，为了便于读者们能够把前文所述的碎片知识串到一起，这里笔者将 eBPF 的大体架构草绘一番，如下图所示，希望能帮助大家对 eBPF 构建一个整体的认识。&lt;/p>
&lt;h4 id="图-5-architecture-of-ebpf">图 5. Architecture of eBPF&lt;/h4>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-30-epbf005.png" alt="">&lt;/p>
&lt;h3 id="追求极简bpf-compiler-collectionbcc">追求极简：BPF Compiler Collection(BCC)&lt;/h3>
&lt;p>现在让我们将目光聚焦到 eBPF 的使用——相信这是大部分读者最感兴趣的部分，毕竟绝大多数人其实并没有多少机会参与 eBPF 的开发——重新回到清单 3&amp;amp;4 中的 sockex1：说句良心话，虽然现在可以用 C 来实现 BPF，但编译出来的却仍然是 ELF 文件，开发者需要手动析出真正可以注入内核的代码。这部分工作多少有些麻烦，如果可以有一个通用的方案一步到位的生成出 BPF 代码就好了，开发者的注意力应该放在其他更有价值的地方，不是吗？&lt;/p>
&lt;p>于是就有人设计了 BPF Compiler Collection(BCC)，BCC 是一个 python 库，但是其中有很大一部分的实现是基于 C 和 C++的，python 只不过实现了对 BCC 应用层接口的封装而已。&lt;/p>
&lt;p>使用 BCC 进行 BPF 的开发仍然需要开发者自行利用 C 来设计 BPF 程序——但也仅此而已，余下的工作，包括编译、解析 ELF、加载 BPF 代码块以及创建 map 等等基本可以由 BCC 一力承担，无需多劳开发者费心。&lt;/p>
&lt;p>限于篇幅关于 BCC 笔者不再过多展开，文章的最后笔者再给出一个基于 BCC 实现的 sockex1 的例子，读者可以感受一下使用 BCC 带给开发者们的便利性：&lt;/p>
&lt;h5 id="清单-7-a-sample-of-bcc">清单 7 A sample of BCC&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">bcc&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">BPF&lt;/span>
&lt;span class="c1"># 和清单 2 一样，篇幅所限，这里只贴一部分源码，完全版请移步 https://raw.githubusercontent.com/windywolf/example/master/eBPF/bccsample.py&lt;/span>
&lt;span class="n">interface&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ens160&amp;#34;&lt;/span>
&lt;span class="c1"># BCC 可以接受直接将 BPF 代码嵌入 python code 之中&lt;/span>
&lt;span class="c1"># 为了方便展示笔者使用了这一功能&lt;/span>
&lt;span class="c1"># 注意：prog 中的中文注释是由于笔者需要写作之故加入，如果读者想尝试运行这段代码，&lt;/span>
&lt;span class="c1"># 则请将中文全部删除，因为目前 BCC 还不支持在内嵌 C 代码中使用中文注释&lt;/span>
&lt;span class="n">prog&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span class="s2">#include &amp;lt;net/sock.h&amp;gt;
&lt;/span>&lt;span class="s2">#include &amp;lt;bcc/proto.h&amp;gt;
&lt;/span>&lt;span class="s2">// BCC 中专门为 map 定义了一系列的宏，以方便使用
&lt;/span>&lt;span class="s2">// 宏中的 struct 下还定义了相应的函数，让开发者可以如 C++一般操作 map
&lt;/span>&lt;span class="s2">// 这里笔者定义了一个 array 类型的 map，名为 my_map1
&lt;/span>&lt;span class="s2">BPF_ARRAY(my_map1, long);
&lt;/span>&lt;span class="s2">// BCC 下的 BPF 程序中不再需要定义把函数或变量专门放置于某个 section 下了
&lt;/span>&lt;span class="s2">int bpf_prog1(struct __sk_buff *skb)
&lt;/span>&lt;span class="s2">{
&lt;/span>&lt;span class="s2"> // ……
&lt;/span>&lt;span class="s2"> struct ethernet_t *eth = cursor_advance(cursor, sizeof(*eth));
&lt;/span>&lt;span class="s2"> // ……
&lt;/span>&lt;span class="s2"> struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));
&lt;/span>&lt;span class="s2"> int index = ip-&amp;gt;nextp;
&lt;/span>&lt;span class="s2"> long zero = 0; // BCC 下的 bpf 书写还是有很多坑的
&lt;/span>&lt;span class="s2"> // 例如，这里如果不去定义一个局部变量 zero，
&lt;/span>&lt;span class="s2"> // 而是直接用常量 0 作为 lookup_or_init()的变量就会报错
&lt;/span>&lt;span class="s2"> // map 类下的各个方法的具体细节可以参照 reference_guide.md
&lt;/span>&lt;span class="s2"> value = my_map1.lookup_or_init(&amp;amp;index, &amp;amp;zero);
&lt;/span>&lt;span class="s2"> if (value)
&lt;/span>&lt;span class="s2"> __sync_fetch_and_add(value, skb-&amp;gt;len);
&lt;/span>&lt;span class="s2"> return 0;
&lt;/span>&lt;span class="s2">}
&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="n">bpf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BPF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">prog&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">debug&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 注入 bpf_prog1 函数&lt;/span>
&lt;span class="n">function&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bpf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">load_func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;bpf_prog1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BPF&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">SOCKET_FILTER&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 这是一段 SOCKET_FILTER 类型的 BPF，所以需要挂载到某一个 interface 上&lt;/span>
&lt;span class="n">BPF&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">attach_raw_socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">function&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">interface&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 利用 map 机制获取进出 interface 的各个协议的报文总长&lt;/span>
&lt;span class="n">bpf_map&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bpf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;my_map1&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nb">print&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;TCP : &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s2">, UDP : &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s2">, ICMP: &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="n">bpf_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">socket&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">IPPROTO_TCP&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="c1"># …&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="结束语">结束语&lt;/h2>
&lt;p>本文从 BPF 的源头开始，一路讲到了近年来刚刚杀青的 eBPF，虽说拘泥于篇幅，大多内容只能蜻蜓点水、浅尝辄止，但文中 BPF 的原理、设计、实现和应用均有所涉猎，勉强也能拿来入个门了。加之近年来基于 eBPF 的应用层出不穷，希望本文能激发读者们的奇思妙想，从而设计出更多基于 BPF 的优秀应用来。&lt;/p>
&lt;h2 id="参考资源">参考资源&lt;/h2>
&lt;ol>
&lt;li>[Steven McCanne, Van Jacobson] The BSD Packet Filter: A New Architecture for User-level Packet Capture, BPF 的源头，可在&lt;a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">这里&lt;/a>查阅；&lt;/li>
&lt;li>&lt;a href="http://www.tcpdump.org/tcpdump_man.html,">http://www.tcpdump.org/tcpdump_man.html,&lt;/a> tcpdump 的 manual page;&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/Documentation/networking/filter.txt,">https://www.kernel.org/doc/Documentation/networking/filter.txt,&lt;/a> 内核的 BPF 文档；&lt;/li>
&lt;li>&lt;a href="http://man7.org/linux/man-pages/man7/socket.7.html,">http://man7.org/linux/man-pages/man7/socket.7.html,&lt;/a> Linux 套接字的 manual page，其中有对 Linux Kernel 中 BPF 接口的大致介绍，不过论及详细程度还是不及参考文献 3 的；&lt;/li>
&lt;li>&lt;a href="https://lwn.net/Articles/437981/">https://lwn.net/Articles/437981/&lt;/a>，LWN 上刊载的 JIT For BPF 首次被引入的消息：A JIT For Packet Filters;&lt;/li>
&lt;li>&lt;a href="https://lwn.net/Articles/603983/,">https://lwn.net/Articles/603983/,&lt;/a> LWN 上刊载的 eBPF 的介绍文献：Extending extended BPF。由于年代久远接口相关的内容已经落后于最新代码了，权作参考；&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc,">https://github.com/iovisor/bcc,&lt;/a> BCC 的源码，但由于编译需要比较多的依赖，如果想偷个懒的话可以移步&lt;a href="https://hub.docker.com/r/zlim/bcc/">这里&lt;/a>直接获取 docker image；&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">bcc/reference_guide.md at master · iovisor/bcc · GitHub&lt;/a>, BCC 开发指南；&lt;/li>
&lt;li>&lt;a href="http://elixir.free-electrons.com/linux/latest/source,">http://elixir.free-electrons.com/linux/latest/source,&lt;/a> Linux Kernel 源码阅读利器。&lt;/li>
&lt;/ol></description></item><item><title>Ext4文件系统架构分析(一)(转)</title><link>https://justice.bj.cn/post/21.linux/ext4%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/ext4%E4%BB%8B%E7%BB%8D/</guid><description>&lt;h2 id="ext4文件系统架构分析一转">Ext4文件系统架构分析(一)(转)&lt;/h2>
&lt;p>本文描述Ext4文件系统磁盘布局和元数据的一些分析，同样适用于Ext3和Ext2文件系统，除了它们不支持的Ext4的特性外。整个分析分两篇博文，分别概述布局和详细介绍各个布局的数据结构及组织寻址方式等。感兴趣的看官敬请留意和指导！&lt;/p>
&lt;h2 id="1-ext4文件系统布局综述">1. Ext4文件系统布局综述&lt;/h2>
&lt;p>一个Ext4文件系统被分成一系列块组。为减少磁盘碎片产生的性能瓶颈，块分配器尽量保持每个文件的数据块都在同一个块组中，从而减少寻道时间。以4KB的数据块为例，一个块组可以包含32768个数据块，也就是128MB。&lt;/p>
&lt;h2 id="11磁盘布局">1.1 磁盘布局&lt;/h2>
&lt;p>Ext4文件系统的标准磁盘布局如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-26-23-28989651_13764045230xDi.jpg" alt="">&lt;/p>
&lt;p>Ext4文件系统主要使用块组0中的超级块和块组描述符表，在其他一些特定块组中有超级块和块组描述符表的冗余备份。如果块组中不含冗余备份，那么块组就以数据块位图开始。当格式化磁盘成为Ext4文件系统的时候，mkfs将在块组描述符表后面分配预留GDT表数据块(“Reserve GDT blocks”)以用于将来扩展文件系统。紧接在预留GDT表数据块后的是数据块位图与inode表位图，这两个位图分别表示本块组内的数据块与inode表的使用，inode表数据块之后就是存储文件的数据块了。在这些各种各样的块中，超级块、GDT、块位图、Inode位图都是整个文件系统的元数据，当然inode表也是文件系统的元数据，但是inode表是与文件一一对应的，我更倾向于将inode当做文件的元数据，因为在实际格式化文件系统的时候，除了已经使用的十来个外，其他inode表中实际上是没有任何数据的，直到创建了相应的文件才会分配inode表，文件系统才会在inode表中写入与文件相关的inode信息。&lt;/p>
&lt;h2 id="12flexible块组flex_bg">1.2 Flexible 块组（flex_bg）&lt;/h2>
&lt;p>Flexible 块组（flex_bg）是从Ext4开始引入的新特性。在一个flex_bg中，几个块组在一起组成一个逻辑块组flex_bg。Flex_bg的第一个块组中的位图空间和inode表空间扩大为包含了flex_bg中其他块组上位图和inode表。&lt;/p>
&lt;p>比如flex_bg包含4个块组，块组0将按序包含超级块、块组描述符表、块组0-3的数据块位图、块组0-3的inode位图、块组0-3的inode表，块组0中的其他空间用于存储文件数据。同时，其他块组上的数据块位图、inode位图、inode表元数据就不存在了，但是SB和GDT还是存在的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-26-33-28989651_1376404620OKyF.jpg" alt="">&lt;/p>
&lt;p>Flexible块组的作用是：&lt;/p>
&lt;ol>
&lt;li>聚集元数据，加速元数据载入；&lt;/li>
&lt;li>使得大文件在磁盘上尽量连续；&lt;/li>
&lt;/ol>
&lt;p>即使开启flex_bg特性，超级块和块组描述符的冗余备份仍然位于块组的开头。 Flex_bg中块组的个数由2^ext4_super_block.s_log_groups_per_flex 给出。&lt;/p>
&lt;h2 id="13元块组metablockgroups">1.3 元块组（Meta Block Groups）&lt;/h2>
&lt;p>通常，在每个冗余备份的超级块的后面是一个完整的(包含所有块组描述符的)块组描述符表的备份。这样会产生一个限制，以Ext4的块组描述符大小64 Bytes计算，文件系统中最多只能有2^21个块组，也就是文件系统最大为256TB。&lt;/p>
&lt;p>使用元块组Meta Block Groups特性，每个块组都包含该块组自己的描述符的冗余备份。因此可以创建2^33个块组，也就是文件系统最大1EB。48位数据块，每个块组128MB，因而可以创建2^33个块组。&lt;/p>
&lt;p>元块组实际上是可以用一个块组描述符块来进行描述的块组集，简单的说，它由一系列块组组成，同时这些块组对应的块组描述符存储在一个块中。它的出现使得Ext3和Ext4的磁盘布局有了一定的变化，以往超级块后紧跟的是变长的GDT块，现在是超级块依然决定于是否是3,5,7的幂，而一个块组描述符块则存储在元块组的第一个，第二个和最后一个块组的开始处(见下图)&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-26-40-28989651_1376404725HTsy.png" alt="">&lt;/p>
&lt;p>(1)  文件系统创建时。用户可以指定使用这种布局。 &lt;/p>
&lt;p>(2)  当文件系统增长而且预留的组描述符块耗尽时。目前超级块中有一个域s_first_meta_bg用于描述第一个使用元块组的块组。 &lt;/p>
&lt;p> 当增加新块组时，我们不需要给组描述符表预留空间，而是在当前文件系统后面直接添加新的元块组就可以了。&lt;/p>
&lt;h2 id="14lazy块组初始化">1.4 Lazy 块组初始化&lt;/h2>
&lt;p>如果块组中的相应标志已设置，那么块组中的inode位图和inode表将不被初始化。这样可以减少mkfs时间，如果开启了块组描述符校验和功能，甚至连块组都可以不初始化。&lt;/p>
&lt;h2 id="15特殊inodes">1.5 特殊inodes&lt;/h2>
&lt;p>Ext4预留了一些inode做特殊特性使用，见下表：&lt;/p>
&lt;p>表 1  Ext4的特殊inode&lt;/p>
&lt;p>Inode号    用途&lt;/p>
&lt;p>0      不存在0号inode&lt;/p>
&lt;p>1      损坏数据块链表&lt;/p>
&lt;p>2      根目录&lt;/p>
&lt;p>3      ACL索引&lt;/p>
&lt;p>4      ACL数据&lt;/p>
&lt;p>5      Boot  loader&lt;/p>
&lt;p>6      未删除的目录&lt;/p>
&lt;p>7      预留的块组描述符inode&lt;/p>
&lt;p>8      日志inode&lt;/p>
&lt;p>11     第一个非预留的inode，通常是lost+found目录&lt;/p>
&lt;h2 id="16数据块和inode分配策略">1.6 数据块和Inode分配策略&lt;/h2>
&lt;p>在机械磁盘上，保持相关的数据块相互接近可以总的磁头移动时间，因而可以加速磁盘IO。在SSD上虽然没有磁头转动，数据局部性可以增加每次IO请求的传输的数据大小，因而减少响应IO请求的传输次数。数据的局部性对单个擦除块的写入产生影响，可以加速文件重写的速度。因而尽可能减少碎片是必要的。inode和数据块的分配策略可以保证数据的局部集中。以下为inode和数据块的分配策略：&lt;/p>
&lt;p>(1)  多块分配可以减少磁盘碎片。当文件初次创建的时候，块分配器预测性地分配8KB的磁盘空间给文件。当文件关闭的时候，未使用的空间当然也就释放了。但是如果推测是正确的，那么文件数据将写到一个多个块的extent中。&lt;/p>
&lt;p>(2)  延迟分配。当一个文件需要更多的数据块引起写操作时，文件系统推迟决定新数据在磁盘上的存放位置，直到脏的buffer写到磁盘为止。&lt;/p>
&lt;p>(3)  尽量保持文件的数据块与其inode在同一个块组中。可以减少磁盘寻道时间.&lt;/p>
&lt;p>(4)  尽量保持同一个目录中的所有inodes与目录位于同一个块组中。这样的假设前提是一个目录中的文件是相关的。&lt;/p>
&lt;p>(5)  磁盘卷被分成128MB的块组。当在根目录中创建目录时，inode分配器扫描块组并将新目录放到它找到的使用负荷最小的块组中。这可以保证目录在磁盘上的分散性。&lt;/p>
&lt;p>(6)  即使上述机制无效，仍然可以使用e4defrag整理碎片文件。&lt;/p>
&lt;h2 id="17超级块">1.7 超级块&lt;/h2>
&lt;p>超级块记录整个文件系统的大量信息，如数据块个数、inode个数、支持的特性、管理信息，等待。&lt;/p>
&lt;p>如果设置sparse_super特性标志，超级块和块组描述符表的冗余备份仅存放在编号为0或3、5、7的幂次方的块组中。如果未设置sparse_super特性标志，冗余备份存在与所有的块组中。以下是2.6.32.18内核中对Ext4超级块的描述：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-11-28989651_1376493519z4rQ.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-15-28989651_1376493582Lvr6.png" alt="">&lt;/p>
&lt;p>3.0的内核中，Ext4的超级块加入了以下相关元数据：快照、文件系统错误处理相关、挂载选项、配额文件inode、超级块校验和等，见下图。目前没有深入研究这些新的元数据。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-21-28989651_1376493600Aq8i.png" alt="">&lt;/p>
&lt;h2 id="18块组描述符">1.8 块组描述符&lt;/h2>
&lt;p>一个块组中，具有固定位置的数据结构是超级块和块组描述符。其他数据结构位置都可以不固定。Flex_bg机制使用这个性质将几个块组聚合成一个flex块组，将flex_bg中所有位图和inode 表放到flex_bg的第一个块组中。详细情况可以参考我的上一篇Ext4分析博文的Flexible 块组（flex_bg）部分。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-25-28989651_1376493616YUiG.png" alt="">&lt;/p>
&lt;h2 id="19数据块位图与inode位图">1.9 数据块位图与inode位图&lt;/h2>
&lt;p>数据块位图跟踪块组中数据块使用情况。Inode位图跟踪块组中Inode使用情况。每个位图一个数据块，每一位用0或1表示一个块组中数据块或inode表中inode的使用情况。如果一个数据块大小是4KB的话，那一个位图块可以表示4&lt;em>1024&lt;/em>8个数据块的使用情况，这也是单个块组具有的最大数据块个数。这样可以算出一个块组大小是128MB。当然一个位图块也可以表示4&lt;em>1024&lt;/em>8个inode的使用情况，但是实际上一个块组中即使存满了文件，也不会用到这么多的inode，因为实际系统中基本不会出现所有文件大小都小于等于1个数据块大小的情况。实际上一个块组中有多少个inode，在块组描述符中是确定的，在文件系统格式化过程中也会看到这个数值，如果没记错的话，大概是每4个还是8个数据块分配一个inode空间。&lt;/p>
&lt;h2 id="110inode表">1.10 Inode表&lt;/h2>
&lt;p>为了找到与一个文件相关的信息，必须遍历目录文件找到与文件相关的目录项，然后加载inode找到该文件的元数据。Ext4在目录项中用一位存储了文件类型(通常存储在inode中)的拷贝，这对性能提升有益。Inode表的大小为ext4_super_block.s_inode_size * ext4_super_block.s_inodes_per_group Bytes。 &lt;br>
&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-33-28989651_13764936686K5v.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-41-28989651_13764936937EGO.png" alt="">&lt;/p>
&lt;h2 id="111查找inode">1.11 查找inode&lt;/h2>
&lt;p>每个块组包含ext4_super_block.s_inodes_per_group个inodes。因为0号inode不存在，可以通过如下的算式计算inode所在的块组：&lt;/p>
&lt;p>&lt;code>bg=(inode_num -1)/ ext4_super_block.s_inodes_per_group&lt;/code>&lt;/p>
&lt;p>inode在块组中inode表中的索引index可以通过如下的算式计算：&lt;/p>
&lt;p>&lt;code>index=(inode_num -1) % ext4_super_block.s_inodes_per_group&lt;/code>&lt;/p>
&lt;p>inode在inode表中的地址偏移为：&lt;/p>
&lt;p>&lt;code>offset=index * ext4_super_block.s_inode _size&lt;/code>&lt;/p>
&lt;h2 id="112inodei_block0s的内容">1.12 inode.i_block0[]s的内容&lt;/h2>
&lt;p>取决于文件类型，inode.i_blocks[]使用的方式不同。一般来说，常规文件和目录用inode.i_blocks[]作为文件数据块索引信息，特殊文件将inode.i_blocks[]用于特殊用途。常规文件用inode.i_blocks[]作为文件数据块索引信息的三级索引结构会在后面直接、间接块地址中详细介绍。&lt;/p>
&lt;h2 id="113-符号链接">1.13  符号链接&lt;/h2>
&lt;p>如果符号链接的目标字符串长度小于60字节，那么就将其存储在inode.i_blocks[]中，inode中inode.i_blocks[]占据的大小刚好是60KB。这里要注意到的是，有些文件其内容是跟文件的元数据放在一起的，因而就没有了数据块。也就是说不是每个文件数据都必然占据着一个数据块。&lt;/p>
&lt;h2 id="114直接间接块地址">1.14 直接/间接块地址&lt;/h2>
&lt;p> Ext2/Ext3中数据块映射方式如下表&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-28-43-28989651_1376493721DQi6.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-28-48-28989651_1376493732tfez.png" alt="">&lt;/p>
&lt;h2 id="115extent树">1.15   Extent 树&lt;/h2>
&lt;p>Ext4中用extent树代替了逻辑块映射。使用extents，用一个struct ext4_extent结构就可以映射多个数据块，减少元数据块的使用。如果设置了flex_bg，甚至可以用一个extent分配一个非常大的文件。使用extent特性，inode必须设置extents flag。&lt;/p>
&lt;p>Extents以树的方式安排。Extent树的每个节点都以一个ext4_extent_header开头，如果节点是内部节点(ext4_extent_header.eh_depth&amp;gt;0)，ext4_extent_header后面紧跟的是ext4_extent_header .eh_entries个索引项struct ext4_extent_idx，每个索引项指向该extent树中一个包含更多的节点的数据块。如果节点是叶子节点(ext4_extent_header.eh_depth==0)，ext4_extent_header后面紧跟的是ext4_extent_header .eh_entries个struct ext4_extent数据结构。这些ext4_extent结构指向文件数据块。Extent树的根结点存储在inode.i_blocks中，可以存储文件的前4个extents而不需额外的元数据块。&lt;/p>
&lt;p>ext4_extent_header：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-28-54-28989651_1376493751828X.png" alt="">&lt;/p>
&lt;p>struct ext4_extent_idx：extent树的内部节点，也称为索引节点。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201308/14/28989651_1376493761Or0J.jpg" alt="">&lt;/p>
&lt;p>ext4_extent：extent树的叶子节点。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-29-08-28989651_1376493772mVMU.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-29-03-28989651_13764937882FDI.png" alt="">&lt;/p>
&lt;h2 id="116extent树数据块校验和可能加入的新元数据">1.16 Extent树数据块校验和：可能加入的新元数据&lt;/h2>
&lt;p>由于extent树的根在inode中，因而Extent树数据块指extent树的除根据节点外的所有内部节点和叶子节点。Extent的树根节点和叶子节点的数据块中存储完xt4_extent_idx和xt4_extent数据结构后至少会留下4 ((2^x%12)&amp;gt;=4) bytes的空间。因而可以加入一个结构struct ext4_extent_tail，其中存储32位的校验和。位于inode中的4个extents无需校验和，因为inode已经做了校验和。&lt;/p>
&lt;h2 id="117目录项">1.17 目录项&lt;/h2>
&lt;p>Ext4文件系统中，一个目录差不多是一个平面文件，映射任意长度的字符串到文件系统中的一个inode。文件系统中存在多个目录项引用同一个inode——硬链接，这也是硬链接不能链接其他文件系统中的文件的原因。&lt;/p>
&lt;h2 id="118线性经典目录">1.18 线性（经典）目录&lt;/h2>
&lt;p>缺省地，目录文件中包含一个线性的目录项数组。未使用的目录项标记为inode =0。Ext4文件系统默认地使用struct ext4_dir_entry_2记录目录项，除非没有设置filetype特性标志。在没有设置filetype特性标志的情况下，使用struct ext4_dir_entry记录目录项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">ext4_dir_entry&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="n">__le32&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__le16&lt;/span> &lt;span class="n">rec_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__le16&lt;/span> &lt;span class="n">name_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">EXT4_NAME_LEN&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">ext4_dir_entry_2&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="n">__le32&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__le16&lt;/span> &lt;span class="n">rec_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__u8&lt;/span> &lt;span class="n">name_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__u8&lt;/span> &lt;span class="n">file_type&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">EXT4_NAME_LEN&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="119哈希树目录">1.19 哈希树目录&lt;/h2>
&lt;p>线性目录项不利于系统性能提升。因而从ext3开始加入了快速平衡树哈希目录项名称。如果在inode中设置EXT4_INDEX_FL标志，目录使用哈希的B树（hashed btree ，htree）组织和查找目录项。为了向后只读兼容Ext2，htree实际上隐藏在目录文件中。&lt;/p>
&lt;p>Ext2的惯例，树的根总是在目录文件的第一个数据块中。“.”和“..”目录项必须出现在第一个数据块的开头。因而这两个目录项在数据块的开头存放两个struct ext4_dir_entry_2结构，且它们不存到树中。根结点的其他部分包含树的元数据，最后一个hash-&amp;gt;block map查找到htree中更低的节点。如果dx_root.info.indirect_levels不为0，那么htree有两层；htree根结点的map指向的数据块是一个内部节点，由一个minor hash索引。Htree中的内部节点的minor_hash-&amp;gt;block map之后包含一个零化的(zeroed out) structext4_dir_entry_2找到叶子节点。叶子节点包括一个线性的struct ext4_dir_entry_2数组；所有这些项都哈希到相同的值。如果发生溢出，目录项简单地溢出到下一个叶子节点，哈希的least-significant位（内部节点的map）做相应设置。&lt;/p>
&lt;p>       以htree的方式遍历目录，计算要查找的目录文件名称的哈希值，然后使用哈希值找到对应的数据块号。如果树是flat，该数据块是目录项的线性数组，因而可被搜索到；否则，计算文件名称的minor hash，并使用minor hash查找相应的第三个数据块号。第三个数据块是目录项线性数组。&lt;/p>
&lt;p>**Htree的根 ：**struct dx_root&lt;br>
&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838358542Gih.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>Htree****的内部节点：&lt;/strong> struct dx_node&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838359310LhJ.jpg" alt="">&lt;/p>
&lt;p>Htree 树根和节点中都存在的 &lt;strong>Hash map&lt;/strong>**：** struct dx_entry&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383835946jC8F.jpg" alt="">&lt;/p>
&lt;h2 id="120扩展属性ea">1.20 扩展属性EA&lt;/h2>
&lt;p>扩展属性（xattrs）通常存储在磁盘上的一个单独的数据块中，通过inode.i_file_acl*引用。扩展属性的第一应用是存储文件的ACL以及其他安全数据(selinux)。使用user_xattr挂载选项就可为用户存储以“user”开头的所有扩展属性。这样的限制在3.0内核中已经消失。&lt;/p>
&lt;p>可以在两个地方找到扩展属性：一是在一个inode项结尾到下一个inode项开头的地方；二是inode.i_file_acl指向 的数据块之中，到3.0为止，这个数据块中不包含指向第二个扩展属性数据块的指针。理论上可以将每个属性值存储到一个单独的数据块中，但是3.0内核为止仍然没有这样做。&lt;/p>
&lt;p>当扩展属性不存储在一个inode之后的时候，就会有一个头部ext4_xattr_ibody_header&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836044J1Ee.jpg" alt="">&lt;/p>
&lt;p>扩展属性数据块的开头是ext4_xattr _header&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836053bZMK.jpg" alt="">&lt;/p>
&lt;p>紧跟在ext4_xattr_ibody_header或者ext4_xattr _header后面的是结构数组 struct ext4_xattr_entry&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838360603T4T.jpg" alt="">&lt;/p>
&lt;p>扩展属性值可以紧跟在ext4_xattr_entry项表后面。考虑4 bytes对齐。扩展属性值从扩展属性数据块的末尾开始向ext4_xattr _header / ext4_xattr_entry表的方向增长。当发生溢出时，溢出的部分放到一个单独的磁盘数据块上。&lt;/p>
&lt;h2 id="121日志jbd2">1.21 日志（JBD2）&lt;/h2>
&lt;p>文件系统在磁盘上保留一段小的连续区域(默认128MB)，作为尽可能需要快速写入磁盘的“重要”数据的存放地。一旦该重要数据事务完全写到磁盘，将其从磁盘写缓存中刷出。被提交的数据一份记录也被写到日志。一段时间后，日志在擦除提交记录前将事务写到它们在磁盘上的最终位置(可能包含大量的寻道或者大量的读-写-擦除)。&lt;/p>
&lt;p>从性能方面考虑，Ext4默认直接将文件系统元数据写到日志。因而不能保证文件数据块的一致性。&lt;/p>
&lt;p>       日志的inode为8。日志inode的前68 bytes复制了ext4 超级块。日志文件在文件系统中是普通文件，但是隐藏不可见。日志文件通常消耗一个完整的块组，可以通过mke2fs将日志文件放在磁盘的中间。&lt;/p>
&lt;p>Ext4和Ocfs2都使用JBD2。&lt;/p>
&lt;h3 id="1211布局">1.21.1 布局&lt;/h3>
&lt;p>日志布局&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836366A8dq.jpg" alt="">&lt;/p>
&lt;p>一个事务以描述符和一些数据或者block revocation链表开始。一个结束的事务总是以一个提交块结束。如果没有提交记录（或者校验和不匹配），事务在日志重演的时候将被丢弃。&lt;/p>
&lt;h3 id="1212-数据块头部">1.21.2  数据块头部&lt;/h3>
&lt;p>日志中的每个数据块的开头都是一个12 bytes的数据结构 struct journal_header_s&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836376fBf6.jpg" alt="">&lt;/p>
&lt;h3 id="1213-超级块">1.21.3  超级块&lt;/h3>
&lt;p>日志的超级块比Ext4的超级块简单。保存在日志的超级块中是日志的关键数据。日志超级块使用数据结构struct journal_superblock_s表示，大小为1024 bytes。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836388Dhwt.jpg" alt="">&lt;/p>
&lt;h3 id="1214-描述数据块descriptor-block">1.21.4  描述数据块Descriptor Block&lt;/h3>
&lt;p>Descriptor Block包含一个日志数据块tags的数组，这些tags描述了日志中接下来的数据块的最终位置。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836398lSZl.jpg" alt="">&lt;/p>
&lt;p>日志数据块tags具有如下格式：由数据结构struct journal_block_tag_s表示，可以是8，12，24或38bytes。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838364075ta9.jpg" alt="">&lt;/p>
&lt;h3 id="1215-数据块data-block">1.21.5  数据块Data Block&lt;/h3>
&lt;p>存放的是通过日志写到磁盘的数据块。但是如果数据块的前4 bytes与jbd2的魔数匹配，那么这些4 bytes用0代替，并且在Descriptor Block中设置escaped。&lt;/p>
&lt;p>&lt;strong>1.21.6  Revocation Block&lt;/strong>&lt;/p>
&lt;p>Revocation block用于记录本事务中的数据块链表，取代任何潜在日志中的更陈旧的数据块这样可以加速恢复，因为陈旧的数据块不必写到磁盘。&lt;/p>
&lt;p>Revocation block使用 structjbd2_journal_revoke_header_s结构表示&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836484127L.jpg" alt="">&lt;/p>
&lt;h3 id="1217-提交块">1.21.7  提交块&lt;/h3>
&lt;p>提交快表明了一个事务已完整写到日志。一旦提交块到达日志，存储在该事务中的数据可以写到它们在磁盘中的最终位置。&lt;/p>
&lt;p>提交快由数据结构struct commit_header表示：&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836493RAT5.jpg" alt="">&lt;/p></description></item><item><title>FUSE- linux用户空间文件系统(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bfuse/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bfuse/</guid><description>&lt;h1 id="fuse-linux用户空间文件系统转">FUSE: linux用户空间文件系统(转)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>用户空间文件系统 是操作系统中的概念，指完全在用户态实现的文件系统。&lt;/p>
&lt;p>目前Linux通过内核模块对此进行支持。一些文件系统如ZFS，glusterfs使用FUSE实现。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/209af4d9f14a2bf12bd44e9d77b47eaa_1174x826.png" alt="">&lt;/p>
&lt;p>FUSE的工作原理如上图所示。&lt;/p>
&lt;p>假设基于FUSE的用户态文件系统hello挂载在/tmp/fuse目录下。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当应用层程序要访问/tmp/fuse下的文件时，通过glibc中的函数进行系统调用，处理这些系统调用的VFS中的函数会调用FUSE在内核中的文件系统；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核中的FUSE文件系统将用户的请求，发送给用户态文件系统hello；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户态文件系统收到请求后，进行处理，将结果返回给内核中的FUSE文件系统；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，内核中的FUSE文件系统将数据返回给用户态程序。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Linux IO 之 IO与网络模型</title><link>https://justice.bj.cn/post/21.linux/linux-io-%E4%B9%8B-io%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux-io-%E4%B9%8B-io%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="linux-io-之-io与网络模型">Linux IO 之 IO与网络模型&lt;/h1>
&lt;p>&lt;img src="https://img.kancloud.cn/3a/19/3a190c1c6a523a9dd47174ede0e7a557_703x536.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>atomic 原子变量: x86在多核环境下，多核竞争数据总线时，提供Lock指令进行锁总线操作。保证“读-修改-写”的操作在芯片级的原子性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>spinlock 自旋锁: 自旋锁将当前线程不停地执行循环体，而不改变线程的运行状态，在CPU上实现忙等，以此保证响应速度更快。这种类型的线程数不断增加时，性能明显下降。所以自旋锁保护的临界区必须小，操作过程必须短。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>semaphore 信号量: 信号量用于保护有限数量的临界资源，信号量在获取和释放时，通过自旋锁保护，当有中断会把中断保存到eflags寄存器，最后再恢复中断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mutex 互斥锁: 为了控制同一时刻只有一个线程进入临界区，让无法进入临界区的线程休眠。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rw-lock 读写锁: 读写锁，把读操作和写操作分别进行加锁处理，减小了加锁粒度，优化了读大于写的场景。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="preempt-抢占">preempt 抢占&lt;/h2>
&lt;ul>
&lt;li>时间片用完后调用schedule函数。&lt;/li>
&lt;li>由于IO等原因自己主动调用schedule。&lt;/li>
&lt;li>其他情况，当前进程被其他进程替换的时候。&lt;/li>
&lt;/ul>
&lt;h2 id="per-cpu-变量">per-cpu 变量&lt;/h2>
&lt;p>linux为解决cpu 各自使用的L2 cache 数据与内存中的不一致的问题。&lt;/p>
&lt;h2 id="rcu机制-read-copy-update">RCU机制 (Read, Copy, Update)&lt;/h2>
&lt;p>用于解决多个CPU同时读写共享数据的场景。它允许多个CPU同时进行写操作，不使用锁，并且实现垃圾回收来处理旧数据。&lt;br>
&lt;img src="https://img.kancloud.cn/eb/25/eb25aceb1f3a87e34bc659922a23fb7f_850x379.png" alt="">&lt;/p>
&lt;h2 id="内存屏障-memory-barrier">内存屏障 memory-barrier&lt;/h2>
&lt;p>程序运行过程中，对内存访问不一定按照代码编写的顺序来进行。&lt;/p>
&lt;ol>
&lt;li>编译器对代码进行优化。&lt;/li>
&lt;li>多cpu架构存在指令乱序访问内存的可能。&lt;/li>
&lt;/ol>
&lt;h1 id="io-与网络模型">I/O 与网络模型&lt;/h1>
&lt;p>介绍各种各样的I/O模型，包括以下场景：&lt;/p>
&lt;ol>
&lt;li>阻塞 &amp;amp; 非阻塞&lt;/li>
&lt;li>多路复用&lt;/li>
&lt;li>Signal IO&lt;/li>
&lt;li>异步 IO&lt;/li>
&lt;li>libevent&lt;/li>
&lt;/ol>
&lt;p>现实生活中的场景复杂，Linux CPU和IO行为，他们之间互相等待。例如，阻塞的IO可能会让CPU暂停。&lt;/p>
&lt;p>I/O模型很难说好与坏，只能说在某些场景下，更适合某些IO模型。其中，1、4 更适合块设备，2、3 更适用于字符设备。&lt;/p>
&lt;p>为什么硬盘没有所谓的 多路复用，libevent，signal IO？&lt;/p>
&lt;p>因为select(串口), epoll（socket） 这些都是在监听事件，所以各种各样的IO模型，更多是描述字符设备和网络socket的问题。但硬盘的文件，只有读写，没有 epoll这些。这些IO模型更多是在字符设备，网络socket的场景。&lt;/p>
&lt;h2 id="为什么程序要选择正确的io模型">为什么程序要选择正确的IO模型？&lt;/h2>
&lt;p>蓝色代表：cpu，红色代表：io&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/2362bcb8a9159af33c0ec6d3e701c3df_1876x1340.png" alt="">&lt;/p>
&lt;p>如上图，某个应用打开一个图片文件，先需要100ms初始化，接下来100ms读这个图片。那打开这个图片就需要200ms。&lt;/p>
&lt;p>但是 是否可以开两个线程，同时做这两件事？&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/561dc951ee90a91df7d4de84ec3e88ce_1538x1128.png" alt="">&lt;/p>
&lt;p>如上图，网络收发程序，如果串行执行，CPU和IO会需要互相等待。&lt;br>
为什么CPU和IO可以并行？因为一般硬件，IO通过DMA，cpu消耗比较小，在硬件上操作的时间更长。CPU和硬盘是两个不同的硬件。&lt;/p>
&lt;p>再比如开机加速中systemd使用的readahead功能:&lt;br>
第一次启动过程，读的文件，会通过Linux inotify监控linux内核文件被操作的情况，记录下来。第二次启动，后台有进程直接读这些文件，而不是等到需要的时候再读。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/7bcb94f8c0d49a964dabf226688164cc_1244x954.png" alt="">&lt;/p>
&lt;p>I/O模型会深刻影响应用的最终性能，阻塞 &amp;amp; 非阻塞 、异步 IO 是针对硬盘， 多路复用、signal io、libevent 是针对字符设备和 socket。&lt;/p>
&lt;h2 id="简单的io模型">简单的IO模型&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/97be9252cd80c3254efc34e477cfb28a_1242x742.png" alt="">&lt;/p>
&lt;p>当一个进程需要读 键盘、触屏、鼠标时，进程会阻塞。但对于大量并发的场景，阻塞IO无法搞定，也可能会被信号打断。&lt;/p>
&lt;p>内核程序等待IO，gobal fifo read不到&lt;/p>
&lt;p>一般情况select返回，会调用 if signal_pending，进程会返回 ERESTARTSYS；此时，进程的read 返回由singal决定。有可能返回（EINTR），也有可能不返回。&lt;/p>
&lt;h3 id="demo">demo:&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sig_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">signum&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;int handler %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">signum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">ssize_t&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">sigaction&lt;/span> &lt;span class="n">oldact&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">sigaction&lt;/span> &lt;span class="n">act&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">act&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sa_handler&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sig_handler&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">act&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sa_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// act.sa_flags |= SA_RESTART;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sigemptyset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">act&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sa_mask&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">sigaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SIGUSR1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">act&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">oldact&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sigaction failed!/n&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">bzero&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">STDIN_FILENO&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">errno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">EINTR&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;retry after eintr&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">errno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">EINTR&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;read %d bytes, content is %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://box.kancloud.cn/d8477b6d3cf9bcc5804f316ea0246aef_719x709.png" alt="">&lt;/p>
&lt;p>一个阻塞的IO，在睡眠等IO时Ready，但中途被信号打断，linux响应信号，read/write请求阻塞。&lt;br>
配置信号时，在SA_FLAG是不是加“自动”，SA_RESTART指定 被阻塞的IO请求是否重发，并且应用中可以捕捉。加了SA_RESTART重发，就不会返回出错码EINTR。&lt;br>
没有加SA_RESTART重发，就会返回出错码（EINTR），这样可以检测read被信号打断时的返回。&lt;/p>
&lt;p>但Linux中有一些系统调用，即便你加了自动重发，也不能自动重发。man signal.&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/4708e2b53d43c11f9d32c0d590f0711a_2172x938.png" alt="">&lt;/p>
&lt;p>当使用阻塞IO时，要小心这部分。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/c92635e764196130ce6938048bed23f3_2258x1366.png" alt="">&lt;/p>
&lt;h2 id="多进程多线程模型">多进程、多线程模型&lt;/h2>
&lt;p>当有多个socket消息需要处理，阻塞IO搞不定，有一种可能是多个进程/线程，每当有一个连接建立（accept socket)，都会启动一个线程去处理新建立的连接。但是，这种模型性能不太好，创建多进程、多线程时会有开销。&lt;/p>
&lt;p>经典的C10K问题，意思是 在一台服务器上维护1w个连接，需要建立1w个进程或者线程。那么如果维护1亿用户在线，则需要1w台服务器。&lt;/p>
&lt;p>IO多路复用，则是解决以上问题的场景。&lt;/p>
&lt;p>总结：多进程、多线程模型企图把每一个fd放到不同的线程/进程处理，避免阻塞的问题，从而引入了进程创建\撤销，调度的开销。能否在一个线程内搞定所有IO? &amp;ndash; 这就是&lt;code>多路复用&lt;/code>的作用。&lt;/p>
&lt;h2 id="多路复用">多路复用&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/4ddb3f8f232beb837f294c27011cc050_2174x1226.png" alt="">&lt;/p>
&lt;h3 id="heading">&lt;/h3>
&lt;h3 id="异步io">异步IO&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/03f7f8364fe3a3f4db456252f83755b3_1454x906.png" alt="">&lt;/p>
&lt;p>Linux中&lt;/p>
&lt;p>不要把aio串起来，&lt;/p>
&lt;p>基于epoll等api进行上层的封装，再基于事件编程。某个事件成立了，就开始去做某件事。&lt;/p>
&lt;h3 id="libevent">libevent&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/503a1ac368ec755abf62083f1573099a_1150x798.png" alt="">&lt;/p>
&lt;p>就像MFC一样，界面上的按钮，VC会产生一个on_button，调对应的函数。是一种典型的事件循环。&lt;/p>
&lt;p>本质上还是用了epoll，只是基于事件编程。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/869403b17eca63bf85ec38d2a99be3b1_1146x812.png" alt="">&lt;/p>
&lt;p>点赞&lt;/p></description></item></channel></rss>