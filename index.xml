<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 06 Jan 2024 09:05:06 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>20.1.第2部分小结</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC2%E9%83%A8%E5%88%86/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E9%A1%BE/</guid><description>&lt;h1 id="201第2部分小结">20.1.第2部分小结&lt;/h1>
&lt;p>第二部分所讲的代码，就和第二部分的目录一样规整，一个 init 方法对应一个章节，简单粗暴。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">trap_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">blk_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">chr_dev_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">tty_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">time_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sched_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">buffer_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer_memory_end&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">hd_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">floppy_init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个过程，你可能觉得无聊，因为全是各种数据结构、中断、外设的初始化工作，后面将会怎么用它们，并没有展开讲解。&lt;/p>
&lt;p>但你也可能觉得兴奋，因为后面操作系统的全部工作，都是围绕着这几个初始化了的结构展开的，而它们却都是那么的好理解。&lt;/p>
&lt;p>其实我是蛮喜欢这个过程的，比如我看电影，其实我对高潮部分并不是很感兴趣，我就喜欢看一场大战或者一场阴谋前各部门的准备工作，看着它们为了后面一个完美的计划，所做的前期筹备，是一种享受，你懂的！&lt;/p>
&lt;p>所以今天特地花一章的功夫，把之前的初始化工作梳理一遍，之前没仔细看的同学，这章是个重新开始的机会！&lt;/p>
&lt;p>&amp;mdash;&amp;mdash;- 开始 &amp;mdash;&amp;mdash;-&lt;/p>
&lt;p>电脑开机后，首先由 BIOS 将操作系统程序加载到内存，之后在进入 main 函数前，我们用汇编语言（boot 包下的三个汇编文件）做了好多苦力活。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-00-39-5842ff28f8ee3ff369e500083ec104f2.png" alt="图片">&lt;/p>
&lt;p> &lt;/p>
&lt;p>这些苦力活做好后，内存布局变成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-00-47-aa6fb6afed20bd2cf4d18b96ae782faf.png" alt="图片">&lt;/p>
&lt;p>其中页表的映射关系，被做成了线性地址与物理地址相同。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-00-56-f83e89ef32c7a89f1e659dd689c0731a.png" alt="图片">&lt;/p>
&lt;p>也因为有了页表的存在，所以多了线性地址空间的概念，即经过分段机制转化后，分页机制转化前的地址，不考虑段限长的话，32 位的 CPU 线性地址空间应为 4G。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-04-46801d4a735b246d73179ecd447f2288.png" alt="图片">&lt;/p>
&lt;p>以上这些，是进入 main 函数之前的事情，由 boot 文件夹下的三个汇编文件完成，具体可以看整个第一部分的总结：&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499882&amp;amp;idx=1&amp;amp;sn=68fd16c5aeae15084be58afb1e5bd9e8&amp;amp;chksm=c2c5bac7f5b233d1c486fa57e9e3a2bc907a92ab69ff0344babab4d50bdaf76e7766b4b42914&amp;amp;scene=21#wechat_redirect">第一部分完结 进入内核前的苦力活&lt;/a>&lt;/p>
&lt;p>&amp;mdash;&amp;mdash;&amp;ndash; 进入 main 函数后 &amp;mdash;&amp;mdash;&amp;mdash;&lt;/p>
&lt;p>进入 main 函数后，首先进行了内存划分，其实就是设置几个边界值，将内核程序、缓冲区、主内存三个部分划分开界限。这就是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500061&amp;amp;idx=1&amp;amp;sn=6cb3382d7ac35ebeac52bbba3a89db4e&amp;amp;scene=21#wechat_redirect">第12回 | 管理内存前先划分出三个边界值&lt;/a> 所做的事情。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-15-d74711a7a01648fdf8a92f76021d62b3.png" alt="图片">&lt;/p>
&lt;p>随后，通过 mem_init 函数，对主内存区域用 mem_map[] 数组管理了起来，其实就是每个位置表示一个 4K 大小的内存页的使用次数而已，今后对主内存的申请和释放，其实都是对 mem_map 数组的操作。这是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;scene=21#wechat_redirect">第13回 | 主内存初始化 mem_init&lt;/a> 所做的事。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-22-eadd7b7ab08de923dd31e4315edbd036.png" alt="图片">&lt;/p>
&lt;p>后面又通过 buffer_init 函数，对缓冲区区域用多种数据结构管理起来。其中包括双向链表缓冲头 h 和每个缓冲头管理的 1024 字节大小的缓冲块 b。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500596&amp;amp;idx=1&amp;amp;sn=0df64f9f5133cfe8a259b8ce7b7feaeb&amp;amp;chksm=c2c5b999f5b2308f76095af30e8915f125f18702df9c58be7612b58e4d009c14948193974f9b&amp;amp;scene=21#wechat_redirect">第19回 | 缓冲区初始化 buffer_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-30-9e0c93a6c20e4071c78f4058101fe157.png" alt="图片">&lt;/p>
&lt;p>同时，又用一个 hashmap 结构，索引到所有缓冲头，方便快速查找，为之后的通过 LRU 算法使用缓冲区做准备。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-37-d9a496e63fb8d1db70414c4fa80a8d44.png" alt="图片">&lt;/p>
&lt;p>这些结构，就是缓冲区部分的管理，而缓冲区的目的是为了加速磁盘的读写效率，后面将读写文件全流程的时候，你会看到它在整个流程中起到中流砥柱的作用。&lt;/p>
&lt;p>再往后，通过 trap_init 函数把中断描述符表的一些默认中断都设置好了，随后再由各个模块设置它们自己需要的个性化的中断（比如硬盘中断、时钟中断、键盘中断等）。这是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500119&amp;amp;idx=1&amp;amp;sn=f46331f70677aba168243040a96be1c0&amp;amp;scene=21#wechat_redirect">第14回 | 中断初始化 trap_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-44-160eaeba72dee3db15d816d635205da3.png" alt="图片">&lt;/p>
&lt;p>再之后，通过 blk_dev_init 对读写块设备（比如硬盘）的管理进行了初始化，比如对硬盘的读写操作，都要封装为一个 request 结构放在 request[] 数组里，后面用电梯调度算法进行排队读写硬盘。这是 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500147&amp;amp;idx=1&amp;amp;sn=409f5ed34ae3822e40a6b443207d40c5&amp;amp;scene=21#wechat_redirect">第15回 | 块设备请求项初始化 blk_dev_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-50-a1f5bad28101fd35f8fcb97e5fb5290d.png" alt="图片">&lt;/p>
&lt;p>再往后，通过 tty_init 里的 con_init，实现了在控制台输出字符的功能，并且可以支持换行、滚屏等效果。当然此处也开启了键盘中断，如果此时中断已经处于打开状态，我们就可以用键盘往屏幕上输出字符啦。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500190&amp;amp;idx=1&amp;amp;sn=b0bebe846b55f7e29fc009e1b6587214&amp;amp;chksm=c2c5bb33f5b23225845ab699d1b8fcee39a04ca98a48ebf0e2c22584b638fa0b0839d1212485&amp;amp;scene=21#wechat_redirect">第16回 | 控制台初始化 tty_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-13-32-1b692caf245f5f7394c7e9735e16d023.gif" alt="图片">&lt;/p>
&lt;p>再之后，整个操作系统的精髓，进程调度，其初始化函数 shed_init，定义好了全部进程的管理结构 task[64] 数组，并在索引 0 位置处赋上了初始值，作为零号进程的结构体。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 进程调度初始化 sched_init&lt;/a> 的内容。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-01-59-35fc10afb266a06ae71d596a65979b66.png" alt="图片">&lt;/p>
&lt;p>然后又将全局描述符表增添了 TSS 和 LDT，用来管理 0 号进程的上下文信息以及内存规划，结构里面具体是什么，先不用管哟。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-06-c6537d21252cae6d3dd38447fd8a7e9f.png" alt="图片">&lt;/p>
&lt;p>同时，将这两个结构的地址，告诉 tr 寄存器和 ldt 寄存器，让 CPU 能够找到它们。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-14-cbe797778a2c502aa98b6342c4f89a39.png" alt="图片">&lt;/p>
&lt;p>随后，开启定时器，以及设置了时钟中断，用于响应定时器每隔 100ms 发来的中断信号。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/2c614feed87da9bbb61467ef39db49ae7eaa7726.gif" alt="图片">&lt;/p>
&lt;p>这样就算把进程调度的初始化工作完成了，之后进程调度就从定时器发出中断开始，先判断当前进程时间片是不是到了，如果到了就去 task[64] 数组里找下一个被调度的进程的信息，切换过去。&lt;/p>
&lt;p>这就是进程调度的简单流程，也是后面要讲的一个非常精彩的环节。&lt;/p>
&lt;p>最后最后，一个简单的硬盘初始化 hd_init，为我们开启了硬盘中断，并设置了硬盘中断处理函数，此时我们便可以真正通过硬盘的端口与其进行读写交互了。这是 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500686&amp;amp;idx=1&amp;amp;sn=c950e586af062e16c7e13a35084ca1d1&amp;amp;chksm=c2c5b923f5b230357ad1bca01a1b0ed76862f696681c92a232e687ab6eff5dbd3990217ac552&amp;amp;scene=21#wechat_redirect">第20回 | 硬盘初始化 hd_init&lt;/a> 的内容。&lt;/p>
&lt;p>把之前几个模块设置的中断放一块，此时的中断表我们看一下。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>中断号&lt;/th>
&lt;th>中断处理函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 ~ 0x10&lt;/td>
&lt;td>trap_init 里设置的一堆&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x20&lt;/td>
&lt;td>timer_interrupt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x21&lt;/td>
&lt;td>keyboard_interrupt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x2E&lt;/td>
&lt;td>hd_interrupt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0x80&lt;/td>
&lt;td>system_call&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这里我又提了一嘴，操作系统本质上就是个中断驱动的死循环，这个后面你会慢慢体会到。&lt;/p>
&lt;p>而我们再往下看一行 main 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define sti() __asm__ (&amp;#34;sti&amp;#34;::)
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是一个 &lt;strong>sti&lt;/strong> 汇编指令，意思是打开中断。其本质上是将 eflags 寄存器里的中断允许标志位 IF 位置 1。（由于已经是 32 位保护模式了，所以我把寄存器也都偷偷换成了 32 位的名字）&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-26-ed37de83e38c451d23dbbedfeb91fed5.png" alt="图片">&lt;/p>
&lt;p>这样 CPU 就开始可以接收并处理中断信号了，键盘可以按了，硬盘可以读写了，时钟可以震荡了，系统调用也可以生效了！&lt;/p>
&lt;p>这就代表着，操作系统具有了控制台交互能力，硬盘读写能力，进程调度能力，以及响应用户进程的系统调用请求！&lt;/p>
&lt;p>至此，全部初始化工作，就结束了！这里有几个初始化函数没有讲，都是可以忽略的，不要担心。&lt;/p>
&lt;p>一个是 chr_dev_init，因为这个函数里面本身就是空的，什么也没做。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-33-2530392bb368667cd391288a6cdabbfe.png" alt="图片">&lt;/p>
&lt;p>一个是 tty_init 里的 rs_init，这个方法是串口中断的开启，以及设置对应的中断处理程序，串口在我们现在的 PC 机上已经很少用到了，所以这个直接忽略。&lt;/p>
&lt;p>还一个是 floppy_init，这个是软盘的初始化，软盘现在已经被淘汰了，且电脑上也没有软盘控制器了，所以也忽略即可。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-02-39-1dd57c9c76269a05c86b8bea52042e2f.png" alt="图片">&lt;/p>
&lt;p>除了这些之外，全部的初始化工作，我们就全部梳理清楚了！再次为我们这一阶段性的胜利，鼓掌吧！！！&lt;/p>
&lt;p>同时，这章也会作为之后工作的一个索引章节，初始化工作所设置的所有数据结构都十分重要，后面如果你忘了，可以常来这里看看，祝大家好运。&lt;/p></description></item><item><title>22.从内核态到用户态</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/22.%E4%BB%8E%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%81/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/22.%E4%BB%8E%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%81/</guid><description>&lt;h1 id="22从内核态到用户态">22.从内核态到用户态&lt;/h1>
&lt;p>书接上回，上回书咱们从整体上鸟瞰了一下第三部分要讲的内容，代码上就是还差四句话就走到了 main 函数的尽头。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void main(void) {
    ...
    move_to_user_mode();
    if (!fork()) {
        init();
    }
    for(;;) 
        pause();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>今天我们就重点讲这第一句代码，&lt;strong>move_to_user_mode&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>让进程无法逃出用户态&lt;/strong>&lt;/p>
&lt;p>这行代码的意思直接说非常简单，就是&lt;strong>从内核态转变为了用户态&lt;/strong>，但要解释清楚这个意思，还需要听我慢慢道来。&lt;/p>
&lt;p>我相信你肯定听说过操作系统的内核态与用户态，用户进程都在用户态这个特权级下运行，而有时程序想要做一些内核态才允许做的事情，比如读取硬盘的数据，就需要通过系统调用，来请求操作系统在内核态特权级下执行一些指令。&lt;/p>
&lt;p>我们现在的代码，还是在内核态下运行，之后操作系统达到怠速状态时，是以用户态的 shell 进程运行，随时等待着来自用户输入的命令。&lt;/p>
&lt;p>所以，就在这一步，也就是 move_to_user_mode 这行代码，作用就是将当前代码的特权级，从内核态变为用户态。&lt;/p>
&lt;p>一旦转变为了用户态，那么之后的代码将一直处于用户态的模式，除非发生了中断，比如用户发出了系统调用的中断指令，那么此时将会从用户态陷入内核态，不过当中断处理程序执行完之后，又会通过中断返回指令从内核态回到用户态。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-03-49-61e0836c15abc0f8a029edd825bd355c.png" alt="图片">&lt;/p>
&lt;p>整个过程被操作系统的机制拿捏的死死的，始终让用户进程处于用户态运行，必要的时候陷入一下内核态，但很快就会被返回而再次回到用户态，是不是非常无奈？这样操作系统就掌控了控制权，而用户进程再怎么折腾也无法逃出这个模式。&lt;/p>
&lt;p>&lt;strong>内核态与用户态的本质-特权级&lt;/strong>&lt;/p>
&lt;p>首先从一个最大的视角来看，这一切都源于 CPU 的保护机制。CPU 为了配合操作系统完成保护机制这一特性，分别设计了&lt;strong>分段保护机制&lt;/strong>与&lt;strong>分页保护机制&lt;/strong>。&lt;/p>
&lt;p>当我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499699&amp;amp;idx=1&amp;amp;sn=000d83798b0158dbdf48d76e49d3ff96&amp;amp;chksm=c2c5851ef5b20c08bc641d4b118db78a3af5a4f90a057d1ce9f9b68f04b529124f466c743bc5&amp;amp;scene=21#wechat_redirect">第七回 | 六行代码就进入了保护模式&lt;/a> 将 cr0 寄存器的 PE 位开启时，就开启了保护模式，也即开启了&lt;strong>分段保护机制&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-03-57-869fff8adaf406ba63172339e1bfd2eb.png" alt="图片">&lt;/p>
&lt;p>当我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499821&amp;amp;idx=1&amp;amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;amp;scene=21#wechat_redirect">第九回 | Intel 内存管理两板斧：分段与分页&lt;/a> 将 cr0 寄存器的 PG 位开启时，就开启了分页模式，也即开启了&lt;strong>分页保护机制&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-05-49129ad6f65dc0681469887da90ed391.png" alt="图片">&lt;/p>
&lt;p>有关特权级的保护，实际上属于分段保护机制的一种。具体怎么保护的呢？由于这里的细节比较繁琐，所以我举个例子简单理解下即可，实际上的特权级检查规则要比我说的多好多内容。&lt;/p>
&lt;p>我们目前正在执行的代码地址，是通过 CPU 中的两个寄存器 cs : eip 指向的对吧？cs 寄存器是代码段寄存器，里面存着的是段选择子，还记得它的结构么？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-13-d9801ca377ad82e2d263899402161335.png" alt="图片">&lt;/p>
&lt;p>这里面的低端两位，此时表示 &lt;strong>CPL&lt;/strong>，也就是&lt;strong>当前所处的特权级&lt;/strong>，假如我们现在这个时刻，CS 寄存器的后两位为 3，二进制就是 11，就表示是当前处理器处于用户态这个特权级。&lt;/p>
&lt;p>假如我们此时要跳转到另一处内存地址执行，在最终的汇编指令层面无非就是 jmp、call 和中断。我们拿 jmp 跳转来举例。&lt;/p>
&lt;p>如果是短跳转，也就是直接 jmp xxx，那不涉及到段的变换，也就没有特权级检查这回事。&lt;/p>
&lt;p>如果是长跳转，也就是 jmp yyy : xxx，这里的 yyy 就是另一个要跳转到的段的段选择子结构。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-19-d9801ca377ad82e2d263899402161335.png" alt="图片">&lt;/p>
&lt;p>这个结构仍然是一样的段选择子结构，只不过这里的低端两位，表示 &lt;strong>RPL&lt;/strong>，也就是&lt;strong>请求特权级&lt;/strong>，表示我想请求的特权级是什么。同时，CPU 会拿这个段选择子去全局描述符表中寻找段描述符，从中找到段基址。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-25-f933895a80f5fcf19722c55b9478c495.png" alt="图片">&lt;/p>
&lt;p>那还记得段描述符的样子么？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-31-cfbf6ade355ec9cf8b84cba0f1fa5078.png" alt="图片">&lt;/p>
&lt;p>你看，这里面又有个 &lt;strong>DPL&lt;/strong>，这表示&lt;strong>目标代码段特权级&lt;/strong>，也就是即将要跳转过去的那个段的特权级。&lt;/p>
&lt;p>好了，我们总结一下简图，就是这三个玩意的比较。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-38-fec7e638b06a864c765a15c470a4d41f.png" alt="图片">&lt;/p>
&lt;p>这里的检查规则比较多，简单说，绝大多数情况下，&lt;strong>要求 CPL 必须等于 DPL&lt;/strong>，才会跳转成功，否则就会报错。&lt;/p>
&lt;p>也就是说，当前代码所处段的特权级，必须要等于要跳转过去的代码所处的段的特权级，那就只能&lt;strong>用户态往用户态跳&lt;/strong>，&lt;strong>内核态往内核态跳&lt;/strong>，这样就防止了处于用户态的程序，跳转到内核态的代码段中做坏事。&lt;/p>
&lt;p>这只是代码段跳转时所做的特权级检查，还有访问内存数据时也会有数据段的特权级检查，这里就不展开了。最终的效果是，&lt;strong>处于内核态的代码可以访问任何特权级的数据段，处于用户态的代码则只可以访问用户态的数据段&lt;/strong>，这也就实现了内存数据读写的保护。&lt;/p>
&lt;p>说了这么多，其实就是，&lt;strong>代码跳转只能同特权级，数据访问只能高特权级访问低特权级&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>特权级转换的方式&lt;/strong>&lt;/p>
&lt;p>诶不对呀，那我们今天要讲的是，从内核态转变为用户态，那如果代码跳转只能同特权级跳，我们现在处于内核态，要怎么样才能跳转到用户态呢？&lt;/p>
&lt;p>Intel 设计了好多种特权级转换的方式，&lt;strong>中断&lt;/strong>和&lt;strong>中断返回&lt;/strong>就是其中的一种。&lt;/p>
&lt;p>&lt;strong>处于用户态的程序，通过触发中断，可以进入内核态，之后再通过中断返回，又可以恢复为用户态&lt;/strong>。&lt;/p>
&lt;p>就是刚刚的图所表示的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-47-61e0836c15abc0f8a029edd825bd355c.png" alt="图片">&lt;/p>
&lt;p>而&lt;strong>系统调用&lt;/strong>就是这么玩的，用户通过 &lt;strong>int 0x80&lt;/strong> 中断指令触发了中断，CPU 切换至内核态，执行中断处理程序，之后中断程序返回，又从内核态切换回用户态。&lt;/p>
&lt;p>但有个问题是，我们当前的代码，此时就是处于内核态，并不是由一个用户态程序通过中断而切换到的内核态，那怎么回到原来的用户态呢？答案还是，通过中断返回。&lt;/p>
&lt;p>没有中断也能中断返回？可以的，Intel 设计的 CPU 就是这样不符合人们的直觉，中断和中断返回的确是应该配套使用的，但也可以单独使用，我们看代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cp">#define move_to_user_mode()
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="n">_asm&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">esp&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="mo">00000017&lt;/span>&lt;span class="n">h&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="n">eax&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">pushfd&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="mf">0000000f&lt;/span>&lt;span class="n">h&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="n">offset&lt;/span> &lt;span class="n">l1&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">iretd&lt;/span> &lt;span class="cm">/* 执行中断返回指令*/&lt;/span>
&lt;span class="err">\&lt;/span>&lt;span class="n">_asm&lt;/span> &lt;span class="nl">l1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="n">h&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">es&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">fs&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span>
&lt;span class="err">\&lt;/span> &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">gs&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span>
&lt;span class="err">\&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你看，这个方法里直接就执行了中断返回指令 iretd。&lt;/p>
&lt;p>那么为什么之前进行了一共&lt;strong>五次的压栈操作呢&lt;/strong>？因为中断返回理论上就是应该和中断配合使用的，而此时并不是真的发生了中断到这里，所以我们得&lt;strong>假装发生了中断&lt;/strong>才行。&lt;/p>
&lt;p>怎么假装呢？其实就把栈做做工作就好了，中断发生时，CPU 会自动帮我们做如下的压栈操作。而中断返回时，CPU 又会帮我们把压栈的这些值返序赋值给响应的寄存器。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-54-7f62b07d76419bae408224583fe649ca.png" alt="图片">&lt;/p>
&lt;p>去掉错误码，刚好是五个参数，所以我们在代码中模仿 CPU 进行了五次压栈操作，这样在执行 iretd 指令时，硬件会按顺序将刚刚压入栈中的数据，分别赋值给 SS、ESP、EFLAGS、CS、EIP 这几个寄存器，这就感觉像是正确返回了一样，让其&lt;strong>误以为这是通过中断进来的&lt;/strong>。&lt;/p>
&lt;p>压入栈的 CS 和 EIP 就表示中断发生前代码所处的位置，这样中断返回后好继续去那里执行。&lt;/p>
&lt;p>压入栈的 SS 和 ESP 表示中断发生前的栈的位置，这样中断返回后才好恢复原来的栈。&lt;/p>
&lt;p>其中，特权级的转换，就体现在 CS 和 SS 寄存器的值里，都是细节！&lt;/p>
&lt;p>CS 和 SS 寄存器是段寄存器的一种，段寄存器里的值是段选择子，其结构上面已经提过两遍了，在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499667&amp;amp;idx=1&amp;amp;sn=a7e2297f16d048794fa31cceaa183fc9&amp;amp;chksm=c2c5853ef5b20c286df24a28013f0fc3b0336790eca4a0d069ab831f6c536c03d1398893534b&amp;amp;scene=21#wechat_redirect">第六回 | 先解决段寄存器的历史包袱问题&lt;/a> 中也专门讲了这个结构的作用。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-04-59-d9801ca377ad82e2d263899402161335.png" alt="图片">&lt;/p>
&lt;p>对着这个结构，我们看代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">#define move_to_user_mode() \
    _asm { \    
        _asm mov eax,esp \    
        _asm push 00000017h \
        ; 给 SS 赋值    
        _asm push eax \    
        _asm pushfd \    
        _asm push 0000000fh \
        ; 给 CS 赋值    
        _asm push offset l1 \    
        _asm iretd /* 执行中断返回指令*/ \
        _asm l1: mov eax,17h \    
        _asm mov ds,ax \    
        _asm mov es,ax \    
        _asm mov fs,ax \    
        _asm mov gs,ax \
    }
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>拿 CS 举例，给它赋的值是，&lt;strong>0000000fh&lt;/strong>，用二进制表示为：&lt;/p>
&lt;p>&lt;strong>0000000000001111&lt;/strong>&lt;/p>
&lt;p>最后两位 11 表示特权级为 3，即用户态。而我们刚刚说了，CS 寄存器里的特权级，表示 CPL，即当前处理器特权级。&lt;/p>
&lt;p>&lt;strong>所以经过 iretd 返回之后，CS 的值就变成了它，而当前处理器特权级，也就变成了用户态特权级。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>除了改变特权级之外&lt;/strong>&lt;/p>
&lt;p>除了改变了特权级之外，还做了什么事情呢？&lt;/p>
&lt;p>刚刚我们关注段寄存器，只关注了特权级的部分，我们再详细看看。&lt;/p>
&lt;p>刚刚说了 CS 寄存器为 &lt;strong>0000000000001111&lt;/strong>，最后两位表示用户态的含义。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-05-10-d9801ca377ad82e2d263899402161335.png" alt="图片">&lt;/p>
&lt;p>那继续解读，倒数第三位 TI 表示，前面的描述符索引，是从 GDT 还是 LDT 中取，1 表示 LDT，也就是从局部描述符表中取。&lt;/p>
&lt;p>前面的描述符索引为 1，表示从局部描述符表中取到代码段描述符，如果你熟悉前面我讲过的内容，你将会直接得出上述结论。不过我还是帮你回忆一下。&lt;/p>
&lt;p>在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的&lt;/a> 中，将 0 号 LDT 作为当前的 LDT 索引，记录在了 CPU 的 lldt 寄存器中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define lldt(n) __asm__(&amp;#34;lldt %%ax&amp;#34;::&amp;#34;a&amp;#34; (_LDT(n)))
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">sched_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">lldt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而整个 GDT 与 LDT 表的设计，经过整个 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499882&amp;amp;idx=1&amp;amp;sn=68fd16c5aeae15084be58afb1e5bd9e8&amp;amp;chksm=c2c5bac7f5b233d1c486fa57e9e3a2bc907a92ab69ff0344babab4d50bdaf76e7766b4b42914&amp;amp;scene=21#wechat_redirect">第一部分 进入内核前的苦力活&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500983&amp;amp;idx=1&amp;amp;sn=ad4c430823c975df97f13de3fbe8c66e&amp;amp;chksm=c2c5be1af5b2370cad4ce3218c5294feee4ae2e4d28804398c1dc8ac252c8dfafbe419ccf58c&amp;amp;scene=21#wechat_redirect">第二部分 大战前期的初始化工作&lt;/a> 的设计后，成了这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-05-16-59768c7248a2cdd6393a240d134c0175.png" alt="图片">&lt;/p>
&lt;p>所以，一目了然。&lt;/p>
&lt;p>再看这行代码，把 EIP 寄存器赋值为了那行标号的地址。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>        
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cp">#define move_to_user_mode() \
&lt;/span>&lt;span class="cp">    _asm { \    
&lt;/span>&lt;span class="cp">&lt;/span>        &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="mo">00000017&lt;/span>&lt;span class="n">h&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="n">eax&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">pushfd&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="mf">0000000f&lt;/span>&lt;span class="n">h&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">push&lt;/span> &lt;span class="n">offset&lt;/span> &lt;span class="n">l1&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">iretd&lt;/span> &lt;span class="cm">/* 执行中断返回指令*/&lt;/span> \
        &lt;span class="n">_asm&lt;/span> &lt;span class="nl">l1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="n">h&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">ds&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">es&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">fs&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span> &lt;span class="err">\&lt;/span>    
        &lt;span class="n">_asm&lt;/span> &lt;span class="n">mov&lt;/span> &lt;span class="n">gs&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ax&lt;/span> \
    &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里刚好设置的是下面标号 l1 的位置，所以 iretd 之后 CPU 就乖乖去那里执行了。所以其实从效果上看，就是顺序往下执行，只不过利用了 iretd 做了些特权级转换等工作。&lt;/p>
&lt;p>同理，这里的栈段 ss 和数据段 ds，都被赋值为了 17h，大家可以展开二进制算一下，他们又是什么特权级，对应的描述符又是谁。&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>所以其实，最终效果上看就是按顺序执行了我们所写的指令，仿佛没有经过什么中断和中断返回的过程，但却通过中断返回实现了特权级的翻转，也就是从内核态变为了用户态，顺便设置了栈段、代码段和数据段的基地址。&lt;/p>
&lt;p>好了，我们兜兜转转终于把这个 mov_to_user_mode 讲完了，特权级这块的检查细节非常繁琐，为了理解操作系统，我们只需要暂且记住如下一句话就好了：&lt;/p>
&lt;p>&lt;strong>数据访问只能高特权级访问低特权级，代码跳转只能同特权级跳转，要想实现特权级转换，可以通过中断和中断返回来实现。&lt;/strong>&lt;/p>
&lt;p>OK，我们现在已经进入了用户态，也即表明了需要内核态来完成的工作已经全部安排妥当了，其实就是整个 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499882&amp;amp;idx=1&amp;amp;sn=68fd16c5aeae15084be58afb1e5bd9e8&amp;amp;chksm=c2c5bac7f5b233d1c486fa57e9e3a2bc907a92ab69ff0344babab4d50bdaf76e7766b4b42914&amp;amp;scene=21#wechat_redirect">第一部分 进入内核前的苦力活&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500983&amp;amp;idx=1&amp;amp;sn=ad4c430823c975df97f13de3fbe8c66e&amp;amp;chksm=c2c5be1af5b2370cad4ce3218c5294feee4ae2e4d28804398c1dc8ac252c8dfafbe419ccf58c&amp;amp;scene=21#wechat_redirect">第二部分 大战前期的初始化工作&lt;/a> 的内容，对全局描述符表、中断描述符表、页表等关键内存结构进行设置，以及对 CPU 特殊寄存器如 cr0 和 cr3 的设置，还有对外设如硬盘、键盘、定时器的设置等。&lt;/p>
&lt;p>看来我们又完成了一大堆苦力活呀，内核态做的工作也真是枯燥乏味呢。接下来只需要在用户态进行工作即可了！&lt;/p></description></item><item><title>23.进程调度</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/23.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/23.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="23进程调度">23.进程调度&lt;/h1>
&lt;p>书接上回，上回书咱们说到，操作系统通过 &lt;strong>move_to_user_mode&lt;/strong> 方法，通过伪造一个中断和中断返回，巧妙地从内核态切换到了用户态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>        
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>今天，本来应该再往下讲 fork。&lt;/p>
&lt;p>但这个是创建新进程的过程，是一个很能体现操作系统设计的地方。&lt;/p>
&lt;p>所以我们先别急着看代码，我们今天就头脑风暴一下，就是&lt;strong>如果让你来设计整个进程调度&lt;/strong>，你会怎么搞？&lt;/p>
&lt;p>别告诉我你先设计锁、设计 volatile 啥的，这都不是进程调度本身需要关心的最根本问题。&lt;/p>
&lt;p>进程调度本质是什么？很简单，假如有三段代码被加载到内存中。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-22-13-11bf0b397b2327b5733894c1d846e755.png" alt="图片">&lt;/p>
&lt;p>进程调度就是让 CPU 一会去程序 1 的位置处运行一段时间，一会去程序 2 的位置处运行一段时间。&lt;/p>
&lt;p>嗯，就这么简单，别反驳我，接着往下看。&lt;/p>
&lt;h2 id="整体流程设计">&lt;strong>整体流程设计&lt;/strong>&lt;/h2>
&lt;p>如何做到刚刚说的，一会去这运行，一会去那运行？&lt;/p>
&lt;p>&lt;strong>第一种办法&lt;/strong>就是，程序 1 的代码里，每隔几行就写一段代码，主动放弃自己的执行权，跳转到程序 2 的地方运行。然后程序 2 也是如此。&lt;/p>
&lt;p>但这种依靠程序自己的办法肯定不靠谱。&lt;/p>
&lt;p>所以&lt;strong>第二种办法&lt;/strong>就是，由一个不受任何程序控制的，第三方的不可抗力，每隔一段时间就中断一下 CPU 的运行，然后跳转到一个特殊的程序那里，这个程序通过某种方式获取到 CPU 下一个要运行的程序的地址，然后跳转过去。&lt;/p>
&lt;p>这个每隔一段时间就中断 CPU 的不可抗力，就是由定时器触发的&lt;strong>时钟中断&lt;/strong>。&lt;/p>
&lt;p>不知道你是否还记得，这个定时器和时钟中断，早在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的&lt;/a> 里讲的 &lt;strong>sched_init&lt;/strong> 函数里就搞定了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-14-19-70ae7bec16f72f3c8d9d00ca14091bb9.gif" alt="图片">&lt;/p>
&lt;p>而那个特殊的程序，就是具体的&lt;strong>进程调度函数&lt;/strong>了。&lt;/p>
&lt;p>好了，整个流程就这样处理完了，那么应该设计什么样的&lt;strong>数据结构&lt;/strong>，来支持这个流程呢？不妨假设这个结构叫 &lt;strong>tast_struct&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="o">?&lt;/span>
&lt;span class="p">}&lt;/span> 
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>换句话说，你总得有一个结构来记录各个进程的信息，比如它上一次执行到哪里了，要不 CPU 就算决定好了要跳转到你这个进程上运行，具体跳到哪一行运行，总得有个地方存吧？&lt;/p>
&lt;p>我们一个个问题抛开来看。&lt;/p>
&lt;h1 id="heading">&lt;/h1>
&lt;p>&lt;strong>上下文环境&lt;/strong>&lt;/p>
&lt;p>每个程序最终的本质就是执行指令。这个过程会涉及&lt;strong>寄存器&lt;/strong>，&lt;strong>内存&lt;/strong>和&lt;strong>外设端口&lt;/strong>。&lt;/p>
&lt;p>内存还有可能设计成相互错开的，互不干扰，比如进程 1 你就用 0~1K 的内存空间，进程 2 就用 1K~2K 的内存空间，咱谁也别影响谁。&lt;/p>
&lt;p>虽然有点浪费空间，而且对程序员十分不友好，但起码还是能实现的。&lt;/p>
&lt;p>不过寄存器一共就那么点，肯定做不到互不干扰，可能一个进程就把寄存器全用上了，那其他进程咋整。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-22-03-8cd7beea3634fd0618c3ed025e209987.png" alt="图片">&lt;/p>
&lt;p>比如程序 1 刚刚往 eax 写入一个值，准备用，这时切换到进程 2 了，又往 eax 里写入了一个值。那么之后再切回进程 1 的时候，就出错了。&lt;/p>
&lt;p>所以最稳妥的做法就是，每次切换进程时，都把当前这些寄存器的值存到一个地方，以便之后切换回来的时候恢复。&lt;/p>
&lt;p>Linux 0.11 就是这样做的，每个进程的结构 task_struct 里面，有一个叫 &lt;strong>tss&lt;/strong> 的结构，存储的就是 CPU 这些&lt;strong>寄存器&lt;/strong>的信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">back_link&lt;/span>&lt;span class="p">;&lt;/span>  &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss0&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss1&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp2&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss2&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">cr3&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">eflags&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ecx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">edx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ebp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">esi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">edi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">es&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">cs&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ss&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ds&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">fs&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">gs&lt;/span>&lt;span class="p">;&lt;/span>     &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">ldt&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* 16 high bits zero */&lt;/span>    
    &lt;span class="kt">long&lt;/span>    &lt;span class="n">trace_bitmap&lt;/span>&lt;span class="p">;&lt;/span>   &lt;span class="cm">/* bits: trace 0, bitmap 16-31 */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">i387_struct&lt;/span> &lt;span class="n">i387&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里提个细节。&lt;/p>
&lt;p>你发现 tss 结构里还有个 &lt;strong>cr3&lt;/strong> 不？它表示 cr3 寄存器里存的值，而 cr3 寄存器是指向页目录表首地址的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-21-58-34fa974385fb2acdfb08645cb50160d0.png" alt="图片">&lt;/p>
&lt;p>那么指向不同的页目录表，整个页表结构就是完全不同的一套，那么线性地址到物理地址的映射关系就有能力做到不同。&lt;/p>
&lt;p>也就是说，在我们刚刚假设的理想情况下，不同程序用不同的内存地址可以做到内存互不干扰。&lt;/p>
&lt;p>但是有了这个 cr3 字段，就完全可以无需由各个进程自己保证不和其他进程使用的内存冲突，因为只要建立不同的映射关系即可，由操作系统来建立不同的页目录表并替换 cr3 寄存器即可。&lt;/p>
&lt;p>这也可以理解为，保存了&lt;strong>内存映射的上下文信息&lt;/strong>。&lt;/p>
&lt;p>当然 Linux 0.11 并不是通过替换 cr3 寄存器来实现内存互不干扰的，它的实现更为简单，这是后话了。&lt;/p>
&lt;h1 id="heading-1">&lt;/h1>
&lt;p>&lt;strong>运行时间信息&lt;/strong>&lt;/p>
&lt;p>如何判断一个进程该让出 CPU 了，切换到下一个进程呢？&lt;/p>
&lt;p>总不能是每次时钟中断时都切换一次吧？一来这样不灵活，二来这完全依赖时钟中断的频率，有点危险。&lt;/p>
&lt;p>所以一个好的办法就是，给进程一个属性，叫&lt;strong>剩余时间片&lt;/strong>，每次时钟中断来了之后都 &lt;strong>-1&lt;/strong>，如果减到 0 了，就触发切换进程的操作。&lt;/p>
&lt;p>在 Linux 0.11 里，这个属性就是 &lt;strong>counter&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而他的用法也非常简单，就是每次中断都判断一下是否到 0 了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void do_timer(long cpl) {    
    ...    
    // 当前线程还有剩余时间片，直接返回    
    if ((--current-&amp;gt;counter)&amp;gt;0) 
        return;    
    // 若没有剩余时间片，调度    
    schedule();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果还没到 0，就直接返回，相当于这次时钟中断什么也没做，仅仅是给当前进程的时间片属性做了 -1 操作。&lt;/p>
&lt;p>如果已经到 0 了，就触发&lt;strong>进程调度&lt;/strong>，选择下一个进程并使 CPU 跳转到那里运行。&lt;/p>
&lt;p>进程调度的逻辑就是在 &lt;strong>schedule&lt;/strong> 函数里，怎么调，我们先不管。&lt;/p>
&lt;h1 id="heading-2">&lt;/h1>
&lt;p>&lt;strong>优先级&lt;/strong>&lt;/p>
&lt;p>上面那个 counter 一开始的时候该是多少呢？而且随着 counter 不断递减，减到 0 时，下一轮回中这个 counter 应该赋予什么值呢？&lt;/p>
&lt;p>其实这俩问题都是一个问题，就是 &lt;strong>counter 的初始化&lt;/strong>问题，也需要有一个属性来记录这个值。&lt;/p>
&lt;p>往宏观想一下，这个值越大，那么 counter 就越大，那么每次轮到这个进程时，它在 CPU 中运行的时间就越长，也就是这个进程比其他进程得到了更多 CPU 运行的时间。&lt;/p>
&lt;p>那我们可以把这个值称为&lt;strong>优先级&lt;/strong>，是不是很形象。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每次一个进程初始化时，都把 counter 赋值为这个 priority，而且当 counter 减为 0 时，下一次分配时间片，也赋值为这个。&lt;/p>
&lt;p>其实叫啥都行，反正就是这么用的，就叫优先级吧。&lt;/p>
&lt;h2 id="进程状态">进程状态&lt;/h2>
&lt;p>其实我们有了上面那三个信息，就已经可以完成进程的调度了。&lt;/p>
&lt;p>甚至如果你的操作系统让所有进程都得到同样的运行时间，连 counter 和 priority 都不用记录，就操作系统自己定一个固定值一直递减，减到 0 了就随机切一个新进程。&lt;/p>
&lt;p>这样就仅仅维护好寄存器的上下文信息 tss 就好了。&lt;/p>
&lt;p>但我们总要不断优化以适应不同场景的用户需求的，那我们再优化一个细节。&lt;/p>
&lt;p>很简单的一个场景，一个进程中有一个读取硬盘的操作，发起读请求后，要等好久才能得到硬盘的中断信号。&lt;/p>
&lt;p>那这个时间其实该进程再占用着 CPU 也没用，此时就可以选择主动放弃 CPU 执行权，然后再把自己的状态标记为等待中。&lt;/p>
&lt;p>意思是告诉进程调度的代码，先别调度我，因为我还在等硬盘的中断，现在轮到我了也没用，把机会给别人吧。&lt;/p>
&lt;p>那这个状态可以记录一个属性了，叫 &lt;strong>state&lt;/strong>，记录了此时&lt;strong>进程的状态&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而这个进程的状态在 Linux 0.11 里有这么五种。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define TASK_RUNNING          0
&lt;/span>&lt;span class="cp">#define TASK_INTERRUPTIBLE    1
&lt;/span>&lt;span class="cp">#define TASK_UNINTERRUPTIBLE  2
&lt;/span>&lt;span class="cp">#define TASK_ZOMBIE           3
&lt;/span>&lt;span class="cp">#define TASK_STOPPED          4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好了，目前我们这几个字段，就已经可以完成简单的进程调度任务了。&lt;/p>
&lt;p>有表示状态的 &lt;strong>state&lt;/strong>，表示剩余时间片的 &lt;strong>counter&lt;/strong>，表示优先级的 &lt;strong>priority&lt;/strong>，和表示上下文信息的 &lt;strong>tss&lt;/strong>。&lt;/p>
&lt;p>其他字段我们需要用到的时候再说，今天只是头脑风暴一下进程调度设计的思路。&lt;/p>
&lt;p>我们看一下 Linux 0.11 中进程结构的全部，心里先有个数，具体干嘛的先别管，就记住我们刚刚头脑风暴的那四个字段就行了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="cm">/* these are hardcoded - don&amp;#39;t touch */&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* -1 unrunnable, 0 runnable, &amp;gt;0 stopped */&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">signal&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">sigaction&lt;/span> &lt;span class="n">sigaction&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">32&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">blocked&lt;/span>&lt;span class="p">;&lt;/span>   &lt;span class="cm">/* bitmap of masked signals */&lt;/span>
    &lt;span class="cm">/* various fields */&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">exit_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">start_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end_code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">end_data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">brk&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start_stack&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">father&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">pgrp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">session&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">leader&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">uid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">euid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">suid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">gid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">egid&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">sgid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">alarm&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">utime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">stime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cutime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cstime&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">start_time&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">used_math&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="cm">/* file system info */&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">;&lt;/span>        &lt;span class="cm">/* -1 if no tty, so it must be signed */&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">umask&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pwd&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">executable&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">close_on_exec&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NR_OPEN&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="cm">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;amp;ss */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">desc_struct&lt;/span> &lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="cm">/* tss for this task */&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看吧，其实也没多少咯～&lt;/p>
&lt;p>好了，今天我们完全由自己从零到有设计出了进程调度的大体流程，以及它需要的数据结构。&lt;/p>
&lt;p>我们知道了进程调度的开始，要从一次定时器滴答来触发，通过时钟中断处理函数走到进程调度函数，然后去进程的结构 task_struct 中取出所需的数据，进行策略计算，并挑选出下一个可以得到 CPU 运行的进程，跳转过去。&lt;/p>
&lt;p>那么下一讲，我们从一次时钟中断出发，看看一次 Linux 0.11 的进程调度的全过程。有了这两回做铺垫，之后再看主流程中的 fork 代码，将会非常清晰！&lt;/p></description></item><item><title>24.定时器</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/24.%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BB%B4%E7%AD%94%E6%9D%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/24.%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BB%B4%E7%AD%94%E6%9D%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="24定时器">24.定时器&lt;/h1>
&lt;p>书接上回，上回书咱们说到，我们完全由自己从零到有设计出了进程调度的大体流程，以及它需要的数据结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这一讲，我们从一次定时器滴答出发，看看一次 Linux 0.11 的进程调度的全过程。&lt;/p>
&lt;p>Let&amp;rsquo;s Go！&lt;/p>
&lt;p>还记得我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的&lt;/a> &lt;strong>sched_init&lt;/strong> 的时候，开启了&lt;strong>定时器&lt;/strong>吧？这个定时器每隔一段时间就会向 CPU 发起一个中断信号。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-14-32-450c8c8d7755fdc58b1e1622465afccf.gif" alt="图片">&lt;/p>
&lt;p>这个间隔时间被设置为 10 ms，也就是 100 Hz。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// schedule.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define HZ 100
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>发起的中断叫&lt;strong>时钟中断&lt;/strong>，其中断向量号被设置为了 &lt;strong>0x20&lt;/strong>。&lt;/p>
&lt;p>还记得我们在 &lt;strong>sched_init&lt;/strong> 里设置的时钟中断和对应的中断处理函数吧？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// schedule.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">set_intr_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x20&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">timer_interrupt&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样，当时钟中断，也就是 0x20 号中断来临时，CPU 会查找中断向量表中 0x20 处的函数地址，即中断处理函数，并跳转过去执行。&lt;/p>
&lt;p>这个中断处理函数就是 &lt;strong>timer_interrupt&lt;/strong>，是用汇编语言写的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="c1">; system_call.s&lt;/span>
&lt;span class="nl">_timer_interrupt:&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="err">    // 增加系统滴答数&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">incl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_jiffies&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;span class="err">    // 调用函数 &lt;/span>&lt;span class="nf">do_timer&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_do_timer&lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数做了两件事，一个是将&lt;strong>系统滴答数&lt;/strong>这个变量 &lt;strong>jiffies&lt;/strong> 加一，一个是调用了另一个函数 &lt;strong>do_timer&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// sched.c
void do_timer(long cpl) {
    ...
    // 当前线程还有剩余时间片，直接返回
    if ((--current-&amp;gt;counter)&amp;gt;0) return;
    // 若没有剩余时间片，调度
    schedule();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>do_timer 最重要的部分就是上面这段代码，非常简单。&lt;/p>
&lt;p>首先将当先进程的时间片 -1，然后判断：&lt;/p>
&lt;p>如果时间片仍然大于零，则什么都不做直接返回。&lt;/p>
&lt;p>如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
        &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NR_TASKS&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NR_TASKS&lt;/span>&lt;span class="p">];&lt;/span>
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!*--&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">TASK_RUNNING&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="p">}&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">LAST_TASK&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">FIRST_TASK&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>
                &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span>
                        &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">}&lt;/span>
    &lt;span class="n">switch_to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>别看这么一大坨，我做个不严谨的简化，你就明白了&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_max_counter_and_runnable_thread&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="n">refresh_all_thread_counter&lt;/span>&lt;span class="p">();&lt;/span>
    &lt;span class="n">switch_to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到没，就剩这么点了。&lt;/p>
&lt;p>很简答，这个函数就做了三件事：&lt;/p>
&lt;p>&lt;strong>1.&lt;/strong> 拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/1a49bdd4f41fa02f7ad396f78ec6a04b75f924c6.gif" alt="图片">&lt;/p>
&lt;p>&lt;strong>2.&lt;/strong> 如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。&lt;/p>
&lt;p>&lt;strong>3.&lt;/strong> 最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。&lt;/p>
&lt;p>看 switch_to 方法，是用内联汇编语句写的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sched.h
#define switch_to(n) {\
    struct {long a,b;} __tmp; \
        __asm__(&amp;#34;cmpl %%ecx,_current\n\t&amp;#34; \    
            &amp;#34;je 1f\n\t&amp;#34; \    
            &amp;#34;movw %%dx,%1\n\t&amp;#34; \    
            &amp;#34;xchgl %%ecx,_current\n\t&amp;#34; \    
            &amp;#34;ljmp %0\n\t&amp;#34; \    
            &amp;#34;cmpl %%ecx,_last_task_used_math\n\t&amp;#34; \    
            &amp;#34;jne 1f\n\t&amp;#34; \    
            &amp;#34;clts\n&amp;#34; \    
            &amp;#34;1:&amp;#34; \    
            ::&amp;#34;m&amp;#34; (*&amp;amp;__tmp.a),&amp;#34;m&amp;#34; (*&amp;amp;__tmp.b), \    
            &amp;#34;d&amp;#34; (_TSS(n)),&amp;#34;c&amp;#34; ((long) task[n])); \
    }
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段话就是进程切换的最最最最底层的代码了。&lt;/p>
&lt;p>看不懂没关系，其实主要就干了一件事，就是 ljmp 到新进程的 tss 段处。&lt;/p>
&lt;p>啥意思？&lt;/p>
&lt;p>CPU 规定，如果 ljmp 指令后面跟的是一个 tss 段，那么，会由硬件将当前各个寄存器的值保存在当前进程的 tss 中，并将新进程的 tss 信息加载到各个寄存器。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-35-12-30e4fce99a9b0aae19382fb96fd9da4f.png" alt="图片">&lt;/p>
&lt;p>上图来源于《Linux内核完全注释V5.0》&lt;/p>
&lt;p>这个图在完全注释这本书里里画的非常清晰，我就不重复造轮子了。&lt;/p>
&lt;p>简单说就是，&lt;strong>保存当前进程上下文，恢复下一个进程的上下文，跳过去&lt;/strong>！&lt;/p>
&lt;p>看，不知不觉，我们上一讲和本讲开头提到的那些进程数据结构的字段，就都用上了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>至此，我们梳理完了一个进程切换的整条链路，来回顾一下。&lt;/p>
&lt;p>&amp;mdash;&amp;ndash; 流水账开始 &amp;mdash;&amp;ndash;&lt;/p>
&lt;p>罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。&lt;/p>
&lt;p>而这个滴答将会给 CPU 产生一个时钟中断信号。&lt;/p>
&lt;p>而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。&lt;/p>
&lt;p>do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。&lt;/p>
&lt;p>但如果 counter = 0 了，就开始进行进程的调度。&lt;/p>
&lt;p>进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。&lt;/p>
&lt;p>switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。&lt;/p>
&lt;p>接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。&lt;/p>
&lt;p>&amp;mdash;&amp;ndash; 流水账结束 &amp;mdash;&amp;ndash;&lt;/p>
&lt;p>好了，这两回我们自己设计了一遍进程调度，又看了一次 Linux 0.11 的进程调度的全过程。有了这两回做铺垫，我们下一回就该非常自信地回到我们的主流程，开始看我们心心念念的 &lt;strong>fork&lt;/strong> 函数！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>        
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>欲知后事如何，且听下回分解。&lt;/p></description></item><item><title>26.fork中进程基本信息的复制</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/26.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%8D%E5%88%B6/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/26.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%8D%E5%88%B6/</guid><description>&lt;h1 id="26fork中进程基本信息的复制">26.fork中进程基本信息的复制&lt;/h1>
&lt;p>书接上回，上回书咱们说到，fork 触发系统调用中断，最终调用到了 sys_fork 函数，借这个过程介绍了一次&lt;strong>系统调用&lt;/strong>的流程。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-36-57-ac20ac53da433f32fb4b63fc8a4e6216.png" alt="图片">&lt;/p>
&lt;p>那今天我们回到正题，开始讲 &lt;strong>fork&lt;/strong> 函数的原理，实际上就是 &lt;strong>sys_fork&lt;/strong> 函数干了啥。&lt;/p>
&lt;p>还是个汇编代码，但我们要关注的地方不多。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">_sys_fork:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_find_empty_process&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">testl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">js&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="nv">f&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">push&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">gs&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esi&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">edi&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">ebp&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_copy_process&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">addl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esp&lt;/span>
&lt;span class="err">1:  &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其实就是调用了两个函数。我们先从方法名直接翻译一下，猜猜意思。&lt;/p>
&lt;p>先是 &lt;strong>find_empty_process&lt;/strong>，就是找到空闲的进程槽位。&lt;/p>
&lt;p>然后 &lt;strong>copy_process&lt;/strong>，就是复制进程。&lt;/p>
&lt;p>那妥了，这个方法的意思非常简单，因为存储进程的数据结构是一个 task[64] 数组，这个是在之前 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500496&amp;amp;idx=1&amp;amp;sn=3bddde6c68c2b03d9721ba74e949cfa8&amp;amp;chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&amp;amp;scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的&lt;/a> &lt;strong>sched_init&lt;/strong> 函数的时候设置的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-05-c020554e43a7953a291a905a845b6176.png" alt="图片">&lt;/p>
&lt;p>就是先在这个数组中找一个空闲的位置，准备存一个新的进程的结构 &lt;strong>task_struct&lt;/strong>，这个结构之前在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501576&amp;amp;idx=1&amp;amp;sn=657e1c89d1007a935820d394d64f4035&amp;amp;chksm=c2c5bda5f5b234b3654c5ea2113cc0d48eee854f9f035ec69ec44bf9d964ae6cd4c181ed5880&amp;amp;scene=21#wechat_redirect">一个新进程的诞生（三）如果让你来设计进程调度&lt;/a> 也简单说过了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">long&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tss_struct&lt;/span> &lt;span class="n">tss&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个结构各个字段具体赋什么值呢？&lt;/p>
&lt;p>通过 &lt;strong>copy_process&lt;/strong> 这个名字我们知道，就是复制原来的进程，也就是当前进程。&lt;/p>
&lt;p>当前只有一个进程，就是数组中位置 0 处的 &lt;strong>init_task.init&lt;/strong>，也就是零号进程，那自然就复制它咯。&lt;/p>
&lt;p>好了，以上只是我们的猜测，有了猜测再看代码会非常轻松，我们一个个函数看。&lt;/p>
&lt;p>先来 &lt;strong>find_empty_process&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">long&lt;/span> &lt;span class="n">last_pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">find_empty_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="nl">repeat&lt;/span>&lt;span class="p">:&lt;/span>        
    &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">last_pid&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>        
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>            
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">)&lt;/span> 
        &lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>            
            &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EAGAIN&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一共三步，很简单。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>第一步&lt;/strong>，判断 ++last_pid 是不是小于零了，小于零说明已经超过 long 的最大值了，重新赋值为 1，起到一个保护作用，这没什么好说的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二步&lt;/strong>，一个 for 循环，看看刚刚的 last_pid 在所有 task[] 数组中，是否已经被某进程占用了。如果被占用了，那就重复执行，再次加一，然后再次判断，直到找到一个 pid 号没有被任何进程用为止。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三步&lt;/strong>，又是个 for 循环，刚刚已经找到一个可用的 pid 号了，那这一步就是再次遍历这个 task[] 试图找到一个空闲项，找到了就返回素组索引下标。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>最终，这个方法就返回 task[] 数组的索引，表示找到了一个空闲项&lt;/strong>，之后就开始往这里塞一个新的进程吧。&lt;/p>
&lt;p>由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，last_**pid 就是 1，也就是新进程被分配的 pid 就是 1**，然后即将要加入的 task[] 数组的索引位置，也是 1。&lt;/p>
&lt;p>好的，那我们接下来就看，怎么构造这个进程结构，塞到这个 1 索引位置的 task[] 中？&lt;/p>
&lt;p>来看 &lt;strong>copy_process&lt;/strong> 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_process(int nr,long ebp,long edi,long esi,
    long gs,long none,        
    long ebx,long ecx,long edx,        
    long fs,long es,long ds,        
    long eip,long cs,long eflags,long esp,long ss){    
        struct task_struct *p;    
        int i;    
        struct file *f;    
        p = (struct task_struct *) get_free_page();    
        if (!p)        
            return -EAGAIN;    
        task[nr] = p;    
        *p = *current;  /* NOTE! this doesn&amp;#39;t copy the supervisor stack */    
        p-&amp;gt;state = TASK_UNINTERRUPTIBLE;    
        p-&amp;gt;pid = last_pid;    
        p-&amp;gt;father = current-&amp;gt;pid;    
        p-&amp;gt;counter = p-&amp;gt;priority;    
        p-&amp;gt;signal = 0;    
        p-&amp;gt;alarm = 0;    
        p-&amp;gt;leader = 0;      /* process leadership doesn&amp;#39;t inherit */    
        p-&amp;gt;utime = p-&amp;gt;stime = 0;    
        p-&amp;gt;cutime = p-&amp;gt;cstime = 0;    
        p-&amp;gt;start_time = jiffies;    
        p-&amp;gt;tss.back_link = 0;    
        p-&amp;gt;tss.esp0 = PAGE_SIZE + (long) p;    
        p-&amp;gt;tss.ss0 = 0x10;    
        p-&amp;gt;tss.eip = eip;    
        p-&amp;gt;tss.eflags = eflags;    
        p-&amp;gt;tss.eax = 0;    
        p-&amp;gt;tss.ecx = ecx;    p-&amp;gt;tss.edx = edx;    p-&amp;gt;tss.ebx = ebx;    
        p-&amp;gt;tss.esp = esp;    p-&amp;gt;tss.ebp = ebp;    p-&amp;gt;tss.esi = esi;    
        p-&amp;gt;tss.edi = edi;    p-&amp;gt;tss.es = es &amp;amp; 0xffff;    p-&amp;gt;tss.cs = cs &amp;amp; 0xffff;    
        p-&amp;gt;tss.ss = ss &amp;amp; 0xffff;    
        p-&amp;gt;tss.ds = ds &amp;amp; 0xffff;    
        p-&amp;gt;tss.fs = fs &amp;amp; 0xffff;    
        p-&amp;gt;tss.gs = gs &amp;amp; 0xffff;    
        p-&amp;gt;tss.ldt = _LDT(nr);    
        p-&amp;gt;tss.trace_bitmap = 0x80000000;    
        if (last_task_used_math == current)        
            __asm__(&amp;#34;clts ; fnsave %0&amp;#34;::&amp;#34;m&amp;#34; (p-&amp;gt;tss.i387));    
        if (copy_mem(nr,p)) {        
            task[nr] = NULL;        
            free_page((long) p);        
            return -EAGAIN;    
        }    
        for (i=0; i&amp;lt;NR_OPEN;i++)        
            if (f=p-&amp;gt;filp[i])            
                f-&amp;gt;f_count++;    
        if (current-&amp;gt;pwd)        
            current-&amp;gt;pwd-&amp;gt;i_count++;    
        if (current-&amp;gt;root)        
            current-&amp;gt;root-&amp;gt;i_count++;    
        if (current-&amp;gt;executable)        
            current-&amp;gt;executable-&amp;gt;i_count++;    
        set_tss_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_TSS_ENTRY,&amp;amp;(p-&amp;gt;tss));    
        set_ldt_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_LDT_ENTRY,&amp;amp;(p-&amp;gt;ldt));    
        p-&amp;gt;state = TASK_RUNNING;    /* do this last, just in case */    
        return last_pid;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>艾玛，这也太多了！&lt;/p>
&lt;p>别急，大部分都是 tss 结构的复制，以及一些无关紧要的分支，看我简化下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span>         
        &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">..&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">edx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ebx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">set_tss_desc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gdt&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">FIRST_TSS_ENTRY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">set_ldt_desc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gdt&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">FIRST_LDT_ENTRY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_RUNNING&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数本来就是 fork 的难点了，所以我们慢慢来。&lt;/p>
&lt;p>首先 &lt;strong>get_free_page&lt;/strong> 会在主内存末端申请一个空闲页面，还记得我们之前在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;chksm=c2c5bb94f5b2328224fbc1309718ac7e022bfa32dbf3d6f593b23f2f58ffd0910fe80de05a7f&amp;amp;scene=21#wechat_redirect">第13回 内存初始化 mem_init&lt;/a> 里是怎么管理内存的吧？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-16-81592896590d34b5d2a86ac5f245a0e2.png" alt="图片">&lt;/p>
&lt;p>那 get_free_page 这个函数就很简单了，&lt;strong>就是遍历 mem_map[] 这个数组，找出值为零的项，就表示找到了空闲的一页内存&lt;/strong>。然后把该项置为 1，表示该页已经被使用。最后，算出这个页的内存起始地址，返回。&lt;/p>
&lt;p>然后，拿到的这个内存起始地址，就给了 task_struct 结构的 p。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span>         
        &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="n">task&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>于是乎，一个进程结构 task_struct 就在内存中有了一块空间，但此时还没有赋值具体的字段。别急。&lt;/p>
&lt;p>首先将这个 p 记录在进程管理结构 task[] 中。&lt;/p>
&lt;p>然后下一句 *p = *current 很简单，&lt;strong>就是把当前进程，也就是 0 号进程的 task_struct 的全部值都复制给即将创建的进程 p&lt;/strong>，目前它们两者就完全一样了。&lt;/p>
&lt;p>嗯，这就附上值了，就完全复制之前的进程的 task_struct 而已，很粗暴。&lt;/p>
&lt;p>最后的内存布局的效果就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-28-fad14d25ff86a1b16de41c6338bc2370.png" alt="图片">&lt;/p>
&lt;p>然后，进程 1 和进程 0 目前是完全复制的关系，但有一些值是需要个性化处理的，下面的代码就是把这些不一样的值覆盖掉。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">..&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">edx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ebx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PAGE_SIZE&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ss0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x10&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不一样的值，一部分是 &lt;strong>state&lt;/strong>，&lt;strong>pid&lt;/strong>，&lt;strong>counter&lt;/strong> 这种&lt;strong>进程的元信息&lt;/strong>，另一部分是 &lt;strong>tss&lt;/strong> 里面保存的各种寄存器的信息，即&lt;strong>上下文&lt;/strong>。&lt;/p>
&lt;p>这里有两个寄存器的值的赋值有些特殊，就是 ss0 和 esp0，这个表示 0 特权级也就是内核态时的 ss:esp 的指向。&lt;/p>
&lt;p>根据代码我们得知，其含义是将代码在内核态时使用的堆栈栈顶指针指向进程 task_struct 所在的 4K 内存页的最顶端，而且之后的每个进程都是这样被设置的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-37-38-1ed3e69dc4d8d2e9162adc6deb1cac6c.png" alt="图片">&lt;/p>
&lt;p>好了，进程槽位的申请，以及基本信息的复制，就讲完了。&lt;/p>
&lt;p>今天就这么点内容，&lt;strong>就是内存中找个地方存一个 task_struct 结构的东东，并添加到 task[] 数组里的空闲位置处，这个东东的具体字段赋值的大部分都是复制原来进程的&lt;/strong>。&lt;/p>
&lt;p>接下来将是进程页表和段表的复制，这将会决定进程之间的内存规划问题，很是精彩，也是 fork 真正的难点所在。&lt;/p></description></item><item><title>27.进程的内存规划</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/27.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/27.fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="27进程的内存规划">27.进程的内存规划&lt;/h1>
&lt;p>书接上回，上回书咱们说到，&lt;strong>fork&lt;/strong> 函数为新的进程（进程 1）申请了槽位，并把全部 &lt;strong>task_struct&lt;/strong> 结构的值都从进程零复制了过来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-44-7970d5e1e0f763b9e0e69afd9dbebfa3.png" alt="图片">&lt;/p>
&lt;p>之后，覆盖了新进程自己的基本信息，包括元信息和 tss 里的寄存器信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_UNINTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">last_pid&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">..&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">edx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">edx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ebx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ebx&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tss&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">esp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">esp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这可以说将 fork 函数的一半都讲完了，那我们今天展开讲讲另一半，也就是 &lt;strong>copy_mem&lt;/strong> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这将会决定进程之间的内存规划问题，十分精彩，我们开始吧。&lt;/p>
&lt;hr>
&lt;p>整个函数不长，我们还是试着先直译一下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 局部描述符表 LDT 赋值    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">old_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">data_limit&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">old_code_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">code_limit&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">code_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x0f&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">data_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x17&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">new_code_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">new_data_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nr&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x4000000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 拷贝页表    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">old_code_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">old_data_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="n">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">data_limit&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，其实就是&lt;strong>新进程 LDT 表项的赋值，以及页表的拷贝&lt;/strong>。&lt;/p>
&lt;h2 id="ldt-的赋值">LDT 的赋值&lt;/h2>
&lt;p>那我们先看 LDT 表项的赋值，要说明白这个赋值的意义，得先回忆一下我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499821&amp;amp;idx=1&amp;amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;amp;scene=21#wechat_redirect">第九回 | Intel 内存管理两板斧：分段与分页&lt;/a> 刚设置完页表时说过的问题。&lt;/p>
&lt;p>程序员给出的逻辑地址最终转化为物理地址要经过这几步骤。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-38-87c01d12d6cdfe079ed2674d79751a78.png" alt="图片">&lt;/p>
&lt;p>而我们已经开启了分页，那么分页机制的具体转化是这样的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-33-49c4c8a3621c3dd867e0c3c89e366ac0.png" alt="图片">&lt;/p>
&lt;p>因为有了页表的存在，所以多了&lt;strong>线性地址空间&lt;/strong>的概念，即经过分段机制转化后，分页机制转化前的地址。&lt;/p>
&lt;p>不考虑段限长的话，32 位的 CPU 线性地址空间应为 4G。现在只有四个页目录表，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-28-f1f35edd25b98b1ce4c089865d91da64.png" alt="图片">&lt;/p>
&lt;p>把这个图和全局描述符表 GDT 联系起来，这个线性地址空间，就是经过分段机制（段可能是 GDT 也可能是 LDT）后的地址，是这样对应的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-22-17ac5f973da5f1a9aaac30b117e9f9e3.png" alt="图片">&lt;/p>
&lt;p>我们给进程 0 准备的 LDT 的代码段和数据段，段基址都是 0，段限长是 640K。给进程 1，也就是我们现在正在 fork 的这个进程，其代码段和数据段还没有设置。&lt;/p>
&lt;p>所以第一步，&lt;strong>局部描述符表 LDT 的赋值&lt;/strong>，就是给上图中那两个还未设置的代码段和数据段赋值。&lt;/p>
&lt;p>其中&lt;strong>段限长&lt;/strong>，就是取自进程 0 设置好的段限长，也就是 640K。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">code_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x0f&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">data_limit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_limit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x17&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而&lt;strong>段基址&lt;/strong>有点意思，是取决于当前是几号进程，也就是 nr 的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_mem(int nr,struct task_struct * p) {    
    ...    
    new_code_base = nr * 0x4000000;    
    new_data_base = nr * 0x4000000;    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的 0x4000000 等于 64M。&lt;/p>
&lt;p>也就是说，今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间（暂不考虑段限长），且紧挨着。&lt;/p>
&lt;p>接着就把 LDT 设置进了 LDT 表里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_mem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_code_base&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="n">set_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ldt&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">new_data_base&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终效果如图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-16-aa192a75588df6873a9c46c74c7c174a.png" alt="图片">&lt;/p>
&lt;p>经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是&lt;strong>段式&lt;/strong>管理。&lt;/p>
&lt;p>当然，Linux 0.11 不但是分段管理，也开启了分页管理，最终形成&lt;strong>段页式&lt;/strong>的管理方式。这就涉及到下面要说的，页表的复制。&lt;/p>
&lt;p>&lt;strong>页表的复制&lt;/strong>&lt;/p>
&lt;p>OK，上面刚刚讲完段表的赋值，接下来就是页表的复制了，这也是 copy_mem 函数里的最后一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int copy_mem(int nr,struct task_struct * p) {    
    ...    
    // old=0, new=64M, limit=640K    
    copy_page_tables(old_data_base,new_data_base,data_limit)
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>原来进程 0 有&lt;strong>一个页目录表&lt;/strong>和&lt;strong>四个页表&lt;/strong>，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-11-f1f35edd25b98b1ce4c089865d91da64.png" alt="图片">&lt;/p>
&lt;p>那么新诞生的这个进程 2，也需要一套映射关系的页表，那我们看看这些页表是怎么建立的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">/* 
*  Well, here is one of the most complicated functions in mm. It 
* copies a range of linerar addresses by copying only the pages. 
* Let&amp;#39;s hope this is bug-free, &amp;#39;cause this one I don&amp;#39;t want to debug :-) 
*/
int copy_page_tables(unsigned long from,unsigned long to,long size){    
    unsigned long * from_page_table;    
    unsigned long * to_page_table;    
    unsigned long this_page;    
    unsigned long * from_dir, * to_dir;    
    unsigned long nr;    
    from_dir = (unsigned long *) ((from&amp;gt;&amp;gt;20) &amp;amp; 0xffc);    
    to_dir = (unsigned long *) ((to&amp;gt;&amp;gt;20) &amp;amp; 0xffc);    
    size = ((unsigned) (size+0x3fffff)) &amp;gt;&amp;gt; 22;    
    for( ; size--&amp;gt;0 ; from_dir++,to_dir++) {        
        if (!(1 &amp;amp; *from_dir))            
            continue;        
        from_page_table = (unsigned long *) (0xfffff000 &amp;amp; *from_dir);        
        to_page_table = (unsigned long *) get_free_page()        
        *to_dir = ((unsigned long) to_page_table) | 7;        
        nr = (from==0)?0xA0:1024;        
        for ( ; nr-- &amp;gt; 0 ; from_page_table++,to_page_table++) {            
            this_page = *from_page_table;            
            if (!(1 &amp;amp; this_page))                
                continue;            
            this_page &amp;amp;= ~2;            
            *to_page_table = this_page;            
            if (this_page &amp;gt; LOW_MEM) {                
                *from_page_table = this_page;                
                this_page -= LOW_MEM;                
                this_page &amp;gt;&amp;gt;= 12;                
                mem_map[this_page]++;            
            }        
        }    
    }    
    invalidate();    
    return 0;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先不讲这个函数，我们先看看注释。&lt;/p>
&lt;p>注释是 Linus 自己写的，他说：&lt;/p>
&lt;p>&amp;ldquo;这部分是内存管理中最复杂的代码，希望这段代码没有错误（bug-free），因为我实在不想调试它！&amp;rdquo;&lt;/p>
&lt;p>可见这是一套让 Linus 都觉得烧脑的逻辑。&lt;/p>
&lt;p>虽说代码实现很复杂，但要完成的事情确实非常简单！我想我们要是产品经理，一定会和 Linus 说这么简单的功能有啥难实现的？哈哈。&lt;/p>
&lt;p>回归正题，这个函数要完成什么事情呢？&lt;/p>
&lt;p>你想，现在进程 0 的线性地址空间是 0 - 64M，进程 1 的线性地址空间是 64M - 128M。&lt;strong>我们现在要造一个进程 1 的页表，使得进程 1 和进程 0 最终被映射到的物理空间都是 0 - 64M&lt;/strong>，这样进程 1 才能顺利运行起来，不然就乱套了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-23-04-7c8fdea0cad3c9569d717bd4f15bf4df.png" alt="图片">&lt;/p>
&lt;p>总之，最终的效果就是：&lt;/p>
&lt;p>假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。&lt;/p>
&lt;p>假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-19-22-58-0fe064755cc493e1955fe810417a0ca1.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>即，进程 0 和进程 1 目前共同映射物理内存的前 640K 的空间。&lt;/strong>&lt;/p>
&lt;p>至于如何将不同地址通过不同页表映射到相同物理地址空间，很简单，举个刚刚的例子。&lt;/p>
&lt;p>刚刚的进程 1 的线性地址 64M + 0x03 用二进制表示是：&lt;/p>
&lt;p>0000010000_0000000000_000000000011&lt;/p>
&lt;p>刚刚的进程 0 的线性地址 0x03 用二进制表示是：&lt;/p>
&lt;p>0000000000_0000000000_000000000011&lt;/p>
&lt;p>根据分页机制的转化规则，&lt;strong>前 10 位表示页目录项，中间 10 位表示页表项，后 12 位表页内偏移。&lt;/strong>&lt;/p>
&lt;p>进程 1 要找的是页目录项 16 中的第 0 号页表&lt;/p>
&lt;p>进程 0 要找的是页目录项 0 中的第 0 号页表&lt;/p>
&lt;p>那只要让这俩最终找到的两个页表里的数据一模一样即可。&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500507&amp;amp;idx=1&amp;amp;sn=a7863ac6144a1fce942a91a9d573ef1a&amp;amp;chksm=c2c5b876f5b23160502f3d1e7a7d00ad43231aa49eea9809e063f010d65846c512ec87e752a0&amp;amp;scene=21#wechat_redirect">我居然会认为权威书籍写错了&amp;hellip;&lt;/a>&lt;/p>
&lt;p>由于理解起来非常简单，但代码中的计算就非常绕，所以我们就不细致分析代码了，只要理解其最终的作用就好。&lt;/p>
&lt;hr>
&lt;p>OK，本章的内容就讲完了，再稍稍展开一个未来要说的东西。还记得页表的结构吧？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-38-22-89e1ac732ea56be5a529c434daa35db2.png" alt="图片">&lt;/p>
&lt;p>其中 RW 位表示读写状态，0 表示只读（或可执行），1表示可读写（或可执行）。当然，在内核态也就是 0 特权级时，这个标志位是没用的。&lt;/p>
&lt;p>那我们看下面的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_page_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">from&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">to&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_dir&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">from_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">to_page_table&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">LOW_MEM&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>                
                &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>                
                &lt;span class="p">...&lt;/span>            
            &lt;span class="p">}&lt;/span>        
        &lt;span class="p">}&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>~2 表示取反，2 用二进制表示是 10，取反就是 01，其目的是把 this_page 也就是当前的页表的 RW 位置零，也就是是&lt;strong>把该页变成只读&lt;/strong>。&lt;/p>
&lt;p>而 *from_page_table = this_page 表示&lt;strong>又把源页表也变成只读&lt;/strong>。&lt;/p>
&lt;p>也就是说，经过 fork 创建出的新进程，其页表项都是只读的，而且导致源进程的页表项也变成了只读。&lt;/p>
&lt;p>这个就是&lt;strong>写时复制&lt;/strong>的基础，新老进程一开始共享同一个物理内存空间，如果只有读，那就相安无事，但如果任何一方有写操作，由于页面是只读的，将触发缺页中断，然后就会分配一块新的物理内存给产生写操作的那个进程，此时这一块内存就不再共享了。&lt;/p>
&lt;p>这是后话了，这里先埋个伏笔。&lt;/p>
&lt;hr>
&lt;p>好了，至此 fork 中的 &lt;strong>copy_process&lt;/strong> 函数就全部被我们读完了，总共做了三件事，把整个进程的数据结构个性化地从进程 0 复制给了进程 1。&lt;/p>
&lt;p>&lt;strong>第一，原封不动复制了一下 task_struct。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-38-28-7970d5e1e0f763b9e0e69afd9dbebfa3.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第二，LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-39-00-aa192a75588df6873a9c46c74c7c174a.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>第三，页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-39-07-78a2e21ba9b35003349fc7b8b289a3df.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>最后，将新老进程的页表都变成只读状态，为后面写时复制的缺页中断做准备。&lt;/strong>&lt;/p></description></item><item><title>30.写时复制</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/30.%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%B0%B1%E8%BF%99%E4%B9%88%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC3%E9%83%A8%E5%88%86/30.%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%B0%B1%E8%BF%99%E4%B9%88%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81/</guid><description>&lt;h1 id="30写时复制">30.写时复制&lt;/h1>
&lt;h2 id="储备知识">储备知识&lt;/h2>
&lt;p>32 位模式下，Intel 设计了&lt;strong>页目录表&lt;/strong>和&lt;strong>页表&lt;/strong>两种结构，用来给程序员们提供分页机制。&lt;/p>
&lt;p>在 Intel Volume-3 Chapter 4.3 Figure 4-4 中给出了页表和页目录表的数据结构，PDE 就是页目录表，PTE 就是页表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-40-54-df34f4bcc1d2a784d69aca42f8497cad.png" alt="图片">&lt;/p>
&lt;p>大部分的操作系统使用的都是 4KB 的页框大小，Linux 0.11 也是，所以我们只看 4KB 页大小时的情况即可。&lt;/p>
&lt;p>一个由程序员给出的逻辑地址，&lt;strong>要先经过分段机制的转化变成线性地址，再经过分页机制的转化变成物理地址&lt;/strong>。&lt;/p>
&lt;p>Figure 4-2 给出了线性地址到物理地址，也就是&lt;strong>分页机制&lt;/strong>的转化过程。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-00-4c712a88b63050669e6197b762ec2c47.png" alt="图片">&lt;/p>
&lt;p>这里的 PDE 就是页目录表，PTE 就是页表，刚刚说过了。&lt;/p>
&lt;p>在手册接下来的 Table 4-5 和 Table 4-6 中，详细解释了页目录表和页表数据结构各字段的含义。&lt;/p>
&lt;p>Table 4-5 是页目录表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-15-738d6f034ec46e2d0b8b1b9380bf8292.png" alt="图片">&lt;/p>
&lt;p>Table 4-6 是页表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-21-b8f0ee7e3663e1cd6bd48a61e14fe155.png" alt="图片">&lt;/p>
&lt;p>他们几乎都是一样的含义，我们就只看页表就好了，看一些比较重要的位。&lt;/p>
&lt;p>&lt;strong>31:12 表示页的起始物理地址&lt;/strong>，加上线性地址的后 12 位偏移地址，就构成了最终要访问的内存的物理地址，这个就不说了。&lt;/p>
&lt;p>&lt;strong>第 0 位是 P&lt;/strong>，表示 Present，存在位。&lt;/p>
&lt;p>&lt;strong>第 1 位是 RW&lt;/strong>，表示读写权限，0 表示只读，那么此时往这个页表示的内存范围内写数据，则不允许。&lt;/p>
&lt;p>&lt;strong>第 2 位是 US&lt;/strong>，表示用户态还是内核态，0 表示内核态，那么此时用户态的程序往这个内存范围内写数据，则不允许。&lt;/p>
&lt;p>在 Linux 0.11 的 head.s 里，初次为页表设置的值如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nl">setup_paging:&lt;/span>&lt;span class="err">   &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="err">     &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">set&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">present&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">bit&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nv">user&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">r&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nv">w&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="err">       &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg2&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="err">       &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">_pg_dir&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="err">      &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">---------&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="nv">pg3&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">4092&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">edi&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mh">0xfff007&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">     &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="nv">Mb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">4096&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nv">r&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nv">w&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">user&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="nl">std1:&lt;/span>&lt;span class="err">  &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">stosl&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>后三位是 7，用二进制表示就是 111，即初始设置的 4 个页目录表和 1024 个页表，都是：&lt;/p>
&lt;p>&lt;strong>存在（1），可读写（1），用户态（1）&lt;/strong>&lt;/p>
&lt;p>好了，储备知识就到这里。&lt;/p>
&lt;p>如果你前面没读懂，你只需要知道，页表当中有一位是表示读\写的，而 Linux 0.11 初始化时，把它设置为了 1，表示可读写。&lt;/p>
&lt;h2 id="写时复制的本质">写时复制的本质&lt;/h2>
&lt;p>在调用 fork() 生成新进程时，新进程与原进程会共享同一内存区。只有当其中一个进程进行写操作时，系统才会为其另外分配内存页面。&lt;/p>
&lt;p>之前在我的&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499207&amp;amp;idx=1&amp;amp;sn=f00bf7653ae57faa6266bfd18287e6bb&amp;amp;chksm=c2c5876af5b20e7cdf5094696d266ee3fa09514601b021ce602ecaf0ec79857045b43e286a58&amp;amp;scene=21#wechat_redirect">操作系统系列&lt;/a>，我给过一个 Linux 0.11 进程的内存规划图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-29-cddee5516f8d72b42b2224257221667d.png" alt="图片">&lt;/p>
&lt;p>不过我们考虑写时复制并不用这么复杂，去掉些细节就是。&lt;/p>
&lt;p>原来的进程通过自己的页表占用了一定范围的物理内存空间。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-37-8cfe12fa1d81555cb760e60b4ff7f332.png" alt="图片">&lt;/p>
&lt;p>调用 fork 创建新进程时，原本页表和物理地址空间里的内容，都要进行复制，因为进程的内存空间是要隔离的嘛。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-46-416b1a8e9908e6ca5da2cb3b5c1cf408.png" alt="图片">&lt;/p>
&lt;p>但 fork 函数认为，复制物理地址空间里的内容，比较费时，&lt;strong>所以姑且先只复制页表，物理地址空间的内容先不复制&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-41-53-7c60b961dda9927b53216beabc6b68b6.png" alt="图片">&lt;/p>
&lt;p>如果只有读操作，那就完全没有影响，复不复制物理地址空间里的内容就无所谓了，这就很赚。&lt;strong>但如果有写操作，那就不得不把物理地址空间里的值复制一份&lt;/strong>，保证进程间的内存隔离。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-01-be6c197ac44068430c319af3e4549387.png" alt="图片">&lt;/p>
&lt;p>有写操作时，再复制物理内存，就叫&lt;strong>写时复制&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>看看代码咋写的&lt;/strong>&lt;/p>
&lt;p>有上述的现象，必然是在 fork 时，对&lt;strong>页表&lt;/strong>做了手脚，这回知道为啥储备知识里讲页表结构了吧？&lt;/p>
&lt;p>同时，只要有写操作，就会触发写时复制这个逻辑，这是咋做到的呢？答案是通过&lt;strong>中断&lt;/strong>，具体是&lt;strong>缺页中断&lt;/strong>。&lt;/p>
&lt;p>好的，首先来看 fork。&lt;/p>
&lt;p>fork 细节很多，具体可以看 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501748&amp;amp;idx=1&amp;amp;sn=2ad618817656321501b2c8e734ffefe6&amp;amp;chksm=c2c5bd19f5b2340f0ae684fa2a2a808a9a5210693736d21019ed542cf5351c3b65b2784d40ee&amp;amp;scene=21#wechat_redirect">一个新进程的诞生（六）fork 中进程基本信息的复制&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501866&amp;amp;idx=1&amp;amp;sn=64adec9179345945d095a1a1bdebcdac&amp;amp;chksm=c2c5b287f5b23b9175d8eacf7731b22823a576f78e14d8b93b2e8c9814bcb11076967d878a12&amp;amp;scene=21#wechat_redirect">一个新进程的诞生（七）透过 fork 来看进程的内存规划&lt;/a>，这里只看其中关键的复制页表的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">copy_page_tables&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 源页表和新页表一样    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">this_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 源页表和新页表均置为只读    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">this_page&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="o">*&lt;/span>&lt;span class="n">from_page_table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_page&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>还记得知识储备当中的页表结构吧，就是把 &lt;strong>R/W&lt;/strong> 位置 &lt;strong>0&lt;/strong> 了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-09-df34f4bcc1d2a784d69aca42f8497cad.png" alt="图片">&lt;/p>
&lt;p>用刚刚的 fork 图表示就是。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-16-552dbc8bbf98616be82577037e770210.png" alt="图片">&lt;/p>
&lt;p>那么此时，再次对这块物理地址空间进行写操作时，就不允许了。&lt;/p>
&lt;p>但不允许并不是真的不允许，Intel 会触发一个&lt;strong>缺页中断&lt;/strong>，具体是 &lt;strong>0x14&lt;/strong> 号中断，中断处理程序里边怎么处理，那就由 Linux 源码自由发挥了。&lt;/p>
&lt;p>Linux 0.11 的缺页中断处理函数的开头是用汇编写的，看着太闹心了，这里我选 Linux 1.0 的代码给大家看，逻辑是一样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void do_page_fault(..., unsigned long error_code) {    
    ...       
    if (error_code &amp;amp; 1)        
        do_wp_page(error_code, address, current, user_esp);    
    else        
        do_no_page(error_code, address, current, user_esp);    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，根据中断异常码 &lt;strong>error_code&lt;/strong> 的不同，有不同的逻辑。&lt;/p>
&lt;p>那触发缺页中断的异常码都有哪些呢？&lt;/p>
&lt;p>在 Intel Volume-3 Chapter 4.7 Figure 4-12 中给出。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-24-6a87d410e95baed64b69c676a59b337a.png" alt="图片">&lt;/p>
&lt;p>可以看出，当 error_code 的第 0 位，也就是存在位为 0 时，会走 do_no_page 逻辑，其余情况，均走 do_wp_page 逻辑。&lt;/p>
&lt;p>我们 fork 的时候只是将读写位变成了只读，存在位仍然是 1 没有动，所以会走 &lt;strong>do_wp_page&lt;/strong> 逻辑。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">void do_wp_page(unsigned long error_code,unsigned long address) {    
    // 后面这一大坨计算了 address 在页表项的指针    
    un_wp_page((unsigned long *)        
        (((address&amp;gt;&amp;gt;10) &amp;amp; 0xffc) + (0xfffff000 &amp;amp;        
            *((unsigned long *) ((address&amp;gt;&amp;gt;20) &amp;amp;0xffc)))));
}
void un_wp_page(unsigned long * table_entry) {    
    unsigned long old_page,new_page;    
    old_page = 0xfffff000 &amp;amp; *table_entry;    
    // 只被引用一次，说明没有被共享，那只改下读写属性就行了    
    if (mem_map[MAP_NR(old_page)]==1) {        
        *table_entry |= 2;        
        invalidate();        
        return;    
    }    
    // 被引用多次，就需要复制页表了   
    new_page=get_free_page()；    
    mem_map[MAP_NR(old_page)]--;    
    *table_entry = new_page | 7;    
    invalidate();    
    copy_page(old_page,new_page);
}
    
// 刷新页变换高速缓冲宏函数
#define invalidate() \
    __asm__(&amp;#34;movl %%eax,%%cr3&amp;#34;::&amp;#34;a&amp;#34; (0))
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我用图直接说明这段代码的细节。&lt;/p>
&lt;p>刚刚 fork 完一个进程，是这个样子的对吧？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-32-552dbc8bbf98616be82577037e770210.png" alt="图片">&lt;/p>
&lt;p>这是我们对着这个物理空间范围，写一个值，就会触发上述函数。&lt;/p>
&lt;p>假如是进程 2 写的。&lt;/p>
&lt;p>显然此时这个物理空间被引用了大于 1 次，所以要复制页面。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">new_page&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">get_free_page&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">；&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>并且更改页面只读属性为可读写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="o">*&lt;/span>&lt;span class="n">table_entry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_page&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>图示就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-39-83b2a555e0f8961bc32a9e2bf0164040.png" alt="图片">&lt;/p>
&lt;p>是不是很简单。&lt;/p>
&lt;p>那此时如果进程 1 再写呢？那么引用次数就等于 1 了，只需要更改下页属性即可，不用进行页面复制操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">mem_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAP_NR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">old_page&lt;/span>&lt;span class="p">)]&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
 &lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>图示就是这样。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-42-46-c5514f64e04562805cca100802380eb3.png" alt="图片">&lt;/p>
&lt;p>就这么简单。&lt;/p>
&lt;p>是不是从细节上看，和你原来理解的写时复制，还有点不同。&lt;/p>
&lt;p>缺页中断的处理过程中，除了写时复制原理的 do_wp_page，还有个 &lt;strong>do_no_page&lt;/strong>，是在页表项的存在位 P 为 0 时触发的。&lt;/p>
&lt;p>这个和&lt;strong>进程按需加载内存&lt;/strong>有关，如果还没加载到内存，会通过这个函数将磁盘中的数据复制到内存来，这个有时间再给大家讲。&lt;/p></description></item><item><title>32.加载根文件系统</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/32.%E5%8A%A0%E8%BD%BD%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/32.%E5%8A%A0%E8%BD%BD%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="32加载根文件系统">32.加载根文件系统&lt;/h1>
&lt;p>书接上回，上回书咱们说到，我们已经把硬盘的基本信息存入了 hd_info[]。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-43-4052e8eeeeb60e0ca6d1be52b74e555d.png" alt="图片">&lt;/p>
&lt;p>把硬盘的分区信息存入了 hd[]。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-50-24869c8c809a0a50594ed3ce9f90b87a.png" alt="图片">&lt;/p>
&lt;p>并且留了个读取硬盘数据的 bread 函数没有讲，等主流程讲完再展开这些函数的细节，我知道这是你们关心的内容。&lt;/p>
&lt;p>这些都是 setup 方法里做的事情，也就是进程 0 fork 出的进程 1 所执行的第一个方法。&lt;/p>
&lt;p>今天我们说 setup 方法中的最后一个函数 &lt;strong>mount_root&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="n">mount_root&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>mount_root 直译过来就是&lt;strong>加载根&lt;/strong>。&lt;/p>
&lt;p>再多说几个字是&lt;strong>加载根文件系统&lt;/strong>，有了它之后，操作系统才能从一个&lt;strong>根儿&lt;/strong>开始找到所有存储在硬盘中的文件，所以它是文件系统的基石，很重要。&lt;/p>
&lt;p>我们翻开看看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">free&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">super_block&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">file_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_dev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_wait&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">read_super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">mi&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">iget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">mi&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_count&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="p">;&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_isup&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_imount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pwd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_nzones&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_zmap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_ninodes&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_imap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单。&lt;/p>
&lt;p>从整体上说，它就是要把硬盘中的数据，以文件系统的格式进行解读，加载到内存中设计好的数据结构，这样操作系统就可以通过内存中的数据，以文件系统的方式访问硬盘中的一个个文件了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-44-59-b6a1ff570c88d23ff34e68d3d09ab079.png" alt="图片">&lt;/p>
&lt;p>那其实搞清楚两个事情即可：&lt;/p>
&lt;p>&lt;strong>第一，硬盘中的文件系统格式是怎样的？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第二，内存中用于文件系统的数据结构有哪些？&lt;/strong>&lt;/p>
&lt;p>我们一个个来。&lt;/p>
&lt;p>&lt;strong>硬盘中的文件系统格式是怎样的&lt;/strong>&lt;/p>
&lt;p>首先硬盘中的文件系统，无非就是硬盘中的一堆数据，我们按照一定格式去解析罢了。Linux-0.11 中的文件系统是 &lt;strong>MINIX&lt;/strong> 文件系统，它就长成这个样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-05-6c55cea738db22bf57e6208ce3091919.png" alt="图片">&lt;/p>
&lt;p>每一个块结构的大小是 1024 字节，也就是 1KB，硬盘里的数据就按照这个结构，妥善地安排在硬盘里。&lt;/p>
&lt;p>可是硬盘中凭什么就有了这些信息呢？这就是个鸡生蛋蛋生鸡的问题了。你可以先写一个操作系统，然后给一个硬盘做某种文件系统类型的格式化，这样你就得到一个有文件系统的硬盘了，有了这个硬盘，你的操作系统就可以成功启动了。&lt;/p>
&lt;p>总之，想个办法给这个硬盘写上数据呗。&lt;/p>
&lt;p>好了，现在我们简单看看 MINIX 文件系统的格式。&lt;/p>
&lt;p>&lt;strong>引导块&lt;/strong>就是我们系列最开头说的启动区，当然不一定所有的硬盘都有启动区，但我们还是得预留出这个位置，以保持格式的统一。&lt;/p>
&lt;p>&lt;strong>超级块&lt;/strong>用于描述整个文件系统的整体信息，我们看它的字段就知道了，有后面的 inode 数量，块数量，第一个块在哪里等信息。有了它，整个硬盘的布局就清晰了。&lt;/p>
&lt;p>&lt;strong>inode 位图和块位图&lt;/strong>，就是位图的基本操作和作用了，表示后面 inode 和块的使用情况，和我们之前讲的内存占用位图 mem_map[] 是类似的。&lt;/p>
&lt;p>再往后，&lt;strong>inode&lt;/strong> 存放着每个文件或目录的元信息和索引信息，元信息就是文件类型、文件大小、修改时间等，索引信息就是大小为 9 的 i_zone[9] 块数组，表示这个文件或目录的具体数据占用了哪些块。&lt;/p>
&lt;p>其中块数组里，0~6 表示直接索引，7 表示一次间接索引，8 表示二次间接索引。当文件比较小时，比如只占用 2 个块就够了，那就只需要 zone[0] 和 zone[1] 两个直接索引即可。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-14-8d12e13b175dce0c8d804f933c9dae18.png" alt="图片">&lt;/p>
&lt;p>再往后，就都是存放具体文件或目录实际信息的&lt;strong>块&lt;/strong>了。如果是一个普通文件类型的 inode 指向的块，那里面就直接是文件的二进制信息。如果是一个目录类型的 inode 指向的块，那里面存放的就是这个目录下的文件和目录的 inode 索引以及文件或目录名称等信息。&lt;/p>
&lt;p>好了，文件系统格式的说明，我们就简单说明完毕了，MINIX 文件系统已经过时，你可以阅读我之前写的 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247494176&amp;amp;idx=1&amp;amp;sn=b4680b50090bb3c7b9c49379241c536c&amp;amp;chksm=c2c5908df5b2199b361885b32b07ab0f597ab25cd1d70bb75ca13fb897c200285685318f145f&amp;amp;scene=21#wechat_redirect">图解 | 你管这破玩意叫文件系统？&lt;/a>来全面了解一个 ext2 文件系统的来龙去脉，基本思想都是一样的。&lt;/p>
&lt;p>&lt;strong>内存中用于文件系统的数据结构有哪些&lt;/strong>&lt;/p>
&lt;p>赶紧回过头来看我们的代码，是如何加载以这样一种格式存放在硬盘里的数据，以被我们操作系统所管控的。&lt;/p>
&lt;p>从头看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">f_mode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">f_flags&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">short&lt;/span> &lt;span class="n">f_count&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f_inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">off_t&lt;/span> &lt;span class="n">f_pos&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">file_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>把 64 个 &lt;strong>file_table&lt;/strong> 里的 f_count 清零。&lt;/p>
&lt;p>&lt;strong>这个 file_table 表示进程所使用的文件&lt;/strong>，进程每使用一个文件，都需要记录在这里，包括文件类型、文件 inode 索引信息等，而这个 f_count 表示被引用的次数，此时还没有引用，所以设置为零。&lt;/p>
&lt;p>而这个 file_table 的索引（当然准确说是进程的filp索引才是），就是我们通常说的文件描述符。比如有如下命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">echo &amp;#34;hello&amp;#34; &amp;gt; 0
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就表示把 hello 输出到 0 号文件描述符。&lt;/p>
&lt;p>0 号文件描述符是哪个文件呢？就是 file_table[0] 所表示的文件。&lt;/p>
&lt;p>这个文件在哪里呢？注意到 file 结构里有个 f_inode 字段，通过 f_inode 即可找到它的 inode 信息，inode 信息包含了一个文件所需要的全部信息，包括文件的大小、文件的类型、文件所在的硬盘块号，这个所在硬盘块号，就是文件的位置咯。&lt;/p>
&lt;p>接着看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">super_block&lt;/span> &lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">super_block&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">super_block&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_dev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_wait&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>又是把一个数组 &lt;strong>super_block&lt;/strong> 做清零工作。&lt;/p>
&lt;p>这个 super_block 存在的意义是，操作系统与一个设备以文件形式进行读写访问时，就需要把这个设备的超级块信息放在这里。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-22-6c55cea738db22bf57e6208ce3091919.png" alt="图片">&lt;/p>
&lt;p>这样通过这个超级块，就可以掌控这个设备的文件系统全局了。&lt;/p>
&lt;p>果然，接下来的操作，就是读取硬盘的超级块信息到内存中来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">read_super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>read_super 就是读取硬盘中的超级块。&lt;/p>
&lt;p>接下来，读取根 inode 信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mi&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">iget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后把该 inode 设置为当前进程（也就是进程 1）的当前工作目录和根目录。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pwd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mi&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后记录块位图信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_nzones&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_zmap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后记录 inode 位图信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">mount_root&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_ninodes&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">set_bit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">8191&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">s_imap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就完事了。&lt;/p>
&lt;p>其实整体上就是把硬盘中文件系统的各个信息，搬到内存中。之前的图可以说非常直观了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-31-b6a1ff570c88d23ff34e68d3d09ab079.png" alt="图片">&lt;/p>
&lt;p>有了内存中的这些结构，我们就可以顺着根 inode，找到所有的文件了。&lt;/p>
&lt;p>至此，加载根文件系统的 &lt;strong>mount_root&lt;/strong> 函数就全部结束了。同时，让我们回到全局视野，发现 &lt;strong>setup&lt;/strong> 函数也一并结束了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">move_to_user_mode&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> 
        &lt;span class="n">pause&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">BIOS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">mount_root&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>setup 的主要工作就是我们今天所讲的，&lt;strong>加载根文件系统&lt;/strong>。&lt;/p>
&lt;p>我们继续往下看 init 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到这相信你也明白了。&lt;/p>
&lt;p>之前 setup 函数的一番折腾，加载了根文件系统，顺着根 inode 可以找到所有文件，就是为了下一行 open 函数可以通过文件路径，从硬盘中把一个文件的信息方便地拿到。&lt;/p>
&lt;p>在这里，我们 open 了一个 &lt;strong>/dev/tty0&lt;/strong> 的文件，那我们接下来的焦点就在这个 /dev/tty0 是个啥？&lt;/p></description></item><item><title>33.打开终端设备文件</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/33.%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/33.%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6/</guid><description>&lt;h1 id="33打开终端设备文件">33.打开终端设备文件&lt;/h1>
&lt;p>书接上回，上回书咱们说到， setup 函数的一番折腾，加载了根文件系统，顺着根 inode 可以找到所有文件，为后续工作奠定了基础。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-43-1082bc1ad88d82d1c2950c0ea6f2672d.png" alt="图片">&lt;/p>
&lt;p>而有了这个功能后，下一行 open 函数可以通过文件路径，从硬盘中把一个文件的信息方便地拿到。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那我们接下来的焦点就在这个 open 函数，以及它要打开的文件 /dev/tty0，还有后面的两个 dup。&lt;/p>
&lt;p>open 函数会触发 0x80 中断，最终调用到 sys_open 这个系统调用函数，相信你已经很熟悉了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// open.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="n">file_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">mode&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mo">0777&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">umask&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">])&lt;/span>
            &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">close_on_exec&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file_table&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open_namei&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISCHR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">leader&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
                &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MINOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
                &lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">pgrp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pgrp&lt;/span>&lt;span class="p">;&lt;/span>
            &lt;span class="p">}&lt;/span>
        &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
                &lt;span class="n">iput&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">);&lt;/span>
                &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
                &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
                &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EPERM&lt;/span>&lt;span class="p">;&lt;/span>
            &lt;span class="p">}&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISBLK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>
        &lt;span class="n">check_disk_change&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这么大一坨别怕，我们慢慢来分析，我先用一张图来描述这一大坨代码的作用。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-51-4e1e11ee5c327696e756e8faea876958.png" alt="图片">&lt;/p>
&lt;ul>
&lt;li>第一步，在进程文件描述符数组 filp 中找到一个空闲项。**还记得进程的 task_struct 结构吧，其中有一个 filp 数组的字段，就是我们常说的文件描述符数组，这里先找到一个空闲项，将空闲地方的索引值即为 fd。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">])&lt;/span>
            &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由于此时当前进程，也就是进程 1，还没有打开过任何文件，所以 0 号索引处就是空闲的，fd 自然就等于 0。&lt;/p>
&lt;ul>
&lt;li>第二步，在系统文件表 file_table 中找到一个空闲项。**一样的玩法。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file_table&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意到，进程的 filp 数组大小是 20，系统的 file_table 大小是 64，可以得出，每个进程最多打开 20 个文件，整个系统最多打开 64 个文件。&lt;/p>
&lt;p>**第三步，将进程的文件描述符数组项和系统的文件表项，对应起来。**代码中就是一个赋值操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int sys_open(const char * filename,int flag,int mode) {
    ...
    current-&amp;gt;filp[fd] = f;
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>**第四步，根据文件名从文件系统中找到这个文件。**其实相当于找到了这个 tty0 文件对应的 &lt;strong>inode&lt;/strong> 信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// filename = &amp;#34;/dev/tty0&amp;#34;
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="c1">// flag = O_RDWR 读写
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="c1">// 不是创建新文件，所以 mode 没用
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="c1">// inode 是返回参数
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">open_namei&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来判断 tty0 这个 inode 是否是字符设备，如果是字符设备文件，那么如果设备号是 4 的话，则设置当前进程的 tty 号为该 inode 的子设备号。并设置当前进程tty 对应的tty 表项的父进程组号等于进程的父进程组号。&lt;/p>
&lt;p>这里我们暂不展开讲。&lt;/p>
&lt;p>**最后第五步，填充 file 数据。**其实就是初始化这个 f，包括刚刚找到的 inode 值。最后返回给上层文件描述符 fd 的值，也就是零。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">int sys_open(const char * filename,int flag,int mode) {
    ...
    f-&amp;gt;f_mode = inode-&amp;gt;i_mode;
    f-&amp;gt;f_flags = flag;
    f-&amp;gt;f_count = 1;
    f-&amp;gt;f_inode = inode;
    f-&amp;gt;f_pos = 0;
    return (fd);
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后再回过头看这张图，是不是就有感觉了？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-45-58-4e1e11ee5c327696e756e8faea876958.png" alt="图片">&lt;/p>
&lt;p>其实打开一个文件，即刚刚的 open 函数，就是在上述操作后，返回一个 int 型的数值 fd，称作文件描述符。&lt;/p>
&lt;p>之后我们就可以对着这个文件描述符进行读写。&lt;/p>
&lt;p>之所以可以这么方便，是由于通过这个文件描述符，最终能够找到其对应文件的 inode 信息，有了这个信息，就能够找到它在磁盘文件中的位置（当然文件还分为常规文件、目录文件、字符设备文件、块设备文件、FIFO 特殊文件等，这个之后再说），进行读写。&lt;/p>
&lt;p>比如&lt;strong>读函数&lt;/strong>的系统调用入口。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>写函数&lt;/strong>的系统调用入口。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_write&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>入参都有个 int 型的文件描述符 fd，就是刚刚 open 时返回的，就这么简单。&lt;/p>
&lt;p>好，我们回过头看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上一讲中我们讲了 setup 加载根文件系统的事情。&lt;/p>
&lt;p>这一讲中利用之前 setup 加载过的根文件系统，通过 open 函数，根据文件名找到并打开了一个文件。&lt;/p>
&lt;p>打开文件，返回给上层的是一个文件描述符，然后操作系统底层进行了一系列精巧的构造，使得一个进程可以通过一个文件描述符 fd，找到对应文件的 inode 信息。&lt;/p>
&lt;p>好了，我们接着再往下看两行代码。接下来，两个一模一样的 dup 函数，什么意思呢？&lt;/p>
&lt;p>其实，刚刚的 open 函数返回的为 0 号 fd，这个&lt;strong>作为标准输入设备&lt;/strong>。&lt;/p>
&lt;p>接下来的 dup 为 1 号 fd 赋值，这个作为&lt;strong>标准输出设备&lt;/strong>。&lt;/p>
&lt;p>再接下来的 dup 为 2 号 fd 赋值，这个作为&lt;strong>标准错误输出设备&lt;/strong>。&lt;/p>
&lt;p>熟不熟悉？这就是我们 Linux 中常说的 &lt;strong>stdin&lt;/strong>、&lt;strong>stdout&lt;/strong>、&lt;strong>stderr&lt;/strong>。&lt;/p>
&lt;p>那这个 dup 又是什么原理呢？非常简单，首先仍然是通过系统调用方式，调用到 sys_dup 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fildes&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">dupfd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fildes&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// fd 是要复制的文件描述符
&lt;/span>&lt;span class="c1">// arg 是指定新文件描述符的最小数值
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">dupfd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">arg&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">])&lt;/span>
            &lt;span class="n">arg&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
        &lt;span class="k">else&lt;/span>
            &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
    &lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我仍然是把一些错误校验的旁路逻辑去掉了。&lt;/p>
&lt;p>那这个函数的逻辑非常单纯，&lt;strong>就是从进程的 filp 中找到下一个空闲项，然后把要复制的文件描述符 fd 的信息，统统复制到这里&lt;/strong>。&lt;/p>
&lt;p>那根据上下文，这一步其实就是把 0 号文件描述符，复制到 1 号文件描述符，那么 0 号和 1 号文件描述符，就统统可以通过一条路子，找到最终 tty0 这个设备文件的 inode 信息了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-46-08-45e22ae155910d541480988ea306382e.png" alt="图片">&lt;/p>
&lt;p>那下一个 dup 就自然理解了吧，直接再来一张图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-46-15-91ee0fed302ffa91c33c2bdbf8b0423b.png" alt="图片">&lt;/p>
&lt;p>气不气，消耗了你两次流量，谁让你不懂呢，哈哈哈哈~&lt;/p>
&lt;p>ok，进程 1 的 init 函数的前四行就讲完了，此时进程 1 已经比进程 0 多了&lt;strong>与 外设交互的能力&lt;/strong>，具体说来是 tty0 这个外设（也是个文件，因为 Linux 下一切皆文件）交互的能力，这句话怎么理解呢？什么叫多了这个能力？&lt;/p>
&lt;p>因为进程 fork 出自己子进程的时候，这个 filp 数组也会被复制，那么当进程 1 fork 出进程 2 时，进程 2 也会拥有这样的映射关系，也可以操作 tty0 这个设备，这就是“能力”二字的体现。&lt;/p>
&lt;p>而进程 0 是不具备与外设交互的能力的，因为它并没有打开任何的文件，filp 数组也就没有任何作用。&lt;/p>
&lt;p>进程 1 刚刚创建的时候，是 fork 的进程 0，所以也不具备这样的能力，而通过 setup 加载根文件系统，open 打开 tty0 设备文件等代码，使得进程 1 具备了与外设交互的能力，同时也使得之后从进程 1 fork 出来的进程 2 也天生拥有和进程 1 同样的与外设交互的能力。&lt;/p>
&lt;p>好了，本文就讲到这里，再往后看两行找找感觉，我们就结束。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d buffers = %d bytes buffer space&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">NR_BUFFERS&lt;/span>&lt;span class="p">,&lt;/span> \
        &lt;span class="n">NR_BUFFERS&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Free mem: %d bytes&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">memory_end&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">main_memory_start&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来的两行是个打印语句，其实就是基于刚刚打开并创建的 0,1,2 三个文件描述符而做出的操作。&lt;/p>
&lt;p>刚刚也说了 1 号文件描述符被当做标准输出，那我们进入 printf 的实现看看有没有用到它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">fmt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">va_list&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">va_start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fmt&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">printbuf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">vsprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">printbuf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fmt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">));&lt;/span>    
    &lt;span class="n">va_end&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，中间有个 write 函数，传入了 1 号文件描述符作为第一个参数。&lt;/p>
&lt;p>细节我们先不展开，这里知道它肯定是顺着这个描述符寻找到了相应的 tty0 也就是终端控制台设备，并输出在了屏幕上。我们赶紧看看实际上有没有输出。&lt;/p>
&lt;p>仍然是 bochs 启动 Linux 0.11 看效果。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-46-24-b0d3099e6fddc9d6f21c69ba69646610.png" alt="图片">&lt;/p>
&lt;p>看到了吧，真的输出了，你偷偷改下这里的源码，再看看这里的输出有没有变化吧！&lt;/p>
&lt;p>经过今天的讲解之后，init 函数后面又要 fork 子进程了，也标志着进程 1 的工作基本结束了，准确说是能力建设的工作结束了，接下来就是控制流程和创建新的进程了，可以到开头的全局视角中展望一下。&lt;/p></description></item><item><title>35.扒开execve的皮</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/35.execve%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8Cshell%E7%A8%8B%E5%BA%8F/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/35.execve%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8Cshell%E7%A8%8B%E5%BA%8F/</guid><description>&lt;h1 id="35扒开execve的皮">35.扒开execve的皮&lt;/h1>
&lt;p>书接上回，上回书咱们说到，进程 1 再次通过 fork 函数创建了进程 2，且进程 2 通过 close 和 open 函数，将 0 号文件描述符指向的标准输入 /dev/tty0 更换为指向 /etc/rc 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时进程 2 和进程 1 几乎是完全一样的。&lt;/p>
&lt;p>接下来进程 2 就将变得不一样了，会通过一个经典的，也是最难理解的 &lt;strong>execve&lt;/strong> 函数调用，使自己摇身一变，成为 &lt;strong>/bin/sh&lt;/strong> 程序继续运行！&lt;/p>
&lt;p>我们先打开 execve，开一下它的调用链。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">argv_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">envp_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;HOME=/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="c1">// 调用方
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 宏定义
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">_syscall3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 通过系统调用进入到这里
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">EIP&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x1C&lt;/span>
&lt;span class="nl">_sys_execve&lt;/span>&lt;span class="p">:&lt;/span>    
    &lt;span class="n">lea&lt;/span> &lt;span class="n">EIP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">pushl&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">call&lt;/span> &lt;span class="n">_do_execve&lt;/span>    
    &lt;span class="n">addl&lt;/span> &lt;span class="err">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>    
    &lt;span class="n">ret&lt;/span>
&lt;span class="c1">// 最终执行的函数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">do_execve&lt;/span>&lt;span class="p">(&lt;/span>        
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">eip&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>        
    &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="n">envp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
        &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501700&amp;amp;idx=1&amp;amp;sn=1b0167cf9852f89748a337d9b06c940b&amp;amp;chksm=c2c5bd29f5b2343ff01c68f1cbc654fbb12148f00eff8c21bb2e725a6054a7a6fbddbc253afb&amp;amp;scene=21#wechat_redirect">第25回 | 通过 fork 看一次系统调用&lt;/a> 已经详细分析了整个调用链中的栈以及参数传递的过程。&lt;/p>
&lt;p>所以这里我们就不再赘述，直接把这里的参数传过来的样子写出来。&lt;/p>
&lt;p>&lt;strong>eip&lt;/strong> 调用方触发系统调用时由 CPU 压入栈空间中的 eip 的指针 。&lt;/p>
&lt;p>&lt;strong>tmp&lt;/strong> 是一个无用的占位参数。&lt;/p>
&lt;p>&lt;strong>filename&lt;/strong> 是 &amp;ldquo;/bin/sh&amp;rdquo;&lt;/p>
&lt;p>&lt;strong>argv&lt;/strong> 是 { &amp;ldquo;/bin/sh&amp;rdquo;, NULL }&lt;/p>
&lt;p>&lt;strong>envp&lt;/strong> 是 { &amp;ldquo;HOME=/&amp;rdquo;, NULL }&lt;/p>
&lt;p>好了，接下来我们看看整个 &lt;strong>do_execve&lt;/strong> 函数，它非常非常长！我先把整个结构列出。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 检查文件类型和权限等
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;span class="c1">// 读取文件的第一块数据到缓冲区
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;span class="c1">// 如果是脚本文件，走这里
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">脚本文件判断逻辑&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 如果是可执行文件，走这里
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 一堆校验可执行文件是否能执行的判断
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 进程管理结构的调整
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 释放进程占有的页面
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 调整线性地址空间、参数列表、堆栈地址等
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="p">...&lt;/span>
    &lt;span class="c1">// 设置 eip 和 esp，这里是 execve 变身大法的关键！
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整理起来的步骤就是。&lt;/p>
&lt;p>&lt;strong>1&lt;/strong> 检查文件类型和权限等&lt;/p>
&lt;p>&lt;strong>2&lt;/strong> 读取文件的第一块数据到缓冲区&lt;/p>
&lt;p>&lt;strong>3&lt;/strong> 脚本文件与可执行文件的判断&lt;/p>
&lt;p>&lt;strong>4&lt;/strong> 校验可执行文件是否能执行&lt;/p>
&lt;p>&lt;strong>5&lt;/strong> 进程管理结构的调整&lt;/p>
&lt;p>&lt;strong>6&lt;/strong> 释放进程占有的页面&lt;/p>
&lt;p>&lt;strong>7&lt;/strong> 调整线性地址空间、参数列表、堆栈地址等&lt;/p>
&lt;p>&lt;strong>8&lt;/strong> 设置 eip 和 esp，完成摇身一变&lt;/p>
&lt;p>如果去掉一些逻辑校验和判断，那核心逻辑就是&lt;strong>加载文件&lt;/strong>、&lt;strong>调整内存&lt;/strong>、&lt;strong>开始执行&lt;/strong>三个步骤，由于这些部分的内容已经非常复杂了，所以我们就去掉那些逻辑校验的部分，直接挑主干逻辑进行讲解，以便带大家认清 execve 的本质。&lt;/p>
&lt;p>走你~&lt;/p>
&lt;h2 id="读取文件开头-1kb-的数据">读取文件开头 1KB 的数据&lt;/h2>
&lt;p>先是根据文件名，找到并读取文件里的内容&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 根据文件名 /bin/sh 获取 inode    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">namei&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 根据 inode 读取文件第一块数据（1024KB）    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">struct&lt;/span> &lt;span class="n">buffer_head&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">bh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，&lt;strong>就是读取了文件（/bin/sh）第一个块&lt;/strong>，也就是 1KB 的数据，&lt;/p>
&lt;p>在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502181&amp;amp;idx=1&amp;amp;sn=b6dcbd1d2cf930002852008a1c4e6a65&amp;amp;chksm=c2c5b3c8f5b23ade1532b725995dbc3b0138202555e44a6e308b84d668a2ef3041eb5cf77f86&amp;amp;scene=21#wechat_redirect">第32回 | 加载根文件系统&lt;/a> 里说过文件系统的结构，所以代码里 &lt;strong>inode -&amp;gt; i_zone[0]&lt;/strong> 就刚好是文件开头的 1KB 数据。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-51-05-ab9a08e64c651eae5174b887b6b97738.png" alt="图片">&lt;/p>
&lt;p>OK，现在这 1KB 的数据，就已经在内存中了，但还没有解析。&lt;/p>
&lt;h2 id="解析这-1kb-的数据为-exec-结构">&lt;strong>解析这 1KB 的数据为 exec 结构&lt;/strong>&lt;/h2>
&lt;p>接下来的工作就是解析它，本质上就是按照指定的数据结构来解读罢了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">exec&lt;/span> &lt;span class="n">ex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">exec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>先从刚刚读取文件返回的缓冲头指针中取出数据部分 &lt;strong>bh -&amp;gt; data&lt;/strong>，也就是文件前 1024 个字节，此时还是一段读不懂的二进制数据。&lt;/p>
&lt;p>然后按照 exec 这个结构体对其进行解析，它便有了生命。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">exec&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 魔数    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">a_magic&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 代码区长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_text&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 数据区长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_data&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 未初始化数据区长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_bss&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 符号表长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_syms&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 执行开始地址    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 代码重定位信息长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_trsize&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 数据重定位信息长度    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="n">a_drsize&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面的代码就是 exec 结构体，这是 &lt;strong>a.out&lt;/strong> 格式文件的头部结构，现在的 Linux 已经弃用了这种古老的格式，改用 ELF 格式了，但大体的思想是一致的。&lt;/p>
&lt;p>这个结构体里的字段表示什么，等我们用到了再说，你可以先通过我的注释自己体会下。&lt;/p>
&lt;h2 id="判断是脚本文件还是可执行文件">&lt;strong>判断是脚本文件还是可执行文件&lt;/strong>&lt;/h2>
&lt;p>我们写一个 Linux 脚本文件的时候，通常可以看到前面有这么一坨东西。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="cp">#!/bin/sh
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">#!/usr/bin/python&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你有没有想过为什么我们通常可以直接执行这样的文件？其实逻辑就在下面这个代码里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;#&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">b_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;!&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">brelse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bh&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到，很简单粗暴地判断前面两个字符是不是 &lt;strong>#!&lt;/strong>，如果是的话，就走&lt;strong>脚本文件&lt;/strong>的执行逻辑。&lt;/p>
&lt;p>当然，我们现在的 /bin/sh 是个&lt;strong>可执行的二进制文件&lt;/strong>，不符合这样的条件，所以这个 if 语句里面的内容我们也可以不看了，直接看外面，执行可执行二进制文件的逻辑。&lt;/p>
&lt;p>第一步就是 brelse 释放这个缓冲块，因为已经把这个缓冲块内容解析成 exec 结构保存到我们程序的栈空间里了，那么这个缓冲块就可以释放，用于其他读取磁盘时的缓冲区。&lt;/p>
&lt;p>不重要，我们继续往下看。&lt;/p>
&lt;h2 id="准备参数空间">&lt;strong>准备参数空间&lt;/strong>&lt;/h2>
&lt;p>我们执行 /bin/sh 时，还给它传了 argc 和 envp 参数，就是通过下面这一系列代码来实现的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define PAGE_SIZE 4096
&lt;/span>&lt;span class="cp">#define MAX_ARG_PAGES 32
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x1FFFC = 128K - 4    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PAGE_SIZE&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">MAX_ARG_PAGES&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x1FFF5 = 128K - 4 - 7    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// p = 0x1FFED = 128K - 4 - 7 - 8    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x3FFFFED = 64M - 4 - 7 - 8    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">change_ldt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_text&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">MAX_ARG_PAGES&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">PAGE_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// p = 0x3FFFFD0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">create_tables&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 设置栈指针    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>准备参数空间的过程，同时也伴随着一个表示地址的 unsigned long p 的计算轨迹。&lt;/p>
&lt;p>有点难以理解，别急，我们一点点分析就会恍然大悟。&lt;/p>
&lt;p>开头一行计算出的 p 值为&lt;/p>
&lt;p>&lt;strong>p = 4096 * 32 - 4 = 0x20000 - 4 = 128K - 4&lt;/strong>&lt;/p>
&lt;p>为什么是这个数呢？整个这块讲完你就会知道，这表示&lt;strong>参数表&lt;/strong>，每个进程的参数表大小为 &lt;strong>128K&lt;/strong>，在每个进程地址空间的&lt;strong>最末端&lt;/strong>。&lt;/p>
&lt;p>还记得之前的一张图么？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-53-d3d0724d13664fbdf2ae5f5e23a6e720.png" alt="图片">&lt;/p>
&lt;p>我们说过，&lt;strong>每个进程通过不同的局部描述符在线性地址空间中瓜分出不同的空间&lt;/strong>，一个进程占 &lt;strong>64M&lt;/strong>，我们单独把这部分表达出来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-47-8893fd2eba2113faebdaf3e88b171f6d.png" alt="图片">&lt;/p>
&lt;p>参数表为 128K，就表示每个进程的线性地址空间的末端 128K，是为参数表保留的，目前这个 p 就指向了参数表的开始处（偏移 4 字节）。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-39-35c25c3f8a431516f4efd555834e8747.png" alt="图片">&lt;/p>
&lt;p>接下来两个 &lt;strong>copy_strings&lt;/strong> 就是往这个参数表里面存放信息，不过具体存放的只是字符串常量值的信息，随后他们将被引用，有点像 Java 里 class 文件的字符串常量池思想。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x1FFF5 = 128K - 4 - 7    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// p = 0x1FFED = 128K - 4 - 7 - 8    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">copy_strings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>具体说来，&lt;strong>envp&lt;/strong> 表示字符串参数 &lt;strong>&amp;ldquo;HOME=/&amp;quot;&lt;/strong>，&lt;strong>argv&lt;/strong> 表示字符串参数 &lt;strong>&amp;quot;/bin/sh&amp;rdquo;&lt;/strong>，两个 copy 就表示把这个字符串参数往参数表里存，相应地指针 p 也往下移动（共移动了 7 + 8 = 15 个字节），和压栈的效果是一样的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-27-590141556318be26eccd87d69315da70.png" alt="图片">&lt;/p>
&lt;p>当然，这个只是示意图，实际上这些字符串都是紧挨着的，我们通过 debug 查看参数表位置处的内存便可以看到真正存放的方式。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-50-19-99c28ea7d149b106bdad8afbdb5b7328.png" alt="图片">&lt;/p>
&lt;p>可以看到，两个字符串乖乖地被安排在了参数表内存处，且参数与参数之间用 00 也就是 NULL 来分隔。&lt;/p>
&lt;p>接下来是&lt;strong>更新局部描述符&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">#define PAGE_SIZE 4096
#define MAX_ARG_PAGES 32
// exec.c
int do_execve(...) {
    ...
    // p = 0x3FFFFED = 64M - 4 - 7 - 8
    p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，就是根据 &lt;strong>ex.a_text&lt;/strong> 修改局部描述符中的&lt;strong>代码段限长&lt;/strong> code_limit，其他没动。&lt;/p>
&lt;p>ex 结构里的 a_text 是生成 /bin/sh 这个 a.out 格式的文件时，写在头部的值，用来表示代码段的长度。至于具体是怎么生成的，我们无需关心。&lt;/p>
&lt;p>由于这个函数返回值是数据段限长，也就是 64M，所以最终的 p 值被调整为了以每个进程的线性地址空间视角下的地址偏移，大家可以仔细想想怎么算的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-49-29-b00b53243d9da16b6274c1069db1a7d9.png" alt="图片">&lt;/p>
&lt;p>接下来就是真正&lt;strong>构造参数表&lt;/strong>的环节了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define PAGE_SIZE 4096
&lt;/span>&lt;span class="cp">#define MAX_ARG_PAGES 32
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// p = 0x3FFFFD0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">create_tables&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>刚刚仅仅是往参数表里面丢入了需要的字符串常量值信息，现在就需要真正把参数表构建起来。&lt;/p>
&lt;p>我们展开 &lt;strong>create_tables&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cm">/* 
&lt;/span>&lt;span class="cm">* create_tables() parses the env- and arg-strings in new user 
&lt;/span>&lt;span class="cm">* memory and creates the pointer tables from them, and puts their 
&lt;/span>&lt;span class="cm">* addresses on the &amp;#34;stack&amp;#34;, returning the new stack pointer value. 
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">create_tables&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">envc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">sp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mh">0xfffffffc&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">sp&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">envc&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">envp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">sp&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">argv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">sp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">sp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">sp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">get_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">))&lt;/span> 
            &lt;span class="cm">/* nothing */&lt;/span> &lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">envc&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">get_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">))&lt;/span> 
            &lt;span class="cm">/* nothing */&lt;/span> &lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">put_fs_long&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="n">sp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可能稍稍有点烧脑，不过如果你一行一行仔细分析，不难分析出就是把参数表空间变成了如下样子。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-49-17-792d0104babe901033e4d0b09c4fce55.png" alt="图片">&lt;/p>
&lt;p>最后，将 sp 返回给 p，这个 p 将作为一个新的栈顶指针，给即将要完成替换的 /bin/sh 程序，也就是下面的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 设置栈指针    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为什么这样操作就可以达到更换栈顶指针的作用呢？那我们结合着更换代码指针 PC 来进行讲解。&lt;/p>
&lt;h2 id="heading">&lt;/h2>
&lt;p>&lt;strong>设置 eip 和 esp，完成摇身一变&lt;/strong>&lt;/p>
&lt;p>下面这两行就是 execve 完成摇身一变的关键，解释了它为什么能做到变成一个新程序开始执行的关键密码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">do_execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">eip&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>     
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>什么叫一个新程序开始执行呢？&lt;/p>
&lt;p>其实本质上就是，&lt;strong>代码指针 eip 和栈指针 esp 指向了一个新的地方&lt;/strong>。&lt;/p>
&lt;p>代码指针 eip 决定了 CPU 将执行哪一段指令，栈指针 esp 决定了 CPU 压栈操作的位置，以及读取栈空间数据的位置，在高级语言视角下就是&lt;strong>局部变量&lt;/strong>以及&lt;strong>函数调用链的栈帧&lt;/strong>。&lt;/p>
&lt;p>所以这两行代码，第一行重新设置了&lt;strong>代码指针 eip&lt;/strong> 的值，指向 /bin/sh 这个 a.out 格式文件的头结构 exec 中的 a_entry 字段，表示该&lt;strong>程序的入口地址&lt;/strong>。&lt;/p>
&lt;p>第二行重新设置了&lt;strong>栈指针 esp&lt;/strong> 的值，指向了我们经过一路计算得到的 p，也就是图中 sp 的值。将这个值作为新的栈顶十分合理。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-49-08-792d0104babe901033e4d0b09c4fce55.png" alt="图片">&lt;/p>
&lt;p>eip 和 esp 都设置好了，那么程序摇身一变的工作，自然就结束了，非常简单。&lt;/p>
&lt;p>至于为什么往 eip 的 0 和 3 索引位置处写入数据，就可以达到替换 eip 和 esp 的目的，那我们就得看看这个 eip 变量是怎么来的了。&lt;/p>
&lt;p>&lt;strong>计算机的世界没有魔法&lt;/strong>&lt;/p>
&lt;p>还记得 execve 的调用链么？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">argv_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">envp_rc&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s">&amp;#34;HOME=/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="c1">// 调用方
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 宏定义
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">_syscall3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">execve&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 通过系统调用进入到这里
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">EIP&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0x1C&lt;/span>
&lt;span class="nl">_sys_execve&lt;/span>&lt;span class="p">:&lt;/span>    
    &lt;span class="n">lea&lt;/span> &lt;span class="n">EIP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">pushl&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="n">eax&lt;/span>    
    &lt;span class="n">call&lt;/span> &lt;span class="n">_do_execve&lt;/span>    
    &lt;span class="n">addl&lt;/span> &lt;span class="err">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">esp&lt;/span>    
    &lt;span class="n">ret&lt;/span>
&lt;span class="c1">// exec.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">do_execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">eip&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">a_entry&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="n">eip&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>     
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>千万别忘了，我们这个 &lt;strong>do_execve&lt;/strong> 函数，是通过一开始的 &lt;strong>execve&lt;/strong> 函数触发了&lt;strong>系统调用&lt;/strong>来到的这里。&lt;/p>
&lt;p>系统调用是一种&lt;strong>中断&lt;/strong>，前面说过，中断时 CPU 会给栈空间里压入一定的信息，这部分信息是死的，查手册可以查得到。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-48-59-41fc6288b7591149cb1f904a1610e7be.png" alt="图片">&lt;/p>
&lt;p>然后，进入中断以后，通过系统调用查表进入到 &lt;strong>_sys_execve&lt;/strong> 这里。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="nf">EIP&lt;/span>&lt;span class="err"> = &lt;/span>&lt;span class="mh">0x1C&lt;/span>
&lt;span class="nl">_sys_execve:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">lea&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">EIP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esp&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">_do_execve&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">addl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">esp&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">ret&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到没？在真正调用 &lt;strong>do_execve&lt;/strong> 函数时，&lt;strong>_sys_execve&lt;/strong> 这段代码偷偷地插入了一个小步骤，就是把当前栈顶指针 esp 偏移到 EIP 处的地址值给当做第一个参数 &lt;strong>unsigned long * eip&lt;/strong> 传入进来了。&lt;/p>
&lt;p>而偏移 EIP 处的位置，恰好就是中断时压入的 EIP 的值的位置，表示中断发生前的指令寄存器的值。&lt;/p>
&lt;p>所以 eip[0] 就表示栈空间里的 EIP 位置，eip[3] 就表示栈空间里的 ESP 位置。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-48-51-28a17b4d53100d5c622e736db98fbcdc.png" alt="图片">&lt;/p>
&lt;p>由于我们现在处于中断，所以&lt;strong>中断返回&lt;/strong>后，也就是 do_execve 这个函数 return 之后，就会寻找中断返回前的这几个值（包括 eip 和 esp）进行恢复。&lt;/p>
&lt;p>这里有疑惑的同学，看下我之前写的 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247498208&amp;amp;idx=1&amp;amp;sn=b784f8b4e627ebd1bfb9810d194fdb80&amp;amp;chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&amp;amp;scene=21#wechat_redirect">认认真真的聊聊中断&lt;/a> 和 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247498246&amp;amp;idx=1&amp;amp;sn=efca37b5dcb06271eb19500b2c2597f1&amp;amp;chksm=c2c580abf5b209bdacd5cba9728723af1f725016960d334067f9cc979b721f29f860d612ec1b&amp;amp;scene=21#wechat_redirect">认认真真的聊聊&amp;quot;软&amp;quot;中断&lt;/a> 这两篇文章，我认为把中断的原理彻底讲清楚了，不过其实就是读 CPU 手册罢了。&lt;/p>
&lt;p>所以如果我们把这个栈空间里的 eip 和 esp 进行替换，换成执行 /bin/sh 所需要的 eip 和 esp，那么中断返回的**&amp;ldquo;恢复&amp;rdquo;**工作，就犹如**&amp;ldquo;跳转&amp;rdquo;**到一个新程序那里一样，其实是我们欺骗了 CPU，达到了 execve 这个函数的魔法效果。&lt;/p>
&lt;p>所以，&lt;strong>计算机的世界里根本没有魔法&lt;/strong>，就是通过这一点点细节而完成的，只是大部分人都不愿意花时间去细究这些细节罢了。&lt;/p></description></item><item><title>36.缺页中断</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/36.%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/36.%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD/</guid><description>&lt;h1 id="36缺页中断">36.缺页中断&lt;/h1>
&lt;p>书接上回，上回书咱们说到，进程 2 通过 &lt;strong>execve&lt;/strong> 函数，将自己摇身一变成为 &lt;strong>/bin/sh&lt;/strong> 程序，也就是 &lt;strong>shell&lt;/strong> 程序开始执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么此时进程 2 就是 shell 程序了。&lt;/p>
&lt;p>再进一步讲，相当于之前的进程 1 通过 &lt;strong>fork + execve&lt;/strong> 这两个函数的组合，创建了一个新的进程去加载并执行了 shell 程序。&lt;/p>
&lt;p>我们在 Linux 里执行一个程序，比如在命令行中 ./xxx，其内部实现逻辑都是 fork + execve 这个原理。&lt;/p>
&lt;p>当然，此时我们仅仅是通过 execve，使得下一条 CPU 指令将会执行到 /bin/sh 程序所在的内存起始位置处，也就是 /bin/sh 头部结构中 &lt;strong>a_entry&lt;/strong> 所描述的地址。&lt;/p>
&lt;p>但有个问题是，我们仅仅将 /bin/sh 文件的头部加载到了内存，其他部分并没有进行加载，那我们是怎么执行到的 /bin/sh 的程序指令呢？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-22-2ddc77fe8686ba8e985c099d1efe6d7d.png" alt="图片">&lt;/p>
&lt;p>我们就带着这个问题，开始今天的探索。&lt;/p>
&lt;h2 id="跳转到一个不存在的地址会发生什么">跳转到一个不存在的地址会发生什么&lt;/h2>
&lt;p>/bin/sh 这个文件并不是 Linux 0.11 源码里的内容，Linux 0.11 只管按照 a.out 这种格式去解读它，跳转到 a.out 格式头部数据结构 &lt;strong>exec.a_entry&lt;/strong> 所指向的内存地址去执行指令。&lt;/p>
&lt;p>所以这个 a_entry 的值是多少，就完全取决于硬盘中 /bin/sh 这个文件是怎么构造的了，我们简单点，就假设它为 &lt;strong>0&lt;/strong>，这表示随后的 CPU 将跳转到 0 地址处进行执行。&lt;/p>
&lt;p>当然，这个 0 仅仅表示&lt;strong>逻辑地址&lt;/strong>，既没有进行分段，也没有进行分页。&lt;/p>
&lt;p>之前说过无数次了，Linux 0.11 的每个进程是通过不同的局部描述符在线性地址空间中瓜分出不同的空间，一个进程占 64M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-29-a49168ac30ab0b1f45ae4daac902533d.png" alt="图片">&lt;/p>
&lt;p>由于我们现在所处的代码是属于进程 2，所以逻辑地址 0 通过分段机制映射到线性地址空间，就是 &lt;strong>0x8000000&lt;/strong>，表示 &lt;strong>128M&lt;/strong> 位置处。&lt;/p>
&lt;p>好，128M 这个线性地址，随后将会通过&lt;strong>分页机制&lt;/strong>的映射转化为物理地址，这才定位到最终的真实物理内存。&lt;/p>
&lt;p>可是，128M 这个线性地址并没有页表映射它，也就是因为上面我们说的，我们除了 /bin/sh 文件的头部加载到了内存外，其他部分并没有进行加载操作。&lt;/p>
&lt;p>&lt;strong>再准确点说，是 0x8000000 这个线性地址的访问，遇到了页表项的存在位 P 等于 0 的情况。&lt;/strong>&lt;/p>
&lt;p>一旦遇到了这种情况，CPU 会触发一个中断：&lt;strong>页错误（Page-Fault）&lt;/strong>，这在 Intel 手册 Volume-3 Chapter 4.7 章节里给出了这个信息。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-36-228eec2d7f2b4640d7441ca0d4aa7be9.png" alt="图片">&lt;/p>
&lt;p>当然，Page-Fault 在很多情况都会触发，具体是因为什么情况触发的，CPU 会帮我们保存在中断的出错码 &lt;strong>Error Code&lt;/strong> 里，这在随后的 Figure 4-12 中给出了详细的出错码说明。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-42-371d5c9369c149d21699fa1f594c81f2.png" alt="图片">&lt;/p>
&lt;p>这块之所以讲这么详细，因为我想让大家知道一切的原理都有最一手资料的来源，这些一手资料写的都非常详细和友好，大家完全不必道听途说，也不必毫无头绪地搜索网上的博客。&lt;/p>
&lt;p>当然，与本文相关的，就是这个&lt;strong>存在位 P&lt;/strong>。&lt;/p>
&lt;p>当触发这个 Page-Fault 中断后，就会进入 Linux 0.11 源码中的 &lt;strong>page_fault&lt;/strong> 方法，由于 Linux 0.11 的 page_fault 是汇编写的，很不直观，这里我选 Linux 1.0 的代码给大家看，逻辑是一样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_page_fault&lt;/span>&lt;span class="p">(...,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">error_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>       
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">do_wp_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">else&lt;/span>        
        &lt;span class="n">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">error_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_esp&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 &lt;strong>error_code&lt;/strong> 的不同，有不同的逻辑。&lt;/p>
&lt;p>刚刚说了，这个中断是由于 &lt;strong>0x8000000&lt;/strong> 这个线性地址的访问，遇到了页表项的&lt;strong>存在位 P&lt;/strong> 等于 0 的情况，所以 error_code 的第 0 位就是 0，会走 &lt;strong>do_no_page&lt;/strong> 逻辑。&lt;/p>
&lt;p>之前在讲 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502033&amp;amp;idx=1&amp;amp;sn=1acfd8b7f4c805906ecd51c33d0010eb&amp;amp;chksm=c2c5b27cf5b23b6a41051c7f93407afc97094a4b0a36ea050616778f4d072f074602f98983b2&amp;amp;scene=21#wechat_redirect">第30回 | 番外篇 - 写时复制就这么几行代码&lt;/a> 的时候，讲了 &lt;strong>do_wp_page&lt;/strong>，这是在 P=1 时的逻辑，文章的结尾我说过，后面会把页表项的存在位 P 为 0 时触发的 do_no_page 逻辑讲给大家，这不就来了么。&lt;/p>
&lt;p>do_wp_page 叫&lt;strong>页写保护中断&lt;/strong>，do_no_page 叫&lt;strong>缺页中断&lt;/strong>。&lt;/p>
&lt;p>好了，我们用了很大篇幅，说明白了跳转到一个 P=0 的地址会发生什么，接下来就是具体看 do_no_page 函数的逻辑咯。&lt;/p>
&lt;h2 id="缺页中断-do_no_page">缺页中断 do_no_page&lt;/h2>
&lt;p>我们先一睹为快它的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// memory.c
// address 缺页产生的线性地址 0x8000000
void do_no_page(unsigned long error_code,unsigned long address) {    
    int nr[4];    
    unsigned long tmp;    
    unsigned long page;    
    int block,i;    
    address &amp;amp;= 0xfffff000;    
    tmp = address - current-&amp;gt;start_code;    
    if (!current-&amp;gt;executable || tmp &amp;gt;= current-&amp;gt;end_data) {        
        get_empty_page(address);        
        return;    
    }    
    if (share_page(tmp))        
        return;    
    if (!(page = get_free_page()))        
        oom();
    /* remember that 1 block is used for header */    
    block = 1 + tmp/BLOCK_SIZE;    
    for (i=0 ; i&amp;lt;4 ; block++,i++)        
        nr[i] = bmap(current-&amp;gt;executable,block);    
    bread_page(page,current-&amp;gt;executable-&amp;gt;i_dev,nr);    
    i = tmp + 4096 - current-&amp;gt;end_data;    
    tmp = page + 4096;    
    while (i-- &amp;gt; 0) {        
        tmp--;        
        *(char *)tmp = 0;    
    }    
    if (put_page(page,address))        
        return;    
    free_page(page);    
    oom();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们仍然是去掉一些不重要的分支，假设跳转不会超过数据末端 end_data，也没有共享内存页面，申请空闲内存时也不会内存不足产生 oom 等，将程序简化如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="c1">// 计算这个地址在文件中的哪个数据块 1    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就简单多了，我们还是一点点看。&lt;/p>
&lt;p>首先，缺页产生的线性地址，之前假设过了，是 0x8000000，也就是进程 2 自己线性地址空间的起始处 128M 这个位置。&lt;/p>
&lt;p>由于我们的页表映射是以&lt;strong>页&lt;/strong>为单位的，所以首先计算出 address 所在的页，其实就是完成一次 &lt;strong>4KB 的对齐&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时 address 对齐后仍然是 0x8000000。&lt;/p>
&lt;p>这个地址是整个线性地址空间的地址，但对于进程 2 自己来说，需要计算出相对于进程 2 的偏移地址，也就是去掉进程 2 的段基址部分。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的 current-&amp;gt;start_code 就是进程 2 的段基址，也是 128M。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-51-a49168ac30ab0b1f45ae4daac902533d.png" alt="图片">&lt;/p>
&lt;p>所以偏移地址 tmp 计算后等于 &lt;strong>0&lt;/strong>，这和我们之前假设的 a_entry = 0 是一致的。&lt;/p>
&lt;p>接下来很简单，就是寻找一个空闲页。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 &lt;strong>get_free_page&lt;/strong> 是用汇编语言写的，其实就是去 &lt;strong>mem_map[]&lt;/strong> 中寻找一个值为 0 的位置，这就表示找到了空闲内存。&lt;/p>
&lt;p>这部分忘记的同学，可以看一下 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500089&amp;amp;idx=1&amp;amp;sn=9a3fd6e585b0fd1ec528599ead6677c6&amp;amp;scene=21#wechat_redirect">第13回 | 主内存初始化 mem_init&lt;/a>，之前苦苦建立的一些初始化的数据结构，就用上了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-44-57-150f714f07d49eae3c6ee4a2cda35b6e.png" alt="图片">&lt;/p>
&lt;p>找到一页物理内存后，当然是把硬盘中的数据加载进来，下面的代码就是完成这个工作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// memory.c
// address 缺页产生的线性地址 0x8000000
void do_no_page(unsigned long address) {    
    ...    
    // 计算这个地址在文件中的哪个数据块 1    
    int block = 1 + tmp/BLOCK_SIZE;    
    // 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
    int nr[4];    
    for (int i=0 ; i&amp;lt;4 ; block++,i++)        
        nr[i] = bmap(current-&amp;gt;executable,block);    
    bread_page(page,current-&amp;gt;executable-&amp;gt;i_dev,nr);    
    ...
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从硬盘的哪个位置开始读呢？&lt;/p>
&lt;p>首先 0 内存地址，应该就对应着这个文件 0 号数据块，当然由于 /bin/sh 这个 a.out 格式的文件使用了 1 个数据块作为头部 exec 结构，所以我们&lt;strong>跳过头部&lt;/strong>，从文件 1 号数据块开始读。&lt;/p>
&lt;p>读多少块呢？&lt;/p>
&lt;p>因为硬盘中的 1 个数据块为 1024 字节，而一页内存为 4096 字节，所以要读 4 块，这就是 nr[4] 的缘故。&lt;/p>
&lt;p>之后读取数据主要是两个函数，&lt;strong>bmap&lt;/strong> 负责将相对于文件的数据块转换为相对于整个硬盘的数据块，比如这个文件的第 1 块数据，可能对应在整个硬盘的第 24 块的位置。&lt;/p>
&lt;p>&lt;strong>bread_page&lt;/strong> 就是连续读取 4 个数据块到 1 页内存的函数，这个函数原理就复杂了，之后第五部分会讲这块的内容，但站在用户层的效果很好理解，就是把硬盘数据复制到内存罢了。&lt;/p>
&lt;p>OK，现在硬盘上所需要的内容已经被读入物理内存了。&lt;/p>
&lt;p>最后一步完成&lt;strong>页表的映射&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是因为我们此时仅仅是申请了物理内存页，并且把硬盘数据复制了进来，但我们并没有把这个物理内存页和线性地址空间的内存页进行映射，也就是没建立相关的&lt;strong>页表&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-45-05-b7d999c9bc53aea332ff6ddfa99b976d.png" alt="图片">&lt;/p>
&lt;p>建立页表的映射，由于 Linux 0.11 使用的是二级页表，所以实际上就是写入&lt;strong>页目录项&lt;/strong>和&lt;strong>页表项&lt;/strong>的过程，我把 &lt;strong>put_page&lt;/strong> 函数简化了一下，只考虑页目录项还不存在的场景。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// memory.c
unsigned long put_page(unsigned long page,unsigned long address) {    
    unsigned long tmp, *page_table;    
    // 找到页目录项    
    page_table = (unsigned long *) ((address&amp;gt;&amp;gt;20) &amp;amp; 0xffc);    
    // 写入页目录项    
    tmp = get_free_page();    
    *page_table = tmp|7;    
    // 写入页表项    
    page_table = (unsigned long *) tmp;    
    page_table[(address&amp;gt;&amp;gt;12) &amp;amp; 0x3ff] = page | 7;    
    return page;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>大家可以结合页目录表和页表的数据结构看一下，很简单，就是个计算过程。&lt;/p>
&lt;p>关于页目录表和页表这些&lt;strong>分页&lt;/strong>相关的知识，可以回顾之前的 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247499821&amp;amp;idx=1&amp;amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;amp;scene=21#wechat_redirect">第9回 | Intel 内存管理两板斧：分段与分页&lt;/a>，这里就不再赘述。&lt;/p>
&lt;h2 id="缺页中断返回">缺页中断返回&lt;/h2>
&lt;p>好了，这就是整个缺页中断处理的过程，本质上就是加载硬盘对应位置的数据，然后建立页表的过程。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// memory.c
&lt;/span>&lt;span class="c1">// address 缺页产生的线性地址 0x8000000
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_no_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">address&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="c1">// 线性地址的页面地址 0x8000000    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">address&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="mh">0xfffff000&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 计算相对于进程基址的偏移 0    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">address&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">start_code&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 寻找空闲的一页内存    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_free_page&lt;/span>&lt;span class="p">();&lt;/span>    
    &lt;span class="c1">// 计算这个地址在文件中的哪个数据块 1    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">block&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">BLOCK_SIZE&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 一个数据块 1024 字节，所以一页内存需要读 4 个数据块    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">block&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="n">nr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">block&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="n">bread_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">executable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_dev&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 完成页表的映射    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">put_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">address&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再回过头看整个代码，是不是清晰了不少？&lt;/p>
&lt;p>好，那我们再往上看，我们之前是在进程 2 里执行了 execve 函数将程序替换成 /bin/sh，也就是 shell 程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/etc/rc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDONLY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">execve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">argv_rc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">envp_rc&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>execve 函数返回后，CPU 就跳转到 /bin/sh 程序的第一行开始执行，但由于跳转到的线性地址不存在，所以引发了今天我们讲的&lt;strong>缺页中断&lt;/strong>，把硬盘里 /bin/sh 所需要的内容加载到了内存，此时缺页中断返回。&lt;/p>
&lt;p>返回后，CPU 会再次尝试跳转到 0x8000000 这个线性地址，此时由于缺页中断的处理结果，&lt;strong>使得该线性地址已有对应的页表进行映射&lt;/strong>，所以顺利地映射到了物理地址，也就是 /bin/sh 的代码部分（从硬盘加载过来的），那接下来就终于可以执行 /bin/sh 程序，也就是 shell 程序了。&lt;/p>
&lt;p>那这个 shell 程序到底是啥呢？他的代码并不在 Linux 0.11 的源码里，所以我们的重点将不是分析它的源码，仅仅了解它的原理即可。&lt;/p></description></item><item><title>39.调试Linux最早期的代码</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/39.%E7%95%AA%E5%A4%96%E7%AF%87-linux_0.11%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC4%E9%83%A8%E5%88%86/39.%E7%95%AA%E5%A4%96%E7%AF%87-linux_0.11%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/</guid><description>&lt;h1 id="39调试linux最早期的代码">39.调试Linux最早期的代码&lt;/h1>
&lt;p>Linux 0.11 是 Linux 最早期的代码，非常适合作为第一款深入探索操作系统原理的代码。&lt;/p>
&lt;p>但同时，Linux 0.11 因为很多古老工具链的缺失，以及一些过时的文件格式比如 a.out，导致成功编译并运行它十分困难，更别说进行源码级别的 debug 调试了。&lt;/p>
&lt;p>要想成功调试 Linux 0.11，需要进行很多改造，并依赖一些古老的工具链，对于仅仅是将 Linux 0.11 作为研究操作系统的手段的我们，无需花费精力自己去改造它，踩各种坑。&lt;/p>
&lt;p>所以今天我就分享一下我调试 Linux 0.11 的一种方式，同时也为了我自己以后换电脑的时候方便照着自己的教程直接无脑搭建环境，那我们开始吧~&lt;/p>
&lt;h2 id="整体思路和效果">整体思路和效果&lt;/h2>
&lt;p>我用的方式是，在 windows 上，搞一个 Ubuntu 16.04 的虚拟机，在里面用 qemu 启动一个开启了调试的 Linux 0.11 系统，然后用本机的 vscode remote ssh 连接到虚拟机，并开启 gdb 调试，最终的效果如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-36-65d7d934154c1e93ccd4a086ef8214fa.png" alt="图片">&lt;/p>
&lt;p>这是最舒服的方式，因为 vscode 是本机的，完全不受虚拟机的影响，这也是我调试其他代码时比较喜欢的方式。&lt;/p>
&lt;p>如果你有自己的豪华服务器，虚拟机也可以换成服务器，这样不但编译速度快，不消耗自己电脑的性能，同时也可以不受终端的影响，在家在公司都可以随时调试（方便摸鱼~）&lt;/p>
&lt;p>当然如果你不需要这么直观 vscode 这一步也可以换成 gdb 命令行，在虚拟机里直接执行 gdb 相关命令即可。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-41-fa8e1e16b008346c82a0e69b7eabe645.png" alt="图片">&lt;/p>
&lt;p>下面我们就一步步来实现这个效果。&lt;/p>
&lt;h2 id="第一步配置虚拟机">第一步：配置虚拟机&lt;/h2>
&lt;p>我用的虚拟机软件是&lt;/p>
&lt;p>&lt;strong>Oracle VM VirtualBox Version 6.0.8 Edition&lt;/strong>&lt;/p>
&lt;p>官网是：&lt;/p>
&lt;p>&lt;a href="https://ubuntu.com/">https://ubuntu.com/&lt;/a>&lt;/p>
&lt;p>下载页面是：&lt;/p>
&lt;p>&lt;a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_0">https://www.virtualbox.org/wiki/Download_Old_Builds_6_0&lt;/a>&lt;/p>
&lt;p>我这个版本的直接下载地址是：&lt;/p>
&lt;p>&lt;a href="https://download.virtualbox.org/virtualbox/6.0.8/VirtualBox-6.0.8-130520-Win.exe">https://download.virtualbox.org/virtualbox/6.0.8/VirtualBox-6.0.8-130520-Win.exe&lt;/a>&lt;/p>
&lt;p>安装的操作系统镜像是&lt;/p>
&lt;p>&lt;strong>ubuntu-16.04.7-desktop-amd64&lt;/strong>&lt;/p>
&lt;p>官网是：&lt;/p>
&lt;p>&lt;a href="https://ubuntu.com/">https://ubuntu.com/&lt;/a>&lt;/p>
&lt;p>下载页面是：&lt;/p>
&lt;p>&lt;a href="https://releases.ubuntu.com/xenial/">https://releases.ubuntu.com/xenial/&lt;/a>&lt;/p>
&lt;p>我这个版本的直接下载地址是：&lt;/p>
&lt;p>&lt;a href="https://releases.ubuntu.com/xenial/ubuntu-16.04.7-desktop-amd64.iso">https://releases.ubuntu.com/xenial/ubuntu-16.04.7-desktop-amd64.iso&lt;/a>&lt;/p>
&lt;p>这个就不详细展开讲解了，最终达到这个效果就行。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-48-da00082b3cd2361979e2770229f04491.png" alt="图片">&lt;/p>
&lt;h2 id="第二步安装-qemu">第二步：安装 qemu&lt;/h2>
&lt;p>qemu 是模拟器，简单理解和虚拟机一样，用来当做真机启动 Linux 0.11 的。&lt;/p>
&lt;p>官网是这个：&lt;/p>
&lt;p>&lt;a href="https://www.qemu.org/">https://www.qemu.org/&lt;/a>&lt;/p>
&lt;p>我们在刚刚的 Ubuntu 虚拟机里直接按照官方教程下载 qemu&lt;/p>
&lt;p>&lt;strong>sudo apt-get install qemu&lt;/strong>&lt;/p>
&lt;p>下载好后，我们输入 &lt;strong>qemu-&lt;/strong>，按两下 tab，查看下支持的体系结构。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-53-824cec1c7ed1c99cfcbd24ae3d2c09b5.png" alt="图片">&lt;/p>
&lt;p>看到有 &lt;strong>qemu-system-x86_64&lt;/strong> 即可，一会我们会用这个来模拟启动 Linux 0.11。&lt;/p>
&lt;h2 id="第三步下载并运行可调试的-linux-011-源码">第三步：下载并运行可调试的 Linux 0.11 源码&lt;/h2>
&lt;p>这一步直接下官网上的是不行的，因为那个依赖好多古老的工具链。&lt;/p>
&lt;p>这里一般网上都是参考了赵炯老师为我们修改好的 Linux 0.11 源码，用现代的工具链即可构建，造福了广大热爱内核的开发者，我们直接拿来主义即可。&lt;/p>
&lt;p>在赵炯老师准备好的源码的基础上，很多人又进行了二次改造，使得其可以一键 qemu 或 bochs 启动，这里我选择了仓库：&lt;/p>
&lt;p>&lt;a href="https://github.com/yuan-xy/Linux-0.11">https://github.com/yuan-xy/Linux-0.11&lt;/a>&lt;/p>
&lt;p>直接把源码下载下来，进入根目录，输入命令 &lt;strong>make start&lt;/strong> 就可以把 Linux 0.11 跑起来了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-49-58-c3ad3b57c48581ccc9eb840e7b2c93c5.png" alt="图片">&lt;/p>
&lt;p>如果想 debug，那么就以 debug 形式启动，输入命令 &lt;strong>make debug&lt;/strong>，它会卡住不动。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-03-5eecaddc641e0cc630fde8bd92f5f666.png" alt="图片">&lt;/p>
&lt;p>此时其实你就可以通过 gdb 进行调试了。&lt;/p>
&lt;p>再开一个窗口，输入命令 &lt;strong>gdb tools/system&lt;/strong>&lt;/p>
&lt;p>然后 &lt;strong>target remote :1234&lt;/strong>&lt;/p>
&lt;p>就可以愉快地进行 gdb 调试了&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-08-fa8e1e16b008346c82a0e69b7eabe645.png" alt="图片">&lt;/p>
&lt;p>具体 gdb 怎么玩，就不展开讲解了。&lt;/p>
&lt;h2 id="第四步通过-vscode-远程调试">第四步：通过 vscode 远程调试&lt;/h2>
&lt;p>当然，你也可以在虚拟机里用 vscode 进行本地调试，但我觉得不爽。&lt;/p>
&lt;p>所以，在本机的 windows 里安装好 vscode，下载 &lt;strong>remote-ssh&lt;/strong> 插件。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-13-0b407d81e66d46020c21b66ad176718f.png" alt="图片">&lt;/p>
&lt;p>下载好后按下 &lt;strong>ctrl + p&lt;/strong>，输入 &lt;strong>&amp;gt;remote-ssh&lt;/strong>，找到 &lt;strong>Connect to Host&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-18-813005ffc72a0560290dc8a7f7472555.png" alt="图片">&lt;/p>
&lt;p>按照它提示的格式输入你的虚拟机 IP 和用户名，随后输入密码，即可远程连接到虚拟机。&lt;/p>
&lt;p>之后点击菜单栏 &lt;strong>运行-启用调试&lt;/strong>，在弹出的 &lt;strong>launch.json&lt;/strong> 中做如下配置&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-23-7a03d0abddd5155ff4c18eb87ff8e676.png" alt="图片">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>    
    &lt;span class="nt">&amp;#34;version&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;0.2.0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>    
    &lt;span class="nt">&amp;#34;configurations&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>        
        &lt;span class="p">{&lt;/span>
            &lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;(gdb) Launch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;cppdbg&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;request&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;launch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;program&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;${workspaceFolder}/tools/system&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;miDebuggerServerAddress&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;127.0.0.1:1234&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;args&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[],&lt;/span>
            &lt;span class="nt">&amp;#34;stopAtEntry&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;cwd&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;${workspaceFolder}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;environment&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[],&lt;/span>
            &lt;span class="nt">&amp;#34;externalConsole&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>
            &lt;span class="nt">&amp;#34;MIMode&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;gdb&amp;#34;&lt;/span>
        &lt;span class="p">}&lt;/span>
    &lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>配置好后保存，在 main 函数里打个断点，再次点击菜单栏 &lt;strong>运行-启用调试&lt;/strong>，可以发现调试成功。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-18-50-30-65d7d934154c1e93ccd4a086ef8214fa.png" alt="图片">&lt;/p>
&lt;p>当然，记得每次 vscode 调试前，在虚拟机里先把 Linux 0.11 跑起来，就是执行命令 &lt;strong>make debug&lt;/strong>。&lt;/p>
&lt;p>这一步也可以配置到 vscode 里，但这一步没多少工作量，而且也不方便直观看到虚拟机里的行为，我就懒得弄了。&lt;/p>
&lt;p>好了，这个教程到这里就结束了，这就是我调试 Linux 0.11 的其中一个办法，当然每个人可能都有自己喜欢的方式，只要适合自己就好。&lt;/p></description></item><item><title>41.命令执行过程</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/41.%E7%95%AA%E5%A4%96%E7%AF%87-%E8%B7%B3%E7%A5%A8%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/41.%E7%95%AA%E5%A4%96%E7%AF%87-%E8%B7%B3%E7%A5%A8%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84/</guid><description>&lt;h1 id="41命令执行过程">41.命令执行过程&lt;/h1>
&lt;p>这部分要讲啥呢？很简单。&lt;/p>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">name:flash
age:28
language:java
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11] cat info.txt | wc -l
3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。&lt;/p>
&lt;p>&lt;strong>我们的第五部分，就是抽丝剥茧般地解释这条命令，从你敲击键盘的那一刻开始，一直到它输出到屏幕 3 这个数字为止的全部过程。&lt;/strong>&lt;/p>
&lt;p>阅读这个部分的同学，应该有一种所有知识都被串起来的爽。因为前四个部分已经把操作系统启动流程的全部秘密讲出来了，而在启动过程中必然伴随着系统各个模块的运作，而我们的第五部分正是想通过这一条命令的执行过程来解读系统各模块的原理与协作方式。&lt;/p>
&lt;p>比如在启动过程中，进程 0 创建进程 1 进行 init 的过程，就需要 fork 函数的支持，这也就涉及到了进程调度模块。&lt;/p>
&lt;p>&lt;img src="https://justice.bj.cn/Users/justice/tmp/notebook-img/43e539974952ac5c91c586a0b27b497200b5dddf.png" alt="图片">&lt;/p>
&lt;p>再比如在加载根文件系统，并打开 /dev/tty0 等文件时，就需要文件系统的支持，比较直观的函数就是 open，close，read，write 等。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-59-14-a1b1b3a733ba0087dab63de189be8c70.png" alt="图片">&lt;/p>
&lt;p>再比如加载并执行 shell 程序的时候，是通过 execve 配合 fork 函数来实现的，这里又涉及到了内存管理系统与中断机制，当然，这俩东西在任何地方都有体现。&lt;/p>
&lt;p>这里的有些部分讲解的较为详细，比如进程调度这块，在启动流程中就直接有调用 fork 函数，如果不讲清楚了，启动流程的理解将会受到阻碍。&lt;/p>
&lt;p>有些部分的讲解就没有那么详细了，因为不影响启动流程的理解，比如说从硬盘中读取数据到内存，其实中间涉及到文件系统，以及文件系统这个抽象层下方的块设备驱动程序，这部分非常复杂，不但分层和抽象层次较多，且涉及到阻塞与唤醒等操作。&lt;/p>
&lt;p>所以从硬盘中读取数据到内存这块就没有展开太多，因为从硬盘读取数据到内存，本身不考虑细节，是一件非常容易理解的事情，就没有在启动流程里展开，以免影响大家对主流程的整体把控。&lt;/p>
&lt;p>&lt;strong>不过不用担心，整个第五部分，我将会通过这一个命令的执行过程，将操作系统各模块的全部核心细节都展开了讲解。&lt;/strong>&lt;/p>
&lt;p>一个命令的执行，可以说调用了操作系统所有模块的运作，就光键盘输入命令到 shell 进程读取到这个命令，就涉及到了文件系统以及其下方的字符设备驱动程序。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-59-22-2bfeeedd528ac67b4fead02642dabd84.png" alt="图片">&lt;/p>
&lt;p>以及字符设备队列读取时的阻塞与唤醒机制。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-16-59-38-5a9524073c66b298af46c4f44c95bac9.png" alt="图片">&lt;/p>
&lt;p>可以说是非常精彩。&lt;/p>
&lt;p>当你通过前四部分理解了操作系统启动流程，再继续通过第五部分理解了一条命令的执行流程，那么你对操作系统的原理就真的不再畏惧了，因为操作系统一共就这两件事，一个是把自己启动起来，另一个是不断接收用户的命令并且执行它，就这么简单。&lt;/p></description></item><item><title>42.用键盘输入一条命令</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/42.%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/42.%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="42用键盘输入一条命令">42.用键盘输入一条命令&lt;/h1>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">name:flash
age:28
language:java
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11] cat info.txt | wc -l
3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。&lt;/p>
&lt;p>我们先从最初始的状态开始说起。&lt;/p>
&lt;p>最初始的状态，电脑屏幕前只有这么一段话。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11]
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后，我们按下按键 &amp;lsquo;c&amp;rsquo;，将会变成这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11] c
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们再按下 &amp;lsquo;a&amp;rsquo;&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11] ca
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来，我们再依次按下 &amp;rsquo;t'、空格、&amp;lsquo;i&amp;rsquo; 等等，才变成了这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11] cat info.txt | wc -l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们今天就要解释这个看起来十分&amp;quot;正常&amp;quot;的过程。&lt;/p>
&lt;p>凭什么我们按下键盘后，屏幕上就会出现如此的变化呢？老天爷规定的么？&lt;/p>
&lt;p>我们就从按下键盘上的 &amp;lsquo;c&amp;rsquo; 键开始说起。&lt;/p>
&lt;p>首先，得益于 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500190&amp;amp;idx=1&amp;amp;sn=b0bebe846b55f7e29fc009e1b6587214&amp;amp;chksm=c2c5bb33f5b23225845ab699d1b8fcee39a04ca98a48ebf0e2c22584b638fa0b0839d1212485&amp;amp;scene=21#wechat_redirect">第16回 | 控制台初始化 tty_init&lt;/a> 中讲述的一行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// console.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">set_trap_gate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">keyboard_interrupt&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们成功将键盘中断绑定在了 &lt;strong>keyboard_interrupt&lt;/strong> 这个中断处理函数上，也就是说当我们按下键盘 &amp;lsquo;c&amp;rsquo; 时，CPU 的中断机制将会被触发，最终执行到这个 keyboard_interrupt 函数中。&lt;/p>
&lt;p>我们来到 keyboard_interrupt 函数一探究竟。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">keyboard_interrupt:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 读取键盘扫描码    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">inb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mh">0x60&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">al&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 调用对应按键的处理函数    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nv">key_table&lt;/span>&lt;span class="p">(,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 0 作为参数，调用 &lt;/span>&lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很简单，首先通过 IO 端口操作，从键盘中读取了刚刚产生的键盘扫描码，就是刚刚按下 &amp;lsquo;c&amp;rsquo; 的时候产生的键盘扫描码。&lt;/p>
&lt;p>随后，在 key_table 中寻找不同按键对应的不同处理函数，比如普通的一个字母对应的字符 &amp;lsquo;c&amp;rsquo; 的处理函数为 do_self，该函数会将扫描码转换为 ASCII 字符码，并将自己放入一个队列里，我们稍后再说这部分的细节。&lt;/p>
&lt;p>接下来，就是调用 &lt;strong>do_tty_interrupt&lt;/strong> 函数，见名知意就是处理终端的中断处理函数，注意这里传递了一个参数 0。&lt;/p>
&lt;p>我们接着探索，打开 do_tty_interrupt 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数几乎什么都没做，将 keyboard_interrupt 时传入的参数 0，作为 tty_table 的索引，找到 tty_table 中的第 0 项作为下一个函数的入参，仅此而已。&lt;/p>
&lt;p>tty_table 是&lt;strong>终端设备表&lt;/strong>，在 Linux 0.11 中定义了三项，分别是&lt;strong>控制台&lt;/strong>、&lt;strong>串行终端 1&lt;/strong> 和&lt;strong>串行终端 2&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="n">tty_table&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="p">{...},&lt;/span>
&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* initial pgrp */&lt;/span>
&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* initial stopped */&lt;/span>
&lt;span class="n">con_write&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="cm">/* console read-queue */&lt;/span>
        &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="cm">/* console write-queue */&lt;/span>
        &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="cm">/* console secondary queue */&lt;/span>
    &lt;span class="p">},&lt;/span>
    &lt;span class="p">{...},&lt;/span>
    &lt;span class="p">{...}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们用的往屏幕上输出内容的终端，就是 0 号索引位置处的控制台终端，所以我将另外两个终端定义的代码省略掉了。&lt;/p>
&lt;p>tty_table 终端设备表中的每一项结构，是 tty_struct，用来描述一个终端的属性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">termios&lt;/span> &lt;span class="n">termios&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">pgrp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">stopped&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="n">read_q&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="n">write_q&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="n">secondary&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">tail&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">proc_list&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">TTY_BUF_SIZE&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>说说其中较为关键的几个。&lt;/p>
&lt;p>&lt;strong>termios&lt;/strong> 是定义了终端的各种模式，包括读模式、写模式、控制模式等，这个之后再说。&lt;/p>
&lt;p>*&lt;em>void (&lt;em>write)(struct tty_struct * tty)&lt;/em>&lt;/em> 是一个接口函数，在刚刚的 tty_table 中我们也可以看出被定义为了 con_write，也就是说今后我们调用这个 0 号终端的写操作时，将会调用的是这个 con_write 函数，这不就是接口思想么。&lt;/p>
&lt;p>还有三个队列分别为&lt;strong>读队列 read_q&lt;/strong>，&lt;strong>写队列 write_q&lt;/strong> 以及一个&lt;strong>辅助队列 secondary&lt;/strong>。&lt;/p>
&lt;p>这些有什么用，我们通通之后再说，跟着我接着看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="kt">signed&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">FULL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="c1">// 从 read_q 中取出字符        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="n">GETCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="c1">// 这里省略了一大坨行规则处理代码        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="p">...&lt;/span>        
        &lt;span class="c1">// 将处理过后的字符放入 secondary        
&lt;/span>&lt;span class="c1">&lt;/span>        &lt;span class="n">PUTCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="n">wake_up&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">proc_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>展开 &lt;strong>copy_to_cooked&lt;/strong> 函数我们发现，一个大体的框架已经有了。&lt;/p>
&lt;p>在 copy_to_cooked 函数里就是个大循环，只要读队列 read_q 不为空，且辅助队列 secondary 没有满，就不断从 read_q 中取出字符，经过一大坨的处理，写入 secondary 队列里。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-09-64bde8b13c3537b65e20a05a43d5b859.png" alt="图片">&lt;/p>
&lt;p>否则，就唤醒等待这个辅助队列 secondary 的进程，之后怎么做就由进程自己决定。&lt;/p>
&lt;p>我们接着看，中间的一大坨处理过程做了什么事情呢？&lt;/p>
&lt;p>这一大坨有太多太多的 if 判断，但都是围绕着同一个目的，我们举其中一个简单的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define IUCLC   0001000
&lt;/span>&lt;span class="cp">#define _I_FLAG(tty,f)  ((tty)-&amp;gt;termios.c_iflag &amp;amp; f)
&lt;/span>&lt;span class="cp">#define I_UCLC(tty) _I_FLAG((tty),IUCLC)
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="c1">// 这里省略了一大坨行规则处理代码    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">I_UCLC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="n">c&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">tolower&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>简单说，就是通过判断 tty 中的 termios，来决定对读出的字符 c 做一些处理。&lt;/p>
&lt;p>在这里，就是判断 termios 中的 c_iflag 中的第 4 位是否为 1，来决定是否要将读出的字符 c 由大写变为小写。&lt;/p>
&lt;p>这个 termios 就是定义了终端的&lt;strong>模式&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">termios&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_iflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* input mode flags */&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_oflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* output mode flags */&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_cflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* control mode flags */&lt;/span>
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">c_lflag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* local mode flags */&lt;/span>
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c_line&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* line discipline */&lt;/span>
    &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c_cc&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NCCS&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="cm">/* control characters */&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>比如刚刚的是否要将大写变为小写，是否将回车字符替换成换行字符，是否接受键盘控制字符信号如 ctrl + c 等。&lt;/p>
&lt;p>这些模式不是 Linux 0.11 自己乱想出来的，而是实现了 &lt;strong>POSIX.1&lt;/strong> 中规定的 &lt;strong>termios 标准&lt;/strong>，具体可以参见：&lt;/p>
&lt;p>&lt;a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html#tag_11">https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html#tag_11&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-18-488c77e0563de2fb7c5d236bff535d52.png" alt="图片">&lt;/p>
&lt;p>好了，我们目前可以总结出，按下键盘后做了什么事情。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-25-ad92b915fd5f7244fc05788755acfae2.png" alt="图片">&lt;/p>
&lt;p>这里我们应该产生几个疑问。&lt;/p>
&lt;p>&lt;strong>一、读队列 read_q 里的字符是什么时候放进去的？&lt;/strong>&lt;/p>
&lt;p>还记不记得最开始讲的 keyboard_interrupt 函数，我们有一个方法没有展开讲。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">keyboard_interrupt:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 读取键盘扫描码    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">inb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mh">0x60&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">al&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 调用对应按键的处理函数    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nv">key_table&lt;/span>&lt;span class="p">(,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 0 作为参数，调用 &lt;/span>&lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">pushl&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="kc">$&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_tty_interrupt&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就是这个 &lt;strong>key_table&lt;/strong>，我们将其展开。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">key_table:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.long&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">none&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="err">  &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">03&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">s0&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nb">es&lt;/span>&lt;span class="nv">c&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.long&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="err">   &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">04&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">07&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">.long&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">do_self&lt;/span>&lt;span class="err">   &lt;/span>&lt;span class="o">/*&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">23&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">d&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">f&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">g&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">h&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="o">*/&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，普通的字符 abcd 这种，对应的处理函数是 &lt;strong>do_self&lt;/strong>，我们再继续展开。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="err">// &lt;/span>&lt;span class="nf">keyboard.s&lt;/span>
&lt;span class="nl">do_self:&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 扫描码转换为 &lt;/span>&lt;span class="nf">ASCII&lt;/span>&lt;span class="err"> 码    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">lea&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">key_map&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">ebx&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">1: &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">movb&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">ebx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">eax&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nb">al&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    &lt;/span>&lt;span class="nf">...&lt;/span>&lt;span class="err">    &lt;/span>
&lt;span class="err">    // 放入队列    &lt;/span>
&lt;span class="nf">call&lt;/span>&lt;span class="err"> &lt;/span>&lt;span class="nv">put_queue&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到最后调用了 &lt;strong>put_queue&lt;/strong> 函数，顾名思义&lt;strong>放入队列&lt;/strong>，看来我们要找到答案了，继续展开。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">table_list&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">write_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">write_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">read_q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">write_q&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="c1">// keyboard.s
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nl">put_queue&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="p">...&lt;/span>
    &lt;span class="n">movl&lt;/span> &lt;span class="n">table_list&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">edx&lt;/span>
    &lt;span class="err">#&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">queue&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">console&lt;/span>
    &lt;span class="n">movl&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">edx&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">ecx&lt;/span>
    &lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，put_queue 正是操作了我们 tty_table 数组中的零号位置，也就是控制台终端 tty 的 &lt;strong>read_q 队列&lt;/strong>，进行入队操作。&lt;/p>
&lt;p>答案揭晓了，那我们的整体流程图也可以再丰富起来。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-32-7a7eca40cdfef3ea9c30af70fd830b85.png" alt="图片">&lt;/p>
&lt;p>&lt;strong>二、放入 secondary 队列之后呢？&lt;/strong>&lt;/p>
&lt;p>按下键盘后，一系列代码将我们的字符放入了 secondary 队列中，然后呢？&lt;/p>
&lt;p>这就涉及到上层进程调用终端的读函数，将这个字符取走了。&lt;/p>
&lt;p>上层经过库函数、文件系统函数等，最终会调用到 tty_read 函数，将字符从 secondary 队列里取走。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tty_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">channel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">GETCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>取走后要干嘛，那就是上层应用程序去决定的事情了。&lt;/p>
&lt;p>假如要写到控制台终端，那上层应用程序又会经过库函数、文件系统函数等层层调用，最终调用到 &lt;strong>tty_write&lt;/strong> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tty_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">channel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">PUTCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">write_q&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数首先会将字符 c 放入 &lt;strong>write_q&lt;/strong> 这个队列，然后调用 tty 里设定的 write 函数。&lt;/p>
&lt;p>终端控制台这个 tty 我们之前说了，初始化的 write 函数是 &lt;strong>con_write&lt;/strong>，也就是 console 的写函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// console.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">con_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>      
    &lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数在 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247500190&amp;amp;idx=1&amp;amp;sn=b0bebe846b55f7e29fc009e1b6587214&amp;amp;chksm=c2c5bb33f5b23225845ab699d1b8fcee39a04ca98a48ebf0e2c22584b638fa0b0839d1212485&amp;amp;scene=21#wechat_redirect">第16回 | 控制台初始化 tty_init&lt;/a> 提到了，最终会配合显卡，在我们的屏幕上输出我们给出的字符。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-42-ec27c844306f4a807e83316c7b33b583.png" alt="图片">&lt;/p>
&lt;p>那我们的图又可以补充了。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-48-66917ca73ea365075ba2701bd6df35fd.png" alt="图片">&lt;/p>
&lt;p>核心点就是三个队列 &lt;strong>read_q&lt;/strong>，&lt;strong>secondary&lt;/strong> 以及 &lt;strong>write_q&lt;/strong>。&lt;/p>
&lt;p>其中 read_q 是键盘按下按键后，进入到键盘中断处理程序 keyboard_interrupt 里，最终通过 put_queue 函数字符放入 read_q 这个队列。&lt;/p>
&lt;p>secondary 是 read_q 队列里的未处理字符，通过 copy_to_cooked 函数，经过一定的 termios 规范处理后，将处理过后的字符放入 secondary。（处理过后的字符就是成&amp;quot;熟&amp;quot;的字符，所以叫 cooked，是不是很形象？）&lt;/p>
&lt;p>然后，进程通过 tty_read 从 secondary 里读字符，通过 tty_write 将字符写入 write_q，最终 write_q 中的字符可以通过 con_write 这个控制台写函数，将字符打印在显示器上。&lt;/p>
&lt;p>这就完成了从键盘输入到显示器输出的一个循环，也就是本回所讲述的内容。&lt;/p>
&lt;p>好了，现在我们已经成功做到可以把这样一个字符串输入并回显在显示器上了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11] cat info.txt | wc -l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么接下来，shell 程序具体是如何读入这个字符串，读入后又是怎么处理的呢？&lt;/p></description></item><item><title>43.shell 程序读取你的命令</title><link>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/43.shell%E7%A8%8B%E5%BA%8F%E8%AF%BB%E5%8F%96%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 06 Jan 2024 09:05:06 +0800</pubDate><guid>https://justice.bj.cn/post/09.pub/linux-0.11%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%AC%AC5%E9%83%A8%E5%88%86/43.shell%E7%A8%8B%E5%BA%8F%E8%AF%BB%E5%8F%96%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="43shell-程序读取你的命令">43.shell 程序读取你的命令&lt;/h1>
&lt;p>新建一个非常简单的 info.txt 文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">name:flash
age:28
language:java
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令行输入一条十分简单的命令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@linux0.11] cat info.txt | wc -l3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这条命令的意思是读取刚刚的 info.txt 文件，输出它的行数。&lt;/p>
&lt;p>在&lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502876&amp;amp;idx=1&amp;amp;sn=2c34491abd6ea14c9c7ccc3d2d9827c1&amp;amp;chksm=c2c5b6b1f5b23fa7bdf9c3e2bf811b84da937d30a2c9825ceba8a57c2c3e8e157dedae0bfc8d&amp;amp;scene=21#wechat_redirect">上一回&lt;/a>，我们详细解读了从键盘敲击出这个命令，到屏幕上显示出这个命令，中间发生的事情。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-00-59-8497ea11709af99bb411bfad007ec4c7.png" alt="图片">&lt;/p>
&lt;p>那今天，我们接着往下走，下一步就是，&lt;strong>shell 程序如何读取到你输入的这条命令的&lt;/strong>。&lt;/p>
&lt;p>这里我们需要知道两件事情。&lt;/p>
&lt;p>第一，我们键盘输入的字符，此时已经到达了控制台终端 tty 结构中的 &lt;strong>secondary&lt;/strong> 这个队列里。&lt;/p>
&lt;p>第二，shell 程序将通过上层的 &lt;strong>read&lt;/strong> 函数调用，来读取这些字符。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// xv6-public sh.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="c1">// 读取命令
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="c1">// 创建新进程
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fork&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 执行命令
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">runcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parsecmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="c1">// 等待进程退出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">wait&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">getcmd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nbuf&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">gets&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nbuf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">gets&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cc&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">){&lt;/span>
&lt;span class="n">cc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cc&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;\r&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
    &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;\0&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看，shell 程序会通过 &lt;strong>getcmd&lt;/strong> 函数最终调用到 &lt;strong>read&lt;/strong> 函数一个字符一个字符读入，直到读到了换行符（\n 或 \r）的时候，才返回。&lt;/p>
&lt;p>读入的字符在 buf 里，遇到换行符后，这些字符将作为一个完整的命令，传入给 &lt;strong>runcmd&lt;/strong> 函数，真正执行这个命令。&lt;/p>
&lt;p>那我们接下来的任务就是，看一下这个 read 函数是怎么把之前键盘输入并转移到 secondary 这个队列里的字符给读出来的。&lt;/p>
&lt;p>read 函数是个用户态的库函数，最终会通过&lt;strong>系统调用&lt;/strong>中断，执行 &lt;strong>sys_read&lt;/strong> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// read_write.c
&lt;/span>&lt;span class="c1">// fd = 0, count = 1
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sys_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">filp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="c1">// 校验 buf 区域的内存限制    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">verify_area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">m_inode&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">inode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_inode&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 管道文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_pipe&lt;/span>&lt;span class="p">)&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_mode&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="n">read_pipe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:-&lt;/span>&lt;span class="n">EIO&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="c1">// 字符设备文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISCHR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">rw_char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">READ&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 块设备文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISBLK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">block_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_zone&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="c1">// 目录文件或普通文件    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S_ISDIR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">S_ISREG&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_pos&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>            
            &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="k">return&lt;/span> &lt;span class="n">file_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="c1">// 不是以上几种，就报错    
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="n">printk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;(Read)inode-&amp;gt;i_mode=%06o&lt;/span>&lt;span class="se">\n\r&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关键地方我已经标上了注释，整体结构不看细节的话特别清晰。&lt;/p>
&lt;p>这个最上层的 &lt;strong>sys_read&lt;/strong>，把读取&lt;strong>管道文件&lt;/strong>、&lt;strong>字符设备文件&lt;/strong>、&lt;strong>块设备文件&lt;/strong>、&lt;strong>目录文件&lt;/strong>或&lt;strong>普通文件&lt;/strong>，都放在了同一个方法里处理，这个方法作为所有读操作的统一入口，由此也可以看出 linux 下一切皆文件的思想。&lt;/p>
&lt;p>read 的第一个参数是 0，也就是 0 号文件描述符，之前我们在讲第四部分的时候说过，shell 进程是由进程 1 通过 fork 创建出来的，而进程 1 在 init 的时候打开了 &lt;strong>/dev/tty0&lt;/strong> 作为 0 号文件描述符。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">setup&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">drive_info&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/dev/tty0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">O_RDWR&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>    
    &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">dup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而这个 /dev/tty0 的文件类型，也就是其 inode 结构中表示文件类型与属性的 &lt;strong>i_mode&lt;/strong> 字段，表示为&lt;strong>字符型设备&lt;/strong>，所以最终会走到 &lt;strong>rw_char&lt;/strong> 这个子方法下，文件系统的第一层划分就走完了。&lt;/p>
&lt;p>接下来我们看 rw_char 这个方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// char_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="n">crw_ptr&lt;/span> &lt;span class="n">crw_table&lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* nodev */&lt;/span>
&lt;span class="n">rw_memory&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/mem etc */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/fd */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/hd */&lt;/span>
    &lt;span class="n">rw_ttyx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/ttyx */&lt;/span>
    &lt;span class="n">rw_tty&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/tty */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* /dev/lp */&lt;/span>
    &lt;span class="nb">NULL&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="cm">/* unnamed pipes */&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">rw_char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">rw&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">off_t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="n">crw_ptr&lt;/span> &lt;span class="n">call_addr&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="n">NRDEVS&lt;/span>&lt;span class="p">)&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ENODEV&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">call_addr&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">crw_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAJOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">)]))&lt;/span>
        &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ENODEV&lt;/span>&lt;span class="p">;&lt;/span>
    &lt;span class="k">return&lt;/span> &lt;span class="n">call_addr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">MINOR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 dev 这个参数，计算出主设备号为 4，次设备号为 0，所以将会走到 &lt;strong>rw_ttyx&lt;/strong> 方法继续执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// char_dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">rw_ttyx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">rw&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">minor&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">off_t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="n">READ&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="n">tty_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">minor&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>        
        &lt;span class="n">tty_write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">minor&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 &lt;strong>rw == READ&lt;/strong> 走到读操作分支 &lt;strong>tty_read&lt;/strong>，这就终于快和上一讲的故事接上了。&lt;/p>
&lt;p>以下是 tty_read 函数，我省略了一些关于信号和超时时间等非核心的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">// channel=0, nr=1
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tty_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="n">channel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">channel&lt;/span>&lt;span class="p">];&lt;/span>    
    &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">...&lt;/span>        
        &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">...)&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="p">}&lt;/span>        
        &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>            
            &lt;span class="n">GETCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="p">...&lt;/span>            
            &lt;span class="n">put_fs_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>            
            &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!--&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="p">)&lt;/span> 
                &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>        
        &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">));&lt;/span>        
        &lt;span class="p">...&lt;/span>    
    &lt;span class="p">}&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>入参有三个参数，非常简单。&lt;/p>
&lt;p>&lt;strong>channel&lt;/strong> 为 0，表示 tty_table 里的控制台终端这个具体的设备。&lt;strong>buf&lt;/strong> 是我们要读取的数据拷贝到内存的位置指针，也就是用户缓冲区指针。&lt;strong>nr&lt;/strong> 为 1，表示我们要读出 1 个字符。&lt;/p>
&lt;p>&lt;strong>整个方法，其实就是不断从 secondary 队列里取出字符，然后放入 buf 指所指向的内存。&lt;/strong>&lt;/p>
&lt;p>如果要读取的字符数 nr 被减为 0，说明已经完成了读取任务，或者说 secondary 队列为空，说明不论你任务完没完成我都没有字符让你继续读了，那此时调用 &lt;strong>sleep_if_empty&lt;/strong> 将线程&lt;strong>阻塞&lt;/strong>，等待被唤醒。&lt;/p>
&lt;p>其中 GETCH 就是个宏，改变 secondary 队列的队头队尾指针，你自己写个队列数据结构，也是这样的操作，不再展开讲解。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define GETCH(queue,c) \
&lt;/span>&lt;span class="cp">    (void)({c=(queue).buf[(queue).tail];INC((queue).tail);})
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同理，判空逻辑就更为简单了，就是队列头尾指针是否相撞。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define EMPTY(a) ((a).head == (a).tail)
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>理解了这些小细节之后，再明白一行关键的代码，整个 read 到 tty_read 这条线就完全可以想明白了。那就是队列为空，即不满足继续读取条件的时候，让进程阻塞的 &lt;strong>sleep_if_empty&lt;/strong>，我们看看。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sleep_if_empty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_queue&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cli&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">signal&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">EMPTY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">interruptible_sleep_on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">proc_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">sti&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">interruptible_sleep_on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">tmp&lt;/span>&lt;span class="o">=*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nl">repeat&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_INTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">schedule&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">repeat&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">tmp&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们先只看一句关键的代码，就是将当前进程的状态设置为可中断等待。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">current&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TASK_INTERRUPTIBLE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么执行到进程调度程序时，当前进程将不会被调度，也就相当于阻塞了，不熟悉进程调度的同学可以复习一下 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247501576&amp;amp;idx=1&amp;amp;sn=657e1c89d1007a935820d394d64f4035&amp;amp;scene=21#wechat_redirect">第23回 | 如果让你来设计进程调度&lt;/a>。&lt;/p>
&lt;p>进程被调度了，什么时候被唤醒呢？&lt;/p>
&lt;p>当我们再次按下键盘，使得 secondary 队列中有字符时，也就打破了为空的条件，此时就应该将之前的进程唤醒了，这在上一回 &lt;a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247502876&amp;amp;idx=1&amp;amp;sn=2c34491abd6ea14c9c7ccc3d2d9827c1&amp;amp;chksm=c2c5b6b1f5b23fa7bdf9c3e2bf811b84da937d30a2c9825ceba8a57c2c3e8e157dedae0bfc8d&amp;amp;scene=21#wechat_redirect">第42回 | 用键盘输入一条命令&lt;/a> 一讲中提到过了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// tty_io.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">do_tty_interrupt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="n">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tty_table&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy_to_cooked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">tty_struct&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="p">...&lt;/span>    
    &lt;span class="n">wake_up&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tty&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">secondary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">proc_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到，在 copy_to_cooked 里，在将 read_q 队列中的字符处理后放入 secondary 队列中的最后一步，就是唤醒 &lt;strong>wake_up&lt;/strong> 这个队列里的等待进程。&lt;/p>
&lt;p>而 wake_up 函数更为简单，就是修改一下状态，使其变成可运行的状态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// sched.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">wake_up&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">task_struct&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>    
    &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>        
        &lt;span class="p">(&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>    
    &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>总体流程就是这个样子的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2024/01/02-17-01-26-608d437c4943b3178c216f4463a0683b.png" alt="图片">&lt;/p>
&lt;p>当然，进程的阻塞与唤醒是个体系，还有很多细节，我们下一回再仔细展开这部分的内容。&lt;/p></description></item></channel></rss>