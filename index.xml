<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 30 Apr 2022 11:32:24 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Disruptor(高效无锁内存队列)</title><link>https://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</guid><description>&lt;h1 id="disruptor高效无锁内存队列">Disruptor(高效无锁内存队列)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Disruptor 是 LMAX 公司开源的一个高效的内存无锁队列。&lt;/p></description></item><item><title>Kafka时间轮算法</title><link>https://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</guid><description>&lt;h1 id="kafka时间轮算法">Kafka时间轮算法&lt;/h1>
&lt;p>Kafka 中存在一些定时任务(DelayedOperation)，如 DelayedFetch、DelayedProduce、DelayedHeartbeat 等，在 Kafka 中，定时任务的添加、轮转、执行、消亡等是通过时间轮来实现的。(时间轮并不是 Kafka 独有的设计，而是一种通用的实现方式，Netty 中也有用到时间轮的方式)&lt;/p>
&lt;h2 id="1-时间轮是什么">1.  时间轮是什么&lt;/h2>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/36/36293d8f2a75cd09852f9189092cbe9e.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/cb/cb615fcfbc43cd42a73b65644701d2a2.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;p>Kafka 时间轮由多个环形数组组成，每个环形数组包含 20 个时间单位，表示一个时间维度（一轮），如：第一层时间轮，数组中的每个元素代表 1ms，一圈就是 20ms，当延迟时间大于 20ms 时，就“进位”到第二层时间轮，第二层中，每“一格”表示 20ms，依此类推…&lt;/p>
&lt;p>对于一个延迟任务，大体包含三个过程：进入时间轮、降级和到期执行。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>进入时间轮&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>根据延迟时间计算对应的时间轮“层次”（如钟表中的“小时级”还是“分钟级”还是“秒级”，实际上是一个不断“升级”的过程，直到找到合适的“层次”）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算在该轮中的位置，并插入该位置（每个 bucket 是一个双向链表，可能包含多个延迟任务，这也是时间轮提高效率的一大原因，后面会提到）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若该 bucket 是首次插入，需要将该 bucket 加入 DelayQueue 中（DelayQueue 的引入是为了解决“空推进”，后面会提到）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/7b/7b74698c1815c0f86af8d1820da6b838.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降级&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>当时间“推进”到某个 bucket 时，说明该 bucket 中的任务在当前时间轮中的时间已经走完，需要进行“降级”，即进入更小粒度的时间轮中，reinsert 的过程和进入时间轮是类似的&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/d4/d4af2f2054bf00f89bcbf4e36044aa56.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>到期执行&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>在 reinsert 的过程中，若发现已经到期，则执行这些任务&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/19/19bb4299ca84652634ea5eade9471905.png" alt="">&lt;/p>
&lt;p>整体过程大致如下：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/e9/e901a56d80092cda0bdbb4260ed21a91.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;h2 id="2-时间的推进">2.  时间的“推进”&lt;/h2>
&lt;p>一种直观的想法是，像现实中的钟表一样，“一格一格”地走，这样就需要有一个线程一直不停的执行，而大多数情况下，时间轮中的 bucket 大部分是空的，指针的“推进”就没有实质作用，因此，为了减少这种“空推进”，Kafka 引入了 DelayQueue，以 bucket 为单位入队，每当有 bucket 到期，即 queue.poll 能拿到结果时，才进行时间的“推进”，减少了 ExpiredOperationReaper 线程空转的开销。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/5e/5e190488738e81a0ab996eb2c155e54f.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="">&lt;/p>
&lt;h2 id="3-为什么要用时间轮">3.  为什么要用时间轮&lt;/h2>
&lt;p>用到延迟任务时，比较直接的想法是 DelayQueue、ScheduledThreadPoolExecutor 这些，而时间轮相比之下，最大的优势是在时间复杂度上：&lt;/p>
&lt;p>时间复杂度对比：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/cc/ccc843d13e25a1fec3e375b14e6658ac.png" alt="">&lt;/p>
&lt;p>因此，理论上，当任务较多时，TimingWheel 的时间性能优势会更明显&lt;/p>
&lt;p>总结一下 Kafka 时间轮性能高的几个主要原因：&lt;/p>
&lt;p>（1）时间轮的结构+双向列表 bucket，使得插入操作可以达到 O(1)的时间复杂度&lt;/p>
&lt;p>（2）Bucket 的设计让多个任务“合并”，使得同一个 bucket 的多次插入只需要在 delayQueue 中入队一次，同时减少了 delayQueue 中元素数量，堆的深度也减小，delayqueue 的插入和弹出操作开销也更小&lt;/p></description></item><item><title>RoaringBitmap</title><link>https://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</guid><description>&lt;h1 id="roaringbitmap">RoaringBitmap&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>RoaringBitmap（简称为 RBM）是 2016 年由 S. Chambi、D. Lemire、O. Kaser 等人在论文中提出的一种高效位图压缩算法;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用于解决稀疏位图空间占用效率问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="主要思想">主要思想&lt;/h2>
&lt;p>将 32 位无符号整数按照高 16 位分桶，即最多可能有 216=65536 个桶，称为&lt;code>container&lt;/code>。存储数据时，按照数据的高 16 位找到 container（找不到就会新建一个），再将低 16 位放入 container 中。也就是说，一个 RBM 就是很多 container 的集合。如下所示。&lt;/p>
&lt;p>&lt;img src="https://upload-images.jianshu.io/upload_images/195230-7b71d0d9abe6e906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp" alt="">&lt;/p>
&lt;p>图中示出了三个 container：&lt;/p>
&lt;ul>
&lt;li>高 16 位为 0000H 的 container，存储有前 1000 个 62 的倍数。&lt;/li>
&lt;li>高 16 位为 0001H 的 container，存储有[216, 216+100)区间内的 100 个数。&lt;/li>
&lt;li>高 16 位为 0002H 的 container，存储有[2×216, 3×216)区间内的所有偶数，共 215 个。&lt;/li>
&lt;/ul>
&lt;p>container 是 RBM 新创造的概念，自然也是提高效率的核心。为了更高效地存储和查询数据，不同情况下会采用不同类型的 container，下面深入讲解一下 container 的细节。&lt;/p>
&lt;h3 id="container">Container&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>ArrayContainer: 当桶内数据的基数不大于 4096 时，会采用它来存储，其本质上是一个 unsigned short 类型的有序数组。数组初始长度为 4，随着数据的增多会自动扩容（但最大长度就是 4096）。另外还维护有一个计数器，用来实时记录基数。上图中的前两个 container 基数都没超过 4096，所以均为 ArrayContainer。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BitmapContainer: 当桶内数据的基数大于 4096 时，会采用它来存储，其本质就是上一节讲过的普通位图，用长度固定为 1024 的 unsigned long 型数组表示，亦即位图的大小固定为 216 位（8KB）。它同样有一个计数器。上图中的第三个 container 基数远远大于 4096，所以要用 BitmapContainer 存储。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RunContainer: RunContainer 在图中并未示出，初始的 RBM 实现中也没有它，而是在本节开头的第二篇论文中新加入的。它使用可变长度的 unsigned short 数组存储用行程长度编码（RLE）压缩后的数据。举个例子，连续的整数序列&lt;code>11, 12, 13, 14, 15, 27, 28, 29&lt;/code>会被 RLE 压缩为两个二元组&lt;code>11, 4, 27, 2&lt;/code>，表示 11 后面紧跟着 4 个连续递增的值，27 后面跟着 2 个连续递增的值。由此可见，RunContainer 的压缩效果可好可坏。考虑极端情况：如果所有数据都是连续的，那么最终只需要 4 字节；如果所有数据都不连续（比如全是奇数或全是偶数），那么不仅不会压缩，还会膨胀成原来的两倍大。所以，RBM 引入 RunContainer 是作为其他两种 container 的折衷方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>来简要看看它们的复杂度和转换方法。&lt;/p>
&lt;h2 id="时空分析">时空分析&lt;/h2>
&lt;p>增删改查的时间复杂度方面，BitmapContainer 只涉及到位运算，显然为 O(1)。而 ArrayContainer 和 RunContainer 都需要用二分查找在有序数组中定位元素，故为 O(logN)。&lt;/p>
&lt;p>空间占用（即序列化时写出的字节流长度）方面，BitmapContainer 是恒定为 8192B 的。ArrayContainer 的空间占用与基数（c）有关，为(2 + 2c)B；RunContainer 的则与它存储的连续序列数（r）有关，为(2 + 4r)B。以上节图中的 RBM 为例，它一共存储了 33868 个 unsigned int，只占用了 10396 个字节的空间，可以说是非常高效了。&lt;/p>
&lt;h4 id="container-的创建与转换">Container 的创建与转换&lt;/h4>
&lt;p>在创建一个新 container 时，如果只插入一个元素，RBM 默认会用 ArrayContainer 来存储。如果插入的是元素序列的话，则会先根据上面的方法计算 ArrayContainer 和 RunContainer 的空间占用大小，并选择较小的那一种进行存储。&lt;/p>
&lt;p>当 ArrayContainer 的容量超过 4096 后，会自动转成 BitmapContainer 存储。4096 这个阈值很聪明，低于它时 ArrayContainer 比较省空间，高于它时 BitmapContainer 比较省空间。也就是说 ArrayContainer 存储稀疏数据，BitmapContainer 存储稠密数据，可以最大限度地避免内存浪费。&lt;/p>
&lt;p>RBM 还可以通过调用特定的 API（名为 optimize）比较 ArrayContainer/BitmapContainer 与等价的 RunContainer 的内存占用情况，一旦 RunContainer 占用较小，就转换之。也就是说，上图例子中的第二个 ArrayContainer 可以转化为只有一个二元组&lt;code>0, 100&lt;/code>的 RunContainer，占用空间进一步下降到 10200 字节。&lt;/p>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;p>官方提供了 RBM 的多种语言实现，Java、C/C++、Python、Go、C#等等一应俱全。Java 版本的 GitHub repo 见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Flemire%2FRoaringBitmap">这里&lt;/a>。代码比较多，但思路很清晰，看官如果对位运算比较熟悉的话读起来不难，故本文就不再长篇大论地讲源码了。值得注意的几点如下：&lt;/p>
&lt;ul>
&lt;li>两个 RBM 做集合操作时，不同种类 container 之间位运算的处理方式，如 ArrayContainer AND BitmapContainer，BitmapContainer OR RunContainer 等；&lt;/li>
&lt;li>对 64 位整数的支持（32 位有时会不够用哈）；&lt;/li>
&lt;li>能够将 RBM 数据写到堆外，即内存映射；&lt;/li>
&lt;li>支持 Kryo 序列化方式。&lt;/li>
&lt;/ul>
&lt;p>RBM 的应用范围极广，下面只简单列举几个有代表性的应用，并给出 reference。&lt;/p>
&lt;h4 id="lucene">Lucene&lt;/h4>
&lt;p>为了加速搜索，Lucene 会将常用的查询过滤条件产生的结果集缓存到内存中，方便复用，称为 filter cache。结果集其实就是文档 ID（整形数）的集合。从 Lucene 5 开始，使用了 RBM 优化过的文档 ID 集合 RoaringDocIdSet 作为 filter cache，详情可以参见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fblog%2Fframe-of-reference-and-roaring-bitmaps">《Frame of Reference and Roaring Bitmaps》&lt;/a>。该文除了介绍 RBM 外，还介绍了压缩倒排索引的 Frame of Reference（FOR）编码，值得一读。&lt;/p>
&lt;h4 id="spark">Spark&lt;/h4>
&lt;p>在 Spark Core 的 MapStatus 组件（用来跟踪 ShuffleMapTask 的输出结果块）中，利用了 RBM 来存储块是否非空的状态。今后会在 Spark 连载里讲到它，所以现在看看&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fapache%2Fspark%2Fblob%2Fmaster%2Fcore%2Fsrc%2Fmain%2Fscala%2Forg%2Fapache%2Fspark%2Fscheduler%2FMapStatus.scala">该类的源码&lt;/a>就可以了，不难理解。&lt;/p>
&lt;h4 id="greenplum">Greenplum&lt;/h4>
&lt;p>我司是 Greenplum 大户，虽然本鶸现在不负责数仓相关的事情了，但是偶尔还是要向 GP 提供一些数据。GP 配合 RoaringBitmap 非常适合做海量用户的近实时画像，每个 RBM 代表一维标签即可，根据标签圈选用户也很方便。GP 原生并未支持 RBM 类型数据，需要安装一个扩展插件，见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fzeromax007%2Fgpdb-roaringbitmap%3Fspm%3Da2c4e.10696291.0.0.a68919a4RFqCuW">这里&lt;/a>。关于 GP 与 RBM 的整合与使用，有两篇不错的参考文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F405191">https://yq.aliyun.com/articles/405191&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://links.jianshu.com/go?to=http%3A%2F%2Fmysql.taobao.org%2Fmonthly%2F2018%2F08%2F09">http://mysql.taobao.org/monthly/2018/08/09&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="redis">Redis&lt;/h4>
&lt;p>我们在 Redis 里经常使用位图存储数据（Redis 原生以字符串的形式支持位图），当然也就会遇到稀疏位图浪费存储空间的问题。但要让 Redis 支持 RBM，需要引入专门的 module，项目地址见&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Faviggiano%2Fredis-roaring">这里&lt;/a>。它的设计思想与 Java 版 RBM 几乎相同，不再废话了。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://roaringbitmap.org/">https://roaringbitmap.org/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1402.6407.pdf">《Better bitmap performance with Roaring bitmaps》&lt;/a>与&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1603.06549.pdf">《Consistently faster and smaller compressed bitmaps with Roaring》&lt;/a>中提出，&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>树状数组(BIT)</title><link>https://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid><description>&lt;h1 id="树状数组bit">树状数组(BIT)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>树状数组&lt;/strong>或&lt;strong>二元索引树&lt;/strong>（英语：Binary Indexed Tree），又以其发明者命名为 FenwickFenwick 树。最早由 PeterM.FenwickPeterM.Fenwick 于 1994 年以 《A New Data Structure for Cumulative Frequency Tables&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84#cite_note-1">[1]&lt;/a>》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以 (logn)O(log⁡n) 的时间&lt;strong>得到任意前缀和（区间和）&lt;/strong>。&lt;/p>
&lt;h2 id="问题引入">问题引入&lt;/h2>
&lt;p>数组的单点修改&lt;code>update&lt;/code>和区间求和&lt;code>range_sum&lt;/code>问题。&lt;/p>
&lt;p>使用普通数组，&lt;code>update&lt;/code>时间复杂度为$O(1)$,&lt;code>range_sum&lt;/code>时间复杂度为$O(n)$.&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-26-2020-11-23-10-34-42-image.png" alt="">&lt;/p>
&lt;p>使用前缀和数组，&lt;code>update&lt;/code>时间复杂度为 O(n),&lt;code>range_sum&lt;/code>时间复杂度为$O(1)$.&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-52-2020-11-23-10-36-20-image.png" alt="">&lt;/p>
&lt;p>树状数组是上述方法的一个折中，&lt;code>update&lt;/code>和&lt;code>range_sum&lt;/code>时间复杂度均为$O(log_2n)$。&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>树状数组就是这样一种结构，它巧妙地利用了&lt;strong>二进制&lt;/strong>（实际上，树状数组的英文名 BIT，直译过来就是&lt;strong>二进制下标树&lt;/strong>）。例如 11，转化为二进制数就是$(1011)_2$ ，如果我们要求前 11 项和，可以分别查询 $ ((0000)_2, (1000)_2] $ , $ ( (1000)_2, (1010)_2 ] $, $ ( (1010)_2, (1101)_2 ] $ 的和再相加。这三个区间怎么来的呢？其实就是&lt;strong>不断地去掉二进制数最右边的一个 1&lt;/strong>的过程（如下图）。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-37-2020-11-23-10-53-33-image.png" alt="">&lt;/p>
&lt;p>二进制数最右边的一个 1，连带着它之后的 0 为&lt;code>lowbit(x)&lt;/code>（稍后再来看如何实现）。那么我们用$C_i$维护区间$ (A_i - lowbit(A_i), A_i] $ 的区间和，这样显然查询前 n 项和时需要合并的区间数是少于 $ log_2n $的。树状数组的结构大概像下面这样：&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-30-2020-11-23-10-56-25-image.png" alt="">&lt;/p>
&lt;p> 可用如下公式表示：&lt;/p>
&lt;p>$$
C[i] = A[i - 2^k+1] + A[i - 2^k+2] + &amp;hellip; + A[i]
$$&lt;/p>
&lt;p>其中: $k$表示 i 的二进制中从最低位到高位连续零的长度。&lt;/p>
&lt;h2 id="lowbit">lowbit&lt;/h2>
&lt;p>一个数的二进制表示中最低的一位&lt;code>1&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="优缺点">优缺点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>优点：修改和查询的复杂度都是$O(logN)$，相比线段树系数要少很多，比传统数组要快，而且容易写。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>缺点：是遇到复杂的区间问题还是不能解决，功能还是有限。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;p>一般用于解决大部分基于区间上的更新以及求和问题。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="cp">#define low(i) ((i)&amp;amp;(-i))
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">low&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//单点修改
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-=&lt;/span>&lt;span class="n">low&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">res&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//询问区间[1,pos]的权值和
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">range_query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">树状数组（BIT）—— 一篇就够了 - Last_Whisper - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/93795692">https://zhuanlan.zhihu.com/p/93795692&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>跳表(skiplist)</title><link>https://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</link><pubDate>Sat, 30 Apr 2022 11:32:24 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</guid><description>&lt;h1 id="跳表skiplist">跳表(skiplist)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>跳表&lt;/code>(SkipList)由 William Pugh 于 1990 年发明。他在 Communications of the ACM June 1990, 33(6) 668-676 上发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了跳表的数据结构和插入删除操作。&lt;/p>
&lt;p>跳表是平衡树的一种替代的数据结构，和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法，跳表的插入和删除的工作是比较简单的。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-04-2020-03-06-11-41-30-image.png" alt="">&lt;/p>
&lt;h2 id="核心思想">核心思想&lt;/h2>
&lt;ul>
&lt;li>在普通链表中增加层级指针，实现节点的快速访问。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-11-image-20190504154638969.png" alt="image-20190504154638969">&lt;/p>
&lt;h2 id="实现要点">实现要点&lt;/h2>
&lt;ol>
&lt;li>新增节点通过随机数决定指针的层级；&lt;/li>
&lt;li>通过调节因子决定随机层级，从而控制层级指针的疏密；&lt;/li>
&lt;/ol>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// member 对象
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">robj&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 分值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 后退指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">backward&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 层
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistLevel&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 前进指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">forward&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 这个层跨越的节点数量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">span&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">[];&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zskiplistNode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html">跳跃表 — Redis 设计与实现&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>k8s Volume实现原理</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s-volume/</link><pubDate>Sat, 30 Apr 2022 09:23:49 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s-volume/</guid><description>&lt;h1 id="k8s-volume实现原理">k8s Volume实现原理&lt;/h1>
&lt;p>在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消息队列等等。&lt;/p>
&lt;p>然而 Kuberentes 中的每一个容器随时都可能因为某些原因而被删除和重启，容器中的文件也会随着它的删除而丢失，所以我们需要对集群中的某些文件和数据进行『持久化』；除此之外，由于同一个 Pod 中的多个 Container 可能也会有共享文件的需求，比如通过共享文件目录的方式为 nginx 生成需要代理的静态文件，所以我们需要一种方式来解决这两个问题。&lt;/p>
&lt;p>作为 Kubernetes 集群中除了 Pod 和 Service 之外最常见的基本对象，Volume 不仅能够解决 Container 中文件的临时性问题，也能够让同一个 Pod 中的多个 Container 共享文件。&lt;/p>
&lt;blockquote>
&lt;p>这篇文章并不会介绍 Kubernetes 中 Volume 的使用方法和 API，而是会着重介绍 Volume 的工作原理，包含其创建过程、多种 Volume 实现的异同以及如何与云服务提供商进行适配。&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>Kubernetes 中的 Volume 种类非常多，它不仅要支持临时的、易失的磁盘文件，还需要解决持久存储的问题；第一个问题往往都比较容易解决，后者作为持久存储在很多时候都需要与云服务商提供的存储方案打交道，如果是 Kubernetes 中已经支持的存储类型倒是还好，遇到不支持的类型还是比较麻烦的。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-storage.png" alt="kubernetes-storage">&lt;/p>
&lt;p>除了卷和持久卷之外，Kubernetes 还有另外一种更加复杂的概念 - 动态存储供应，它能够允许存储卷按需进行创建，不再需要集群的管理员手动调用云服务商提供的接口或者界面创建新的存储卷。&lt;/p>
&lt;p>集群中的每一个卷在被 Pod 使用时都会经历四个操作，也就是附着（Attach）、挂载（Mount）、卸载（Unmount）和分离（Detach）。&lt;/p>
&lt;p>如果 Pod 中使用的是 EmptyDir、HostPath 这种类型的卷，那么这些卷并不会经历附着和分离的操作，它们只会被挂载和卸载到某一个的 Pod 中，不过如果使用的云服务商提供的存储服务，这些持久卷只有附着到某一个节点之后才可以被挂在到相应的目录下，不过在其他节点使用这些卷时，该存储资源也需要先与当前的节点分离。&lt;/p>
&lt;p>如果 pod&lt;/p>
&lt;h3 id="卷">卷&lt;/h3>
&lt;p>在这一节中提到的卷（Volume）其实是一个比较特定的概念，它并不是一个持久化存储，可能会随着 Pod 的删除而删除，常见的卷就包括 EmptyDir、HostPath、ConfigMap 和 Secret，这些卷与所属的 Pod 具有相同的生命周期，它们可以通过如下的方式挂载到 Pod 下面的某一个目录中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.gcr.io/busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/cache&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/hostpath&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">config-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/configmap&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">special-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hostpath-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/hostpath&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Directory&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">config-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">configMap&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">special-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要注意的是，当我们将 ConfigMap 或者 Secret 『包装』成卷并挂载到某个目录时，我们其实创建了一些新的 Volume，这些 Volume 并不是 Kubernetes 中的对象，它们只存在于当前 Pod 中，随着 Pod 的删除而删除，但是需要注意的是这些『临时卷』的删除并不会导致相关  &lt;code>ConfigMap&lt;/code>  或者  &lt;code>Secret&lt;/code>  对象的删除。&lt;/p>
&lt;p>从上面我们其实可以看出 Volume 没有办法脱离 Pod 而生存，它与 Pod 拥有完全相同的生命周期，而且它们也不是 Kubernetes 对象，所以 Volume 的主要作用还是用于跨节点或者容器对数据进行同步和共享。&lt;/p>
&lt;h3 id="持久卷">持久卷&lt;/h3>
&lt;p>临时的卷没有办法解决数据持久存储的问题，想要让数据能够持久化，首先就需要将 Pod 和卷的声明周期分离，这也就是引入持久卷  &lt;code>PersistentVolume(PV)&lt;/code>  的原因。我们可以将  &lt;code>PersistentVolume&lt;/code>  理解为集群中资源的一种，它与集群中的节点 Node 有些相似，PV 为 Kubernete 集群提供了一个如何提供并且使用存储的抽象，与它一起被引入的另一个对象就是  &lt;code>PersistentVolumeClaim(PVC)&lt;/code>，这两个对象之间的关系与节点和 Pod 之间的关系差不多：&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-pv-and-pvc.png" alt="kubernetes-pv-and-pvc">&lt;/p>
&lt;p>&lt;code>PersistentVolume&lt;/code>  是集群中的一种被管理员分配的存储资源，而  &lt;code>PersistentVolumeClaim&lt;/code>  表示用户对存储资源的申请，它与 Pod 非常相似，PVC 消耗了持久卷资源，而 Pod 消耗了节点上的 CPU 和内存等物理资源。&lt;/p>
&lt;p>因为 PVC 允许用户消耗抽象的存储资源，所以用户需要不同类型、属性和性能的 PV 就是一个比较常见的需求了，在这时我们可以通过  &lt;code>StorageClass&lt;/code>  来提供不同种类的 PV 资源，上层用户就可以直接使用系统管理员提供好的存储类型。&lt;/p>
&lt;h4 id="访问模式">访问模式&lt;/h4>
&lt;p>Kubernetes 中的 PV 提供三种不同的访问模式，分别是  &lt;code>ReadWriteOnce&lt;/code>、&lt;code>ReadOnlyMany&lt;/code>  和  &lt;code>ReadWriteMany&lt;/code>，这三种模式的含义和用法我们可以通过它们的名字推测出来：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ReadWriteOnce&lt;/code>  表示当前卷可以被一个节点使用读写模式挂载；&lt;/li>
&lt;li>&lt;code>ReadOnlyMany&lt;/code>  表示当前卷可以被多个节点使用只读模式挂载；&lt;/li>
&lt;li>&lt;code>ReadWriteMany&lt;/code>  表示当前卷可以被多个节点使用读写模式挂载；&lt;/li>
&lt;/ul>
&lt;p>不同的卷插件对于访问模式其实有着不同的支持，AWS 上的  &lt;code>AWSElasticBlockStore&lt;/code>  和 GCP 上的  &lt;code>GCEPersistentDisk&lt;/code>  就只支持  &lt;code>ReadWriteOnce&lt;/code>  方式的挂载，不能同时挂载到多个节点上，但是  &lt;code>CephFS&lt;/code>  就同时支持这三种访问模式。&lt;/p>
&lt;h4 id="回收策略">回收策略&lt;/h4>
&lt;p>当某个服务使用完某一个卷之后，它们会从 apiserver 中删除 PVC 对象，这时 Kubernetes 就需要对卷进行回收（Reclaim），持久卷也同样包含三种不同的回收策略，这三种回收策略会指导 Kubernetes 选择不同的方式对使用过的卷进行处理。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-pv-reclaiming-strategy.png" alt="kubernetes-pv-reclaiming-strategy">&lt;/p>
&lt;p>第一种回收策略就是保留（Retain）PV 中的数据，如果希望 PV 能够被重新使用，系统管理员需要删除被使用的  &lt;code>PersistentVolume&lt;/code>  对象并手动清除存储和相关存储上的数据。&lt;/p>
&lt;p>另一种常见的回收策略就是删除（Delete），当 PVC 被使用者删除之后，如果当前卷支持删除的回收策略，那么 PV 和相关的存储会被自动删除，如果当前 PV 上的数据确实不再需要，那么将回收策略设置成 Delete 能够节省手动处理的时间并快速释放无用的资源。&lt;/p>
&lt;h4 id="存储供应">存储供应&lt;/h4>
&lt;p>Kubernetes 集群中包含了很多的 PV 资源，而 PV 资源有两种供应的方式，一种是静态的，另一种是动态的，静态存储供应要求集群的管理员预先创建一定数量的 PV，然后使用者通过 PVC 的方式对 PV 资源的使用进行声明和申请；但是当系统管理员创建的 PV 对象不能满足使用者的需求时，就会进入动态存储供应的逻辑，供应的方式是基于集群中的  &lt;code>StorageClass&lt;/code>  对象，当然这种动态供应的方式也可以通过配置进行关闭。&lt;/p>
&lt;h2 id="管理">管理&lt;/h2>
&lt;p>Volume 的创建和管理在 Kubernetes 中主要由卷管理器  &lt;code>VolumeManager&lt;/code>  和  &lt;code>AttachDetachController&lt;/code>  和  &lt;code>PVController&lt;/code>  三个组件负责。其中卷管理器会负责卷的创建和管理的大部分工作，而  &lt;code>AttachDetachController&lt;/code>  主要负责对集群中的卷进行 Attach 和 Detach，&lt;code>PVController&lt;/code>  负责处理持久卷的变更，&lt;/p>
&lt;p>文章接下来的内容会详细介绍这几部分之间的关系、工作原理以及它们是如何协作的。&lt;/p>
&lt;h3 id="kubelet">kubelet&lt;/h3>
&lt;p>作者在  &lt;a href="https://draveness.me/kubernetes-pod">详解 Kubernetes Pod 的实现原理&lt;/a>  一文中曾简单介绍过 kubelet 和 Pod 的关系，&lt;/p>
&lt;p>前者会负责后者的创建和管理，kubelet 中与 Pod 相关的信息都是从 apiserver 中获取的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
apiserver-.-&amp;gt;u
u((updates))-.-&amp;gt;kubelet
kubelet-.-&amp;gt;podWorkers
podWorkers-.-&amp;gt;worker1
podWorkers-.-&amp;gt;worker2
style u fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>两者的通信会使用一个  &lt;code>kubetypes.PodUpdate&lt;/code>  类型的 Channel，kubelet 从 apiserver 中获取 Pod 时也会通过字段过滤器  &lt;code>fields.OneTermEqualSelector(api.PodHostField, string(nodeName))&lt;/code>  仅选择被调度到 kubelet 所在节点上的 Pod：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewSourceApiserver&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span> &lt;span class="nx">clientset&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Interface&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">nodeName&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NodeName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">updates&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">lw&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewListWatchFromClient&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CoreV1&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">RESTClient&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="s">&amp;#34;pods&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NamespaceAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fields&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">OneTermEqualSelector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">api&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodHostField&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nodeName&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="nf">newSourceApiserverFromLW&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">lw&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">updates&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所有对 Pod 的变更最终都会通知给具体的 PodWorker，这些 Worker 协程会调用 kubelet &lt;code>syncPod&lt;/code>  函数完成对 Pod 的同步：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant PW as PodWorker
participant K as Kubelet
participant VL as VolumeManager
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
PW-&amp;gt;&amp;gt;+K: syncPod
K-&amp;gt;&amp;gt;+VL: WaitForAttachAndMount
VL-xDSOWP: ReprocessPod
loop verifyVolumesMounted
VL-&amp;gt;&amp;gt;+ASOW: getUnmountedVolumes
ASOW--&amp;gt;&amp;gt;-VL: Volumes
end
VL--&amp;gt;&amp;gt;-K: Attached/Timeout
K--&amp;gt;&amp;gt;-PW: return
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在一个 100 多行的  &lt;code>syncPod&lt;/code>  方法中，kubelet 会调用  &lt;code>WaitForAttachAndMount&lt;/code>  方法，等待某一个 Pod 中的全部卷已经被成功地挂载：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">kl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Kubelet&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">o&lt;/span> &lt;span class="nx">syncPodOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">o&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">podIsTerminated&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumeManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WaitForAttachAndMount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法会将当前的 Pod 加入需要重新处理卷挂载的队列并在循环中持续调用  &lt;code>verifyVolumesMounted&lt;/code>  方法来比较期望挂载的卷和实际挂载卷的区别，这个循环会等待两者变得完全相同或者超时后才会返回，当前方法的返回一般也意味着 Pod 中的全部卷已经挂载成功了。&lt;/p>
&lt;h3 id="卷管理器">卷管理器&lt;/h3>
&lt;p>当前节点卷的管理就都是由  &lt;code>VolumeManager&lt;/code>  来负责了，在 Kubernetes 集群中的每一个节点（Node）上的 kubelet 启动时都会运行一个  &lt;code>VolumeManager&lt;/code> Goroutine，它会负责在当前节点上的 Pod 和 Volume 发生变动时对 Volume 进行挂载和卸载等操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph TD
subgraph Node
VolumeManager-.-&amp;gt;Kubelet
DesiredStateOfWorldPopulator-.-&amp;gt;VolumeManager
Reconciler-.-&amp;gt;VolumeManager
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个组件会在运行时启动两个 Goroutine 来管理节点中的卷，其中一个是  &lt;code>DesiredStateOfWorldPopulator&lt;/code>，另一个是  &lt;code>Reconciler&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
VM(VolumeManager)-. run .-&amp;gt;R(Reconciler)
VM-. run .-&amp;gt;DSWP(DesiredStateOfWorldPopulator)
DSWP-. update .-&amp;gt;DSW[DesiredStateOfWorld]
ASW[ActualStateOfWorld]-. get .-&amp;gt;DSWP
DSW-. get .-&amp;gt;R
R-. update .-&amp;gt;ASW
DSWP-. getpods .-&amp;gt;PodManager
style ASW fill:#fffede,stroke:#ebebb7
style DSW fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如上图所示，这里的  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  和  &lt;code>Reconciler&lt;/code>  两个 Goroutine 会通过图中两个的  &lt;code>XXXStateOfWorld&lt;/code>  状态进行通信，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  主要负责从 Kubernetes 节点中获取新的 Pod 对象并更新  &lt;code>DesiredStateOfWorld&lt;/code>  结构；而后者会根据实际状态和当前状态的区别对当前节点的状态进行迁移，也就是通过  &lt;code>DesiredStateOfWorld&lt;/code>  中状态的变更更新  &lt;code>ActualStateOfWorld&lt;/code>  中的内容。&lt;/p>
&lt;p>卷管理器中的两个 Goroutine，一个根据工程师的需求更新节点的期望状态  &lt;code>DesiredStateOfWorld&lt;/code>，另一个 Goroutine 保证节点向期望状态『迁移』，也就是说  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  是卷管理器中的生产者，而  &lt;code>Reconciler&lt;/code>  是消费者，接下来我们会分别介绍这两个 Goroutine 的工作和实现。&lt;/p>
&lt;h4 id="desiredstateofworldpopulator">DesiredStateOfWorldPopulator&lt;/h4>
&lt;p>作为卷管理器中的消费者，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  会根据工程师的请求不断修改当前节点的期望状态，我们可以通过以下的时序图来了解它到底做了哪些工作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant PM as PodManager
participant VPM as VolumePluginManager
loop populatorLoop
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndAddNewPods
DSOWP-&amp;gt;&amp;gt;+ASOW: GetMountedVolumes
ASOW--&amp;gt;&amp;gt;-DSOWP: mountedVolume
DSOWP-&amp;gt;&amp;gt;+PM: GetPods
PM--&amp;gt;&amp;gt;-DSOWP: pods
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+DSOW: AddPodToVolume
DSOW-&amp;gt;&amp;gt;+VPM: FindPluginBySpec
VPM--&amp;gt;&amp;gt;-DSOW: volumePlugin
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeName
end
deactivate DSOWP
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndRemoveDeletedPods
DSOWP-&amp;gt;&amp;gt;+DSOW: GetVolumesToMount
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeToMount
loop Every Volume
DSOWP-&amp;gt;&amp;gt;+PM: GetPodByUID
PM--&amp;gt;&amp;gt;-DSOWP: pods
DSOWP-&amp;gt;&amp;gt;DSOW: DeletePodFromVolume
end
deactivate DSOWP
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整个  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  运行在一个大的循环  &lt;code>populatorLoop&lt;/code>  中，当前循环会通过两个方法  &lt;code>findAndAddNewPods&lt;/code>  和  &lt;code>findAndRemoveDeletedPods&lt;/code>  分别获取节点中被添加的新 Pod 或者已经被删除的老 Pod，获取到 Pod 之后会根据当前的状态修改期望状态：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dswp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">desiredStateOfWorldPopulator&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">findAndAddNewPods&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">mountedVolumesForPod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">volumetypes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UniquePodName&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">processedVolumesForFSResize&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewString&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetPods&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">isPodTerminated&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">continue&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">processPodVolumes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountedVolumesForPod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">processedVolumesForFSResize&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就像时序图和代码中所描述的，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  会从  &lt;code>PodManager&lt;/code>  中获取当前节点中的 Pod，随后调用  &lt;code>processPodVolumes&lt;/code>  方法为将所有的 Pod 对象加入  &lt;code>DesiredStateOfWorld&lt;/code>  结构中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dswp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">desiredStateOfWorldPopulator&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">processPodVolumes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountedVolumesForPod&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">volumetypes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UniquePodName&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">processedVolumesForFSResize&lt;/span> &lt;span class="nx">sets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">uniquePodName&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">util&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetUniquePodName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">podPreviouslyProcessed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">mountsMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">devicesMap&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">makeVolumeMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podVolume&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Volumes&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pvc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeGidValue&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">createVolumeSpec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountsMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">devicesMap&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">desiredStateOfWorld&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddPodToVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podVolume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeGidValue&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">markPodProcessed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">actualStateOfWorld&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MarkRemountRequired&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>findAndAddNewPods&lt;/code>  方法做的主要就是将节点中加入的新 Pod 添加到  &lt;code>DesiredStateOfWorld&lt;/code>  中，而另一个方法  &lt;code>findAndRemoveDeletedPods&lt;/code>  其实也做着类似的事情，它会将已经被删除的节点从  &lt;code>DesiredStateOfWorld&lt;/code>  中剔除，总而言之  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  就是将当前节点的期望状态同步到  &lt;code>DesiredStateOfWorld&lt;/code>  中，等待消费者的处理。&lt;/p>
&lt;h4 id="reconciler">Reconciler&lt;/h4>
&lt;p>&lt;code>VolumeManager&lt;/code>  持有的另一个 Goroutine &lt;code>Reconciler&lt;/code>  会负责对当前节点上的 Volume 进行管理，它在正常运行时会启动  &lt;code>reconcile&lt;/code>  循环，在这个方法中会分三次对当前状态和期望状态不匹配的卷进行卸载、挂载等操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant R as Reconciler
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant OE as OperationExecutor
loop reconcile
R-&amp;gt;&amp;gt;+ASOW: GetMountedVolumes
activate R
ASOW--&amp;gt;&amp;gt;-R: MountedVolumes
R-&amp;gt;&amp;gt;DSOW: PodExistsInVolume
R-&amp;gt;&amp;gt;OE: UnmountVolume
deactivate R
R-&amp;gt;&amp;gt;+DSOW: GetVolumesToMount
activate R
DSOW--&amp;gt;&amp;gt;-R: volumeToMount
R-&amp;gt;&amp;gt;ASOW: PodExistsInVolume
R-&amp;gt;&amp;gt;OE: AttachVolume/MountVolume
deactivate R
R-&amp;gt;&amp;gt;+ASOW: GetUnmountedVolumes
activate R
R-&amp;gt;&amp;gt;DSOW: VolumeExists
R-&amp;gt;&amp;gt;OE: UnmountDevice/DetachVolume
deactivate R
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在当前的循环中首先会保证应该被卸载但是仍然在节点中存在的卷被卸载，然后将应该挂载的卷挂载到合适的位置，最后将设备与节点分离或者卸载，所有挂载和卸载的操作都是通过  &lt;code>OperationExecutor&lt;/code>  完成的，这个结构体负责调用相应的插件执行操作，我们会在文章的后面展开进行介绍。&lt;/p>
&lt;h3 id="附着分离控制器">附着分离控制器&lt;/h3>
&lt;p>除了  &lt;code>VolumeManager&lt;/code>  之外，另一个负责管理 Kubernetes 卷的组件就是  &lt;code>AttachDetachController&lt;/code>  了，引入这个组件的目的主要是：&lt;/p>
&lt;ol>
&lt;li>让卷的挂载和卸载能够与节点的可用性脱离；
&lt;ul>
&lt;li>一旦节点或者 kubelet 宕机，附着（Attach）在当前节点上的卷应该能够被分离（Detach），分离之后的卷就能够再次附着到其他节点上；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>保证云服务商秘钥的安全；
&lt;ul>
&lt;li>如果每一个 kubelet 都需要触发卷的附着和分离逻辑，那么每一个节点都应该有操作卷的权限，但是这些权限应该只由主节点掌握，这样能够降低秘钥泄露的风险；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>提高卷附着和分离部分代码的稳定性；&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>这些内容都是在 Kubernetes 官方项目的 GitHub issue &lt;a href="https://github.com/kubernetes/kubernetes/issues/20262">Detailed Design for Volume Attach/Detach Controller #20262&lt;/a>  中讨论的，想要了解  &lt;code>AttachDetachController&lt;/code>  出现的原因可以阅读相关的内容。&lt;/p>
&lt;/blockquote>
&lt;p>每一个  &lt;code>AttachDetachController&lt;/code>  其实也包含  &lt;code>Reconciler&lt;/code>  和  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  两个组件，这两个组件虽然与  &lt;code>VolumeManager&lt;/code>  中的两个组件重名，实现的功能也非常类似，与  &lt;code>VolumeManager&lt;/code>  具有几乎相同的数据流向，但是这两个 Goroutine 是跑在 Kubernetes 主节点中的，所以实现上可能一些差异：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
ADC(AttachDetachController)-. run .-&amp;gt;R(Reconciler)
ADC-. run .-&amp;gt;DSWP(DesiredStateOfWorldPopulator)
DSWP-. update .-&amp;gt;DSW[DesiredStateOfWorld]
ASW[ActualStateOfWorld]-. get .-&amp;gt;DSWP
DSW-. get .-&amp;gt;R
R-. update .-&amp;gt;ASW
DSWP-. getpods .-&amp;gt;PodManager
style ASW fill:#fffede,stroke:#ebebb7
style DSW fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，无论是  &lt;code>Reconciler&lt;/code>  还是  &lt;code>DesiredStateOfWorldPopulator&lt;/code>，它们同步的就不再只是某个节点上 Pod 的信息了，它们需要对整个集群中的 Pod 对象负责，相关数据也不再是通过 apiserver 拉取了，而是使用  &lt;code>podInformer&lt;/code>  在 Pod 对象发生变更时调用相应的方法。&lt;/p>
&lt;h4 id="desiredstateofworldpopulator-1">DesiredStateOfWorldPopulator&lt;/h4>
&lt;p>作为  &lt;code>AttachDetachController&lt;/code>  启动的 Goroutine，&lt;code>DesiredStateOfWorldPopulator&lt;/code>  的主要作用是从当前集群的状态中获取 Pod 对象并修改  &lt;code>DesiredStateOfWorld&lt;/code>  结构，与  &lt;code>VolumeManager&lt;/code>  中的同名 Goroutine 起到相同的作用，作为整个链路的生产者，它们只是在实现上由于处理 Pod 范围的不同有一些区别：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant PL as PodLister
participant VPM as VolumePluginManager
loop populatorLoopFunc
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndRemoveDeletedPods
DSOWP-&amp;gt;&amp;gt;+DSOW: GetPodToAdd
DSOW--&amp;gt;&amp;gt;-DSOWP: podsToAdd
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+PL: GetPod
alt PodNotFound
PL--&amp;gt;&amp;gt;-DSOWP: return
DSOWP-&amp;gt;&amp;gt;DSOW: DeletePod
else
end
end
deactivate DSOWP
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndAddActivePods
DSOWP-&amp;gt;&amp;gt;+PL: List
PL--&amp;gt;&amp;gt;-DSOWP: pods
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+VPM: FindAttachablePluginBySpec
VPM--&amp;gt;&amp;gt;-DSOW: attachableVolumePlugin
DSOWP-&amp;gt;&amp;gt;+DSOW: AddPod/DeletePod
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeName
end
deactivate DSOWP
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>AttachDetachController&lt;/code>  中的  &lt;code>DesiredStateOfWorldPopulator&lt;/code>  协程就主要会先处理 Pod 的删除逻辑，添加 Pod 的逻辑都是根据  &lt;code>listPodsRetryDuration&lt;/code>  的设置周期性被触发的，所以从这里我们就能看到  &lt;code>AttachDetachController&lt;/code>  其实主要还是处理被删除 Pod 中 Volume 的分离工作，当节点或者 kubelet 宕机时能够将节点中的卷进行分离，保证 Pod 在其他节点重启时不会出现问题。&lt;/p>
&lt;h4 id="reconciler-1">Reconciler&lt;/h4>
&lt;p>另一个用于调节当前状态与期望状态的 Goroutine 在执行它内部的循环时，也会优先处理分离卷的逻辑，后处理附着卷的工作，整个时序图与  &lt;code>VolumeManager&lt;/code>  中的  &lt;code>Reconciler&lt;/code>  非常相似：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant R as Reconciler
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant OE as OperationExecutor
loop reconcile
R-&amp;gt;&amp;gt;+ASOW: GetAttachedVolumes
activate R
ASOW--&amp;gt;&amp;gt;-R: attachedVolumes
R-&amp;gt;&amp;gt;+DSOW: VolumeExists
alt VolumeNotExists
DSOW--&amp;gt;&amp;gt;-R: return
R-&amp;gt;&amp;gt;OE: DetachVolume
deactivate R
else
end
R-&amp;gt;&amp;gt;+DSOW: GetVolumesToAttach
activate R
DSOW--&amp;gt;&amp;gt;-R: volumeToAttach
R-&amp;gt;&amp;gt;+ASOW: VolumeNodeExists
alt VolumeNotExists
ASOW--&amp;gt;&amp;gt;-R: return
R-&amp;gt;&amp;gt;OE: AttachVolume
else
end
deactivate R
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里处理的工作其实相对更少一些，&lt;code>Reconciler&lt;/code>  会将期望状态中的卷与实际状态进行比较，然后分离需要分离的卷、附着需要附着的卷，逻辑非常的清晰和简单。&lt;/p>
&lt;h3 id="持久卷控制器">持久卷控制器&lt;/h3>
&lt;p>作为集群中与 PV 和 PVC 打交道的控制器，持久卷控制器同时运行着三个 Goroutine 用于处理相应的逻辑，其中  &lt;code>Resync&lt;/code>  协程负责从 Kubernetes 集群中同步 PV 和 PVC 的信息，而另外两个工作协程主要负消费队列中的任务：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
PVC(PVController)-.-&amp;gt;R(Resync)
PVC-.-&amp;gt;VW(VolumeWorker)
R-. enqueue .-&amp;gt;VQ(VolumeQueue)
R-. enqueue .-&amp;gt;CQ(ClaimQueue)
VQ-. dequeue .-&amp;gt;VW
CQ-. dequeue .-&amp;gt;CW
PVC-.-&amp;gt;CW(ClaimWorker)
style VQ fill:#fffede,stroke:#ebebb7
style CQ fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这两个工作协程主要负责对需要绑定或者解绑的 PV 和 PVC 进行处理，例如，当用户创建了新的 PVC 对象时，从集群中查找该 PVC 选择的 PV 并绑定到当前的 PVC 上。&lt;/p>
&lt;h4 id="volumeworker">VolumeWorker&lt;/h4>
&lt;p>&lt;code>VolumeWorker&lt;/code>  协程中执行的最重要的方法其实就是  &lt;code>syncVolume&lt;/code>，在这个方法中会根据当前 PV 对象的规格对 PV 和 PVC 进行绑定或者解绑：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>
&lt;span class="nx">claimName&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">claimrefToClaimKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">claims&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claimName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">claim&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">claim&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">reclaimVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">claimQueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">claimToClaimKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HasAnnotation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">annDynamicallyProvisioned&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeReclaimPolicy&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeReclaimDelete&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">reclaimVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">unbindVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果当前 PV 没有绑定的 PVC 对象，那么这里的  &lt;code>reclaimVolume&lt;/code>  可能会将当前的 PV 对象根据回收策略将其放回资源池等待重用、回收或者保留；而  &lt;code>unbindVolume&lt;/code>  会删除 PV 与 PVC 之间的关系并更新 apiserver 中保存的 Kubernetes 对象数据。&lt;/p>
&lt;h4 id="claimworker">ClaimWorker&lt;/h4>
&lt;p>&lt;code>ClaimWorker&lt;/code>  就是控制器用来决定如何处理一个 PVC 对象的方法了，它会在一个 PVC 对象被创建、更新或者同步时被触发，&lt;code>syncClaim&lt;/code>  会根据当前对象中的注解决定调用  &lt;code>syncUnboundClaim&lt;/code>  或者  &lt;code>syncBoundClaim&lt;/code>  方法来处理相应的逻辑：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HasAnnotation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">annBindCompleted&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">syncUnboundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">syncBoundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>syncUnboundClaim&lt;/code>  会处理绑定没有结束的 PVC 对象，如果当前 PVC 对象没有对应合适的 PV 存在，那么就会调用  &lt;code>provisionClaim&lt;/code>  尝试从集群中获取新的 PV 供应，如果能够找到 PV 对象，就会通过  &lt;code>bind&lt;/code>  方法将两者绑定：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncUnboundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">shouldDelayBinding&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">findBestMatchForClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">v1helper&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetPersistentVolumeClaimClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">provisionClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">found&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">store&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">found&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nf">isVolumeBoundToClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>绑定的过程其实就是将 PV 和 PVC 之间建立起新的关系，更新 Spec 中的数据让两者能够通过引用 Ref 找到另一个对象并将更新后的 Kubernetes 对象存储到 apiserver 中。&lt;/p>
&lt;p>另一个用于绑定 PV 和 PVC 对象的方法就是  &lt;code>syncBoundClaim&lt;/code>  了，相比于  &lt;code>syncUnboundClaim&lt;/code>  方法，该方法的实现更为简单，直接从缓存中尝试获取对应的 PV 对象：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncBoundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">found&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">store&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">found&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果找到了 PV 对象并且该对象没有绑定的 PVC 或者当前 PV 和 PVC 已经存在了引用就会调用  &lt;code>bind&lt;/code>  方法对两者进行绑定。&lt;/p>
&lt;h4 id="小结">小结&lt;/h4>
&lt;p>无论是  &lt;code>VolumeWorker&lt;/code>  还是  &lt;code>ClaimWorker&lt;/code>  最终都可能会通过 apiserver 更新集群中 etcd 的数据，当然它们也会调用一些底层的插件获取新的存储供应、删除或者重用一些持久卷，我们会在下面介绍插件的工作原理。&lt;/p>
&lt;h2 id="插件">插件&lt;/h2>
&lt;p>Kubernetes 中的所有对卷的操作最终基本都是通过  &lt;code>OperationExecutor&lt;/code>  来完成的，这个组件包含了用于附着、挂载、卸载和分离几个常见的操作以及对设备进行操作的一些方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">OperationExecutor&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">AttachVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToAttach&lt;/span> &lt;span class="nx">VolumeToAttach&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldAttacherUpdater&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">DetachVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToDetach&lt;/span> &lt;span class="nx">AttachedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">verifySafeToDetach&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldAttacherUpdater&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">MountVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">waitForAttachTimeout&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeToMount&lt;/span> &lt;span class="nx">VolumeToMount&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldMounterUpdater&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">isRemount&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">UnmountVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToUnmount&lt;/span> &lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldMounterUpdater&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podsDir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实现  &lt;code>OperationExecutor&lt;/code>  接口的私有结构体会通过  &lt;code>OperatorGenerator&lt;/code>  来生成一个用于挂载和卸载卷的方法，并将这个方法包装在一个  &lt;code>GeneratedOperations&lt;/code>  结构中，在这之后操作执行器会启动一个新的 Goroutine 用于执行生成好的方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
OE(OperationExexutor)-. 1. 获取相关方法 .-&amp;gt;OG(OperationGenerator)
OG-. 2. 根据 Spec 获取插件 .-&amp;gt;VM(VolumePluginManager)
VM-. 3. 返回 VolumePlugin .-&amp;gt;OG
OG-. 4. 构建方法 .-&amp;gt;OG
OG-. 5. 生成一个 Operation 结构 .-&amp;gt;OE
OE-. 6. 运行 Operation .-&amp;gt;NPO(NestedPendingOperations)
NPO-. 7. 启动 Goroutine 运行生成的方法 .-&amp;gt;Goroutine
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>VolumePluginManager&lt;/code>  和  &lt;code>VolumePlugin&lt;/code>  这两个组件在整个流程中帮我们屏蔽了底层不同类型卷的实现差异，我们能直接在上层调用完全相同的接口，剩下的逻辑都由底层的插件来负责。&lt;/p>
&lt;p>Kubernetes 提供了插件的概念，通过  &lt;code>Volume&lt;/code>  和  &lt;code>Mounter&lt;/code>  两个接口支持卷类型的扩展，作为存储提供商或者不同类型的文件系统，我们都可以通过实现以上的两个接口成为 Kubernetes 存储系统中一个新的存储类型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">VolumePlugin&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">Init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">host&lt;/span> &lt;span class="nx">VolumeHost&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">GetPluginName&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nf">GetVolumeName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">NewMounter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podRef&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">opts&lt;/span> &lt;span class="nx">VolumeOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">Mounter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Mounter&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Volume&lt;/span>
&lt;span class="nf">CanMount&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">SetUp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">GetAttributes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">Attributes&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这一节中我们将介绍几种不同卷插件的实现，包括最常见的 EmptyDir、ConfigMap、Secret 和 Google 云上的 GCEPersistentDisk，这一节会简单介绍不同卷插件的实现方式，想要了解详细实现的读者可以阅读相关的源代码。&lt;/p>
&lt;h3 id="emptydir">EmptyDir&lt;/h3>
&lt;p>EmptyDir 是 Kubernetes 中最简单的卷了，当我们为一个 Pod 设置一个 EmptyDir 类型的卷时，其实就是在当前 Pod 对应的目录创建了一个空的文件夹，这个文件夹会随着 Pod 的删除而删除。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">emptyDir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">setupDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetVolumeOwnership&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volumeutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetReady&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getMetaDir&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">emptyDir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">setupDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MkdirAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">perm&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>SetUpAt&lt;/code>  方法其实就实现了对这种类型卷的创建工作，每当 Pod 被分配到了某个节点上，对应的文件目录就会通过  &lt;code>MkdirAl&lt;/code>  方法创建，如果使用者配置了 medium 字段，也会选择使用相应的文件系统挂载到当前目录上，例如：tmpfs、nodev 等。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.gcr.io/test-webserver&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/cache&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们经常会使用 EmptyDir 类型的卷在多个容器之间共享文件、充当缓存或者保留一些临时的日志，总而言之，这是一种经常被使用的卷类型。&lt;/p>
&lt;h3 id="configmap-和-secret">ConfigMap 和 Secret&lt;/h3>
&lt;p>另一种比较常见的卷就是 ConfigMap 了，首先，ConfigMap 本身就是 Kubernetes 中常见的对象了，其中的  &lt;code>data&lt;/code>  就是一个存储了从文件名到文件内容的字段，这里的 ConfigMap 对象被挂载到文件目录时就会创建一个名为  &lt;code>redis-config&lt;/code>  的文件，然后将文件内容写入该文件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ConfigMap&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">redis-config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maxmemory 2mb maxmemory-policy allkeys-lru&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在对 ConfigMap 类型的卷进行挂载时，总共需要完成三部分工作，首先从 apiserver 中获取当前 ConfigMap 对象，然后根据当前的 ConfigMap 生成一个从文件名到文件内容的键值对，最后构造一个 Writer 并执行  &lt;code>Write&lt;/code>  方法写入内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">configMapVolumeMounter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">configMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getConfigMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">totalBytes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">totalBytes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">configMap&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">payload&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">MakePayload&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">configMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultMode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writerContext&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;pod %v/%v volume %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">volumeutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewAtomicWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">writerContext&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">payload&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在涉及挂载的函数几个中，作者想要着重介绍的也就是在底层直接与文件系统打交道的  &lt;code>writePayloadToDir&lt;/code>  方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">AtomicWriter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">writePayloadToDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">payload&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">FileProjection&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">userVisiblePath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fileProjection&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">payload&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">content&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">fileProjection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Data&lt;/span>
&lt;span class="nx">mode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">FileMode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fileProjection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">fullPath&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">path&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">userVisiblePath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">baseDir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MkdirAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">baseDir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ModePerm&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">content&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Chmod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法使用了  &lt;code>os&lt;/code>  包提供的接口完成了拼接文件名、创建相应文件目录、写入文件并且修改文件模式的工作，将 ConfigMap &lt;code>data&lt;/code>  中的数据映射到了一个文件夹中，达到了让 Pod 中的容器可以直接通过文件系统获取内容的目的。&lt;/p>
&lt;p>对于另一个非常常见的卷类型 Secret，Kubernetes 其实也做了几乎完全相同的工作，也是先获取 Secret 对象，然后构建最终写入到文件的键值对，最后初始化一个 Writer 并调用它的  &lt;code>Write&lt;/code>  方法，从这里我们也能看出在卷插件这一层对于 ConfigMap 和 Secret 的处理几乎完全相同，并没有出现需要对 Secret 对象中的内容进行解密的工作。&lt;/p>
&lt;h3 id="gcepersistentdisk">GCEPersistentDisk&lt;/h3>
&lt;p>最后一个要介绍的卷与上面的几种都非常的不同，它在底层使用的是云服务商提供的网络磁盘，想要在一个节点上使用云磁盘其实总共需要两个步骤，首先是要将云磁盘附着到当前的节点上，这部分的工作其实就是由  &lt;code>gcePersistentDiskAttacher&lt;/code>  完成的，每当调用  &lt;code>AttachDisk&lt;/code>  方法时，最终都会执行云服务商提供的接口，将磁盘附着到相应的节点实例上：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant GPDA as gcePersistentDiskAttacher
participant C as Cloud
participant GCESM as gceServiceManager
participant I as GCEInstances
GPDA-&amp;gt;&amp;gt;+C: DiskIsAttached
alt NotAttached
C--&amp;gt;&amp;gt;-GPDA: return NotAttached
GPDA-&amp;gt;&amp;gt;+C: AttachDisk
C-&amp;gt;&amp;gt;+GCESM: AttachDiskOnCloudProvider
GCESM-&amp;gt;&amp;gt;+I: AttachDisk
I--&amp;gt;&amp;gt;-GCESM: return
GCESM--&amp;gt;&amp;gt;-C: return
C--&amp;gt;&amp;gt;-GPDA: return
else
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在方法的的最后会将该请求包装成一个 HTTP 的方法调用向  &lt;code>https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{resourceId}/attachDisk&lt;/code>  链接发出一个 POST 请求，这个请求会将某个 GCE 上的磁盘附着到目标实例上，详细的内容可以阅读  &lt;a href="https://cloud.google.com/compute/docs/reference/rest/v1/instances/attachDisk">相关文档&lt;/a>。&lt;/p>
&lt;p>一旦当前的磁盘被附着到了当前节点上，我们就能跟使用其他的插件一样，把磁盘挂载到某个目录上，完成从附着到挂载的全部操作。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Volume 和存储系统是 Kubernetes 非常重要的一部分，它能够帮助我们在多个容器之间共享文件，同时也能够为集群提供持久存储的功能，假如 Kubernetes 没有用于持久存储的对象，我们也很难在集群中运行有状态的服务，例如：消息队列、分布式存储等。&lt;/p>
&lt;p>对于刚刚使用 Kubernetes 的开发者来说，Volume、PV 和 PVC 确实是比较难以理解的概念，但是这却是深入使用 Kubernetes 必须要了解和掌握的，希望这篇文章能够帮助各位读者更好地理解存储系统底层的实现原理。&lt;/p>
&lt;h2 id="相关文章">相关文章&lt;/h2>
&lt;p>{% include related/distributed-system.md %}&lt;/p>
&lt;h2 id="referenece">Referenece&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/volumes/">Volumes · Kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/issues/20262">Detailed Design for Volume Attach/Detach Controller #20262&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/issues/21931">Detailed Design for Volume Mount/Unmount Redesign #21931&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/issues/18333">Kubernetes Volume System Redesign Proposal #18333&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface (CSI)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>k8s之CSI实现原理</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E4%B9%8Bcsi%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 30 Apr 2022 09:23:49 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E4%B9%8Bcsi%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="k8s之csi实现原理">k8s之CSI实现原理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Kubernetes存储系统的核心概念包括：&lt;/p>
&lt;ul>
&lt;li>StorageClass (SC)：存储类，类似存储池的概念，包括了存储池的一些信息；&lt;/li>
&lt;li>PersistenVolume (PV)：持久卷，独立的存储资源对象，其生命周期与Pod无关；&lt;/li>
&lt;li>PersistenVolumeClaim (PVC): 声明，代表计算任务对存储资源的需求。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.xsky.com/wp-content/uploads/2019/01/1-1.gif" alt="">&lt;/p>
&lt;p>这种存储结构是为了解决&lt;/p>
&lt;ul>
&lt;li>有状态的容器实例需要持久化卷；&lt;/li>
&lt;li>容器实例动态提供新卷；&lt;/li>
&lt;li>不同类型的应用需要不同访问模式的存储卷；&lt;/li>
&lt;li>解耦计算资源和存储资源。&lt;/li>
&lt;/ul>
&lt;p>但是对于接触Kubernetes不久的人而言，可能仍然存在不少疑惑，卷(Volume)，持久卷(PersistoneVolume)，存储类(StorageClass)，供给器(Provisioner)， 容器存储接口(CSI)，动态供应（Dynamic provisioning）等等到底是什么？存储提供商如何提供自定义存储服务？下面我们将一步一步深入了解。&lt;/p>
&lt;h2 id="kubernetes-存储对接如何选择">Kubernetes 存储对接如何选择&lt;/h2>
&lt;p>如果有使用过Docker经验的话，就会发现在Docker中就有Volume的概念，Volume本质上是容器上挂载的某个目录 [1]。&lt;/p>
&lt;h3 id="volume卷">Volume（卷）&lt;/h3>
&lt;p>Kubernetes同样也有Volume的概念，它属于Pod内部共享资源存储，生命周期和Pod相同，与Container无关，即使Pod上的容器停止或者重启，Volume不会受到影响，但是如果Pod终止，那么这个Volume的生命周期也将结束。&lt;/p>
&lt;h3 id="persistent-volume持久卷">Persistent Volume（持久卷）&lt;/h3>
&lt;p>Volume无法满足有状态服务的需求，持久卷(Persistent Volume)是能将数据进行持久化存储的一种资源对象。它是独立于Pod的一种资源，生命周期和Pod无关。PV的种类也包括很多，包括iSCSI，RBD，NFS，以及CSI, CephFS, OpenSDS, GlusterFS, Cinder等网络存储。&lt;/p>
&lt;p>&lt;img src="https://www.xsky.com/wp-content/uploads/2019/01/2.gif" alt="">&lt;/p>
&lt;h3 id="dynamic-provisioning动态供应">Dynamic Provisioning（动态供应）&lt;/h3>
&lt;p>iSCSI，RBD，NFS等PV分别代表了各种类型的存储资源，供集群消费，PersistentVolumeClaim（PVC）就是对这些存储资源的请求。PVC消耗的资源是PV，这很好理解，就像Pod消耗Node资源一样。于是，在Kubernetes中Pod可以不直接使用PV，而是通过PVC来使用PV。&lt;/p>
&lt;p>通过PVC可以将Pod和PV解耦，Pod不需要知道确切的文件系统和支持它的持久化引擎，可以把PVC理解为存储的抽象，把底层存储细节给隔离了。另一方面，如果使用PV作为存储的话，需要集群管理员事先创建好这些PV，但是如果使用PVC的话则不需要提前准备好PV，而是通过StorageClass把存储资源定义好，Kubernetes会在需要使用的时候动态创建，这种方式称为动态供应 (Dynamic Provisioning)。&lt;/p>
&lt;p>&lt;img src="https://www.xsky.com/wp-content/uploads/2019/01/3-1.gif" alt="">&lt;/p>
&lt;p>详细流程分析如下：&lt;/p>
&lt;p>（1）Pod加载存储卷，请求PVC&lt;/p>
&lt;p>（2）PVC根据存储类型(此处为rbd)找到存储类StorageClass&lt;/p>
&lt;p>（3）Provisioner根据StorageClass动态生成一个持久卷PV&lt;/p>
&lt;p>（4）持久卷PV和PVC最终形成绑定关系&lt;/p>
&lt;p>（5）持久卷PV开始提供给Pod使用&lt;/p>
&lt;p>简单总结下，如果在Kubernetes中运行有状态服务，比如数据库MySQL，MongoDB或者中间件Redis，RabbitMQ等，那么就需要用持久卷（PV），从而不用担心随着Pod的终止而丢失数据（相比使用了普通Volume）。 另外，从以上对比可看出，直接使用PV适合变动较少，不会频繁修改的场景，是比较直接的使用方式。&lt;/p>
&lt;h2 id="动态供应">动态供应&lt;/h2>
&lt;p>面对计算层的多种存储需求，要考虑如何高效且灵活的提供存储服务，于是就有了动态供应的策略。动态供应能按需分配资源，大大减轻了运维工作，是目前最为推荐的一种方式，在很多企业生产环境中都有它的应用。&lt;/p>
&lt;h3 id="如何实现动态供应">如何实现动态供应&lt;/h3>
&lt;p>显然动态供应比静态供应灵活更多，而且这种方式还解耦了Kubernetes系统的计算层和存储层，更重要的是它给存储供应商提供了可插拔式的开发模型，存储供应商只需要根据这个模型开发相应的卷插件即可为Kubernetes提供存储服务。&lt;/p>
&lt;p>有如下三种方法实现卷插件:&lt;/p>
&lt;ul>
&lt;li>In-tree Volume Plugin&lt;/li>
&lt;li>Out-of-tree Provisioner&lt;/li>
&lt;li>Out-of-tree CSI Driver&lt;/li>
&lt;/ul>
&lt;p>第一种，Kubernetes内部代码中实现了一些存储插件，用于支持一些主流网络存储，叫作In-tree Volume Plugin。&lt;/p>
&lt;p>第二种 Out-of-tree Provisioner：如果官方的插件不能满足要求，存储供应商可以根据需要去定制或者优化存储插件并集成到Kubernetes系统。&lt;/p>
&lt;p>第三种是容器存储接口CSI (Container Storage Interface)，是Kubernetes对外开放的存储接口，实现这个接口即可集成到Kubernetes系统中。CSI特性在刚过去的12月正式GA，同时社区也宣布未来将不再对In tree/Out of tree继续开发，并将已有功能全部迁移到CSI上，所以对于存储供应商和使用者来说，第三种CSI是更推荐的解决方案。&lt;/p>
&lt;h3 id="几种卷插件对比">几种卷插件对比&lt;/h3>
&lt;p>In-tree Volume Plugin&lt;/p>
&lt;p>&lt;img src="https://www.xsky.com/wp-content/uploads/2019/01/4.gif" alt="">&lt;/p>
&lt;p>In-tree Volume Plugin是Kubernetes自带的，属于Kubernetes的一部分，由Kubernetes一起发布和维护，所有存储插件代码都集成在Kubernetes中，第三方存储供应商难以集成。&lt;/p>
&lt;p>Out-of-tree Provisioner&lt;/p>
&lt;p>&lt;img src="https://www.xsky.com/wp-content/uploads/2019/01/5.gif" alt="">&lt;/p>
&lt;p>其中挂载组件还是复用，只是把Provisioner组件从Kubernetes中挪出来，以供实现定制化或者自定义的高级功能。&lt;/p>
&lt;p>创建流程（绿色）：状态更新，监听状态，调用外部供给器，结合后端存储服务，创建一个PV对象，这一步借助外部的Provisioner组件来完成。&lt;/p>
&lt;p>挂载流程（橙色）：监听事件，插件挂载卷等操作由原有挂载组件继续负责。&lt;/p>
&lt;p>Container Storage Interface (CSI)&lt;/p>
&lt;p>&lt;img src="https://www.xsky.com/wp-content/uploads/2019/01/6.gif" alt="">&lt;/p>
&lt;p>一直以来，存储插件的测试、维护等事宜都由Kubernetes社区来完成，即使有贡献者提供协作也不容易合并到主分支发布。另外，存储插件需要随Kubernetes一同发布，如果存储插件存在问题有可能会影响Kubernetes其他组件的正常运行。&lt;/p>
&lt;p>鉴于此，Kubernetes和CNCF决定把容器存储进行抽象，通过标准接口的形式把存储部分移到容器编排系统外部去。CSI的设计目的是定义一个行业标准，该标准将使存储供应商能够自己实现，维护和部署他们的存储插件。这些存储插件会以Sidecar Container形式运行在Kubernetes上并为容器平台提供稳定的存储服务。&lt;/p>
&lt;p>如上CSI设计图：浅绿色表示从Kubernetes社区中抽离出来且可复用的组件，负责连接XSKY CSI插件（右侧）以及和Kubernetes集群交互：&lt;/p>
&lt;ul>
&lt;li>Driver-registrar: 使用 Kubelet注册 CSI 驱动程序的 sidecar 容器，并将 NodeId （通过 GetNodeID 调用检索到 CSI endpoint）添加到 Kubernetes Node API 对象的 annotation 里面；&lt;/li>
&lt;li>External-provisioner: 监听 Kubernetes PersistentVolumeClaim 对象的 sidecar 容器，并触发对 CSI 端点的 CreateVolume 和DeleteVolume 操作；&lt;/li>
&lt;li>External-attacher: 可监听 Kubernetes VolumeAttachment 对象并触发 ControllerPublish 和 ControllerUnPublish 操作的 sidecar 容器，负责attache/detache卷到node节点上。&lt;/li>
&lt;/ul>
&lt;p>右侧橘黄色表示XSKY实现的存储插件驱动，分别有三个服务：&lt;/p>
&lt;ul>
&lt;li>CSI identify: 标志插件服务，并维持插件健康状态；&lt;/li>
&lt;li>CSI Controller: 创建/删除，attaching/detaching，快照等；&lt;/li>
&lt;li>CSI Node: attach/mount、umount/detach。&lt;/li>
&lt;/ul>
&lt;p>动态供应方式总结：通过对比Kubernetes的In-tree Volume Plugin，以及Out-of-tree Provisioner和CSI三种方式，在对接比较常见的存储时，可以使用不需要改动的In-tree方案，因为开箱即用，但是缺点也非常明显，只支持有限的存储类型，可拓展性较差甚至有版本限制，另外官方宣布以后新特性将不再添加到其中。&lt;/p>
&lt;p>相比之下，使用Out-of-tree Provisioner或者CSI则可以实现和Kubernetes的核心组件解耦，并能支持更多的存储类型和高级特性，因而也是推荐使用的一种供应方式。由于后者对编排系统而言是非侵入式插件部署，因而更受存储供应商的青睐。&lt;/p>
&lt;h2 id="基于csi的容器存储方案">基于CSI的容器存储方案&lt;/h2>
&lt;p>Kubernetes作为最流行的容器编排系统之一，用户的接受度高，XSKY也密切关注Kubernetes社区的发展。从最初的In-tree 插件支持，后来又支持Out-of-tree provisioner，到现在最新的CSI，XSKY都是同步跟进支持的。&lt;/p>
&lt;p>前面已经非常详尽的对CSI技术原理进行了剖析，XSKY基于CSI的容器存储方案，具体如下图所示：&lt;/p>
&lt;p>&lt;img src="https://www.xsky.com/wp-content/uploads/2019/01/7.gif" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>统一存储&lt;/strong>：基于CSI接口提供iSCSI和NFS两种容器存储方案，无论是块存储还是文件存储，都可以通过CSI的方式去使用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>稳定性：CSI方案将存储和计算两种资源完全解耦，实现了资源的隔离，同时CSI插件以容器化部署，因此稳定性更进一步得到保障；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>兼容性：CSI插件以容器化部署，不会受到操作系统版本和存储集群的限制，消除环境差异所带来的不确定性以及其他约束；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>易运维：不需要复杂的集群配置修改和准备工作，只需填好CSI容器配置，拉取镜像，一键可达；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无缝升级：如果之前使用的RBD，iSCSI，NFS对接，XSKY也提供完善可靠的无缝升级方案，从In-tree/Out-of-tree升级到CSI接口上；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>丰富的特性支持：不仅仅满足客户存储的基本需求，在实际使用中，XSKY提供的存储插件有很多非常重要和倍受青睐的高级特性，支持动态扩容，根据实际需求动态地扩容和缩容。除此之外，还会有Snapshots快照以及QoS管理等其他的特性，进一步完善容器生态；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>高性能：在容器的使用场景，通常会有非常多的Pod或者在Pod上会挂载较多的卷，需要消耗一定的资源，得益于后端存储的IO全路径性能优化以及资源的有效管理，我们仍然能保证非常高的性能。特别如今云原生时代，非常适合要求轻量，快速的容器云平台，一分钟内就能启动上百个pod，不但存储IO性能良好，并发创建也是经得起考验的。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>k8s基本操作</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 30 Apr 2022 09:23:49 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid><description>&lt;h1 id="k8s基本操作">k8s基本操作&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>k8s提供了kubeadm，kubectl, kubelet等二进制命令；&lt;/li>
&lt;/ul>
&lt;h2 id="kubeadm">kubeadm&lt;/h2>
&lt;ul>
&lt;li>kubeadm是k8s的部署工具；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## 在k8s master节点执行命令，初始化k8s master节点&lt;/span>
&lt;span class="o">[&lt;/span>k8s-master-node&lt;span class="o">]&lt;/span>$ kubeadm init &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --apiserver-advertise-address&lt;span class="o">=&lt;/span>192.168.32.128 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --image-repository registry.aliyuncs.com/google_containers &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --kubernetes-version v1.18.0 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --service-cidr&lt;span class="o">=&lt;/span>10.92.0.0/12 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --pod-network-cidr&lt;span class="o">=&lt;/span>10.220.0.0/16 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --ignore-preflight-errors&lt;span class="o">=&lt;/span>all
&lt;span class="c1">## 命令执行成功后，按提示，在需要加入k8s集群的node节点执行命令，&lt;/span>
&lt;span class="c1">## 将节点加入到k8s cluster中&lt;/span>
&lt;span class="o">[&lt;/span>k8s-node&lt;span class="o">]&lt;/span>$ kubeadm join 192.168.32.128:6443 --token 733dim.91wwhdfgqn8c461r &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --discovery-token-ca-cert-hash sha256:6f4f75170f512fc2fb11f13637023fbb56734b301826bf53485a9e6e75b60f42
&lt;span class="c1"># 刚加入node后会看到node状态为NotReady，是因为没有安装CNI，kubelet无法通过网络给apiserver上报node状态，安装CNI后即可恢复&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="kubectl">kubectl&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>kubectl是k8s管理控制命令行工具；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubectl通过和&lt;code>apiserver&lt;/code>通信，来对k8s集群进行管理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默认情况下，&lt;code>kubectl&lt;/code> 读取 &lt;code>$HOME/.kube/config&lt;/code> 作为配置文件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以通过两种方式为 &lt;code>kubectl&lt;/code> 指定配置文件：&lt;/p>
&lt;ul>
&lt;li>环境变量 &lt;code>KUBECONFIG&lt;/code>&lt;/li>
&lt;li>命令行参数 &lt;code>--kubeconfig&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>可以在一个或多个kubeconfig文件中配置多个集群的访问信息；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## kubectl配置&lt;/span>
&lt;span class="c1"># 使用kubeadm init初始化k8s集群后，会在/etc/kubernetes/目录生成配置文件admin.conf&lt;/span>
&lt;span class="c1"># 将admin.conf配置文件复制到~/.kube/config, 产生kubectl 集群配置文件&lt;/span>
&lt;span class="o">[&lt;/span>k8s-master-node&lt;span class="o">]&lt;/span> scp -i /etc/kubernetes/admin.conf &lt;span class="nv">$HOME&lt;/span>/.kube/config
&lt;span class="c1"># 查看kubectl配置&lt;/span>
&lt;span class="o">[&lt;/span>k8sctl-node&lt;span class="o">]&lt;/span>$ kubectl config view
&lt;span class="c1"># 获取&lt;/span>
&lt;span class="o">[&lt;/span>k8sctl-node&lt;span class="o">]&lt;/span>$ kubectl config get-contexts
&lt;span class="c1"># 切换context&lt;/span>
kubectl config use-context dev-storage
&lt;span class="c1">## 获取所有node列表&lt;/span>
&lt;span class="o">[&lt;/span>k8sctl-node&lt;span class="o">]&lt;/span>$ kubectl get nodes -o wide
&lt;span class="c1">## 查看pod信息&lt;/span>
&lt;span class="o">[&lt;/span>k8sctl-node&lt;span class="o">]&lt;/span>$ kubectl get pods --all-namespaces -o wide
&lt;span class="c1">## 检查pod详细信息&lt;/span>
&lt;span class="o">[&lt;/span>k8sctl-node&lt;span class="o">]&lt;/span>$ kubectl describe pod &amp;lt;yourPodName&amp;gt; -n kube-system
&lt;span class="c1">## 查看pod日志&lt;/span>
&lt;span class="o">[&lt;/span>k8sctl-node&lt;span class="o">]&lt;/span>$ kubectl logs &amp;lt;yourPodName&amp;gt; -n kube-system
&lt;span class="c1">## 获取admin-token&lt;/span>
kubectl -n kube-system describe secret &lt;span class="sb">`&lt;/span>kubectl -n kube-system get secret&lt;span class="p">|&lt;/span>grep admin-token&lt;span class="p">|&lt;/span>cut -d &lt;span class="s2">&amp;#34; &amp;#34;&lt;/span> -f1&lt;span class="sb">`&lt;/span>&lt;span class="p">|&lt;/span>grep &lt;span class="s2">&amp;#34;token:&amp;#34;&lt;/span>&lt;span class="p">|&lt;/span>tr -s &lt;span class="s2">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">|&lt;/span>cut -d &lt;span class="s2">&amp;#34; &amp;#34;&lt;/span> -f2
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="kubelet">kubelet&lt;/h2>
&lt;ul>
&lt;li>kubelet是k8s在每个物理机器上运行的代理进程，用于处理；&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1674040">【Kubernetes】10分钟部署一套K8S集群(kubeadm) - 云+社区 - 腾讯云&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">https://kubernetes.io/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>k8s存储原理</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 30 Apr 2022 09:23:49 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="k8s存储原理">k8s存储原理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 &lt;code>kubectl explain pod.spec.volumes&lt;/code> 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，&lt;/p>
&lt;p>在 Kubernetes 中就对应 &lt;code>In-Tree&lt;/code> 和 &lt;code>Out-Of-Tree&lt;/code> 两种方式:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>In-Tree&lt;/code> 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Out-Of-Tree&lt;/code> 是独立于 Kubernetes 的，目前主要有 &lt;code>CSI&lt;/code> 和 &lt;code>FlexVolume&lt;/code> 两种机制，开发者可以根据自己的存储类型实现不同的存储插件接入到 Kubernetes 中去，其中 &lt;code>CSI&lt;/code> 是现在也是以后主流的方式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="存储架构">存储架构&lt;/h2>
&lt;p>前面我们了解到了 PV、PVC、StorgeClass 的使用，但是他们是如何和我们的 Pod 关联起来使用的呢？这就需要从 Volume 的处理流程和原理说起了。&lt;/p>
&lt;p>如下所示，我们创建了一个 nfs 类型的 PV 资源对象：（volume.yaml）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nfs-pv&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storageClassName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manual&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">capacity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">1Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="l">ReadWriteOnce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeReclaimPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Retain&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">nfs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/k8s &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 指定nfs的挂载点&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10.151.30.11&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 指定nfs服务地址&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PersistentVolumeClaim&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nfs-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storageClassName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manual&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessModes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="l">ReadWriteOnce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">requests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">storage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">1Gi&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们知道用户真正使用的是 PVC，而要使用 PVC 的前提就是必须要先和某个符合条件的 PV 进行一一绑定，比如存储容器、访问模式，以及 PV 和 PVC 的 storageClassName 字段必须一样，这样才能够进行绑定，当 PVC 和 PV 绑定成功后就可以直接使用这个 PVC 对象了：(pod.yaml)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-volumes&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nfs&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">persistentVolumeClaim&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">claimName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nfs-pvc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nfs&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">subPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-volumes&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/usr/share/nginx/html&amp;#34;&lt;/span>&lt;span class="l">`&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>直接创建上面的资源对象即可：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ kubectl apply -f volume.yaml
$ kubectl apply -f pod.yaml`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们只是在 volumes 中指定了我们上面创建的 PVC 对象，当这个 Pod 被创建之后， kubelet 就会把这个 PVC 对应的这个 NFS 类型的 Volume（PV）挂载到这个 Pod 容器中的目录中去。前面我们也提到了这样的话对于普通用户来说完全就不用关心后面的具体存储在 NFS 还是 Ceph 或者其他了，只需要直接使用 PVC 就可以了，因为真正的存储是需要很多相关的专业知识的，这样就完全职责分离解耦了。&lt;/p>
&lt;p>普通用户直接使用 PVC 没有问题，但是也会出现一个问题，那就是当普通用户创建一个 PVC 对象的时候，这个时候系统里面并没有合适的 PV 来和它进行绑定，因为 PV 大多数情况下是管理员给我们创建的，这个时候启动 Pod 肯定就会失败了，如果现在管理员如果去创建一个对应的 PV 的话，PVC 和 PV 当然就可以绑定了，然后 Pod 也会自动的启动成功，这是因为在 Kubernetes 中有一个专门处理持久化存储的控制器 Volume Controller，这个控制器下面有很多个控制循环，其中一个就是用于 PV 和 PVC 绑定的 PersistentVolumeController。&lt;/p>
&lt;p>PersistentVolumeController 会不断地循环去查看每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与未绑定的 PVC 进行绑定，这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态。而所谓将一个 PV 与 PVC 进行&lt;code>“绑定”&lt;/code>，其实就是将这个 PV 对象的名字，填在了 PVC 对象的 &lt;code>spec.volumeName&lt;/code> 字段上。&lt;/p>
&lt;p>PV 和 PVC 绑定上了，那么又是如何将容器里面的数据进行持久化的呢，前面我们学习过 Docker 的 Volume 挂载，其实就是&lt;strong>将一个宿主机上的目录和一个容器里的目录绑定挂载在了一起&lt;/strong>，具有持久化功能当然就是指的宿主机上面的这个目录了，当容器被删除或者在其他节点上重建出来以后，这个目录里面的内容依然存在，所以一般情况下实现持久化是需要一个远程存储的，比如 NFS、Ceph 或者云厂商提供的磁盘等等。所以接下来需要做的就是持久化宿主机目录这个过程。&lt;/p>
&lt;p>当 Pod 被调度到一个节点上后，节点上的 kubelet 组件就会为这个 Pod 创建它的 Volume 目录，默认情况下 kubelet 为 Volume 创建的目录在 kubelet 工作目录下面：&lt;/p>
&lt;p>&lt;code>/var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;&lt;/code>&lt;/p>
&lt;p>比如上面我们创建的 Pod 对应的 Volume 目录完整路径为：&lt;/p>
&lt;p>&lt;code>/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;/code>&lt;/p>
&lt;p>提示&lt;/p>
&lt;p>要获取 Pod 的唯一标识 uid，可通过命令 &lt;code>kubectl get pod pod名 -o jsonpath={.metadata.uid}&lt;/code> 获取。&lt;/p>
&lt;p>然后就需要根据我们的 Volume 类型来决定需要做什么操作了，比如上节课我们用的 Ceph RBD，那么 kubelet 就需要先将 Ceph 提供的 RBD 挂载到 Pod 所在的宿主机上面，这个阶段在 Kubernetes 中被称为 Attach 阶段。Attach 阶段完成后，为了能够使用这个块设备，kubelet 还要进行第二个操作，即：格式化这个块设备，然后将它挂载到宿主机指定的挂载点上。这个挂载点，也就是上面我们提到的 Volume 的宿主机的目录。将块设备格式化并挂载到 Volume 宿主机目录的操作，在 Kubernetes 中被称为 Mount 阶段。上节课我们使用 Ceph RBD 持久化的 Wordpress 的 MySQL 数据，我们可以查看对应的 Volume 信息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ kubectl get pods -o wide -l app=wordpress
NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES
wordpress-5b886cf59b-dv2zt 1/1 Running 0 20d 10.244.1.158 ydzs-node1 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
wordpress-mysql-b9ddd6d4c-pjhbt 1/1 Running 0 20d 10.244.4.70 ydzs-node4 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以看到 MySQL 运行在 node4 节点上，然后可以在该节点上查看 Volume 信息，Pod 对应的 uid 可以通过如下命令获取：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ kubectl get pod wordpress-mysql-b9ddd6d4c-pjhbt -o jsonpath={.metadata.uid}
3f84af87-9f58-4c69-9e38-5ef234498133
$ ls /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/
mount vol_data.json
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后通过如下命令可以查看 Volume 的持久化信息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ findmnt /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount
TARGET SOURCE FSTYPE OPTIONS
/var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount /dev/rbd0 ext4 rw,relatime,`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到这里的 Volume 是挂载到 &lt;code>/dev/rbd0&lt;/code> 这个设备上面的，通过 &lt;code>df&lt;/code> 命令也是可以看到的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ df -h |grep dev
devtmpfs 3.9G 0 3.9G 0% /dev
tmpfs 3.9G 0 3.9G 0% /dev/shm
/dev/vda3 18G 4.7G 13G 27% /
/dev/vda1 497M 158M 340M 32% /boot
/dev/vdb1 197G 24G 164G 13% /data
/dev/rbd0 20G 160M 20G 1% /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里我们就经过了 &lt;code>Attach&lt;/code> 和 &lt;code>Mount&lt;/code> 两个阶段完成了 Volume 的持久化。但是对于上面我们使用的 NFS 就更加简单了， 因为 NFS 存储并没有一个设备需要挂载到宿主机上面，所以这个时候 kubelet 就会直接进入第二个 &lt;code>Mount&lt;/code> 阶段，相当于直接在宿主机上面执行如下的命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ mount -t nfs 10.151.30.11:/data/k8s /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样可以在测试的 Pod 所在节点查看 Volume 的挂载信息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ findmnt /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv
TARGET SOURCE FSTYPE OPTIONS
/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv
10.151.30.11:/data/k8s nfs4 rw,relatime,`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以看到这个 Volume 被挂载到了 NFS（10.151.30.11:/data/k8s）下面，以后我们在这个目录里写入的所有文件，都会被保存在远程 NFS 服务器上。&lt;/p>
&lt;p>这样在经过了上面的两个阶段过后，我们就得到了一个持久化的宿主机上面的 Volume 目录了，接下来 kubelet 只需要把这个 Volume 目录挂载到容器中对应的目录即可，这样就可以为 Pod 里的容器挂载这个持久化的 Volume 了，这一步其实也就相当于执行了如下所示的命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ docker run -v /var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;:/&amp;lt;容器内的目标目录&amp;gt; 我的镜像 ...`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整个存储的架构可以用下图来说明： &lt;img src="https://www.qikqiak.com/k8strain/assets/img/storage/k8s-storage-structrue.png" alt="存储架构">&lt;/p>
&lt;ul>
&lt;li>PV Controller：负责 PV/PVC 的绑定，并根据需求进行数据卷的 Provision/Delete 操作&lt;/li>
&lt;li>AD Controller：负责存储设备的 Attach/Detach 操作，将设备挂载到目标节点&lt;/li>
&lt;li>Volume Manager：管理卷的 Mount/Unmount 操作、卷设备的格式化等操作&lt;/li>
&lt;li>Volume Plugin：扩展各种存储类型的卷管理能力，实现第三方存储的各种操作能力和 Kubernetes 存储系统结合&lt;/li>
&lt;/ul>
&lt;p>我们上面使用的 NFS 就属于 In-Tree 这种方式，而上节课使用的 Ceph RBD 就是 Out-Of-Tree 的方式，而且是使用的是 CSI 插件。下面我们再来了解下 &lt;code>FlexVolume&lt;/code> 和 &lt;code>CSI&lt;/code> 两种插件方式。&lt;/p>
&lt;h2 id="flexvolumehttpswwwqikqiakcomk8strainstoragecsiflexvolume-permanent-link">FlexVolume&lt;a href="https://www.qikqiak.com/k8strain/storage/csi/#flexvolume" title="Permanent link">¶&lt;/a>&lt;/h2>
&lt;p>FlexVolume 提供了一种扩展 Kubernetes 存储插件的方式，用户可以自定义自己的存储插件。要使用 FlexVolume 需要在每个节点上安装存储插件二进制文件，该二进制需要实现 FlexVolume 的相关接口，默认存储插件的存放路径为&lt;code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/&amp;lt;vendor~driver&amp;gt;/&amp;lt;driver&amp;gt;&lt;/code>，&lt;code>VolumePlugins&lt;/code> 组件会不断 watch 这个目录来实现插件的添加、删除等功能。&lt;/p>
&lt;p>其中 &lt;code>vendor~driver&lt;/code> 的名字需要和 Pod 中&lt;code>flexVolume.driver&lt;/code> 的字段名字匹配，例如：&lt;/p>
&lt;p>&lt;code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/foo~cifs/cifs&lt;/code>&lt;/p>
&lt;p>对应的 Pod 中的 &lt;code>flexVolume.driver&lt;/code> 属性为：&lt;code>foo/cifs&lt;/code>。&lt;/p>
&lt;p>在我们实现自定义存储插件的时候，需要实现 FlexVolume 的部分接口，因为要看实际需求，并不一定所有接口都需要实现。比如对于类似于 NFS 这样的存储就没必要实现 &lt;code>attach/detach&lt;/code> 这些接口了，因为不需要，只需要实现 &lt;code>init/mount/umount&lt;/code> 3个接口即可。&lt;/p>
&lt;ul>
&lt;li>init: &lt;code>&amp;lt;driver executable&amp;gt; init&lt;/code> - kubelet/kube-controller-manager 初始化存储插件时调用，插件需要返回是否需要要 attach 和 detach 操作&lt;/li>
&lt;li>attach: &lt;code>&amp;lt;driver executable&amp;gt; attach &amp;lt;json options&amp;gt; &amp;lt;node name&amp;gt;&lt;/code> - 将存储卷挂载到 Node 节点上&lt;/li>
&lt;li>detach: &lt;code>&amp;lt;driver executable&amp;gt; detach &amp;lt;mount device&amp;gt; &amp;lt;node name&amp;gt;&lt;/code> - 将存储卷从 Node 上卸载&lt;/li>
&lt;li>waitforattach: &lt;code>&amp;lt;driver executable&amp;gt; waitforattach &amp;lt;mount device&amp;gt; &amp;lt;json options&amp;gt;&lt;/code> - 等待 attach 操作成功（超时时间为 10 分钟）&lt;/li>
&lt;li>isattached: &lt;code>&amp;lt;driver executable&amp;gt; isattached &amp;lt;json options&amp;gt; &amp;lt;node name&amp;gt;&lt;/code> - 检查存储卷是否已经挂载&lt;/li>
&lt;li>mountdevice: &lt;code>&amp;lt;driver executable&amp;gt; mountdevice &amp;lt;mount dir&amp;gt; &amp;lt;mount device&amp;gt; &amp;lt;json options&amp;gt;&lt;/code> - 将设备挂载到指定目录中以便后续 bind mount 使用&lt;/li>
&lt;li>unmountdevice: &lt;code>&amp;lt;driver executable&amp;gt; unmountdevice &amp;lt;mount device&amp;gt;&lt;/code> - 将设备取消挂载&lt;/li>
&lt;li>mount: &lt;code>&amp;lt;driver executable&amp;gt; mount &amp;lt;mount dir&amp;gt; &amp;lt;json options&amp;gt;&lt;/code> - 将存储卷挂载到指定目录中&lt;/li>
&lt;li>unmount: &lt;code>&amp;lt;driver executable&amp;gt; unmount &amp;lt;mount dir&amp;gt;&lt;/code> - 将存储卷取消挂载&lt;/li>
&lt;/ul>
&lt;p>实现上面的这些接口需要返回如下所示的 JSON 格式的数据：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;status&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;Success/Failure/Not supported&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;message&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;Reason for success/failure&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;device&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;Path to the device attached. This field is valid only for attach &amp;amp; waitforattach call-outs&amp;gt;&amp;#34;&lt;/span>
&lt;span class="s2">&amp;#34;volumeName&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;Cluster wide unique name of the volume. Valid only for getvolumename call-out&amp;gt;&amp;#34;&lt;/span>
&lt;span class="s2">&amp;#34;attached&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="err">&amp;lt;True/False&lt;/span> &lt;span class="err">(Return&lt;/span> &lt;span class="kc">true&lt;/span> &lt;span class="err">if&lt;/span> &lt;span class="err">volume&lt;/span> &lt;span class="err">is&lt;/span> &lt;span class="err">attached&lt;/span> &lt;span class="err">on&lt;/span> &lt;span class="err">the&lt;/span> &lt;span class="err">node.&lt;/span> &lt;span class="err">Valid&lt;/span> &lt;span class="err">only&lt;/span> &lt;span class="err">for&lt;/span> &lt;span class="err">isattached&lt;/span> &lt;span class="err">call-out)&amp;gt;&lt;/span>
&lt;span class="s2">&amp;#34;capabilities&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="err">&amp;lt;Only&lt;/span> &lt;span class="err">included&lt;/span> &lt;span class="err">as&lt;/span> &lt;span class="err">part&lt;/span> &lt;span class="err">of&lt;/span> &lt;span class="err">the&lt;/span> &lt;span class="err">Init&lt;/span> &lt;span class="err">response&amp;gt;&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;attach&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="err">&amp;lt;True/False&lt;/span> &lt;span class="err">(Return&lt;/span> &lt;span class="kc">true&lt;/span> &lt;span class="err">if&lt;/span> &lt;span class="err">the&lt;/span> &lt;span class="err">driver&lt;/span> &lt;span class="err">implements&lt;/span> &lt;span class="err">attach&lt;/span> &lt;span class="err">and&lt;/span> &lt;span class="err">detach)&amp;gt;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>比如我们来实现一个 NFS 的 FlexVolume 插件，最简单的方式就是写一个脚本，然后实现 init、mount、unmount 3个命令即可，然后按照上面的 JSON 格式返回数据，最后把这个脚本放在节点的 FlexVolume 插件目录下面即可。&lt;/p>
&lt;p>下面就是官方给出的一个 NFS 的 FlexVolume 插件示例，可以从 &lt;a href="https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs">examples/nfs at master · kubernetes/examples · GitHub&lt;/a> 获取脚本：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt"> 10
&lt;/span>&lt;span class="lnt"> 11
&lt;/span>&lt;span class="lnt"> 12
&lt;/span>&lt;span class="lnt"> 13
&lt;/span>&lt;span class="lnt"> 14
&lt;/span>&lt;span class="lnt"> 15
&lt;/span>&lt;span class="lnt"> 16
&lt;/span>&lt;span class="lnt"> 17
&lt;/span>&lt;span class="lnt"> 18
&lt;/span>&lt;span class="lnt"> 19
&lt;/span>&lt;span class="lnt"> 20
&lt;/span>&lt;span class="lnt"> 21
&lt;/span>&lt;span class="lnt"> 22
&lt;/span>&lt;span class="lnt"> 23
&lt;/span>&lt;span class="lnt"> 24
&lt;/span>&lt;span class="lnt"> 25
&lt;/span>&lt;span class="lnt"> 26
&lt;/span>&lt;span class="lnt"> 27
&lt;/span>&lt;span class="lnt"> 28
&lt;/span>&lt;span class="lnt"> 29
&lt;/span>&lt;span class="lnt"> 30
&lt;/span>&lt;span class="lnt"> 31
&lt;/span>&lt;span class="lnt"> 32
&lt;/span>&lt;span class="lnt"> 33
&lt;/span>&lt;span class="lnt"> 34
&lt;/span>&lt;span class="lnt"> 35
&lt;/span>&lt;span class="lnt"> 36
&lt;/span>&lt;span class="lnt"> 37
&lt;/span>&lt;span class="lnt"> 38
&lt;/span>&lt;span class="lnt"> 39
&lt;/span>&lt;span class="lnt"> 40
&lt;/span>&lt;span class="lnt"> 41
&lt;/span>&lt;span class="lnt"> 42
&lt;/span>&lt;span class="lnt"> 43
&lt;/span>&lt;span class="lnt"> 44
&lt;/span>&lt;span class="lnt"> 45
&lt;/span>&lt;span class="lnt"> 46
&lt;/span>&lt;span class="lnt"> 47
&lt;/span>&lt;span class="lnt"> 48
&lt;/span>&lt;span class="lnt"> 49
&lt;/span>&lt;span class="lnt"> 50
&lt;/span>&lt;span class="lnt"> 51
&lt;/span>&lt;span class="lnt"> 52
&lt;/span>&lt;span class="lnt"> 53
&lt;/span>&lt;span class="lnt"> 54
&lt;/span>&lt;span class="lnt"> 55
&lt;/span>&lt;span class="lnt"> 56
&lt;/span>&lt;span class="lnt"> 57
&lt;/span>&lt;span class="lnt"> 58
&lt;/span>&lt;span class="lnt"> 59
&lt;/span>&lt;span class="lnt"> 60
&lt;/span>&lt;span class="lnt"> 61
&lt;/span>&lt;span class="lnt"> 62
&lt;/span>&lt;span class="lnt"> 63
&lt;/span>&lt;span class="lnt"> 64
&lt;/span>&lt;span class="lnt"> 65
&lt;/span>&lt;span class="lnt"> 66
&lt;/span>&lt;span class="lnt"> 67
&lt;/span>&lt;span class="lnt"> 68
&lt;/span>&lt;span class="lnt"> 69
&lt;/span>&lt;span class="lnt"> 70
&lt;/span>&lt;span class="lnt"> 71
&lt;/span>&lt;span class="lnt"> 72
&lt;/span>&lt;span class="lnt"> 73
&lt;/span>&lt;span class="lnt"> 74
&lt;/span>&lt;span class="lnt"> 75
&lt;/span>&lt;span class="lnt"> 76
&lt;/span>&lt;span class="lnt"> 77
&lt;/span>&lt;span class="lnt"> 78
&lt;/span>&lt;span class="lnt"> 79
&lt;/span>&lt;span class="lnt"> 80
&lt;/span>&lt;span class="lnt"> 81
&lt;/span>&lt;span class="lnt"> 82
&lt;/span>&lt;span class="lnt"> 83
&lt;/span>&lt;span class="lnt"> 84
&lt;/span>&lt;span class="lnt"> 85
&lt;/span>&lt;span class="lnt"> 86
&lt;/span>&lt;span class="lnt"> 87
&lt;/span>&lt;span class="lnt"> 88
&lt;/span>&lt;span class="lnt"> 89
&lt;/span>&lt;span class="lnt"> 90
&lt;/span>&lt;span class="lnt"> 91
&lt;/span>&lt;span class="lnt"> 92
&lt;/span>&lt;span class="lnt"> 93
&lt;/span>&lt;span class="lnt"> 94
&lt;/span>&lt;span class="lnt"> 95
&lt;/span>&lt;span class="lnt"> 96
&lt;/span>&lt;span class="lnt"> 97
&lt;/span>&lt;span class="lnt"> 98
&lt;/span>&lt;span class="lnt"> 99
&lt;/span>&lt;span class="lnt">100
&lt;/span>&lt;span class="lnt">101
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">## 注意:&lt;/span>
&lt;span class="c1"># - 在使用插件之前需要先安装 jq。&lt;/span>
usage&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
err &lt;span class="s2">&amp;#34;Invalid usage. Usage: &amp;#34;&lt;/span>
err &lt;span class="s2">&amp;#34;\t&lt;/span>&lt;span class="nv">$0&lt;/span>&lt;span class="s2"> init&amp;#34;&lt;/span>
err &lt;span class="s2">&amp;#34;\t&lt;/span>&lt;span class="nv">$0&lt;/span>&lt;span class="s2"> mount &amp;lt;mount dir&amp;gt; &amp;lt;json params&amp;gt;&amp;#34;&lt;/span>
err &lt;span class="s2">&amp;#34;\t&lt;/span>&lt;span class="nv">$0&lt;/span>&lt;span class="s2"> unmount &amp;lt;mount dir&amp;gt;&amp;#34;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="o">}&lt;/span>
err&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nb">echo&lt;/span> -ne &lt;span class="nv">$*&lt;/span> 1&amp;gt;&lt;span class="p">&amp;amp;&lt;/span>&lt;span class="m">2&lt;/span>
&lt;span class="o">}&lt;/span>
log&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nb">echo&lt;/span> -ne &lt;span class="nv">$*&lt;/span> &amp;gt;&lt;span class="p">&amp;amp;&lt;/span>&lt;span class="m">1&lt;/span>
&lt;span class="o">}&lt;/span>
ismounted&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nv">MOUNT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>findmnt -n &lt;span class="si">${&lt;/span>&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="si">}&lt;/span> 2&amp;gt;/dev/null &lt;span class="p">|&lt;/span> cut -d&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span> -f1&lt;span class="sb">`&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MOUNT&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>
&lt;span class="k">fi&lt;/span>
&lt;span class="o">}&lt;/span>
domount&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">$1&lt;/span>
&lt;span class="nv">NFS_SERVER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$2&lt;/span> &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.server&amp;#39;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;span class="nv">SHARE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="nv">$2&lt;/span> &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.share&amp;#39;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="k">$(&lt;/span>ismounted&lt;span class="k">)&lt;/span> -eq &lt;span class="m">1&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
log &lt;span class="s1">&amp;#39;{&amp;#34;status&amp;#34;: &amp;#34;Success&amp;#34;}&amp;#39;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="k">fi&lt;/span>
mkdir -p &lt;span class="si">${&lt;/span>&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="p">&amp;amp;&lt;/span>&amp;gt; /dev/null
mount -t nfs &lt;span class="si">${&lt;/span>&lt;span class="nv">NFS_SERVER&lt;/span>&lt;span class="si">}&lt;/span>:/&lt;span class="si">${&lt;/span>&lt;span class="nv">SHARE&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="p">&amp;amp;&lt;/span>&amp;gt; /dev/null
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$?&lt;/span> -ne &lt;span class="m">0&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
err &lt;span class="s2">&amp;#34;{ \&amp;#34;status\&amp;#34;: \&amp;#34;Failure\&amp;#34;, \&amp;#34;message\&amp;#34;: \&amp;#34;Failed to mount &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">NFS_SERVER&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">:&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">SHARE&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> at &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">\&amp;#34;}&amp;#34;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="k">fi&lt;/span>
log &lt;span class="s1">&amp;#39;{&amp;#34;status&amp;#34;: &amp;#34;Success&amp;#34;}&amp;#39;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="o">}&lt;/span>
unmount&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">$1&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="k">$(&lt;/span>ismounted&lt;span class="k">)&lt;/span> -eq &lt;span class="m">0&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
log &lt;span class="s1">&amp;#39;{&amp;#34;status&amp;#34;: &amp;#34;Success&amp;#34;}&amp;#39;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="k">fi&lt;/span>
umount &lt;span class="si">${&lt;/span>&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="p">&amp;amp;&lt;/span>&amp;gt; /dev/null
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$?&lt;/span> -ne &lt;span class="m">0&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
err &lt;span class="s2">&amp;#34;{ \&amp;#34;status\&amp;#34;: \&amp;#34;Failed\&amp;#34;, \&amp;#34;message\&amp;#34;: \&amp;#34;Failed to unmount volume at &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MNTPATH&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">\&amp;#34;}&amp;#34;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="k">fi&lt;/span>
log &lt;span class="s1">&amp;#39;{&amp;#34;status&amp;#34;: &amp;#34;Success&amp;#34;}&amp;#39;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nv">op&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">$1&lt;/span>
&lt;span class="k">if&lt;/span> ! &lt;span class="nb">command&lt;/span> -v jq &amp;gt;/dev/null 2&amp;gt;&lt;span class="p">&amp;amp;&lt;/span>1&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
err &lt;span class="s2">&amp;#34;{ \&amp;#34;status\&amp;#34;: \&amp;#34;Failure\&amp;#34;, \&amp;#34;message\&amp;#34;: \&amp;#34;&amp;#39;jq&amp;#39; binary not found. Please install jq package before using this driver\&amp;#34;}&amp;#34;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="k">fi&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$op&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;init&amp;#34;&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
log &lt;span class="s1">&amp;#39;{&amp;#34;status&amp;#34;: &amp;#34;Success&amp;#34;, &amp;#34;capabilities&amp;#34;: {&amp;#34;attach&amp;#34;: false}}&amp;#39;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="k">fi&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$#&lt;/span> -lt &lt;span class="m">2&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span>
usage
&lt;span class="k">fi&lt;/span>
&lt;span class="nb">shift&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$op&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> in
mount&lt;span class="o">)&lt;/span>
domount &lt;span class="nv">$*&lt;/span>
&lt;span class="p">;;&lt;/span>
unmount&lt;span class="o">)&lt;/span>
unmount &lt;span class="nv">$*&lt;/span>
&lt;span class="p">;;&lt;/span>
*&lt;span class="o">)&lt;/span>
log &lt;span class="s1">&amp;#39;{&amp;#34;status&amp;#34;: &amp;#34;Not supported&amp;#34;}&amp;#39;&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="k">esac&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将上面脚本命名成 nfs，放置到 node1 节点对应的插件下面： &lt;code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs&lt;/code>，并设置权限为 700：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ chmod 700 /usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs
# 安装 jq 工具
$ yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
$ yum install jq -y
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个时候我们部署一个应用到 node1 节点上，并用 &lt;code>flexVolume&lt;/code> 来持久化容器中的数据（当然也可以通过定义 flexvolume 类型的 PV、PVC 来使用），如下所示：(test-flexvolume.yaml)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">apiVersion: v1
kind: Pod
metadata:
name: test-flexvolume
spec:
nodeSelector:
kubernetes.io/hostname: ydzs-node1
volumes:
- name: test
flexVolume:
driver: &amp;#34;ydzs/nfs&amp;#34; # 定义插件类型，根据这个参数在对应的目录下面找到插件的可执行文件
fsType: &amp;#34;nfs&amp;#34; # 定义存储卷文件系统类型
options: # 定义所有与存储相关的一些具体参数
server: &amp;#34;10.151.30.11&amp;#34;
share: &amp;#34;data/k8s&amp;#34;
containers:
- name: web
image: nginx
ports:
- containerPort: 80
volumeMounts:
- name: test
subPath: testflexvolume
mountPath: /usr/share/nginx/html
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中 &lt;code>flexVolume.driver&lt;/code> 就是插件目录 &lt;code>ydzs~nfs&lt;/code> 对应的 &lt;code>ydzs/nfs&lt;/code> 名称，&lt;code>flexVolume.options&lt;/code> 中根据上面的 nfs 脚本可以得知里面配置的是 NFS 的 Server 地址和挂载目录路径，直接创建上面的资源对象：&lt;/p>
&lt;p>&lt;code>$ kubectl apply -f test-flexvolume.yaml $ kubectl get pods NAME READY STATUS RESTARTS AGE test-flexvolume 1/1 Running 0 13h ...... $ kubectl exec -it test-flexvolume mount |grep test 10.151.30.11:/data/k8s/testflexvolume on /usr/share/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11) $ mount |grep test 10.151.30.11:/data/k8s on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volumes/ydzs~nfs/test type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11) 10.151.30.11:/data/k8s/testflexvolume on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volume-subpaths/test/web/0 type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)&lt;/code>&lt;/p>
&lt;p>同样我们可以查看到 Pod 的本地持久化目录是被 mount 到了 NFS 上面，证明上面我们的 FlexVolume 插件是正常的。&lt;/p>
&lt;p>调用&lt;/p>
&lt;p>当我们要去真正的 mount NFS 的时候，就是通过 kubelet 调用 VolumePlugin，然后直接执行命令&lt;code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs mount &amp;lt;mount dir&amp;gt; &amp;lt;json param&amp;gt;&lt;/code> 来完成的，就相当于平时我们在宿主机上面手动挂载 NFS 的方式一样的，所以存储插件 nfs 是一个可执行的二进制文件或者 shell 脚本都是可以的。&lt;/p>
&lt;h2 id="csihttpswwwqikqiakcomk8strainstoragecsicsi-permanent-link">CSI&lt;a href="https://www.qikqiak.com/k8strain/storage/csi/#csi" title="Permanent link">¶&lt;/a>&lt;/h2>
&lt;p>既然已经有了 FlexVolume 插件了，为什么还需要 CSI 插件呢？上面我们使用 FlexVolume 插件的时候可以看出 FlexVolume 插件实际上相当于就是一个普通的 shell 命令，类似于平时我们在 Linux 下面执行的 &lt;code>ls&lt;/code> 命令一样，只是返回的信息是 JSON 格式的数据，并不是我们通常认为的一个常驻内存的进程，而 CSI 是一个更加完善、编码更加方便友好的一种存储插件扩展方式。&lt;/p>
&lt;p>CSI 是由来自 Kubernetes、Mesos、 Cloud Foundry 等社区成员联合制定的一个行业标准接口规范，旨在将任意存储系统暴露给容器化应用程序。CSI 规范定义了存储提供商实现 CSI 兼容插件的最小操作集合和部署建议，CSI 规范的主要焦点是声明插件必须实现的接口。&lt;/p>
&lt;p>在 Kubernetes 上整合 CSI 插件的整体架构如下图所示： &lt;img src="https://www.qikqiak.com/k8strain/assets/img/storage/k8s-csi-structrue.png" alt="kubernetes csi structrue">&lt;/p>
&lt;p>Kubernetes CSI 存储体系主要由两部分组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Kubernetes 外部组件：包含 Driver registrar、External provisioner、External attacher 三部分，这三个组件是从 Kubernetes 原本的 in-tree 存储体系中剥离出来的存储管理功能，实际上是 Kubernetes 中的一种外部 controller ，它们 watch kubernetes 的 API 资源对象，根据 watch 到的状态来调用下面提到的第二部分的 CSI 插件来实现存储的管理和操作。这部分是 Kubernetes 团队维护的，插件开发者完全不必关心其实现细节。&lt;/p>
&lt;ul>
&lt;li>Driver registra：用于将插件注册到 kubelet 的 sidecar 容器，并将驱动程序自定义的 NodeId 添加到节点的 Annotations 上，通过与 CSI 上面的 Identity 服务进行通信调用 CSI 的 GetNodeId 方法来完成该操作。&lt;/li>
&lt;li>External provisioner：用于 watch Kubernetes 的 PVC 对象并调用 CSI 的 CreateVolume 和 DeleteVolume 操作。&lt;/li>
&lt;li>External attacher：用于 Attach/Detach 阶段，通过 watch Kubernetes 的 VolumeAttachment 对象并调用 CSI 的 ControllerPublish 和 ControllerUnpublish 操作来完成对应的 Volume 的 Attach/Detach。而 Volume 的 Mount/Unmount 阶段并不属于外部组件，当真正需要执行 Mount 操作的时候，kubelet 会去直接调用下面的 CSI Node 服务来完成 Volume 的 Mount/UnMount 操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CSI 存储插件: 这部分正是开发者需要实现的 CSI 插件部分，都是通过 gRPC 实现的服务，一般会用一个二进制文件对外提供服务，主要包含三部分：CSI Identity、CSI Controller、CSI Node。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CSI Identity — 主要用于负责对外暴露这个插件本身的信息，确保插件的健康状态。&lt;/p>
&lt;p>`service Identity {&lt;/p>
&lt;pre>&lt;code>// 返回插件的名称和版本
rpc GetPluginInfo(GetPluginInfoRequest)
returns (GetPluginInfoResponse) {}
// 返回这个插件的包含的功能，比如非块存储类型的 CSI 插件不需要实现 Attach 功能，GetPluginCapabilities 就可以在返回中标注这个 CSI 插件不包含 Attach 功能
rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)
returns (GetPluginCapabilitiesResponse) {}
// 插件插件是否正在运行
rpc Probe (ProbeRequest)
returns (ProbeResponse) {}
&lt;/code>&lt;/pre>
&lt;p>}`&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CSI Controller - 主要实现 Volume 管理流程当中的 Provision 和 Attach 阶段，Provision 阶段是指创建和删除 Volume 的流程，而 Attach 阶段是指把存储卷附着在某个节点或脱离某个节点的流程，另外只有块存储类型的 CSI 插件才需要 Attach 功能。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">service Controller {
// 创建存储卷，包括云端存储介质以及PV对象
rpc CreateVolume (CreateVolumeRequest)
returns (CreateVolumeResponse) {}
// 删除存储卷
rpc DeleteVolume (DeleteVolumeRequest)
returns (DeleteVolumeResponse) {}
// 挂载存储卷，将存储介质挂载到目标节点
rpc ControllerPublishVolume (ControllerPublishVolumeRequest)
returns (ControllerPublishVolumeResponse) {}
// 卸载存储卷
rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)
returns (ControllerUnpublishVolumeResponse) {}
// 例如：是否可以同时用于多个节点的读/写
rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)
returns (ValidateVolumeCapabilitiesResponse) {}
// 返回所有可用的 volumes
rpc ListVolumes (ListVolumesRequest)
returns (ListVolumesResponse) {}
// 可用存储池的总容量
rpc GetCapacity (GetCapacityRequest)
returns (GetCapacityResponse) {}
// 例如. 插件可能未实现 GetCapacity、Snapshotting
rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)
returns (ControllerGetCapabilitiesResponse) {}
// 创建快照
rpc CreateSnapshot (CreateSnapshotRequest)
returns (CreateSnapshotResponse) {}
// 删除指定的快照
rpc DeleteSnapshot (DeleteSnapshotRequest)
returns (DeleteSnapshotResponse) {}
// 获取所有的快照
rpc ListSnapshots (ListSnapshotsRequest)
returns (ListSnapshotsResponse) {}
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>CSI Node — 负责控制 Kubernetes 节点上的 Volume 操作。其中 Volume 的挂载被分成了 NodeStageVolume 和 NodePublishVolume 两个阶段。NodeStageVolume 接口主要是针对块存储类型的 CSI 插件而提供的，块设备在 &amp;ldquo;Attach&amp;rdquo; 阶段被附着在 Node 上后，需要挂载至 Pod 对应目录上，但因为块设备在 linux 上只能 mount 一次，而在 kubernetes volume 的使用场景中，一个 volume 可能被挂载进同一个 Node 上的多个 Pod 实例中，所以这里提供了 NodeStageVolume 这个接口，使用这个接口把块设备格式化后先挂载至 Node 上的一个临时全局目录，然后再调用 NodePublishVolume 使用 linux 中的 &lt;code>bind mount&lt;/code> 技术把这个全局目录挂载进 Pod 中对应的目录上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span class="kd">service&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// 在节点上初始化存储卷（格式化），并执行挂载到Global目录
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodeStageVolume&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeStageVolumeRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeStageVolumeResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// umount 存储卷在节点上的 Global 目录
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodeUnstageVolume&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeUnstageVolumeRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeUnstageVolumeResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// 在节点上将存储卷的 Global 目录挂载到 Pod 的实际挂载目录
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodePublishVolume&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodePublishVolumeRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodePublishVolumeResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// unmount 存储卷在节点上的 Pod 挂载目录
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodeUnpublishVolume&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeUnpublishVolumeRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeUnpublishVolumeResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// 获取节点上Volume挂载文件系统统计信息（总空间、可用空间等）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodeGetVolumeStats&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetVolumeStatsRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetVolumeStatsResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// 获取节点的唯一 ID
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodeGetId&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetIdRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetIdResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">option&lt;/span> &lt;span class="n">deprecated&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// 返回节点插件的能力
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodeGetCapabilities&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetCapabilitiesRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetCapabilitiesResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="c1">// 获取节点的一些信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">rpc&lt;/span> &lt;span class="n">NodeGetInfo&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetInfoRequest&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">returns&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NodeGetInfoResponse&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>只需要实现上面的接口就可以实现一个 CSI 插件了。虽然 Kubernetes 并未规定 CSI 插件的打包安装，但是提供了以下建议来简化我们在 Kubernetes 上容器化 CSI Volume 驱动程序的部署方案，具体的方案介绍可以查看 CSI 规范介绍文档 &lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">https://github.com/kubernetes/community&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://www.qikqiak.com/k8strain/assets/img/storage/container-storage-interface_diagram1.png" alt="container storage interface deploy">&lt;/p>
&lt;p>按照上图的推荐方案，CSI Controller 部分以 StatefulSet 或者 Deployment 方式部署，CSI Node 部分以 DaemonSet 方式部署。因为这两部分实现在同一个 CSI 插件程序中，因此只需要把这个 CSI 插件与 External Components 以容器方式部署在同一个 Pod中，把这个 CSI 插件与 Driver registrar 以容器方式部署在 DaemonSet 的 Pod 中，即可完成 CSI 的部署。&lt;/p>
&lt;p>前面我们使用的 Rook 部署的 Ceph 集群就是实现了 CSI 插件的:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">$ kubectl get pods -n rook-ceph |grep plugin
csi-cephfsplugin-2s9d5 3/3 Running 0 21d
csi-cephfsplugin-fgp4v 3/3 Running 0 17d
csi-cephfsplugin-fv5nx 3/3 Running 0 21d
csi-cephfsplugin-mn8q4 3/3 Running 0 17d
csi-cephfsplugin-nf6h8 3/3 Running 0 21d
csi-cephfsplugin-provisioner-56c8b7ddf4-68h6d 4/4 Running 0 21d
csi-cephfsplugin-provisioner-56c8b7ddf4-rq4t6 4/4 Running 0 21d
csi-cephfsplugin-xwnl4 3/3 Running 0 21d
csi-rbdplugin-7r88w 3/3 Running 0 21d
csi-rbdplugin-95g5j 3/3 Running 0 21d
csi-rbdplugin-bnzpr 3/3 Running 0 21d
csi-rbdplugin-dvftb 3/3 Running 0 21d
csi-rbdplugin-jzmj2 3/3 Running 0 17d
csi-rbdplugin-provisioner-6ff4dd4b94-bvtss 5/5 Running 0 21d
csi-rbdplugin-provisioner-6ff4dd4b94-lfn68 5/5 Running 0 21d
csi-rbdplugin-trxb4 3/3 Running 0 17d`
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里其实是实现了 RBD 和 CephFS 两种 CSI，用 DaemonSet 在每个节点上运行了一个包含 &lt;code>Driver registra&lt;/code> 容器的 Pod，当然和节点相关的操作比如 Mount/Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 &lt;code>csi-rbdplugin-provisioner-xxx&lt;/code> Pod 中执行的。&lt;/p></description></item><item><title>k8s存储架构</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84/</link><pubDate>Sat, 30 Apr 2022 09:23:49 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84/</guid><description>&lt;h1 id="k8s存储架构">k8s存储架构&lt;/h1>
&lt;h2 id="在-kubernetes-中挂载一个-volume">在 Kubernetes 中挂载一个 Volume&lt;/h2>
&lt;p>如下图所示，左边的 YAML 模板定义了一个 StatefulSet 的一个应用，其中定义了一个名为 disk-pvc 的 volume，挂载到 Pod 内部的目录是 /data。disk-pvc 是一个 PVC 类型的数据卷，其中定义了一个 storageClassName。&lt;/p>
&lt;p>因此这个模板是一个典型的动态存储的模板。右图是数据卷挂载的过程，主要分为 6 步：&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/827b01acd90341d096b462f5d2dc07b0.png" alt="1.png" title="1.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一步&lt;/strong>：用户创建一个包含 PVC的 Pod；&lt;/li>
&lt;li>&lt;strong>第二步&lt;/strong>：PV Controller 会不断观察 ApiServer，如果它发现一个 PVC 已经创建完毕但仍然是未绑定的状态，它就会试图把一个 PV 和 PVC 绑定；&lt;/li>
&lt;/ul>
&lt;p>PV Controller 首先会在集群内部找到一个适合的 PV 进行绑定，如果未找到相应的 PV，就调用 Volume Plugin 去做 Provision。Provision 就是从远端上一个具体的存储介质创建一个 Volume，并且在集群中创建一个 PV 对象，然后将此 PV 和 PVC 进行绑定；&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第三步&lt;/strong>：通过 Scheduler 完成一个调度功能；&lt;/li>
&lt;/ul>
&lt;p>我们知道，当一个 Pod 运行的时候，需要选择一个 Node，这个节点的选择就是由 Scheduler 来完成的。Scheduler 进行调度的时候会有多个参考量，比如 Pod 内部所定义的 nodeSelector、nodeAffinity 这些定义以及 Volume 中所定义的一些标签等。&lt;/p>
&lt;p>我们可以在数据卷中添加一些标签，这样使用这个 pv 的 Pod 就会由于标签的限制，被调度器调度到期望的节点上。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第四步&lt;/strong>：如果有一个 Pod 调度到某个节点之后，它所定义的 PV 还没有被挂载（Attach），此时 AD Controller 就会调用 VolumePlugin，把远端的 Volume 挂载到目标节点中的设备上（如：/dev/vdb）；&lt;/li>
&lt;li>&lt;strong>第五步&lt;/strong>:当 Volum Manager 发现一个 Pod 调度到自己的节点上并且 Volume 已经完成了挂载，它就会执行 mount 操作，将本地设备（也就是刚才得到的 /dev/vdb）挂载到 Pod 在节点上的一个子目录中。同时它也可能会做一些像格式化、是否挂载到 GlobalPath 等这样的附加操作。&lt;/li>
&lt;li>&lt;strong>第六步&lt;/strong>：绑定操作，就是将已经挂载到本地的 Volume 映射到容器中。&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes-的存储架构">Kubernetes 的存储架构&lt;/h2>
&lt;p>接下来，我们一起看一下 Kubernetes 的存储架构。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/be84773ac4f242e29167a124ac55566f.png" alt="2.png" title="2.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>PV Controller&lt;/strong>: 负责 PV/PVC 的绑定、生命周期管理，并根据需求进行数据卷的 Provision/Delete 操作；&lt;/li>
&lt;li>&lt;strong>AD Controller&lt;/strong>：负责存储设备的 Attach/Detach 操作，将设备挂载到目标节点；&lt;/li>
&lt;li>&lt;strong>Volume Manager&lt;/strong>：管理卷的 Mount/Unmount 操作、卷设备的格式化以及挂载到一些公用目录上的操作；&lt;/li>
&lt;li>&lt;strong>Volume Plugins&lt;/strong>：它主要是对上面所有挂载功能的实现；&lt;/li>
&lt;/ul>
&lt;p>PV Controller、AD Controller、Volume Manager 主要是进行操作的调用，而具体操作则是由 Volume Plugins 实现的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Scheduler&lt;/strong>：实现对 Pod 的调度能力，会根据一些存储相关的的定义去做一些存储相关的调度；&lt;/li>
&lt;/ul>
&lt;p>接下来，我们分别介绍上面这几部分的功能。&lt;/p>
&lt;h3 id="pv-controller">PV Controller&lt;/h3>
&lt;p>首先我们先来回顾一下几个基本概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Persistent Volume (PV)&lt;/strong>： 持久化存储卷，详细定义了预挂载存储空间的各项参数；&lt;/li>
&lt;/ul>
&lt;p>例如，我们去挂载一个远端的 NAS 的时候，这个 NAS 的具体参数就要定义在 PV 中。PV 是没有 NameSpace 限制的，它一般由 Admin 来创建与维护；&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Persistent Volume Claim (PVC)&lt;/strong>：持久化存储卷声明；&lt;/li>
&lt;/ul>
&lt;p>它是用户所使用的存储接口，对存储细节无感知，主要是定义一些基本存储的 Size、AccessMode 参数在里面，并且它是属于某个 NameSpace 内部的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>StorageClass&lt;/strong>：存储类；&lt;/li>
&lt;/ul>
&lt;p>一个动态存储卷会按照 StorageClass 所定义的模板来创建一个 PV，其中定义了创建模板所需要的一些参数和创建 PV 的一个 Provisioner（就是由谁去创建的）。&lt;/p>
&lt;p>PV Controller 的主要任务就是完成 PV、PVC 的生命周期管理，比如创建、删除 PV 对象，负责 PV、PVC 的状态迁移；另一个任务就是绑定 PVC 与 PV 对象，一个 PVC 必须和一个 PV 绑定后才能被应用使用，它们是一一绑定的，一个 PV 只能被一个 PVC 绑定，反之亦然。&lt;/p>
&lt;p>接下来，我们看一下一个 PV 的状态迁移图。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/ce66a434ad924dac812fd5ee45115ebc.png" alt="3.png" title="3.png">&lt;/p>
&lt;p>创建好一个 PV 以后，我们就处于一个 Available 的状态，当一个 PVC 和一个 PV 绑定的时候，这个 PV 就进入了 Bound 的状态，此时如果我们把 PVC 删掉，Bound 状态的 PV 就会进入 Released 的状态。&lt;/p>
&lt;p>一个 Released 状态的 PV 会根据自己定义的 ReclaimPolicy 字段来决定自己是进入一个 Available 的状态还是进入一个 Deleted 的状态。如果 ReclaimPolicy 定义的是 “recycle” 类型，它会进入一个 Available 状态，如果转变失败，就会进入 Failed 的状态。&lt;/p>
&lt;p>相对而言，PVC 的状态迁移图就比较简单。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/4f29e87ce9294113b38880bbd68daf0e.png" alt="4.png" title="4.png">&lt;/p>
&lt;p>一个创建好的 PVC 会处于 Pending 状态，当一个 PVC 与 PV 绑定之后，PVC 就会进入 Bound 的状态，当一个 Bound 状态的 PVC 的 PV 被删掉之后，该 PVC 就会进入一个 Lost 的状态。对于一个 Lost 状态的 PVC，它的 PV 如果又被重新创建，并且重新与该 PVC 绑定之后，该 PVC 就会重新回到 Bound 状态。&lt;/p>
&lt;p>下图是一个 PVC 去绑定 PV 时对 PV 筛选的一个流程图。就是说一个 PVC 去绑定一个 PV 的时候，应该选择一个什么样的 PV 进行绑定。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/efaa7acc32fd4a2b80051bd4155b660a.png" alt="5.png" title="5.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>首先&lt;/strong>它会检查 VolumeMode 这个标签，PV 与 PVC 的 VolumeMode 标签必须相匹配。VolumeMode 主要定义的是我们这个数据卷是文件系统 (FileSystem) 类型还是一个块 (Block) 类型；&lt;/li>
&lt;li>&lt;strong>第二个部分&lt;/strong>是 LabelSelector。当 PVC 中定义了 LabelSelector 之后，我们就会选择那些有 Label 并且与 PVC 的 LabelSelector 相匹配的 PV 进行绑定；&lt;/li>
&lt;li>&lt;strong>第三个部分&lt;/strong>是 StorageClassName 的检查。如果 PVC 中定义了一个 StorageClassName，则必须有此相同类名的 PV 才可以被筛选中。&lt;/li>
&lt;/ul>
&lt;p>这里再具体解释一下 StorageClassName 这个标签，该标签的目的就是说，当一个 PVC 找不到相应的 PV 时，我们就会用该标签所指定的 StorageClass 去做一个动态创建 PV 的操作，同时它也是一个绑定条件，当存在一个满足该条件的 PV 时，就会直接使用现有的 PV，而不再去动态创建。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第四个部分&lt;/strong>是 AccessMode 检查。&lt;/li>
&lt;/ul>
&lt;p>AccessMode 就是平时我们在 PVC 中定义的如 “ReadWriteOnce”、”RearWriteMany” 这样的标签。该绑定条件就是要求 PVC 和 PV 必须有匹配的 AccessMode，即 PVC 所需求的 AccessMode 类型，PV 必须具有。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>最后&lt;/strong>一个部分是 Size 的检查。&lt;/li>
&lt;/ul>
&lt;p>一个 PVC 的 Size 必须小于等于 PV 的 Size，这是因为 PVC 是一个声明的 Volume，实际的 Volume 必须要大于等于声明的 Volume，才能进行绑定。&lt;/p>
&lt;p>接下来，我们看一个 PV Controller 的一个实现。&lt;/p>
&lt;p>PV Controller 中主要有两个实现逻辑：一个是 ClaimWorker；一个是 VolumeWorker。&lt;/p>
&lt;p>ClaimWorker 实现的是 PVC 的状态迁移。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/4b2b674d11794036988d1b512c153231.png" alt="6.png" title="6.png">&lt;/p>
&lt;p>通过系统标签 “pv.kubernetes.io/bind-completed” 来标识一个 PVC 的状态。&lt;/p>
&lt;ul>
&lt;li>如果该标签为 True，说明我们的 PVC 已经绑定完成，此时我们只需要去同步一些内部的状态；&lt;/li>
&lt;li>如果该标签为 False，就说明我们的 PVC 处于未绑定状态。&lt;/li>
&lt;/ul>
&lt;p>这个时候就需要检查整个集群中的 PV 去进行筛选。通过 findBestMatch 就可以去筛选所有的 PV，也就是按照之前提到的五个绑定条件来进行筛选。如果筛选到 PV，就执行一个 Bound 操作，否则就去做一个 Provision 的操作，自己去创建一个 PV。&lt;/p>
&lt;p>再看 VolumeWorker 的操作。它实现的则是 PV 的状态迁移。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/8b609ce7bf194f6889c8aa04d91d371e.png" alt="7.png" title="7.png">&lt;/p>
&lt;p>通过 PV 中的 ClaimRef 标签来进行判断，如果该标签为空，就说明该 PV 是一个 Available 的状态，此时只需要做一个同步就可以了；如果该标签非空，这个值是 PVC 的一个值，我们就会去集群中查找对应的 PVC。如果存在该 PVC，就说明该 PV 处于一个 Bound 的状态，此时会做一些相应的状态同步；如果找不到该 PVC，就说明该 PV 处于一个绑定过的状态，相应的 PVC 已经被删掉了，这时 PV 就处于一个 Released 的状态。此时再根据 ReclaimPolicy 是否是 Delete 来决定是删掉还是只做一些状态的同步。&lt;/p>
&lt;p>以上就是 PV Controller 的简要实现逻辑。&lt;/p>
&lt;h3 id="ad-controller">AD Controller&lt;/h3>
&lt;p>AD Controller 是 Attach/Detach Controller 的一个简称。&lt;/p>
&lt;p>它有两个核心对象，即 DesiredStateofWorld 和 ActualStateOfWorld。&lt;/p>
&lt;ul>
&lt;li>DesiredStateofWorld: 集群中预期要达到的数据卷的挂载状态；&lt;/li>
&lt;li>ActualStateOfWorld: 集群内部实际存在的数据卷挂载状态。&lt;/li>
&lt;/ul>
&lt;p>它有两个核心逻辑，desiredStateOfWorldPopulator 和 Reconcile。&lt;/p>
&lt;ul>
&lt;li>desiredStateOfWorldPopulator 主要是用来同步集群的一些数据以及 DSW、ASW 数据的更新，它会把集群里面，比如说我们创建一个新的 PVC、创建一个新的 Pod 的时候，我们会把这些数据的状态同步到 DSW 中；&lt;/li>
&lt;li>Reconcile 则会根据 DSW 和 ASW 对象的状态做状态同步。它会把 ASW 状态变成 DSW 状态，在这个状态的转变过程中，它会去执行 Attach、Detach 等操作。&lt;/li>
&lt;/ul>
&lt;p>下面这个表分别给出了 desiredStateOfWorld 以及 actualStateOfWorld 对象的一个具体例子。&lt;/p>
&lt;ul>
&lt;li>desiredStateOfWorld 会对每一个 Worker 进行定义，包括 Worker 所包含的 Volume 以及一些试图挂载的信息；&lt;/li>
&lt;li>actualStateOfWorld 会把所有的 Volume 进行一次定义，包括每一个 Volume 期望挂载到哪个节点上、挂载的状态是什么样子的等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/f2d8148efa0d40f899b9ec9b15fb7b5e.png" alt="8.png" title="8.png">&lt;/p>
&lt;p>下图是 AD Controller 实现的逻辑框图。&lt;/p>
&lt;p>从中我们可以看到，AD Controller 中有很多 Informer，Informer 会把集群中的 Pod 状态、PV 状态、Node 状态、PVC 状态同步到本地。&lt;/p>
&lt;p>在初始化的时候会调用 populateDesireStateofWorld 以及 populateActualStateofWorld 将 desireStateofWorld、actualStateofWorld 两个对象进行初始化。&lt;/p>
&lt;p>在执行的时候，通过 desiredStateOfWorldPopulator 进行数据同步，即把集群中的数据状态同步到 desireStateofWorld 中。reconciler 则通过轮询的方式把 actualStateofWorld 和 desireStateofWorld 这两个对象进行数据同步，在同步的时候，会通过调用 Volume Plugin 进行 attach 和 detach 操作，同时它也会调用 nodeStatusUpdater 对 Node 的状态进行更新。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/70759996a961448f8d6455a090c5d2ae.png" alt="9.png" title="9.png">&lt;/p>
&lt;p>以上就是 AD Controller 的简要实现逻辑。&lt;/p>
&lt;h3 id="volume-manager">Volume Manager&lt;/h3>
&lt;p>Volume Manager 实际上是 Kubelet 中一部分，是 Kubelet 中众多 Manager 的一个。它主要是用来做本节点 Volume 的 Attach/Detach/Mount/Unmount 操作。&lt;/p>
&lt;p>它和 AD Controller 一样包含有 desireStateofWorld 以及 actualStateofWorld，同时还有一个 volumePluginManager 对象，主要进行节点上插件的管理。在核心逻辑上和 AD Controller 也类似，通过 desiredStateOfWorldPopulator 进行数据的同步以及通过 Reconciler 进行接口的调用。&lt;/p>
&lt;p>这里我们需要讲一下 Attach/Detach 这两个操作：&lt;/p>
&lt;p>之前我们提到 AD Controller 也会做 Attach/Detach 操作，所以到底是由谁来做呢？我们可以通过 “–enable-controller-attach-detach” 标签进行定义，如果它为 True，则由 AD Controller 来控制；若为 False，就由 Volume Manager 来做。&lt;/p>
&lt;p>它是 Kubelet 的一个标签，只能定义某个节点的行为，所以如果假设一个有 10 个节点的集群，它有 5 个节点定义该标签为 False，说明这 5 个节点是由节点上的 Kubelet 来做挂载，而其它 5 个节点是由 AD Controller 来做挂载。&lt;/p>
&lt;p>下图是 Volume Manager 实现逻辑图。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/37008bb3525c47dbbecca528e5710746.png" alt="10.png" title="10.png">&lt;/p>
&lt;p>我们可以看到，最外层是一个循环，内部则是根据不同的对象，包括 desireStateofWorld， actualStateofWorld 的不同对象做一个轮询。&lt;/p>
&lt;p>例如，对 actualStateofWorld 中的 MountedVolumes 对象做轮询，对其中的某一个 Volume，如果它同时存在于 desireStateofWorld，这就说明实际的和期望的 Volume 均是处于挂载状态，因此我们不会做任何处理。如果它不存在于 desireStateofWorld，说明期望状态中该 Volume 应该处于 Umounted 状态，就执行 UnmountVolume，将其状态转变为 desireStateofWorld 中相同的状态。&lt;/p>
&lt;p>所以我们可以看到：实际上，该过程就是根据 desireStateofWorld 和 actualStateofWorld 的对比，再调用底层的接口来执行相应的操作，下面的 desireStateofWorld.UnmountVolumes 和 actualStateofWorld.AttachedVolumes 的操作也是同样的道理。&lt;/p>
&lt;h3 id="volume-plugins">Volume Plugins&lt;/h3>
&lt;p>我们之前提到的 PV Controller、AD Controller 以及 Volume Manager 其实都是通过调用 Volume Plugin 提供的接口，比如 Provision、Delete、Attach、Detach 等去做一些 PV、PVC 的管理。而这些接口的具体实现逻辑是放在 VolumePlugin 中的&lt;/p>
&lt;p>根据源码的位置可将 Volume Plugins 分为 In-Tree 和 Out-of-Tree 两类：&lt;/p>
&lt;ul>
&lt;li>In-Tree 表示源码是放在 Kubernetes 内部的，和 Kubernetes 一起发布、管理与迭代，缺点及时迭代速度慢、灵活性差；&lt;/li>
&lt;li>Out-of-Tree 类的 Volume Plugins 的代码独立于 Kubernetes，它是由存储商提供实现的，目前主要有 Flexvolume 和 CSI 两种实现机制，可以根据存储类型实现不同的存储插件。所以我们比较推崇 Out-of-Tree 这种实现逻辑。&lt;/li>
&lt;/ul>
&lt;p>从位置上我们可以看到，Volume Plugins 实际上就是 PV Controller、AD Controller 以及 Volume Manager 所调用的一个库，分为 In-Tree 和 Out-of-Tree 两类 Plugins。它通过这些实现来调用远端的存储，比如说挂载一个 NAS 的操作 “mount -t nfs ***“，该命令其实就是在 Volume Plugins 中实现的，它会去调用远程的一个存储挂载到本地。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/7da549b58fe44840bfcfd30d72cb2c35.png" alt="11.png" title="11.png">&lt;/p>
&lt;p>从类型上来看，Volume Plugins 可以分为很多种。In-Tree 中就包含了 几十种常见的存储实现，但一些公司的自己定义私有类型，有自己的 API 和参数，公共存储插件是无法支持的，这时就需要 Out-of-Tree 类的存储实现，比如 CSI、FlexVolume。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/70db6852adc843098c657c5b7c882de3.png" alt="12.png" title="12.png">&lt;/p>
&lt;p>Volume Plugins 的具体实现会放到后面去讲。这里主要看一下 Volume Plugins 的插件管理。&lt;/p>
&lt;p>Kubernetes会在 PV Controller、AD Controller 以及 Volume Manager 中来做插件管理。通过 VolumePlguinMg 对象进行管理。主要包含 Plugins 和 Prober 两个数据结构。&lt;/p>
&lt;p>Plugins 主要是用来保存 Plugins 列表的一个对象，而 Prober 是一个探针，用于发现新的 Plugin，比如 FlexVolume、CSI 是扩展的一种插件，它们是动态创建和生成的，所以一开始我们是无法预知的，因此需要一个探针来发现新的 Plugin。&lt;/p>
&lt;p>下图是插件管理的整个过程。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/3e5213685724478683738ec2a728613b.png" alt="13.png" title="13.png">&lt;/p>
&lt;p>PV Controller、AD Controller 以及 Volume Manager 在启动的时候会执行一个 InitPlugins 方法来对 VolumePluginsMgr 做一些初始化。&lt;/p>
&lt;p>它首先会将所有 In-Tree 的 Plugins 加入到我们的插件列表中。同时会调用 Prober 的 init 方法，该方法会首先调用一个 InitWatcher，它会时刻观察着某一个目录 (比如图中的 /usr/libexec/kubernetes/kubelet-plugins/volume/exec/)，当这个目录每生成一个新文件的时候，也就是创建了一个新的 Plugins，此时就会生成一个新的 FsNotify.Create 事件，并将其加入到 EventsMap 中；同理，如果删除了一个文件，就生成一个 FsNotify.Remove 事件加入到 EventsMap 中。&lt;/p>
&lt;p>当上层调用 refreshProbedPlugins 时，Prober 就会把这些事件进行一个更新，如果是 Create，就将其添加到插件列表；如果是 Remove，就从插件列表中删除一个插件。&lt;/p>
&lt;p>以上就是 Volume Plugins 的插件管理机制。&lt;/p>
&lt;h3 id="kubernetes-存储卷调度">Kubernetes 存储卷调度&lt;/h3>
&lt;p>我们之前说到 Pod 必须被调度到某个 Worker 上才能去运行。在调度 Pod 时，我们会使用不同的调度器来进行筛选，其中有一些与 Volume 相关的调度器。例如 VolumeZonePredicate、VolumeBindingPredicate、CSIMaxVolumLimitPredicate 等。&lt;/p>
&lt;p>VolumeZonePredicate 会检查 PV 中的 Label，比如 failure-domain.beta.kubernetes.io/zone 标签，如果该标签定义了 zone 的信息，VolumeZonePredicate 就会做相应的判断，即必须符合相应的 zone 的节点才能被调度。&lt;/p>
&lt;p>比如下图左侧的例子，定义了一个 label 的 zone 为 cn-shenzhen-a。右侧的 PV 则定义了一个 nodeAffinity，其中定义了 PV 所期望的节点的 Label，该 Label 是通过 VolumeBindingPredicate 进行筛选的。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/608586e635c34ae59008fce9332fc34e.png" alt="14.png" title="14.png">&lt;/p>
&lt;p>存储卷具体调度信息的实现可以参考《&lt;a href="http://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247487353&amp;amp;idx=1&amp;amp;sn=80263666e7e2e17da37374990262d283&amp;amp;chksm=fae504b6cd928da0b44045ed3d1596597a84128cd6a7d6cfbcfac33382a252f295fce2e39d78&amp;amp;scene=21#wechat_redirect">从零开始入门 K8s | 应用存储和持久化数据卷：存储快照与拓扑调度&lt;/a>》，这里会有一个更加详细的介绍。&lt;/p>
&lt;h1 id="二flexvolume-介绍及使用">二、Flexvolume 介绍及使用&lt;/h1>
&lt;p>Flexvolume 是 Volume Plugins 的一个扩展，主要实现 Attach/Detach/Mount/Unmount 这些接口。我们知道这些功能本是由 Volume Plugins 实现的，但是对于某些存储类型，我们需要将其扩展到 Volume Plugins 以外，所以我们需要把接口的具体实现放到外面。&lt;/p>
&lt;p>在下图中我们可以看到，Volume Plugins 其实包含了一部分 Flexvolume 的实现代码，但这部分代码其实只有一个 “Proxy”的功能。&lt;/p>
&lt;p>比如当 AD Controller 调用插件的一个 Attach 时，它首先会调用 Volume Plugins 中 Flexvolume 的 Attach 接口，但这个接口只是把调用转到相应的 Flexvolume 的Out-Of-Tree实现上。&lt;/p>
&lt;p>Flexvolume是可被 Kubelet 驱动的可执行文件，每一次调用相当于执行一次 shell 的 ls 这样的脚本，都是可执行文件的命令行调用，因此它不是一个常驻内存的守护进程。&lt;/p>
&lt;p>Flexvolume 的 Stdout 作为 Kubelet 调用的返回结果，这个结果需要是 JSON 格式。&lt;/p>
&lt;p>Flexvolume默认的存放地址为 &lt;code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/alicloud~disk/disk&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/54c8c693c28446c4bf1b840c277d0afb.png" alt="15.png" title="15.png">&lt;/p>
&lt;p>下面是一个命令格式和调用的实例。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/4a66003358ac44b7a9ee2846d2e9fed9.png" alt="16.png" title="16.png">&lt;/p>
&lt;h2 id="flexvolume-的接口介绍">Flexvolume 的接口介绍&lt;/h2>
&lt;p>Flexvolum 包含以下接口：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>init&lt;/strong>: 主要做一些初始化的操作，比如部署插件、更新插件的时候做 init 操作，返回的时候会返回刚才我们所说的 DriveCapabilities 类型的数据结构，用来说明我们的 Flexvolume 插件有哪些功能；&lt;/li>
&lt;li>&lt;strong>GetVolumeName&lt;/strong>： 返回插件名;&lt;/li>
&lt;li>&lt;strong>Attach&lt;/strong>: 挂载功能的实现。根据 –enable-controller-attach-detach 标签来决定是由 AD Controller 还是 Kubelet 来发起挂载操作;&lt;/li>
&lt;li>&lt;strong>WaitforAttach&lt;/strong>： Attach 经常是异步操作，因此需要等待挂载完成，才能需要进行下面的操作;&lt;/li>
&lt;li>MountDevice：它是 mount 的一部分。这里我们将 mount 分为 MountDevice 和 SetUp 两部分，MountDevice 主要做一些简单的预处理工作，比如将设备格式化、挂载到 GlobalMount 目录中等；&lt;/li>
&lt;li>&lt;strong>GetPath&lt;/strong>：获取每个 Pod 对应的本地挂载目录；&lt;/li>
&lt;li>&lt;strong>Setup&lt;/strong>：使用 Bind 方式将 GlobalPath 中的设备挂载到 Pod 的本地目录；&lt;/li>
&lt;li>&lt;strong>TearDown&lt;/strong>、&lt;strong>UnmountDevice&lt;/strong>、&lt;strong>Detach&lt;/strong> 实现的是上面一些借口的逆过程；&lt;/li>
&lt;li>&lt;strong>ExpandVolumeDevice&lt;/strong>：扩容存储卷，由 Expand Controller 发起调用；&lt;/li>
&lt;li>&lt;strong>NodeExpand&lt;/strong>： 扩容文件系统，由 Kubelet 发起调用。&lt;/li>
&lt;/ul>
&lt;p>上面这些接口不一定需要全部实现，如果某个接口没有实现的话，可以将返回结果定义成：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">{
&amp;#34;status&amp;#34;: &amp;#34;Not supported&amp;#34;,
&amp;#34;message&amp;#34;: &amp;#34;error message&amp;#34;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>告诉调用者没有实现这个接口。此外，Volume Plugins 中的 Flexvolume 接口除了作为一个 Proxy 外，它也提供了一些默认实现，比如 Mount 操作。所以如果你的 Flexvolume 中没有定义该接口，该默认实现就会被调用。&lt;/p>
&lt;p>在定义 PV 时可以通过 secretRef 字段来定义一些 secret 的功能。比如挂载时所需的用户名和密码，就可以通过 secretRef 传入。&lt;/p>
&lt;h2 id="flexvolume-的挂载分析">Flexvolume 的挂载分析&lt;/h2>
&lt;p>从挂载流程和卸载流程两个方向来分析 Flexvolume 的挂载过程。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/7be062cf8e844ac2a7556471c166dc4b.png" alt="17.png" title="17.png">&lt;/p>
&lt;p>我们首先看 Attach 操作，它调用了一个远端的 API 把我们的 Storage 挂载到目标节点中的某个设备上去。然后通过 MountDevice 将本地设备挂载到 GlobalPath 中，同时也会做一些格式化这样的操作。Mount 操作（SetUp），它会把 GlobalPath 挂载 PodPath 中，PodPath 就是 Pod 启动时所映射的一个目录。&lt;/p>
&lt;p>下图给出了一个例子，比如我们一个云盘，其 Volume ID 为 d-8vb4fflsonz21h31cmss，在执行完 Attach 和 WaitForAttach 操作之后，就会将其挂载到目标节点上的 /dec/vdc 设备中。执行 MountDevice 之后，就会把上述设备格式化，挂载到一个本地的 GlobalPath 中。而执行完 Mount 之后，就会将 GlobalPath 映射到 Pod 相关的一个子目录中。最后执行 Bind 操作，将我们的本地目录映射到容器中。这样完成一次挂载过程。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/bc5f070d8bf14ac994ddc2a5075eeaab.png" alt="18.png" title="18.png">&lt;/p>
&lt;p>卸载流程就是一个逆过程。上述过程描述的是一个块设备的挂载过程，对于文件存储类型，就无需 Attach、MountDevice操作，只需要 Mount 操作，因此文件系统的 Flexvolume 实现较为简单，只需要 Mount 和 Unmount 过程即可。&lt;/p>
&lt;h2 id="flexvolume-的代码示例">Flexvolume 的代码示例&lt;/h2>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/3beec866fc4d47dcb704103037c4987b.png" alt="19.png" title="19.png">&lt;/p>
&lt;p>其中主要实现的是 init()、doMount()、doUnmount() 方法。在执行该脚本的时候对传入的参数进行判断来决定执行哪一个命令。&lt;/p>
&lt;p>在 Github 上还有很多 Flexvolume 的示例，大家可以自行参考查阅。阿里云提供了一个 &lt;a href="https://github.com/AliyunContainerService/flexvolume">Flexvolume 的实现&lt;/a>，有兴趣的可以参考一下。&lt;/p>
&lt;h2 id="flexvolume-的使用">Flexvolume 的使用&lt;/h2>
&lt;p>下图给出了一个 Flexvolume 类型的 PV 模板。它和其它模板实际上没有什么区别，只不过类型被定义为 flexVolume 类型。flexVolume 中定义了 driver、fsType、options。&lt;/p>
&lt;ul>
&lt;li>driver 定义的是我们实现的某种驱动，比如图中的是 aliclound/disk，也可以是 aliclound/nas 等；&lt;/li>
&lt;li>fsType 定义的是文件系统类型，比如 “ext4″；&lt;/li>
&lt;li>options 包含了一些具体的参数，比如定义云盘的 id 等。&lt;/li>
&lt;/ul>
&lt;p>我们也可以像其它类型一样，通过 selector 中的 matchLabels 定义一些筛选条件。同样也可以定义一些相应的调度信息，比如定义 zone 为 cn-shenzhen-a。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/2d279e210fb447349393288fcce484e8.png" alt="20.png" title="20.png">&lt;/p>
&lt;p>下面是一个具体的运行结果。在 Pod 内部我们挂载了一个云盘，其所在本地设备为 /dev/vdb。通过 mount | grep disk 我们可以看到相应的挂载目录，首先它会将 /dev/vdb 挂载到 GlobalPath 中；其次会将 GlobalPath 通过 mount 命令挂载到一个 Pod 所定义的本地子目录中去；最后会把该本地子目录映射到 /data 上。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/31a9e77d0f7c45199457957cf7b095d4.png" alt="21.png" title="21.png">&lt;/p>
&lt;h1 id="三csi-介绍及使用">三、CSI 介绍及使用&lt;/h1>
&lt;p>和 Flexvolume 类似，CSI 也是为第三方存储提供数据卷实现的抽象接口。&lt;/p>
&lt;p>有了 Flexvolume，为何还要 CSI 呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Flexvolume 只是给 kubernetes 这一个编排系统来使用的，而 CSI 可以满足不同编排系统的需求，比如 Mesos，Swarm。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其次 CSI 是容器化部署，可以减少环境依赖，增强安全性，丰富插件的功能。我们知道，Flexvolume 是在 host 空间一个二进制文件，执行 Flexvolum 时相当于执行了本地的一个 shell 命令，这使得我们在安装 Flexvolume 的时候需要同时安装某些依赖，而这些依赖可能会对客户的应用产生一些影响。因此在安全性上、环境依赖上，就会有一个不好的影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时对于丰富插件功能这一点，我们在 Kubernetes 生态中实现 operator 的时候，经常会通过 RBAC 这种方式去调用 Kubernetes 的一些接口来实现某些功能，而这些功能必须要在容器内部实现，因此像 Flexvolume 这种环境，由于它是 host 空间中的二进制程序，就没法实现这些功能。而 CSI 这种容器化部署的方式，可以通过 RBAC 的方式来实现这些功能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>CSI 主要包含两个部分：CSI Controller Server 与 CSI Node Server。&lt;/p>
&lt;ul>
&lt;li>Controller Server 是控制端的功能，主要实现创建、删除、挂载、卸载等功能；&lt;/li>
&lt;li>Node Server 主要实现的是节点上的 mount、Unmount 功能。&lt;/li>
&lt;/ul>
&lt;p>下图给出了 CSI 接口通信的描述。CSI Controller Server 和 External CSI SideCar 是通过 Unix Socket 来进行通信的，CSI Node Server 和 Kubelet 也是通过 Unix Socket 来通信，之后我们会讲一下 External CSI SiderCar 的具体概念。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/a26d9a4a9b3143d293743ec5aa450d95.png" alt="22.png" title="22.png">&lt;/p>
&lt;p>下图给出了 CSI 的接口。主要分为三类：通用管控接口、节点管控接口、中心管控接口。&lt;/p>
&lt;ul>
&lt;li>通用管控接口：主要返回 CSI 的一些通用信息，像插件的名字、Driver 的身份信息、插件所提供的能力等；&lt;/li>
&lt;li>节点管控接口：的 NodeStageVolume 和 NodeUnstageVolume 就相当于 Flexvolume 中的 MountDevice 和 UnmountDevice。NodePublishVolume 和 NodeUnpublishVolume 就相当于 SetUp 和 TearDown 接口；&lt;/li>
&lt;li>中心管控接口：的 CreateVolume 和 DeleteVolume 就是我们的 Provision 和 Delete 存储卷的一个接口，ControllerPublishVolume 和 ControllerUnPublishVolume 则分别是 Attach 和 Detach 的接口。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/5959aa6f8841488da306e631497ffe62.png" alt="23.png" title="23.png">&lt;/p>
&lt;h2 id="csi-的系统结构">CSI 的系统结构&lt;/h2>
&lt;p>CSI 是通过 CRD 的形式实现的，所以 CSI 引入了这么几个对象类型：VolumeAttachment、CSINode、CSIDriver 以及 CSI Controller Server 与 CSI Node Server 的一个实现。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/4341928d9cf74f1aba10dc7d5c7e22d0.png" alt="24.png" title="24.png">&lt;/p>
&lt;p>在 CSI Controller Server 中，有传统的类似 Kubernetes 中的 AD Controller 和 Volume Plugins，VolumeAttachment 对象就是由它们所创建的。&lt;/p>
&lt;p>此外，还包含多个 External Plugin组件，每个组件和 CSI Plugin 组合的时候会完成某种功能。比如：&lt;/p>
&lt;ul>
&lt;li>External Provisioner 和 Controller Server 组合的时候就会完成数据卷的创建与删除功能；&lt;/li>
&lt;li>External Attacher 和 Controller Server 组合起来可以执行数据卷的挂载和操作；&lt;/li>
&lt;li>External Resizer 和 Controller Server 组合起来可以执行数据卷的扩容操作；&lt;/li>
&lt;li>External Snapshotter 和 Controller Server 组合则可以完成快照的创建和删除。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/00121822daba4d3fa77735fb5e9a8ae4.png" alt="25.png" title="25.png">&lt;/p>
&lt;p>CSI Node Server 中主要包含 Kubelet 组件，包括 VolumeManager 和 VolumePlugin，它们会去调用 CSI Plugin 去做 mount 和 unmount 操作；另外一个组件 Driver Registrar 主要实现的是 CSI Plugin 注册的功能。&lt;/p>
&lt;p>以上就是 CSI 的整个拓扑结构，接下来我们将分别介绍不同的对象和组件。&lt;/p>
&lt;h3 id="csi-对象">CSI 对象&lt;/h3>
&lt;p>我们将介绍 3 种对象：VolumeAttachment，CSIDriver，CSINode。&lt;/p>
&lt;p>VolumeAttachment 描述一个 Volume 卷在一个 Pod 使用中挂载、卸载的相关信息。例如，对一个卷在某个节点上的挂载，我们通过 VolumeAttachment 对该挂载进行跟踪。AD Controller 创建一个 VolumeAttachment，而 External-attacher 则通过观察该 VolumeAttachment，根据其状态来进行挂载和卸载操作。&lt;/p>
&lt;p>下图就是一个 VolumeAttachment 的例子，其类别 (kind) 为 VolumeAttachment，spec 中指定了 attacher 为 ossplugin.csi.alibabacloud.com，即指定挂载是由谁操作的；指定了 nodeName 为 cn-zhangjiakou.192.168.1.53，即该挂载是发生在哪个节点上的；指定了 source 为 persistentVolumeName 为 oss-csi-pv，即指定了哪一个数据卷进行挂载和卸载。&lt;/p>
&lt;p>status 中 attached 指示了挂载的状态，如果是 False， External-attacher 就会执行一个挂载操作。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/f7e88b2a04594bb98111c5881e8e5916.png" alt="26.png" title="26.png">&lt;/p>
&lt;p>第二个对象是 CSIDriver，它描述了集群中所部署的 CSI Plugin 列表，需要管理员根据插件类型进行创建。&lt;/p>
&lt;p>例如下图中创建了一些 CSI Driver，通过 &lt;code>kuberctl get csidriver&lt;/code> 我们可以看到集群里面创建的 3 种类型的 CSI Driver：一个是云盘；一个是 NAS；一个是 OSS。&lt;/p>
&lt;p>在 CSI Driver 中，我们定义了它的名字，在 spec 中还定义了 attachRequired 和 podInfoOnMount 两个标签。&lt;/p>
&lt;ul>
&lt;li>attachRequired 定义一个 Plugin 是否支持 Attach 功能，主要是为了对块存储和文件存储做区分。比如文件存储不需要 Attach 操作，因此我们将该标签定义为 False；&lt;/li>
&lt;li>podInfoOnMount 则是定义 Kubernetes 在调用 Mount 接口时是否带上 Pod 信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/21cdf4bd73bb40049cb188e0028b31a7.png" alt="27.png" title="27.png">&lt;/p>
&lt;p>第三个对象是 CSINode，它是集群中的节点信息，由 node-driver-registrar 在启动时创建。它的作用是每一个新的 CSI Plugin 注册后，都会在 CSINode 列表里添加一个 CSINode 信息。&lt;/p>
&lt;p>例如下图，定义了 CSINode 列表，每一个 CSINode 都有一个具体的信息（左侧的 YAML）。以 一 cn-zhangjiakou.192.168.1.49 为例，它包含一个云盘的 CSI Driver，还包含一个 NAS 的 CSI Driver。每个 Driver 都有自己的 nodeID 和它的拓扑信息 topologyKeys。如果没有拓扑信息，可以将 topologyKeys 设置为 “null”。也就是说，假如有一个有 10 个节点的集群，我们可以只定义一部分节点拥有 CSINode。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/8d8ccc3214c246d19488a485b0d0af7e.png" alt="28.png" title="28.png">&lt;/p>
&lt;h3 id="csi-组件之-node-driver-registrar">CSI 组件之 Node-Driver-Registrar&lt;/h3>
&lt;p>Node-Driver-Registrar 主要实现了 CSI Plugin 注册的一个机制。我们来看一下下图中的流程图。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/2b24b73055b34a6d91e675772ce0c968.png" alt="29.png" title="29.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第 1 步&lt;/strong>，在启动的时候有一个约定，比如说在 /var/lib/kuberlet/plugins_registry 这个目录每新加一个文件，就相当于每新加了一个 Plugin；&lt;/li>
&lt;/ul>
&lt;p>启动 Node-Driver-Registrar，它首先会向 CSI-Plugin 发起一个接口调用 GetPluginInfo，这个接口会返回 CSI 所监听的地址以及 CSI-Plugin 的一个 Driver name；&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第 2 步&lt;/strong>，Node-Driver-Registrar 会监听 GetInfo 和 NotifyRegistrationStatus 两个接口；&lt;/li>
&lt;li>&lt;strong>第 3 步&lt;/strong>，会在 &lt;code>/var/lib/kuberlet/plugins_registry&lt;/code> 这个目录下启动一个 Socket，生成一个 Socket 文件 ，例如：”diskplugin.csi.alibabacloud.com-reg.sock”，此时 Kubelet 通过 Watcher 发现这个 Socket 后，它会通过该 Socket 向 Node-Driver-Registrar 的 GetInfo 接口进行调用。GetInfo 会把刚才我们所获得的的 CSI-Plugin 的信息返回给 Kubelet，该信息包含了 CSI-Plugin 的监听地址以及它的 Driver name；&lt;/li>
&lt;li>&lt;strong>第 4 步&lt;/strong>，Kubelet 通过得到的监听地址对 CSI-Plugin 的 NodeGetInfo 接口进行调用；&lt;/li>
&lt;li>&lt;strong>第 5 步&lt;/strong>，调用成功之后，Kubelet 会去更新一些状态信息，比如节点的 Annotations、Labels、status.allocatable 等信息，同时会创建一个 CSINode 对象；&lt;/li>
&lt;li>&lt;strong>第 6 步&lt;/strong>，通过对 Node-Driver-Registrar 的 NotifyRegistrationStatus 接口的调用告诉它我们已经把 CSI-Plugin 注册成功了。&lt;/li>
&lt;/ul>
&lt;p>通过以上 6 步就实现了 CSI Plugin 注册机制。&lt;/p>
&lt;h3 id="csi-组件之-external-attacher">CSI 组件之 External-Attacher&lt;/h3>
&lt;p>External-Attacher 主要是通过 CSI Plugin 的接口来实现数据卷的挂载与卸载功能。它通过观察 VolumeAttachment 对象来实现状态的判断。VolumeAttachment 对象则是通过 AD Controller 来调用 Volume Plugin 中的 CSI Attacher 来创建的。CSI Attacher 是一个 In-Tree 类，也就是说这部分是 Kubernetes 完成的。&lt;/p>
&lt;p>当 VolumeAttachment 的状态是 False 时，External-Attacher 就去调用底层的一个 Attach 功能；若期望值为 False，就通过底层的 ControllerPublishVolume 接口实现 Detach 功能。同时，External-Attacher 也会同步一些 PV 的信息在里面。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/8d02f8f2e2784362831363770e3ae6fa.png" alt="30.png" title="30.png">&lt;/p>
&lt;h2 id="csi-部署">CSI 部署&lt;/h2>
&lt;p>我们现在来看一下块存储的部署情况。&lt;/p>
&lt;p>之前提到 CSI 的 Controller 分为两部分，一个是 Controller Server Pod，一个是 Node Server Pod。&lt;/p>
&lt;p>我们只需要部署一个 Controller Server，如果是多备份的，可以部署两个。Controller Server 主要是通过多个外部插件来实现的，比如说一个 Pod 中可以定义多个 External 的 Container 和一个包含 CSI Controller Server 的 Container，这时候不同的 External 组件会和 Controller Server 组成不同的功能。&lt;/p>
&lt;p>而 Node Server Pod 是个 DaemonSet，它会在每个节点上进行注册。Kubelet 会直接通过 Socket 的方式直接和 CSI Node Server 进行通信、调用 Attach/Detach/Mount/Unmount 等。&lt;/p>
&lt;p>Driver Registrar 只是做一个注册的功能，会在每个节点上进行部署。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/ef96ad51a5de42d2995e0a8b000ae5cc.png" alt="31.png" title="31.png">&lt;/p>
&lt;p>文件存储和块存储的部署情况是类似的。只不过它会把 Attacher 去掉，也没有 VolumeAttachment 对象。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/9f482d24daa04d2a80ee56ce662faa84.png" alt="32.png" title="32.png">&lt;/p>
&lt;h2 id="csi-使用示例">CSI 使用示例&lt;/h2>
&lt;p>和 Flexvolume 一样，我们看一下它的定义模板。&lt;/p>
&lt;p>可以看到，它和其它的定义并没什么区别。主要的区别在于类型为 CSI，里面会定义 driver，volumeHandle，volumeAttribute，nodeAffinity 等。&lt;/p>
&lt;ul>
&lt;li>driver 就是定义是由哪一个插件来去实现挂载；&lt;/li>
&lt;li>volumeHandle 主要是指示 PV 的唯一标签；&lt;/li>
&lt;li>volumeAttribute 用于附加参数，比如 PV 如果定义的是 OSS，那么就可以在 volumeAttribute 定义 bucket、访问的地址等信息在里面；&lt;/li>
&lt;li>nodeAffinity 则可以定义一些调度信息。与 Flexvolume 类似，还可以通过 selector 和 Label 定义一些绑定条件。&lt;/li>
&lt;/ul>
&lt;p>中间的图给出了一个动态调度的例子，它和其它类型的动态调度是一样的。只不过在定义 provisioner 的时候指定了一个 CSI 的 provisioner。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/70345fe4428147e6a929248ed402e0cf.png" alt="33.png" title="33.png">&lt;/p>
&lt;p>下面给出了一个具体的挂载例子。&lt;/p>
&lt;p>Pod 启动之后，我们可以看到 Pod 已经把一个 /dev/vdb 挂载到 /data 上了。同理，它有一个 GlobalPath 和一个 PodPath 的集群在里面。我们可以把一个 /dev/vdb 挂载到一个 GlobalPath 里面，它就是一个 CSI 的一个 PV 在本节点上唯一确定的目录。一个 PodPath 就是一个 Pod 所确定的一个本地节点的目录，它会把 Pod 所对应的目录映射到我们的容器中去。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/726a4f02be694475850a691ee07201ac.png" alt="34.png" title="34.png">&lt;/p>
&lt;h2 id="csi-的其它功能">CSI 的其它功能&lt;/h2>
&lt;p>除了挂载、卸载之外，CSI 化提供了一些附加的功能。例如，在定义模板的时候往往需要一些用户名和密码信息，此时我们就可通过 &lt;strong>Secret&lt;/strong> 来进行定义。之前我们所讲的 Flexvolume 也支持这个功能，只不过 CSI 可以根据不同的阶段定义不同的 Secret 类型，比如挂载阶段的 Secret、Mount 阶段的 Secret、Provision 阶段的 Secret。&lt;/p>
&lt;p>&lt;strong>Topology&lt;/strong> 是一个拓扑感知的功能。当我们定义一个数据卷的时候，集群中并不是所有节点都能满足该数据卷的需求，比如我们需要挂载不同的 zone 的信息在里面，这就是一个拓扑感知的功能。这部分在第 10 讲已有详细的介绍，大家可以进行参考。&lt;/p>
&lt;p>&lt;strong>Block Volume&lt;/strong> 就是 volumeMode 的一个定义，它可以定义成 Block 类型，也可以定义成文件系统类型，CSI 支持 Block 类型的 Volume，就是说挂载到 Pod 内部时，它是一个块设备，而不是一个目录。&lt;/p>
&lt;p>**Skip Attach **和 &lt;strong>PodInfo On Mount&lt;/strong> 是刚才我们所讲过的 CSI Driver 中的两个功能。&lt;/p>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/00d0b04477a64cb2a1e09b5f4f43d672.png" alt="35.png" title="35.png">&lt;/p>
&lt;h2 id="csi-的近期-features">CSI 的近期 Features&lt;/h2>
&lt;p>&lt;img src="https://ucc.alicdn.com/pic/developer-ecology/916bf4d196714c74981ce2867afff97b.png" alt="36.png" title="36.png">&lt;/p>
&lt;p>CSI 还是一个比较新的实现方式。近期也有了很多更新，比如 ExpandCSIVolumes 可以实现文件系统扩容的功能；VolumeSnapshotDataSource 可以实现数据卷的快照功能；VolumePVCDataSource 实现的是可以定义 PVC 的数据源；我们以前在使用 CSI 的时候只能通过 PVC、PV 的方式定义，而不能直接在 Pod 里面定义 Volume，CSIInlineVolume 则可以让我们可以直接在 Volume 中定义一些 CSI 的驱动。&lt;/p></description></item><item><title>k8s之Pod基本原理</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E4%B9%8Bpod%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 30 Apr 2022 00:25:08 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E4%B9%8Bpod%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="k8s之pod基本原理">k8s之Pod基本原理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Pod、Service、Volume 和 Namespace 是 Kubernetes 集群中四大基本对象，&lt;/p>
&lt;p>它们能够表示系统中部署的应用、工作负载、网络和磁盘资源，共同定义了集群的状态。&lt;/p>
&lt;p>Kubernetes 中很多其他的资源其实只对这些基本的对象进行了组合。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2018-12-25-kubernetes-basic-objects.png" alt="kubernetes-basic-objects">&lt;/p>
&lt;p>Pod 是 Kubernetes 集群中能够被创建和管理的最小部署单元。&lt;/p>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>作为 Kubernetes 集群中的基本单元，Pod 就是最小并且最简单的 Kubernetes 对象，&lt;/p>
&lt;p>这个简单的对象其实就能够独立启动一个后端进程并在集群的内部为调用方提供服务。&lt;/p>
&lt;p>在上一篇文章  &lt;a href="https://draveness.me/kubernetes-object-intro">从 Kubernetes 中的对象谈起&lt;/a>  中，我们曾经介绍过简单的 Kubernetes Pod 是如何使用 YAML 进行描述的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">sleep&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;3600&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 YAML 文件描述了一个 Pod 启动时运行的容器和命令以及它的重启策略，&lt;/p>
&lt;p>在当前 Pod 出现错误或者执行结束后是否应该被 Kubernetes 的控制器拉起来，&lt;/p>
&lt;p>除了这些比较显眼的配置之外，元数据  &lt;code>metadata&lt;/code>  的配置也非常重要，&lt;code>name&lt;/code>  是当前对象在 Kubernetes 集群中的唯一标识符，&lt;/p>
&lt;p>而标签  &lt;code>labels&lt;/code>  可以帮助我们快速选择对象。&lt;/p>
&lt;p>在同一个 Pod 中，有几个概念特别值得关注，&lt;/p>
&lt;p>首先就是容器，在 Pod 中其实可以同时运行一个或者多个容器，这些容器能够共享网络、存储以及 CPU、内存等资源。&lt;/p>
&lt;p>在这一小节中我们将关注 Pod 中的容器、卷和网络三大概念。&lt;/p>
&lt;h3 id="容器">容器&lt;/h3>
&lt;p>每一个 Kubernetes 的 Pod 其实都具有两种不同的容器，两种不同容器的职责其实十分清晰，&lt;/p>
&lt;p>一种是  &lt;code>InitContainer&lt;/code>，这种容器会在 Pod 启动时运行，主要用于初始化一些配置，&lt;/p>
&lt;p>另一种是 Pod 在 Running 状态时内部存活的  &lt;code>Container&lt;/code>，它们的主要作用是对外提供服务或者作为工作节点处理异步任务等等。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2018-12-25-kubernetes-pod-init-and-regular-containers.png" alt="kubernetes-pod-init-and-regular-containers">&lt;/p>
&lt;p>通过对不同容器类型的命名我们也可以看出，&lt;/p>
&lt;p>&lt;code>InitContainer&lt;/code>  会比  &lt;code>Container&lt;/code>  优先启动，在  &lt;code>kubeGenericRuntimeManager.SyncPod&lt;/code>  方法中会先后启动两种容器。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeGenericRuntimeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SyncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Secret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">backOff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">flowcontrol&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Backoff&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">result&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSyncResult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Step 1: Compute sandbox and container changes.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// Step 2: Kill the pod if the sandbox has changed.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// Step 3: kill any running containers in this pod which are not to keep.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// Step 4: Create a sandbox for the pod if necessary.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// Step 5: start the init container.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">container&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NextInitContainerToStart&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">container&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podSandboxID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podSandboxConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podIP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerTypeInit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Step 6: start containers in podContainerChanges.ContainersToStart.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainersToStart&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">container&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podSandboxID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podSandboxConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podIP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerTypeRegular&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过分析私有方法  &lt;code>startContainer&lt;/code>  的实现我们得出：容器的类型最终只会影响在 Debug 时创建的标签，所以对于 Kubernetes 来说两种容器的启动和执行也就只有顺序先后的不同。&lt;/p>
&lt;h3 id="卷">卷&lt;/h3>
&lt;p>每一个 Pod 中的容器是可以通过  &lt;a href="https://draveness.me/kubernetes-volume">卷（Volume）&lt;/a>  的方式共享文件目录的，这些 Volume 能够存储持久化的数据；在当前 Pod 出现故障或者滚动更新时，对应 Volume 中的数据并不会被清除，而是会在 Pod 重启后重新挂载到期望的文件目录中：&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2018-12-25-kubernetes-containers-share-volumes.png" alt="kubernetes-containers-share-volumes">&lt;/p>
&lt;p>kubelet.go 文件中的私有方法  &lt;code>syncPod&lt;/code>  会调用  &lt;code>WaitForAttachAndMount&lt;/code>  方法为等待当前 Pod 启动需要的挂载文件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">vm&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">volumeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">WaitForAttachAndMount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">expectedVolumes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getExpectedVolumes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">uniquePodName&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">util&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetUniquePodName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">vm&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">desiredStateOfWorldPopulator&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ReprocessPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">wait&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">PollImmediate&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="nx">podAttachAndMountRetryInterval&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">podAttachAndMountTimeout&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">vm&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">verifyVolumesMountedFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expectedVolumes&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们会在  &lt;a href="https://draveness.me/kubernetes-volume">后面的章节&lt;/a>  详细地介绍 Kubernetes 中卷的创建、挂载是如何进行的，在这里我们需要知道的是卷的挂载是 Pod 启动之前必须要完成的工作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">kl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Kubelet&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">o&lt;/span> &lt;span class="nx">syncPodOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">podIsTerminated&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumeManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WaitForAttachAndMount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">pullSecrets&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getPullSecretsForPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">result&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">containerRuntime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SyncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">apiPodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">backOff&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reasonCache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在当前 Pod 的卷创建完成之后，就会调用上一节中提到的  &lt;code>SyncPod&lt;/code>  公有方法继续进行同步 Pod 信息和创建、启动容器的工作。&lt;/p>
&lt;h3 id="网络">网络&lt;/h3>
&lt;p>同一个 Pod 中的多个容器会被共同分配到同一个 Host 上并且共享网络栈，&lt;/p>
&lt;p>这些 Pod 能够通过 localhost 互相访问到彼此的端口和服务，如果使用了相同的端口也会发生冲突，&lt;/p>
&lt;p>同一个 Pod 上的所有容器会连接到同一个网络设备上，这个网络设备就是由 Pod Sandbox 中的沙箱容器在  &lt;code>RunPodSandbox&lt;/code>  方法中启动时创建的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ds&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">dockerService&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">RunPodSandbox&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">runtimeapi&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RunPodSandboxRequest&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">runtimeapi&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RunPodSandboxResponse&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">config&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetConfig&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">// Step 1: Pull the image for the sandbox.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">image&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">defaultSandboxImage&lt;/span>
&lt;span class="c1">// Step 2: Create the sandbox container.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">createConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">makeSandboxDockerConfig&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">image&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">createResp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CreateContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">createConfig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">resp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">runtimeapi&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RunPodSandboxResponse&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">PodSandboxId&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">createResp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">ds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">setNetworkReady&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">createResp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Step 3: Create Sandbox Checkpoint.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">ds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">checkpointManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CreateCheckpoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">createResp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">constructPodSandboxCheckpoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1">// Step 4: Start the sandbox container.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">ds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StartContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">createResp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Step 5: Setup networking for the sandbox.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">cID&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">BuildContainerID&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">runtimeName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">createResp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">networkOptions&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">ds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">network&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetUpPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetMetadata&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetMetadata&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">cID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Annotations&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">networkOptions&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">resp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>沙箱容器其实就是  &lt;code>pause&lt;/code>  容器，&lt;/p>
&lt;p>上述方法引用的  &lt;code>defaultSandboxImage&lt;/code>  其实就是官方提供的  &lt;code>k8s.gcr.io/pause:3.1&lt;/code>  镜像，&lt;/p>
&lt;p>这里会创建沙箱镜像和检查点并启动容器。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2018-12-25-kubernetes-pod-network.png" alt="kubernetes-pod-network">&lt;/p>
&lt;p>每一个节点上都会由 Kubernetes 的网络插件 Kubenet 创建一个基本的  &lt;code>cbr0&lt;/code>  网桥并为每一个 Pod 创建  &lt;code>veth&lt;/code>  虚拟网络设备，同一个 Pod 中的所有容器就会通过这个网络设备共享网络，也就是能够通过 localhost 互相访问彼此暴露的端口和服务。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>Kubernetes 中的每一个 Pod 都包含多个容器，这些容器在通过 Kubernetes 创建之后就能共享网络和存储，这其实是 Pod 非常重要的特性，我们能通过这个特性构建比较复杂的服务拓扑和依赖关系。&lt;/p>
&lt;h2 id="生命周期">生命周期&lt;/h2>
&lt;p>想要深入理解 Pod 的实现原理，最好最快的办法就是从 Pod 的生命周期入手，通过理解 Pod 创建、重启和删除的原理我们最终就能够系统地掌握 Pod 的生命周期与核心原理。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2018-12-25-kubernetes-pod-lifecycle.png" alt="kubernetes-pod-lifecycle">&lt;/p>
&lt;p>当 Pod 被创建之后，就会进入健康检查状态，&lt;/p>
&lt;p>当 Kubernetes 确定当前 Pod 已经能够接受外部的请求时，才会将流量打到新的 Pod 上并继续对外提供服务，&lt;/p>
&lt;p>在这期间如果发生了错误就可能会触发重启机制，在 Pod 被删除之前都会触发一个  &lt;code>PreStop&lt;/code>  的钩子，&lt;/p>
&lt;p>其中的方法完成之后 Pod 才会被删除，接下来我们就会按照这里的顺序依次介绍 Pod 『从生到死』的过程。&lt;/p>
&lt;h3 id="创建">创建&lt;/h3>
&lt;p>Pod 的创建都是通过  &lt;code>SyncPod&lt;/code>  来实现的，创建的过程大体上可以分为六个步骤：&lt;/p>
&lt;ol>
&lt;li>计算 Pod 中沙盒和容器的变更；&lt;/li>
&lt;li>强制停止 Pod 对应的沙盒；&lt;/li>
&lt;li>强制停止所有不应该运行的容器；&lt;/li>
&lt;li>为 Pod 创建新的沙盒；&lt;/li>
&lt;li>创建 Pod 规格中指定的初始化容器；&lt;/li>
&lt;li>依次创建 Pod 规格中指定的常规容器；&lt;/li>
&lt;/ol>
&lt;p>我们可以看到 Pod 的创建过程其实是比较简单的，首先计算 Pod 规格和沙箱的变更，然后停止可能影响这一次创建或者更新的容器，最后依次创建沙盒、初始化容器和常规容器。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeGenericRuntimeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SyncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Secret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">backOff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">flowcontrol&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Backoff&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">result&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSyncResult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">podContainerChanges&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">computePodActions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CreateSandbox&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ref&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ref&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetReference&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">legacyscheme&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Scheme&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KillPod&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CreateSandbox&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">purgeInitContainers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerInfo&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainersToKill&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">killContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerInfo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerInfo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">message&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">podSandboxID&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SandboxID&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CreateSandbox&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">podSandboxID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">createPodSandbox&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Attempt&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">podSandboxConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">generatePodSandboxConfig&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Attempt&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">container&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NextInitContainerToStart&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">container&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podSandboxID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podSandboxConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podIP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerTypeInit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">podContainerChanges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainersToStart&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">container&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podSandboxID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podSandboxConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podIP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerTypeRegular&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>简化后的  &lt;code>SyncPod&lt;/code>  方法的脉络非常清晰，可以很好地理解整个创建 Pod 的工作流程；而初始化容器和常规容器被调用  &lt;code>startContainer&lt;/code>  来启动：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeGenericRuntimeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">startContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podSandboxID&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podSandboxConfig&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">runtimeapi&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSandboxConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podStatus&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Secret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podIP&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerType&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerType&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">imageRef&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">imagePuller&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EnsureImageExists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pullSecrets&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runtimeService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CreateContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podSandboxID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podSandboxConfig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">internalLifecycle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">PreStartContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runtimeService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StartContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">containerID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Lifecycle&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Lifecycle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PostStart&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kubeContainerID&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerID&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runtimeName&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">ID&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runner&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">kubeContainerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Lifecycle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PostStart&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在启动每一个容器的过程中也都按照相同的步骤进行操作：&lt;/p>
&lt;ol>
&lt;li>通过镜像拉取器获得当前容器中使用镜像的引用；&lt;/li>
&lt;li>调用远程的  &lt;code>runtimeService&lt;/code>  创建容器；&lt;/li>
&lt;li>调用内部的生命周期方法  &lt;code>PreStartContainer&lt;/code>  为当前的容器设置分配的 CPU 等资源；&lt;/li>
&lt;li>调用远程的  &lt;code>runtimeService&lt;/code>  开始运行镜像；&lt;/li>
&lt;li>如果当前的容器包含  &lt;code>PostStart&lt;/code>  钩子就会执行该回调；&lt;/li>
&lt;/ol>
&lt;p>每次  &lt;code>SyncPod&lt;/code>  被调用时不一定是创建新的 Pod 对象，它还会承担更新、删除和同步 Pod 规格的职能，根据输入的新规格执行相应的操作。&lt;/p>
&lt;h3 id="健康检查">健康检查&lt;/h3>
&lt;p>如果我们遵循 Pod 的最佳实践，其实应该尽可能地为每一个 Pod 添加  &lt;code>livenessProbe&lt;/code>  和  &lt;code>readinessProbe&lt;/code>  的健康检查，这两者能够为 Kubernetes 提供额外的存活信息，如果我们配置了合适的健康检查方法和规则，那么就不会出现服务未启动就被打入流量或者长时间未响应依然没有重启等问题。&lt;/p>
&lt;p>在 Pod 被创建或者被移除时，会被加入到当前节点上的  &lt;code>ProbeManager&lt;/code>  中，&lt;code>ProbeManager&lt;/code>  会负责这些 Pod 的健康检查：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">kl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Kubelet&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">HandlePodAdditions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pods&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">start&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">pods&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">dispatchWork&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubetypes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SyncPodCreate&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mirrorPod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">start&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">probeManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">kl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Kubelet&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">HandlePodRemoves&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pods&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">start&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">pods&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">DeletePod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">deletePod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">probeManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">RemovePod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>简化后的  &lt;code>HandlePodAdditions&lt;/code>  和  &lt;code>HandlePodRemoves&lt;/code>  方法非常直白，我们可以直接来看  &lt;code>ProbeManager&lt;/code>  如何处理不同节点的健康检查。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2018-12-25-kubernetes-probe-manager.png" alt="kubernetes-probe-manager">&lt;/p>
&lt;p>每一个新的 Pod 都会被调用  &lt;code>ProbeManager&lt;/code>  的&lt;code>AddPod&lt;/code>  函数，这个方法会初始化一个新的 Goroutine 并在其中运行对当前 Pod 进行健康检查：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">manager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">AddPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">key&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">probeKey&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">podUID&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">key&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">containerName&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ReadinessProbe&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">key&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">probeType&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">readiness&lt;/span>
&lt;span class="nx">w&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">newWorker&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">readiness&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">workers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">w&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="nx">w&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">run&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">LivenessProbe&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">key&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">probeType&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">liveness&lt;/span>
&lt;span class="nx">w&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">newWorker&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">liveness&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">workers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">w&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="nx">w&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">run&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在执行健康检查的过程中，Worker 只是负责根据当前 Pod 的状态定期触发一次  &lt;code>Probe&lt;/code>，它会根据 Pod 的配置分别选择调用  &lt;code>Exec&lt;/code>、&lt;code>HTTPGet&lt;/code>  或  &lt;code>TCPSocket&lt;/code>  三种不同的  &lt;code>Probe&lt;/code>  方式：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">pb&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">prober&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">runProbe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">probeType&lt;/span> &lt;span class="nx">probeType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Probe&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">status&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerID&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerID&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">probe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">timeout&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Duration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TimeoutSeconds&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Exec&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">command&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ExpandContainerCommandOnlyStatic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Exec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Env&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Probe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">newExecInContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timeout&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HTTPGet&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">scheme&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ToLower&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HTTPGet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Scheme&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">host&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HTTPGet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Host&lt;/span>
&lt;span class="nx">port&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">extractPort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HTTPGet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Port&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">path&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HTTPGet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Path&lt;/span>
&lt;span class="nx">url&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">formatURL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">scheme&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">host&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">port&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">headers&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">buildHeader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HTTPGet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HTTPHeaders&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">probeType&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">liveness&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">livenessHttp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Probe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">url&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">headers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timeout&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// readiness
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">readinessHttp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Probe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">url&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">headers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timeout&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TCPSocket&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">port&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">extractPort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TCPSocket&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Port&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">host&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TCPSocket&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Host&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">pb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tcp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Probe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">host&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">port&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timeout&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">probe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Unknown&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Missing probe handler for %s:%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">format&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Kubernetes 在 Pod 启动后的  &lt;code>InitialDelaySeconds&lt;/code>  时间内会等待 Pod 的启动和初始化，在这之后会开始健康检查，默认的健康检查重试次数是三次，如果健康检查正常运行返回了一个确定的结果，那么 Worker 就是记录这次的结果，在连续失败  &lt;code>FailureThreshold&lt;/code>  次或者成功  &lt;code>SuccessThreshold&lt;/code>  次，那么就会改变当前 Pod 的状态，这也是为了避免由于服务不稳定带来的抖动。&lt;/p>
&lt;h3 id="删除">删除&lt;/h3>
&lt;p>当 Kubelet 在  &lt;code>HandlePodRemoves&lt;/code>  方法中接收到来自客户端的删除请求时，就会通过一个名为  &lt;code>deletePod&lt;/code>  的私有方法中的 Channel 将这一事件传递给 PodKiller 进行处理：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">kl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Kubelet&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">deletePod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podWorkers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ForgetWorker&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">runningPods&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runtimeCache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetPods&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">runningPod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pods&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">runningPods&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">FindPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">podPair&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodPair&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">APIPod&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">RunningPod&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">runningPod&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podKillingCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">podPair&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Kubelet 除了将事件通知给 PodKiller 之外，还需要将当前 Pod 对应的 Worker 从持有的  &lt;code>podWorkers&lt;/code>  中删除；PodKiller 其实就是 Kubelet 持有的一个 Goroutine，它会在后台持续运行并监听来自  &lt;code>podKillingCh&lt;/code>  的事件：&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2018-12-25-kubernetes-pod-killer.png" alt="kubernetes-pod-killer">&lt;/p>
&lt;p>经过一系列的方法调用之后，最终调用容器运行时的  &lt;code>killContainersWithSyncResult&lt;/code>  方法，这个方法会同步地杀掉当前 Pod 中全部的容器：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeGenericRuntimeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">killContainersWithSyncResult&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">runningPod&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gracePeriodOverride&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">syncResults&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SyncResult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">containerResults&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SyncResult&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">runningPod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">runningPod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">container&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">killContainerResult&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewSyncResult&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KillContainer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">killContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Need to kill Pod&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gracePeriodOverride&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">containerResults&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">killContainerResult&lt;/span>
&lt;span class="p">}(&lt;/span>&lt;span class="nx">container&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">containerResults&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">containerResult&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">containerResults&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">syncResults&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">syncResults&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerResult&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于每一个容器来说，它们在被停止之前都会先调用  &lt;code>PreStop&lt;/code>  的钩子方法，让容器中的应用程序能够有时间完成一些未处理的操作，随后调用远程的服务停止运行的容器：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeGenericRuntimeManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">killContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerID&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ContainerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerName&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">reason&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gracePeriodOverride&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">containerSpec&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kubecontainer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetContainerSpec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerName&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">gracePeriod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">int64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">minimumGracePeriodInSeconds&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DeletionGracePeriodSeconds&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">gracePeriod&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DeletionGracePeriodSeconds&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TerminationGracePeriodSeconds&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">gracePeriod&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TerminationGracePeriodSeconds&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">executePreStopHook&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">containerSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gracePeriod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">internalLifecycle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">PreStopContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">containerID&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runtimeService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StopContainer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">containerID&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gracePeriod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">containerRefManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ClearRef&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">containerID&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从这个简化版本的  &lt;code>killContainer&lt;/code>  方法中，我们可以大致看出停止运行容器的大致逻辑，先从 Pod 的规格中计算出当前停止所需要的时间，然后运行钩子方法和内部的生命周期方法，最后将容器停止并清除引用。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在这篇文章中，我们已经介绍了 Pod 中的几个重要概念 — 容器、卷和网络以及从创建到删除整个过程是如何实现的。&lt;/p>
&lt;p>Kubernetes 中 Pod 的运行和管理总是与 kubelet 以及它的组件密不可分，后面的文章中也会介绍 kubelet 究竟是什么，它在整个 Kubernetes 中扮演什么样的角色。&lt;/p></description></item><item><title>K8S之Volume原理</title><link>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E4%B9%8Bvolume%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 30 Apr 2022 00:25:08 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/k8s/k8s%E4%B9%8Bvolume%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="k8s之volume原理">K8S之Volume原理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消息队列等等。&lt;/p>
&lt;p>然而 Kubernetes 中的每一个容器随时都可能因为某些原因而被删除和重启，容器中的文件也会随着它的删除而丢失，所以我们需要对集群中的某些文件和数据进行『持久化』；除此之外，由于同一个 Pod 中的多个 Container 可能也会有共享文件的需求，比如通过共享文件目录的方式为 nginx 生成需要代理的静态文件，所以我们需要一种方式来解决这两个问题。&lt;/p>
&lt;p>作为 Kubernetes 集群中除了 Pod 和 Service 之外最常见的基本对象，Volume 不仅能够解决 Container 中文件的临时性问题，也能够让同一个 Pod 中的多个 Container 共享文件&lt;/p>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>Kubernetes 中的 Volume 种类非常多，它不仅要支持临时的、易失的磁盘文件，还需要解决持久存储的问题；第一个问题往往都比较容易解决，后者作为持久存储在很多时候都需要与云服务商提供的存储方案打交道，如果是 Kubernetes 中已经支持的存储类型倒是还好，遇到不支持的类型还是比较麻烦的。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-storage.png" alt="kubernetes-storage">&lt;/p>
&lt;p>除了卷和持久卷之外，Kubernetes 还有另外一种更加复杂的概念 - 动态存储供应，它能够允许存储卷按需进行创建，不再需要集群的管理员手动调用云服务商提供的接口或者界面创建新的存储卷。&lt;/p>
&lt;p>集群中的每一个卷在被 Pod 使用时都会经历四个操作，也就是附着（Attach）、挂载（Mount）、卸载（Unmount）和分离（Detach）。&lt;/p>
&lt;p>如果 Pod 中使用的是 EmptyDir、HostPath 这种类型的卷，那么这些卷并不会经历附着和分离的操作，它们只会被挂载和卸载到某一个的 Pod 中，不过如果使用的云服务商提供的存储服务，这些持久卷只有附着到某一个节点之后才可以被挂在到相应的目录下，不过在其他节点使用这些卷时，该存储资源也需要先与当前的节点分离。&lt;/p>
&lt;h3 id="卷">卷&lt;/h3>
&lt;p>在这一节中提到的卷（Volume）其实是一个比较特定的概念，它并不是一个持久化存储，可能会随着 Pod 的删除而删除，常见的卷就包括 EmptyDir、HostPath、ConfigMap 和 Secret，这些卷与所属的 Pod 具有相同的生命周期，它们可以通过如下的方式挂载到 Pod 下面的某一个目录中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.gcr.io/busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/cache&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/hostpath&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">config-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/configmap&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">special-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hostpath-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data/hostpath&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Directory&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">config-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">configMap&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">special-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要注意的是，当我们将 ConfigMap 或者 Secret 『包装』成卷并挂载到某个目录时，我们其实创建了一些新的 Volume，这些 Volume 并不是 Kubernetes 中的对象，它们只存在于当前 Pod 中，随着 Pod 的删除而删除，但是需要注意的是这些『临时卷』的删除并不会导致相关 &lt;code>ConfigMap&lt;/code> 或者 &lt;code>Secret&lt;/code> 对象的删除。&lt;/p>
&lt;p>从上面我们其实可以看出 Volume 没有办法脱离 Pod 而生存，它与 Pod 拥有完全相同的生命周期，而且它们也不是 Kubernetes 对象，所以 Volume 的主要作用还是用于跨节点或者容器对数据进行同步和共享。&lt;/p>
&lt;h3 id="持久卷">持久卷&lt;/h3>
&lt;p>临时的卷没有办法解决数据持久存储的问题，想要让数据能够持久化，首先就需要将 Pod 和卷的声明周期分离，这也就是引入持久卷 &lt;code>PersistentVolume(PV)&lt;/code> 的原因。我们可以将 &lt;code>PersistentVolume&lt;/code> 理解为集群中资源的一种，它与集群中的节点 Node 有些相似，PV 为 Kubernete 集群提供了一个如何提供并且使用存储的抽象，与它一起被引入的另一个对象就是 &lt;code>PersistentVolumeClaim(PVC)&lt;/code>，这两个对象之间的关系与节点和 Pod 之间的关系差不多：&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-pv-and-pvc.png" alt="kubernetes-pv-and-pvc">&lt;/p>
&lt;p>&lt;code>PersistentVolume&lt;/code> 是集群中的一种被管理员分配的存储资源，而 &lt;code>PersistentVolumeClaim&lt;/code> 表示用户对存储资源的申请，它与 Pod 非常相似，PVC 消耗了持久卷资源，而 Pod 消耗了节点上的 CPU 和内存等物理资源。&lt;/p>
&lt;p>因为 PVC 允许用户消耗抽象的存储资源，所以用户需要不同类型、属性和性能的 PV 就是一个比较常见的需求了，在这时我们可以通过 &lt;code>StorageClass&lt;/code> 来提供不同种类的 PV 资源，上层用户就可以直接使用系统管理员提供好的存储类型。&lt;/p>
&lt;h4 id="访问模式">访问模式&lt;/h4>
&lt;p>Kubernetes 中的 PV 提供三种不同的访问模式，分别是 &lt;code>ReadWriteOnce&lt;/code>、&lt;code>ReadOnlyMany&lt;/code> 和 &lt;code>ReadWriteMany&lt;/code>，这三种模式的含义和用法我们可以通过它们的名字推测出来：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ReadWriteOnce&lt;/code> 表示当前卷可以被一个节点使用读写模式挂载；&lt;/li>
&lt;li>&lt;code>ReadOnlyMany&lt;/code> 表示当前卷可以被多个节点使用只读模式挂载；&lt;/li>
&lt;li>&lt;code>ReadWriteMany&lt;/code> 表示当前卷可以被多个节点使用读写模式挂载；&lt;/li>
&lt;/ul>
&lt;p>不同的卷插件对于访问模式其实有着不同的支持，AWS 上的 &lt;code>AWSElasticBlockStore&lt;/code> 和 GCP 上的 &lt;code>GCEPersistentDisk&lt;/code> 就只支持 &lt;code>ReadWriteOnce&lt;/code> 方式的挂载，不能同时挂载到多个节点上，但是 &lt;code>CephFS&lt;/code> 就同时支持这三种访问模式。&lt;/p>
&lt;h4 id="回收策略">回收策略&lt;/h4>
&lt;p>当某个服务使用完某一个卷之后，它们会从 apiserver 中删除 PVC 对象，这时 Kubernetes 就需要对卷进行回收（Reclaim），持久卷也同样包含三种不同的回收策略，这三种回收策略会指导 Kubernetes 选择不同的方式对使用过的卷进行处理。&lt;/p>
&lt;p>&lt;img src="https://img.draveness.me/2019-01-14-kubernetes-pv-reclaiming-strategy.png" alt="kubernetes-pv-reclaiming-strategy">&lt;/p>
&lt;p>第一种回收策略就是保留（Retain）PV 中的数据，如果希望 PV 能够被重新使用，系统管理员需要删除被使用的 &lt;code>PersistentVolume&lt;/code> 对象并手动清除存储和相关存储上的数据。&lt;/p>
&lt;p>另一种常见的回收策略就是删除（Delete），当 PVC 被使用者删除之后，如果当前卷支持删除的回收策略，那么 PV 和相关的存储会被自动删除，如果当前 PV 上的数据确实不再需要，那么将回收策略设置成 Delete 能够节省手动处理的时间并快速释放无用的资源。&lt;/p>
&lt;h4 id="存储供应">存储供应&lt;/h4>
&lt;p>Kubernetes 集群中包含了很多的 PV 资源，而 PV 资源有两种供应的方式，一种是静态的，另一种是动态的，静态存储供应要求集群的管理员预先创建一定数量的 PV，然后使用者通过 PVC 的方式对 PV 资源的使用进行声明和申请；但是当系统管理员创建的 PV 对象不能满足使用者的需求时，就会进入动态存储供应的逻辑，供应的方式是基于集群中的 &lt;code>StorageClass&lt;/code> 对象，当然这种动态供应的方式也可以通过配置进行关闭。&lt;/p>
&lt;h2 id="管理">管理&lt;/h2>
&lt;p>Volume 的创建和管理在 Kubernetes 中主要由卷管理器 &lt;code>VolumeManager&lt;/code> 和 &lt;code>AttachDetachController&lt;/code> 和 &lt;code>PVController&lt;/code> 三个组件负责。其中卷管理器会负责卷的创建和管理的大部分工作，而 &lt;code>AttachDetachController&lt;/code> 主要负责对集群中的卷进行 Attach 和 Detach，&lt;code>PVController&lt;/code> 负责处理持久卷的变更，文章接下来的内容会详细介绍这几部分之间的关系、工作原理以及它们是如何协作的。&lt;/p>
&lt;h3 id="kubelet">kubelet&lt;/h3>
&lt;p>作者在 &lt;a href="https://draveness.me/kubernetes-pod">详解 Kubernetes Pod 的实现原理&lt;/a> 一文中曾简单介绍过 kubelet 和 Pod 的关系，前者会负责后者的创建和管理，kubelet 中与 Pod 相关的信息都是从 apiserver 中获取的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
apiserver-.-&amp;gt;u
u((updates))-.-&amp;gt;kubelet
kubelet-.-&amp;gt;podWorkers
podWorkers-.-&amp;gt;worker1
podWorkers-.-&amp;gt;worker2
style u fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>两者的通信会使用一个 &lt;code>kubetypes.PodUpdate&lt;/code> 类型的 Channel，kubelet 从 apiserver 中获取 Pod 时也会通过字段过滤器 &lt;code>fields.OneTermEqualSelector(api.PodHostField, string(nodeName))&lt;/code> 仅选择被调度到 kubelet 所在节点上的 Pod：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewSourceApiserver&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span> &lt;span class="nx">clientset&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Interface&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">nodeName&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NodeName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">updates&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">lw&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewListWatchFromClient&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CoreV1&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">RESTClient&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="s">&amp;#34;pods&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NamespaceAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fields&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">OneTermEqualSelector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">api&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodHostField&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nodeName&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="nf">newSourceApiserverFromLW&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">lw&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">updates&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所有对 Pod 的变更最终都会通知给具体的 PodWorker，这些 Worker 协程会调用 kubelet &lt;code>syncPod&lt;/code> 函数完成对 Pod 的同步：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant PW as PodWorker
participant K as Kubelet
participant VL as VolumeManager
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
PW-&amp;gt;&amp;gt;+K: syncPod
K-&amp;gt;&amp;gt;+VL: WaitForAttachAndMount
VL-xDSOWP: ReprocessPod
loop verifyVolumesMounted
VL-&amp;gt;&amp;gt;+ASOW: getUnmountedVolumes
ASOW--&amp;gt;&amp;gt;-VL: Volumes
end
VL--&amp;gt;&amp;gt;-K: Attached/Timeout
K--&amp;gt;&amp;gt;-PW: return
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在一个 100 多行的 &lt;code>syncPod&lt;/code> 方法中，kubelet 会调用 &lt;code>WaitForAttachAndMount&lt;/code> 方法，等待某一个 Pod 中的全部卷已经被成功地挂载：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">kl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Kubelet&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">o&lt;/span> &lt;span class="nx">syncPodOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">o&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">podIsTerminated&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumeManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WaitForAttachAndMount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法会将当前的 Pod 加入需要重新处理卷挂载的队列并在循环中持续调用 &lt;code>verifyVolumesMounted&lt;/code> 方法来比较期望挂载的卷和实际挂载卷的区别，这个循环会等待两者变得完全相同或者超时后才会返回，当前方法的返回一般也意味着 Pod 中的全部卷已经挂载成功了。&lt;/p>
&lt;h3 id="卷管理器">卷管理器&lt;/h3>
&lt;p>当前节点卷的管理就都是由 &lt;code>VolumeManager&lt;/code> 来负责了，在 Kubernetes 集群中的每一个节点（Node）上的 kubelet 启动时都会运行一个 &lt;code>VolumeManager&lt;/code> Goroutine，它会负责在当前节点上的 Pod 和 Volume 发生变动时对 Volume 进行挂载和卸载等操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph TD
subgraph Node
VolumeManager-.-&amp;gt;Kubelet
DesiredStateOfWorldPopulator-.-&amp;gt;VolumeManager
Reconciler-.-&amp;gt;VolumeManager
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个组件会在运行时启动两个 Goroutine 来管理节点中的卷，其中一个是 &lt;code>DesiredStateOfWorldPopulator&lt;/code>，另一个是 &lt;code>Reconciler&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
VM(VolumeManager)-. run .-&amp;gt;R(Reconciler)
VM-. run .-&amp;gt;DSWP(DesiredStateOfWorldPopulator)
DSWP-. update .-&amp;gt;DSW[DesiredStateOfWorld]
ASW[ActualStateOfWorld]-. get .-&amp;gt;DSWP
DSW-. get .-&amp;gt;R
R-. update .-&amp;gt;ASW
DSWP-. getpods .-&amp;gt;PodManager
style ASW fill:#fffede,stroke:#ebebb7
style DSW fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如上图所示，这里的 &lt;code>DesiredStateOfWorldPopulator&lt;/code> 和 &lt;code>Reconciler&lt;/code> 两个 Goroutine 会通过图中两个的 &lt;code>XXXStateOfWorld&lt;/code> 状态进行通信，&lt;code>DesiredStateOfWorldPopulator&lt;/code> 主要负责从 Kubernetes 节点中获取新的 Pod 对象并更新 &lt;code>DesiredStateOfWorld&lt;/code> 结构；而后者会根据实际状态和当前状态的区别对当前节点的状态进行迁移，也就是通过 &lt;code>DesiredStateOfWorld&lt;/code> 中状态的变更更新 &lt;code>ActualStateOfWorld&lt;/code> 中的内容。&lt;/p>
&lt;p>卷管理器中的两个 Goroutine，一个根据工程师的需求更新节点的期望状态 &lt;code>DesiredStateOfWorld&lt;/code>，另一个 Goroutine 保证节点向期望状态『迁移』，也就是说 &lt;code>DesiredStateOfWorldPopulator&lt;/code> 是卷管理器中的生产者，而 &lt;code>Reconciler&lt;/code> 是消费者，接下来我们会分别介绍这两个 Goroutine 的工作和实现。&lt;/p>
&lt;h4 id="desiredstateofworldpopulator">DesiredStateOfWorldPopulator&lt;/h4>
&lt;p>作为卷管理器中的消费者，&lt;code>DesiredStateOfWorldPopulator&lt;/code> 会根据工程师的请求不断修改当前节点的期望状态，我们可以通过以下的时序图来了解它到底做了哪些工作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant PM as PodManager
participant VPM as VolumePluginManager
loop populatorLoop
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndAddNewPods
DSOWP-&amp;gt;&amp;gt;+ASOW: GetMountedVolumes
ASOW--&amp;gt;&amp;gt;-DSOWP: mountedVolume
DSOWP-&amp;gt;&amp;gt;+PM: GetPods
PM--&amp;gt;&amp;gt;-DSOWP: pods
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+DSOW: AddPodToVolume
DSOW-&amp;gt;&amp;gt;+VPM: FindPluginBySpec
VPM--&amp;gt;&amp;gt;-DSOW: volumePlugin
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeName
end
deactivate DSOWP
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndRemoveDeletedPods
DSOWP-&amp;gt;&amp;gt;+DSOW: GetVolumesToMount
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeToMount
loop Every Volume
DSOWP-&amp;gt;&amp;gt;+PM: GetPodByUID
PM--&amp;gt;&amp;gt;-DSOWP: pods
DSOWP-&amp;gt;&amp;gt;DSOW: DeletePodFromVolume
end
deactivate DSOWP
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>整个 &lt;code>DesiredStateOfWorldPopulator&lt;/code> 运行在一个大的循环 &lt;code>populatorLoop&lt;/code> 中，当前循环会通过两个方法 &lt;code>findAndAddNewPods&lt;/code> 和 &lt;code>findAndRemoveDeletedPods&lt;/code> 分别获取节点中被添加的新 Pod 或者已经被删除的老 Pod，获取到 Pod 之后会根据当前的状态修改期望状态：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dswp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">desiredStateOfWorldPopulator&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">findAndAddNewPods&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">mountedVolumesForPod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">volumetypes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UniquePodName&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">processedVolumesForFSResize&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewString&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">podManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetPods&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">isPodTerminated&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">continue&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">processPodVolumes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountedVolumesForPod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">processedVolumesForFSResize&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就像时序图和代码中所描述的，&lt;code>DesiredStateOfWorldPopulator&lt;/code> 会从 &lt;code>PodManager&lt;/code> 中获取当前节点中的 Pod，随后调用 &lt;code>processPodVolumes&lt;/code> 方法为将所有的 Pod 对象加入 &lt;code>DesiredStateOfWorld&lt;/code> 结构中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dswp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">desiredStateOfWorldPopulator&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">processPodVolumes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountedVolumesForPod&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">volumetypes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UniquePodName&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">processedVolumesForFSResize&lt;/span> &lt;span class="nx">sets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">uniquePodName&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">util&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetUniquePodName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">podPreviouslyProcessed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">mountsMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">devicesMap&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">makeVolumeMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Containers&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podVolume&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Volumes&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pvc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeGidValue&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">createVolumeSpec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">podVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mountsMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">devicesMap&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">desiredStateOfWorld&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddPodToVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeSpec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podVolume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeGidValue&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">markPodProcessed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">dswp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">actualStateOfWorld&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MarkRemountRequired&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uniquePodName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>findAndAddNewPods&lt;/code> 方法做的主要就是将节点中加入的新 Pod 添加到 &lt;code>DesiredStateOfWorld&lt;/code> 中，而另一个方法 &lt;code>findAndRemoveDeletedPods&lt;/code> 其实也做着类似的事情，它会将已经被删除的节点从 &lt;code>DesiredStateOfWorld&lt;/code> 中剔除，总而言之 &lt;code>DesiredStateOfWorldPopulator&lt;/code> 就是将当前节点的期望状态同步到 &lt;code>DesiredStateOfWorld&lt;/code> 中，等待消费者的处理。&lt;/p>
&lt;h4 id="reconciler">Reconciler&lt;/h4>
&lt;p>&lt;code>VolumeManager&lt;/code> 持有的另一个 Goroutine &lt;code>Reconciler&lt;/code> 会负责对当前节点上的 Volume 进行管理，它在正常运行时会启动 &lt;code>reconcile&lt;/code> 循环，在这个方法中会分三次对当前状态和期望状态不匹配的卷进行卸载、挂载等操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant R as Reconciler
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant OE as OperationExecutor
loop reconcile
R-&amp;gt;&amp;gt;+ASOW: GetMountedVolumes
activate R
ASOW--&amp;gt;&amp;gt;-R: MountedVolumes
R-&amp;gt;&amp;gt;DSOW: PodExistsInVolume
R-&amp;gt;&amp;gt;OE: UnmountVolume
deactivate R
R-&amp;gt;&amp;gt;+DSOW: GetVolumesToMount
activate R
DSOW--&amp;gt;&amp;gt;-R: volumeToMount
R-&amp;gt;&amp;gt;ASOW: PodExistsInVolume
R-&amp;gt;&amp;gt;OE: AttachVolume/MountVolume
deactivate R
R-&amp;gt;&amp;gt;+ASOW: GetUnmountedVolumes
activate R
R-&amp;gt;&amp;gt;DSOW: VolumeExists
R-&amp;gt;&amp;gt;OE: UnmountDevice/DetachVolume
deactivate R
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在当前的循环中首先会保证应该被卸载但是仍然在节点中存在的卷被卸载，然后将应该挂载的卷挂载到合适的位置，最后将设备与节点分离或者卸载，所有挂载和卸载的操作都是通过 &lt;code>OperationExecutor&lt;/code> 完成的，这个结构体负责调用相应的插件执行操作，我们会在文章的后面展开进行介绍。&lt;/p>
&lt;h3 id="附着分离控制器">附着分离控制器&lt;/h3>
&lt;p>除了 &lt;code>VolumeManager&lt;/code> 之外，另一个负责管理 Kubernetes 卷的组件就是 &lt;code>AttachDetachController&lt;/code> 了，引入这个组件的目的主要是：&lt;/p>
&lt;ol>
&lt;li>让卷的挂载和卸载能够与节点的可用性脱离；
&lt;ul>
&lt;li>一旦节点或者 kubelet 宕机，附着（Attach）在当前节点上的卷应该能够被分离（Detach），分离之后的卷就能够再次附着到其他节点上；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>保证云服务商秘钥的安全；
&lt;ul>
&lt;li>如果每一个 kubelet 都需要触发卷的附着和分离逻辑，那么每一个节点都应该有操作卷的权限，但是这些权限应该只由主节点掌握，这样能够降低秘钥泄露的风险；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>提高卷附着和分离部分代码的稳定性；&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>这些内容都是在 Kubernetes 官方项目的 GitHub issue &lt;a href="https://github.com/kubernetes/kubernetes/issues/20262">Detailed Design for Volume Attach/Detach Controller #20262&lt;/a> 中讨论的，想要了解 &lt;code>AttachDetachController&lt;/code> 出现的原因可以阅读相关的内容。&lt;/p>
&lt;/blockquote>
&lt;p>每一个 &lt;code>AttachDetachController&lt;/code> 其实也包含 &lt;code>Reconciler&lt;/code> 和 &lt;code>DesiredStateOfWorldPopulator&lt;/code> 两个组件，这两个组件虽然与 &lt;code>VolumeManager&lt;/code> 中的两个组件重名，实现的功能也非常类似，与 &lt;code>VolumeManager&lt;/code> 具有几乎相同的数据流向，但是这两个 Goroutine 是跑在 Kubernetes 主节点中的，所以实现上可能一些差异：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
ADC(AttachDetachController)-. run .-&amp;gt;R(Reconciler)
ADC-. run .-&amp;gt;DSWP(DesiredStateOfWorldPopulator)
DSWP-. update .-&amp;gt;DSW[DesiredStateOfWorld]
ASW[ActualStateOfWorld]-. get .-&amp;gt;DSWP
DSW-. get .-&amp;gt;R
R-. update .-&amp;gt;ASW
DSWP-. getpods .-&amp;gt;PodManager
style ASW fill:#fffede,stroke:#ebebb7
style DSW fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，无论是 &lt;code>Reconciler&lt;/code> 还是 &lt;code>DesiredStateOfWorldPopulator&lt;/code>，它们同步的就不再只是某个节点上 Pod 的信息了，它们需要对整个集群中的 Pod 对象负责，相关数据也不再是通过 apiserver 拉取了，而是使用 &lt;code>podInformer&lt;/code> 在 Pod 对象发生变更时调用相应的方法。&lt;/p>
&lt;h4 id="desiredstateofworldpopulator-1">DesiredStateOfWorldPopulator&lt;/h4>
&lt;p>作为 &lt;code>AttachDetachController&lt;/code> 启动的 Goroutine，&lt;code>DesiredStateOfWorldPopulator&lt;/code> 的主要作用是从当前集群的状态中获取 Pod 对象并修改 &lt;code>DesiredStateOfWorld&lt;/code> 结构，与 &lt;code>VolumeManager&lt;/code> 中的同名 Goroutine 起到相同的作用，作为整个链路的生产者，它们只是在实现上由于处理 Pod 范围的不同有一些区别：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant DSOWP as DesiredStateOfWorldPopulator
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant PL as PodLister
participant VPM as VolumePluginManager
loop populatorLoopFunc
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndRemoveDeletedPods
DSOWP-&amp;gt;&amp;gt;+DSOW: GetPodToAdd
DSOW--&amp;gt;&amp;gt;-DSOWP: podsToAdd
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+PL: GetPod
alt PodNotFound
PL--&amp;gt;&amp;gt;-DSOWP: return
DSOWP-&amp;gt;&amp;gt;DSOW: DeletePod
else
end
end
deactivate DSOWP
DSOWP-&amp;gt;&amp;gt;+DSOWP: findAndAddActivePods
DSOWP-&amp;gt;&amp;gt;+PL: List
PL--&amp;gt;&amp;gt;-DSOWP: pods
loop Every Pod
DSOWP-&amp;gt;&amp;gt;+VPM: FindAttachablePluginBySpec
VPM--&amp;gt;&amp;gt;-DSOW: attachableVolumePlugin
DSOWP-&amp;gt;&amp;gt;+DSOW: AddPod/DeletePod
DSOW--&amp;gt;&amp;gt;-DSOWP: volumeName
end
deactivate DSOWP
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>AttachDetachController&lt;/code> 中的 &lt;code>DesiredStateOfWorldPopulator&lt;/code> 协程就主要会先处理 Pod 的删除逻辑，添加 Pod 的逻辑都是根据 &lt;code>listPodsRetryDuration&lt;/code> 的设置周期性被触发的，所以从这里我们就能看到 &lt;code>AttachDetachController&lt;/code> 其实主要还是处理被删除 Pod 中 Volume 的分离工作，当节点或者 kubelet 宕机时能够将节点中的卷进行分离，保证 Pod 在其他节点重启时不会出现问题。&lt;/p>
&lt;h4 id="reconciler-1">Reconciler&lt;/h4>
&lt;p>另一个用于调节当前状态与期望状态的 Goroutine 在执行它内部的循环时，也会优先处理分离卷的逻辑，后处理附着卷的工作，整个时序图与 &lt;code>VolumeManager&lt;/code> 中的 &lt;code>Reconciler&lt;/code> 非常相似：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant R as Reconciler
participant ASOW as ActualStateOfWorld
participant DSOW as DesiredStateOfWorld
participant OE as OperationExecutor
loop reconcile
R-&amp;gt;&amp;gt;+ASOW: GetAttachedVolumes
activate R
ASOW--&amp;gt;&amp;gt;-R: attachedVolumes
R-&amp;gt;&amp;gt;+DSOW: VolumeExists
alt VolumeNotExists
DSOW--&amp;gt;&amp;gt;-R: return
R-&amp;gt;&amp;gt;OE: DetachVolume
deactivate R
else
end
R-&amp;gt;&amp;gt;+DSOW: GetVolumesToAttach
activate R
DSOW--&amp;gt;&amp;gt;-R: volumeToAttach
R-&amp;gt;&amp;gt;+ASOW: VolumeNodeExists
alt VolumeNotExists
ASOW--&amp;gt;&amp;gt;-R: return
R-&amp;gt;&amp;gt;OE: AttachVolume
else
end
deactivate R
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里处理的工作其实相对更少一些，&lt;code>Reconciler&lt;/code> 会将期望状态中的卷与实际状态进行比较，然后分离需要分离的卷、附着需要附着的卷，逻辑非常的清晰和简单。&lt;/p>
&lt;h3 id="持久卷控制器">持久卷控制器&lt;/h3>
&lt;p>作为集群中与 PV 和 PVC 打交道的控制器，持久卷控制器同时运行着三个 Goroutine 用于处理相应的逻辑，其中 &lt;code>Resync&lt;/code> 协程负责从 Kubernetes 集群中同步 PV 和 PVC 的信息，而另外两个工作协程主要负消费队列中的任务：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
PVC(PVController)-.-&amp;gt;R(Resync)
PVC-.-&amp;gt;VW(VolumeWorker)
R-. enqueue .-&amp;gt;VQ(VolumeQueue)
R-. enqueue .-&amp;gt;CQ(ClaimQueue)
VQ-. dequeue .-&amp;gt;VW
CQ-. dequeue .-&amp;gt;CW
PVC-.-&amp;gt;CW(ClaimWorker)
style VQ fill:#fffede,stroke:#ebebb7
style CQ fill:#fffede,stroke:#ebebb7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这两个工作协程主要负责对需要绑定或者解绑的 PV 和 PVC 进行处理，例如，当用户创建了新的 PVC 对象时，从集群中查找该 PVC 选择的 PV 并绑定到当前的 PVC 上。&lt;/p>
&lt;h4 id="volumeworker">VolumeWorker&lt;/h4>
&lt;p>&lt;code>VolumeWorker&lt;/code> 协程中执行的最重要的方法其实就是 &lt;code>syncVolume&lt;/code>，在这个方法中会根据当前 PV 对象的规格对 PV 和 PVC 进行绑定或者解绑：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>
&lt;span class="nx">claimName&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">claimrefToClaimKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">claims&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claimName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">claim&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">claim&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">reclaimVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">claimQueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">claimToClaimKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HasAnnotation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">annDynamicallyProvisioned&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeReclaimPolicy&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeReclaimDelete&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">reclaimVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">unbindVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果当前 PV 没有绑定的 PVC 对象，那么这里的 &lt;code>reclaimVolume&lt;/code> 可能会将当前的 PV 对象根据回收策略将其放回资源池等待重用、回收或者保留；而 &lt;code>unbindVolume&lt;/code> 会删除 PV 与 PVC 之间的关系并更新 apiserver 中保存的 Kubernetes 对象数据。&lt;/p>
&lt;h4 id="claimworker">ClaimWorker&lt;/h4>
&lt;p>&lt;code>ClaimWorker&lt;/code> 就是控制器用来决定如何处理一个 PVC 对象的方法了，它会在一个 PVC 对象被创建、更新或者同步时被触发，&lt;code>syncClaim&lt;/code> 会根据当前对象中的注解决定调用 &lt;code>syncUnboundClaim&lt;/code> 或者 &lt;code>syncBoundClaim&lt;/code> 方法来处理相应的逻辑：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HasAnnotation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">annBindCompleted&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">syncUnboundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">syncBoundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>syncUnboundClaim&lt;/code> 会处理绑定没有结束的 PVC 对象，如果当前 PVC 对象没有对应合适的 PV 存在，那么就会调用 &lt;code>provisionClaim&lt;/code> 尝试从集群中获取新的 PV 供应，如果能够找到 PV 对象，就会通过 &lt;code>bind&lt;/code> 方法将两者绑定：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncUnboundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">shouldDelayBinding&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">findBestMatchForClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">delayBinding&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">v1helper&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetPersistentVolumeClaimClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">provisionClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">found&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">store&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">found&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nf">isVolumeBoundToClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>绑定的过程其实就是将 PV 和 PVC 之间建立起新的关系，更新 Spec 中的数据让两者能够通过引用 Ref 找到另一个对象并将更新后的 Kubernetes 对象存储到 apiserver 中。&lt;/p>
&lt;p>另一个用于绑定 PV 和 PVC 对象的方法就是 &lt;code>syncBoundClaim&lt;/code> 了，相比于 &lt;code>syncUnboundClaim&lt;/code> 方法，该方法的实现更为简单，直接从缓存中尝试获取对应的 PV 对象：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ctrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">PersistentVolumeController&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">syncBoundClaim&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolumeClaim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">found&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volumes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">store&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">VolumeName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">found&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PersistentVolume&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClaimRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctrl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">claim&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果找到了 PV 对象并且该对象没有绑定的 PVC 或者当前 PV 和 PVC 已经存在了引用就会调用 &lt;code>bind&lt;/code> 方法对两者进行绑定。&lt;/p>
&lt;h4 id="小结">小结&lt;/h4>
&lt;p>无论是 &lt;code>VolumeWorker&lt;/code> 还是 &lt;code>ClaimWorker&lt;/code> 最终都可能会通过 apiserver 更新集群中 etcd 的数据，当然它们也会调用一些底层的插件获取新的存储供应、删除或者重用一些持久卷，我们会在下面介绍插件的工作原理。&lt;/p>
&lt;h2 id="插件">插件&lt;/h2>
&lt;p>Kubernetes 中的所有对卷的操作最终基本都是通过 &lt;code>OperationExecutor&lt;/code> 来完成的，这个组件包含了用于附着、挂载、卸载和分离几个常见的操作以及对设备进行操作的一些方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">OperationExecutor&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">AttachVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToAttach&lt;/span> &lt;span class="nx">VolumeToAttach&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldAttacherUpdater&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">DetachVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToDetach&lt;/span> &lt;span class="nx">AttachedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">verifySafeToDetach&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldAttacherUpdater&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">MountVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">waitForAttachTimeout&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">volumeToMount&lt;/span> &lt;span class="nx">VolumeToMount&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldMounterUpdater&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">isRemount&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">UnmountVolume&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">volumeToUnmount&lt;/span> &lt;span class="nx">MountedVolume&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">actualStateOfWorld&lt;/span> &lt;span class="nx">ActualStateOfWorldMounterUpdater&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podsDir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实现 &lt;code>OperationExecutor&lt;/code> 接口的私有结构体会通过 &lt;code>OperatorGenerator&lt;/code> 来生成一个用于挂载和卸载卷的方法，并将这个方法包装在一个 &lt;code>GeneratedOperations&lt;/code> 结构中，在这之后操作执行器会启动一个新的 Goroutine 用于执行生成好的方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph LR
OE(OperationExexutor)-. 1. 获取相关方法 .-&amp;gt;OG(OperationGenerator)
OG-. 2. 根据 Spec 获取插件 .-&amp;gt;VM(VolumePluginManager)
VM-. 3. 返回 VolumePlugin .-&amp;gt;OG
OG-. 4. 构建方法 .-&amp;gt;OG
OG-. 5. 生成一个 Operation 结构 .-&amp;gt;OE
OE-. 6. 运行 Operation .-&amp;gt;NPO(NestedPendingOperations)
NPO-. 7. 启动 Goroutine 运行生成的方法 .-&amp;gt;Goroutine
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>VolumePluginManager&lt;/code> 和 &lt;code>VolumePlugin&lt;/code> 这两个组件在整个流程中帮我们屏蔽了底层不同类型卷的实现差异，我们能直接在上层调用完全相同的接口，剩下的逻辑都由底层的插件来负责。&lt;/p>
&lt;p>Kubernetes 提供了插件的概念，通过 &lt;code>Volume&lt;/code> 和 &lt;code>Mounter&lt;/code> 两个接口支持卷类型的扩展，作为存储提供商或者不同类型的文件系统，我们都可以通过实现以上的两个接口成为 Kubernetes 存储系统中一个新的存储类型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">VolumePlugin&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">Init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">host&lt;/span> &lt;span class="nx">VolumeHost&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">GetPluginName&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nf">GetVolumeName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">NewMounter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">podRef&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">opts&lt;/span> &lt;span class="nx">VolumeOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">Mounter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Mounter&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Volume&lt;/span>
&lt;span class="nf">CanMount&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">SetUp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nf">GetAttributes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">Attributes&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这一节中我们将介绍几种不同卷插件的实现，包括最常见的 EmptyDir、ConfigMap、Secret 和 Google 云上的 GCEPersistentDisk，这一节会简单介绍不同卷插件的实现方式，想要了解详细实现的读者可以阅读相关的源代码。&lt;/p>
&lt;h3 id="emptydir">EmptyDir&lt;/h3>
&lt;p>EmptyDir 是 Kubernetes 中最简单的卷了，当我们为一个 Pod 设置一个 EmptyDir 类型的卷时，其实就是在当前 Pod 对应的目录创建了一个空的文件夹，这个文件夹会随着 Pod 的删除而删除。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">emptyDir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">setupDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volume&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetVolumeOwnership&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">volumeutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetReady&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getMetaDir&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ed&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">emptyDir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">setupDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MkdirAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">perm&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>SetUpAt&lt;/code> 方法其实就实现了对这种类型卷的创建工作，每当 Pod 被分配到了某个节点上，对应的文件目录就会通过 &lt;code>MkdirAll&lt;/code> 方法创建，如果使用者配置了 medium 字段，也会选择使用相应的文件系统挂载到当前目录上，例如：tmpfs、nodev 等。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-pd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.gcr.io/test-webserver&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/cache&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cache-volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">emptyDir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们经常会使用 EmptyDir 类型的卷在多个容器之间共享文件、充当缓存或者保留一些临时的日志，总而言之，这是一种经常被使用的卷类型。&lt;/p>
&lt;h3 id="configmap-和-secret">ConfigMap 和 Secret&lt;/h3>
&lt;p>另一种比较常见的卷就是 ConfigMap 了，首先，ConfigMap 本身就是 Kubernetes 中常见的对象了，其中的 &lt;code>data&lt;/code> 就是一个存储了从文件名到文件内容的字段，这里的 ConfigMap 对象被挂载到文件目录时就会创建一个名为 &lt;code>redis-config&lt;/code> 的文件，然后将文件内容写入该文件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ConfigMap&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">redis-config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">maxmemory 2mb maxmemory-policy allkeys-lru&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在对 ConfigMap 类型的卷进行挂载时，总共需要完成三部分工作，首先从 apiserver 中获取当前 ConfigMap 对象，然后根据当前的 ConfigMap 生成一个从文件名到文件内容的键值对，最后构造一个 Writer 并执行 &lt;code>Write&lt;/code> 方法写入内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">configMapVolumeMounter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">SetUpAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fsGroup&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">configMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getConfigMap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">totalBytes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">totalBytes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">configMap&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">payload&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">MakePayload&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">configMap&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultMode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writerContext&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;pod %v/%v volume %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pod&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">volName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">volumeutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewAtomicWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">writerContext&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">writer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">payload&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在涉及挂载的函数几个中，作者想要着重介绍的也就是在底层直接与文件系统打交道的 &lt;code>writePayloadToDir&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">AtomicWriter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">writePayloadToDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">payload&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">FileProjection&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">userVisiblePath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fileProjection&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">payload&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">content&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">fileProjection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Data&lt;/span>
&lt;span class="nx">mode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">FileMode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fileProjection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">fullPath&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">path&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">userVisiblePath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">baseDir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MkdirAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">baseDir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ModePerm&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">content&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Chmod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fullPath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法使用了 &lt;code>os&lt;/code> 包提供的接口完成了拼接文件名、创建相应文件目录、写入文件并且修改文件模式的工作，将 ConfigMap &lt;code>data&lt;/code> 中的数据映射到了一个文件夹中，达到了让 Pod 中的容器可以直接通过文件系统获取内容的目的。&lt;/p>
&lt;p>对于另一个非常常见的卷类型 Secret，Kubernetes 其实也做了几乎完全相同的工作，也是先获取 Secret 对象，然后构建最终写入到文件的键值对，最后初始化一个 Writer 并调用它的 &lt;code>Write&lt;/code> 方法，从这里我们也能看出在卷插件这一层对于 ConfigMap 和 Secret 的处理几乎完全相同，并没有出现需要对 Secret 对象中的内容进行解密的工作。&lt;/p>
&lt;h3 id="gcepersistentdisk">GCEPersistentDisk&lt;/h3>
&lt;p>最后一个要介绍的卷与上面的几种都非常的不同，它在底层使用的是云服务商提供的网络磁盘，想要在一个节点上使用云磁盘其实总共需要两个步骤，首先是要将云磁盘附着到当前的节点上，这部分的工作其实就是由 &lt;code>gcePersistentDiskAttacher&lt;/code> 完成的，每当调用 &lt;code>AttachDisk&lt;/code> 方法时，最终都会执行云服务商提供的接口，将磁盘附着到相应的节点实例上：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant GPDA as gcePersistentDiskAttacher
participant C as Cloud
participant GCESM as gceServiceManager
participant I as GCEInstances
GPDA-&amp;gt;&amp;gt;+C: DiskIsAttached
alt NotAttached
C--&amp;gt;&amp;gt;-GPDA: return NotAttached
GPDA-&amp;gt;&amp;gt;+C: AttachDisk
C-&amp;gt;&amp;gt;+GCESM: AttachDiskOnCloudProvider
GCESM-&amp;gt;&amp;gt;+I: AttachDisk
I--&amp;gt;&amp;gt;-GCESM: return
GCESM--&amp;gt;&amp;gt;-C: return
C--&amp;gt;&amp;gt;-GPDA: return
else
end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在方法的的最后会将该请求包装成一个 HTTP 的方法调用向 &lt;code>https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/instances/{resourceId}/attachDisk&lt;/code> 链接发出一个 POST 请求，这个请求会将某个 GCE 上的磁盘附着到目标实例上，详细的内容可以阅读 &lt;a href="https://cloud.google.com/compute/docs/reference/rest/v1/instances/attachDisk">相关文档&lt;/a>。&lt;/p>
&lt;p>一旦当前的磁盘被附着到了当前节点上，我们就能跟使用其他的插件一样，把磁盘挂载到某个目录上，完成从附着到挂载的全部操作。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Volume 和存储系统是 Kubernetes 非常重要的一部分，它能够帮助我们在多个容器之间共享文件，同时也能够为集群提供持久存储的功能，假如 Kubernetes 没有用于持久存储的对象，我们也很难在集群中运行有状态的服务，例如：消息队列、分布式存储等。&lt;/p>
&lt;p>对于刚刚使用 Kubernetes 的开发者来说，Volume、PV 和 PVC 确实是比较难以理解的概念，但是这却是深入使用 Kubernetes 必须要了解和掌握的，希望这篇文章能够帮助各位读者更好地理解存储系统底层的实现原理。&lt;/p></description></item><item><title>字符串解码</title><link>https://justice.bj.cn/post/leetcode/doc/394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link><pubDate>Sat, 30 Apr 2022 00:25:08 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid><description>&lt;h1 id="字符串解码httpsleetcode-cncomproblemsdecode-stringdescription-httpsleetcode-cncomproblemsdecode-stringdescription">&lt;a href="https://leetcode-cn.com/problems/decode-string/description/" title="https://leetcode-cn.com/problems/decode-string/description/">字符串解码&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Medium (56.01%)&lt;/td>
&lt;td>1124&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/stack" title="https://leetcode.com/tag/stack">&lt;code>stack&lt;/code>&lt;/a> | &lt;a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search">&lt;code>depth-first-search&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>google&lt;/code> | &lt;code>yelp&lt;/code>&lt;/p>
&lt;p>给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p>
&lt;p>编码规则为: &lt;code>k[encoded_string]&lt;/code>，表示其中方括号内部的 &lt;code>encoded_string&lt;/code> 正好重复 &lt;code>k&lt;/code> 次。注意 &lt;code>k&lt;/code> 保证为正整数。&lt;/p>
&lt;p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/p>
&lt;p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 &lt;code>k&lt;/code> ，例如不会出现像 &lt;code>3a&lt;/code> 或 &lt;code>2[4]&lt;/code> 的输入。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;3[a]2[bc]&amp;#34;
输出：&amp;#34;aaabcbc&amp;#34;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;3[a2[c]]&amp;#34;
输出：&amp;#34;accaccacc&amp;#34;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;2[abc]3[cd]ef&amp;#34;
输出：&amp;#34;abcabccdcdcdef&amp;#34;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 4：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：s = &amp;#34;abc3[cd]xyz&amp;#34;
输出：&amp;#34;abccdcdcdxyz&amp;#34;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= s.length &amp;lt;= 30&lt;/code>&lt;/li>
&lt;li>&lt;code>s&lt;/code> 由小写英文字母、数字和方括号 &lt;code>'[]'&lt;/code> 组成&lt;/li>
&lt;li>&lt;code>s&lt;/code> 保证是一个 &lt;strong>有效&lt;/strong> 的输入。&lt;/li>
&lt;li>&lt;code>s&lt;/code> 中所有整数的取值范围为 &lt;code>[1, 300]&lt;/code> &lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/decode-string/comments/" title="https://leetcode-cn.com/problems/decode-string/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode-cn.com/problems/decode-string/solution/" title="https://leetcode-cn.com/problems/decode-string/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * ## 解题思路
&lt;/span>&lt;span class="cm"> * * 深度遍历
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">decodeString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> * 递归decode
&lt;/span>&lt;span class="cm"> * s: 待decode的字符串， 使用引用可避免多余的拷贝；
&lt;/span>&lt;span class="cm"> * i: 当前decode的起始字符下标，需要将i值返回到调用上级，所以使用引用；
&lt;/span>&lt;span class="cm"> * 返回：从i开始的decode字符串；
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="nf">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">repeat&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="sc">&amp;#39;9&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">repeat&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">repeat&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;[&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">subs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">repeat&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">subs&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">repeat&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;]&amp;#39;&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Docker基础</title><link>https://justice.bj.cn/post/32.cloudnative/docker%E5%9F%BA%E7%A1%80/</link><pubDate>Fri, 29 Apr 2022 23:24:04 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/docker%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="docker基础">Docker基础&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>docker是一个开源的应用容器引擎，基于go语言开发并遵循了apache2.0协议开源。&lt;/p>
&lt;p>docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux服务器，也可以实现虚拟化。&lt;/p>
&lt;p>容器是完全使用沙箱机制，相互之间不会有任何接口（类iphone的app），并且容器开销极其低。&lt;/p>
&lt;h3 id="容器和虚拟机">容器和虚拟机&lt;/h3>
&lt;p>容器时在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。&lt;/p>
&lt;p>虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。&lt;/p>
&lt;p> &lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQh5SJzVziaQ5Zhib5Z2hlSNS1xwjicXK5fra81kibukKyz2K8ZYRmBrtGdQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;h3 id="8容器在内核中支持2种重要技术">&lt;strong>8、容器在内核中支持2种重要技术&lt;/strong>&lt;/h3>
&lt;p>docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）&lt;/p>
&lt;p>1）namespaces 名称空间&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQiaXAsDznWiaTVMEgH9l7wg603nZJ7ia0yib2AtrvNwfLMIDWg1raSTBSBQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p> 2）control Group 控制组&lt;/p>
&lt;p>cgroup的特点是：　&lt;/p>
&lt;ul>
&lt;li>
&lt;p>cgroup的api以一个伪文件系统的实现方式，用户的程序可以通过文件系统实现cgroup的组件管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup的组件管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源载分配和再利用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有资源管理的功能都以子系统的方式实现，接口统一子任务创建之初与其父任务处于同一个cgroup的控制组&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>四大功能：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>资源限制：可以对任务使用的资源总额进行限制&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级&lt;/p>
&lt;/li>
&lt;li>
&lt;p>资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任务控制：cgroup可以对任务执行挂起、恢复等操作&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="heading">&lt;/h3>
&lt;h2 id="重要概念">重要概念&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>image镜像：docker镜像就是一个只读模板，比如，一个镜像可以包含一个完整的centos，里面仅安装apache或用户的其他应用，镜像可以用来创建docker容器，另外docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下周一个已经做好的镜像来直接使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>container容器：docker利用容器来运行应用，容器是从镜像创建的运行实例，它可以被启动，开始、停止、删除、每个容器都是互相隔离的，保证安全的平台，可以吧容器看做是要给简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行再其中的应用程序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>repostory仓库：仓库是集中存储镜像文件的沧桑，registry是仓库主从服务器，实际上参考注册服务器上存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>仓库分为两种，公有参考，和私有仓库，最大的公开仓库是docker Hub，存放了数量庞大的镜像供用户下周，国内的docker pool，这里仓库的概念与Git类似，registry可以理解为github这样的托管服务&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;h3 id="1总体架构">&lt;strong>1、总体架构&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQP05SZIegcKiaLYoSNMNVAKLiaGdaTWNg6u4bUdvcuNWcvusCkZ7wvibuA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>distribution 负责与docker registry交互，上传洗澡镜像以及v2 registry 有关的源数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>registry负责docker registry有关的身份认证、镜像查找、镜像验证以及管理registry mirror等交互操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>image 负责与镜像源数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>reference负责存储本地所有镜像的repository和tag名，并维护与镜像id之间的映射关系&lt;/p>
&lt;/li>
&lt;li>
&lt;p>layer模块负责与镜像层和容器层源数据有关的增删改查，并负责将镜像层的增删改查映射到实际存储镜像层文件的graphdriver模块&lt;/p>
&lt;/li>
&lt;li>
&lt;p>graghdriver是所有与容器镜像相关操作的执行者&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="2docker架构2">&lt;strong>2、docker架构2&lt;/strong>&lt;/h3>
&lt;p>如果觉得上面架构图比较乱可以看这个架构：&lt;/p>
&lt;h3 id="httpsmmbizqpiccnmmbiz_jpgicnyeyk3vqgm9yicn3viaynt53xk9vanziqbqbbbiugyerdnepf9jkodiafzjgqg9zmxi0qy0empg0iaonaicmdy5vqq640wx_fmtjpegtpwebpwxfrom5wx_lazy1wx_co1">&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQbQbBBIUgYerDNepf9jkoDiafzJGQg9zMXI0qY0eMPg0iaoNaicMDY5VQQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/h3>
&lt;p>从上图不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。&lt;/p>
&lt;p>而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。&lt;/p>
&lt;p>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。&lt;/p>
&lt;p>而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。&lt;/p>
&lt;h3 id="3docker架构3">&lt;strong>3、docker架构3&lt;/strong>&lt;/h3>
&lt;p>再来看看另外一个架构，这个个架构就简单清晰指明了server/client交互，容器和镜像、数据之间的一些联系。&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQPo5rennpNHVZaT2ceMmGrP5icFBVD94LiaP15ib8L2zHVIj0kkpyvy87A/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>这个架构图更加清晰了架构&lt;/p>
&lt;p>docker daemon就是docker的守护进程即server端，可以是远程的，也可以是本地的，这个不是C/S架构吗，客户端Docker client 是通过rest api进行通信。&lt;/p>
&lt;p>docker cli 用来管理容器和镜像，客户端提供一个只读镜像，然后通过镜像可以创建多个容器，这些容器可以只是一个RFS（Root file system根文件系统），也可以ishi一个包含了用户应用的RFS，容器再docker client中只是要给进程，两个进程之间互不可见。&lt;/p>
&lt;p>用户不能与server直接交互，但可以通过与容器这个桥梁来交互，由于是操作系统级别的虚拟技术，中间的损耗几乎可以不计。&lt;/p>
&lt;h2 id="三docker架构2各个模块的功能带完善">&lt;strong>三、docker架构2各个模块的功能（带完善）&lt;/strong>&lt;/h2>
&lt;p>主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。　　　&lt;/p>
&lt;h3 id="heading-1">&lt;/h3>
&lt;h3 id="1docker-client">&lt;strong>1、docker client&lt;/strong>&lt;/h3>
&lt;p>docker client 是docker架构中用户用来和docker daemon建立通信的客户端，用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。&lt;/p>
&lt;p>docker client可以通过一下三宗方式和docker daemon建立通信：tcp://host:port;unix:path_to_socket;fd://socketfd。，docker client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性&lt;/p>
&lt;p>docker client发送容器管理请求后，由docker daemon接受并处理请求，当docker client 接收到返回的请求相应并简单处理后，docker client 一次完整的生命周期就结束了，当需要继续发送容器管理请求时，用户必须再次通过docker可以执行文件创建docker client。&lt;/p>
&lt;h3 id="heading-2">&lt;/h3>
&lt;h3 id="2docker-daemon">&lt;strong>2、docker daemon&lt;/strong>&lt;/h3>
&lt;p>docker daemon 是docker架构中一个常驻在后台的系统进程，功能是：接收处理docker client发送的请求。该守护进程在后台启动一个server，server负载接受docker client发送的请求；接受请求后，server通过路由与分发调度，找到相应的handler来执行请求。&lt;/p>
&lt;p>docker daemon启动所使用的可执行文件也为docker，与docker client启动所使用的可执行文件docker相同，在docker命令执行时，通过传入的参数来判别docker daemon与docker client。&lt;/p>
&lt;p>docker daemon的架构可以分为：docker server、engine、job。daemon&lt;/p>
&lt;h3 id="heading-3">&lt;/h3>
&lt;h3 id="3docker-server">&lt;strong>3、docker server&lt;/strong>&lt;/h3>
&lt;p>docker server在docker架构中时专门服务于docker client的server，该server的功能时：接受并调度分发docker client发送的请求，架构图如下：&lt;/p>
&lt;p>&lt;img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="">&lt;/p>
&lt;p>在Docker的启动过程中，通过包gorilla/mux（golang的类库解析），创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。&lt;/p>
&lt;p>若Docker Client通过HTTP的形式访问Docker Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。&lt;/p>
&lt;p>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。&lt;/p>
&lt;p>需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。&lt;/p>
&lt;h3 id="heading-4">&lt;/h3>
&lt;h3 id="4engine">&lt;strong>4、engine&lt;/strong>&lt;/h3>
&lt;p>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。&lt;/p>
&lt;p>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler。&lt;/p>
&lt;h3 id="heading-5">&lt;/h3>
&lt;h3 id="5job">&lt;strong>5、job&lt;/strong>&lt;/h3>
&lt;p>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。&lt;/p>
&lt;p>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。&lt;/p>
&lt;h3 id="heading-6">&lt;/h3>
&lt;h3 id="6docker-registry">&lt;strong>6、docker registry&lt;/strong>&lt;/h3>
&lt;p>Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。&lt;/p>
&lt;p>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。&lt;/p>
&lt;p>其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成。&lt;/p>
&lt;h3 id="heading-7">&lt;/h3>
&lt;h3 id="7graph">&lt;strong>7、Graph&lt;/strong>&lt;/h3>
&lt;p>Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。&lt;/p>
&lt;p>Graph的架构如下：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQDticrbs6fTR1ZvAvK5ufFO1MicOjiaClM6SIXpA2EiaFqhBvjlnzdhb4YQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。&lt;/p>
&lt;p>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。&lt;/p>
&lt;p>&lt;strong>8、driver&lt;/strong>&lt;/p>
&lt;p>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。&lt;/p>
&lt;p>在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。&lt;/p>
&lt;p>graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。&lt;/p>
&lt;p>在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。&lt;/p>
&lt;p>graphdriver的架构如下：&lt;/p>
&lt;p>&lt;img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="">&lt;/p>
&lt;p>networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如下：&lt;/p>
&lt;p>&lt;img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="">&lt;/p>
&lt;p>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如下：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQ2mENqgVLbqicwOZs40ibSm9FbCu5GKiaM7VicliaNWKKH1WYm4ibfkh8V98w/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;h3 id="9libcontainer">&lt;strong>9、libcontainer&lt;/strong>&lt;/h3>
&lt;p>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。&lt;/p>
&lt;p>正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如下：&lt;/p>
&lt;p>&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icNyEYk3VqGm9yicn3ViaynT53XK9VanZIQgial97GT7cIBa4wxBXwhKicjoH7PnjMx6bNFtavDz6jSjofmwEYRw9TA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1" alt="">&lt;/p>
&lt;p>另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。&lt;/p>
&lt;p>暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。&lt;/p>
&lt;h3 id="heading-8">&lt;/h3>
&lt;h3 id="10docker-container">&lt;strong>10、docker container&lt;/strong>&lt;/h3>
&lt;p>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。&lt;/p>
&lt;p>Docker按照用户的需求与指令，订制相应的Docker容器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户通过指定运行的命令，使得Docker容器执行指定的工作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="">&lt;/p>
&lt;h2 id="四docker简单使用">&lt;strong>四、docker简单使用&lt;/strong>&lt;/h2>
&lt;h3 id="1安装">&lt;strong>1、安装&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">yum install docker -ysystemctl enable dockersystemctl start docker
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意：启动前应当设置源&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">vim /usr/lib/systemd/system/docker.service
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>2、docker版本查询&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 ~]# docker version
Client:Version: 1.13.1
API version: 1.26
Package version: docker-1.13.1-96.gitb2f74b2.el7.centos.x86_64
Go version: go1.10.3
Git commit: b2f74b2/1.13.1
Built: Wed May 1 14:55:20 2019OS/
Arch: linux/amd64
Server:Version: 1.13.1
API version: 1.26 (minimum version 1.12)
Package version: docker-1.13.1-96.gitb2f74b2.el7.centos.x86_64
Go version: go1.10.3
Git commit: b2f74b2/1.13.1
Built: Wed May 1 14:55:20 2019OS/
Arch: linux/amd64
Experimental: false
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>3、搜索下载镜像&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">docker pull alpine    #下载镜像
docker search nginx   #查看镜像docker pull nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4查看已经下载的镜像">&lt;strong>4、查看已经下载的镜像&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 ~]# docker images
REPOSITORY         TAG      IMAGE  ID     CREATED      SIZEzxg/my_nginx      v1       b164f4c07c64  8 days ago    126 MBzxg/my_nginx      latest   f07837869dfc  8 days ago    126 MBdocker.io/nginx   latest   e445ab08b2be  2 weeks ago   126 MBdocker.io/alpine  latest   b7b28af77ffe  3 weeks ago   5.58 MBdocker.io/centos  latest   9f38484d220f  4 months ago  202 MB
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="5导出镜像">&lt;strong>5、导出镜像&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">docker save nginx &amp;gt;/tmp/nginx.tar.gz
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="6删除镜像">&lt;strong>6、删除镜像&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">docker rmi -f nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="7导入镜像">&lt;strong>7、导入镜像&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">docker load &amp;lt;/tmp/nginx.tar.gz
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="8默认配置文件">&lt;strong>8、默认配置文件&lt;/strong>&lt;/h3>
&lt;p>vim /usr/lib/systemd/system/docker.service &lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[Unit]
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果更改存储目录就添加　　&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">--graph=/opt/docker
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果更改DNS——默认采用宿主机的dns&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">--dns=xxxx的方式指定
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="heading-9">&lt;/h3>
&lt;h3 id="9运行hello-world">&lt;strong>9、运行hello world&lt;/strong>&lt;/h3>
&lt;p>这里用centos镜像echo一个hello word&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 overlay2]# docker images
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="10运行一个容器-run">&lt;strong>10、运行一个容器-run&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 overlay2]# docker run -it alpine sh   #运行并进入alpine
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>后台运行（-d后台运行）（&amp;ndash;name添加一个名字）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 overlay2]# docker run -it -d --name test1 alpine
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>还有一种-rm参数，ctrl+c后就删除，可以测试环境用，生成环境用的少&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 overlay2]# docker run -it --rm --name centos nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="11如何进入容器">&lt;strong>11、如何进入容器&lt;/strong>&lt;/h3>
&lt;p>三种方法，上面已经演示了一种&lt;/p>
&lt;p>第一种，需要容器本身的pid及util-linux，不推荐，暂时不演示了&lt;/p>
&lt;p>第二种，不分配bash终端的一种实施操作，不推荐，这种操作如果在开一个窗口也能看到操作的指令，所有人都能看到&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 overlay2]# docker ps
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第三种：exec方式，终端时分开的，推荐&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">[root@web1 overlay2]# docker exec -it mynginx sh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="12查看docker进程及删除容器">&lt;strong>12、查看docker进程及删除容器&lt;/strong>&lt;/h3>
&lt;p>上面已经演示：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ docker ps
$ docker ps -a 　　　　　　&lt;span class="c1">#-a :显示所有的容器，包括未运行的&lt;/span>
&lt;span class="c1"># 查看容器详细信息&lt;/span>
$ docker inspect mynginx
&lt;span class="c1"># 查看日志**&lt;/span>
$ docker logs -f mynginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.cnblogs.com/zhangxingeng/p/11236968.html">Docker1 架构原理及简单使用 - 乐章 - 博客园&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.yuanshuli.com/post-64.html">【解决】docker启动报错：Running modprobe xt_conntrack failed with message: `modprobe: ERROR: could not insert &amp;lsquo;xt_conntrack&amp;rsquo;&amp;hellip;&amp;hellip; - 碧海长天&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Helm基础</title><link>https://justice.bj.cn/post/32.cloudnative/helm%E5%9F%BA%E7%A1%80/</link><pubDate>Fri, 29 Apr 2022 23:24:04 +0800</pubDate><guid>https://justice.bj.cn/post/32.cloudnative/helm%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="helm基础">Helm基础&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;a href="https://www.kubernetes.org.cn/tags/helm">Helm&lt;/a>是 k8s 的一个管理工具，用来简化 k8s 应用的部署和管理，类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM。Helm 提供以下能力：&lt;/p>
&lt;ul>
&lt;li>创建新的 charts&lt;/li>
&lt;li>将 charts 打包成 tgz 文件&lt;/li>
&lt;li>与 chart 仓库交互&lt;/li>
&lt;li>安装和卸载 Kubernetes 的应用&lt;/li>
&lt;li>管理使用 Helm 安装的 charts 的生命周期&lt;/li>
&lt;/ul>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;p>Helm 有如下几个基本概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Chart&lt;/strong>: 是 Helm 管理的安装包，里面包含需要部署的安装包资源。可以把 Chart 比作 CentOS yum 使用的 rpm 文件。每个 Chart 包含下面两部分：
&lt;ul>
&lt;li>包的基本描述文件 Chart.yaml&lt;/li>
&lt;li>放在 templates 目录中的一个或多个 Kubernetes manifest 文件模板&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Config&lt;/strong>：包含了应用发布配置信息&lt;/li>
&lt;li>&lt;strong>Release&lt;/strong>：是 chart 的部署实例，一个 chart 在一个 Kubernetes 集群上可以有多个 release，即这个 chart 可以被安装多次&lt;/li>
&lt;li>&lt;strong>Repository&lt;/strong>：chart 的仓库，用于发布和存储 chart&lt;/li>
&lt;/ul>
&lt;p>Helm 把 Kubernetes 资源(比如 deployments、services 或 ingress 等) 打包到一个 chart 中，而 chart 被保存到 chart 仓库。通过 chart 仓库可用来存储和分享 chart。Helm 使发布可配置，支持发布应用配置的版本管理，简化了 Kubernetes 部署应用的版本控制、打包、发布、删除、更新等操作。&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="https://justice.bj.cn/Users/zhuzhengyi/tmp/32-assets/image-20190516091239555-1240024.png" alt="loading-ag-1128">&lt;/p>
&lt;p>Helm 由两部分组成，客户端 helm 和服务端 tiller。&lt;/p>
&lt;ul>
&lt;li>Tiller：运行在 Kubernetes 集群上，监听 helm client 请求，通过 chart 构建发布，安装 chart 到 k8s 集群，管理已发布 chart 的升级和卸载。&lt;/li>
&lt;li>Helm：是一个命令行工具，可在本地运行，一般运行在 CI/CD Server 上。&lt;/li>
&lt;/ul>
&lt;h2 id="语法">语法&lt;/h2>
&lt;ul>
&lt;li>多行字符串&lt;/li>
&lt;/ul>
&lt;h2 id="操作">操作&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ helm repo update
$ helm create hello-svc &lt;span class="c1">#创建模板&lt;/span>
$ &lt;span class="nb">cd&lt;/span> ./hello-svc
$ helm install --dry-run --debug ./ &lt;span class="c1">#测试&lt;/span>
$ helm install ./ &lt;span class="c1">#安装&lt;/span>
$ helm list &lt;span class="c1">#查看&lt;/span>
$ helm delete hello-svc &lt;span class="c1">#删除&lt;/span>
&lt;span class="c1">#打包, 当前目录生成tgz文件&lt;/span>
$ helm package ./
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;h2 id="参考">参考&lt;/h2>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&lt;a href="https://feisky.gitbooks.io/kubernetes/apps/helm.html">https://feisky.gitbooks.io/kubernetes/apps/helm.html&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item></channel></rss>