<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 29 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Chubao-Raft</title><link>https://justice.bj.cn/post/40.storage/chubaofs/chubao-raft/</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/40.storage/chubaofs/chubao-raft/</guid><description>&lt;h1 id="chubao-raft">Chubao-Raft&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Chubao Raft 是 chubaofs 项目使用的multigroup-raft 库，是在 etcd raft 库上进行了重构和优化。&lt;/p>
&lt;p>向较于 etcd-raft，chubao-raft 有以下改进：&lt;/p>
&lt;ul>
&lt;li>multi-raft：支持多组 raft；&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="状态机">状态机&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph TB
F(Follower)
C(Candidate)
L(Leader)
E(ElectionAck)
S((START)) --&amp;gt; F
F --timeout--&amp;gt; C
C --timeout/vote req--&amp;gt; C
C --electAck/append/hb/minor votes--&amp;gt; F
C -- quorum:lease_off --&amp;gt; L
C -- quorum:lease_on --&amp;gt; E
L -- lease offline --&amp;gt; F
E -- vote req --&amp;gt; E
E --electAck/append/hb--&amp;gt; F
E --quorum--&amp;gt; L
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="重要数据结构">重要数据结构&lt;/h2>
&lt;h3 id="future">Future&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>future&lt;/code>是raft中用于描述raft输出结果的一个数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>future&lt;/code>内部有2个长度为1的&lt;code>chan&lt;/code>，分别代表着&lt;code>正常输出&lt;/code>和&lt;code>错误输出&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>future&lt;/code>主要提供以下2个外部调用来获取输出：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Response()&lt;/code>: 获取同步输出结果；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>AsyncResponse&lt;/code>: 异步输出；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">respErr&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">errCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Future&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">respErr&lt;/span>
&lt;span class="nx">respCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Future&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Response&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nb">error&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">resp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">respCh&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Future&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">AsyncResponse&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">respCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">errCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">respCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">errCh&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="关键流程">关键流程&lt;/h2>
&lt;h3 id="新建raftserver">新建RaftServer&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>chubao raft的multi-raft, 多个raft主要通过&lt;code>RaftServer-&amp;gt;rafts&lt;/code>进行管理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动入口为&lt;code>raft/server.go&lt;/code>中的&lt;code>NewRaftServer&lt;/code>, 通过输入参数&lt;code>config&lt;/code>生成一个新的&lt;code>RaftSever&lt;/code>结构体对象，并启动后台服务协程&lt;code>run()&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>RaftServer-&amp;gt;run()&lt;/code>协程监听如下事件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>rs-&amp;gt;stopC&lt;/code>: &lt;code>RaftServer&lt;/code>结束消息，接收该消息，立马结束&lt;code>run&lt;/code>服务协程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>fatalStopC&lt;/code>: 关闭raft消息，从&lt;code>rs-&amp;gt;rafts&lt;/code> map中删除对应的raft；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rs-&amp;gt;heartc&lt;/code>: 遍历所有&lt;code>raft&lt;/code>, 将msg放入&lt;code>raft-&amp;gt;recv&lt;/code>中处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rs-&amp;gt;ticker.C&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>递增&lt;code>ticks&lt;/code>计数器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>ticks&lt;/code>达到配置的&lt;code>HeartbeatTick&lt;/code>值，则将计数器置0，并给所有非&lt;code>Leader&lt;/code>节点发送&lt;code>ReqMsgHeartBeat&lt;/code>消息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果节点不在恢复快照状态，则依次给所有&lt;code>raft&lt;/code> tickc发送数据，激活各raft &lt;code>tick()&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="新建raft">新建Raft&lt;/h3>
&lt;p>RaftSever启动后，通过&lt;code>RaftServer-&amp;gt;CreateRaft()&lt;/code>函数可新建&lt;code>raft&lt;/code>, 并将raft加入到&lt;code>RaftSever-&amp;gt;rafts&lt;/code>中。&lt;code>newRaft()&lt;/code>流程如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>校验config;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据配置，生成新&lt;code>raftFsm&lt;/code>实例；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>初始化&lt;code>raft&lt;/code>实例；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动&lt;code>Raft.runApply（）&lt;/code>协程，该协程主要用于监听&lt;code>raft-&amp;gt;applyc&lt;/code>channel上的事件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动&lt;code>Raft.run()&lt;/code>协程,&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="raft主处理流程">Raft主处理流程&lt;/h3>
&lt;p>&lt;code>raft.run()&lt;/code>是各个raft主要用来处理各个事件的总协程入口，其处理如下事件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>s.stopc&lt;/code>: 退出信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>s.tickc&lt;/code>: 计数器信号，调用&lt;code>raftFsm.tick()&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>s.propc&lt;/code>:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="选举">选举&lt;/h3>
&lt;h3 id="选举发生条件">选举发生条件&lt;/h3>
&lt;ul>
&lt;li>&lt;code>Follower&lt;/code>或&lt;code>Candidate&lt;/code>节点&lt;code>选举计时器&lt;/code>超时（lease off） 或收到 Leader 的 Lease TimeOut 消息（lease on）；&lt;/li>
&lt;li>ElectionAck 状态时，选举计时器超时；&lt;/li>
&lt;li>外界选举信号；&lt;/li>
&lt;/ul>
&lt;h3 id="选举过程">选举过程&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>当选举条件达到时，raft 状态机会产生一个&lt;code>LocalMsgHup&lt;/code>消息中断当前任期，发起选举；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非 Leader 节点收到 LocalMsgHup 消息，如果可以提升为 Leader，且 raft 中没有待处理的配置变更日志，则举行选举(campaign)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>发起节点先将自己变成候选人(Candidate);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断得票数。如果达到法定票数(大于总数一半)&lt;/p>
&lt;ul>
&lt;li>启用 Lease，则直接当选为领导人(Leader)，选举结束;&lt;/li>
&lt;li>未启用 Lease，则进入选举确认(ElectionAck)状态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>否则，如果未达到法定票数，则给各个复制节点发送&lt;code>ReqMsgVote&lt;/code>拉票消息，强制各节点投票；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>拉票消息，投反对票，并回复 RespMsgVote 消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>拉票消息后，&lt;/p>
&lt;ul>
&lt;li>如果满足投票条件(条件：未设置 lease，或没有 leader 节点 并且 未投票给其他节点 且 日志为最新)，投赞成票，回复 RespMsgVote 消息给拉票节点；&lt;/li>
&lt;li>否则，投反对票；回复 RespMsgVote 消息给拉票节点；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Leader&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>消息，投反对票，回复&lt;code>RespMsgVote&lt;/code>消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ElectionAck&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>消息，投反对票；回复 RespMsgVote 消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code> 收到 &lt;code>RespMsgVote&lt;/code>投票消息后，统计有效票数：&lt;/p>
&lt;ul>
&lt;li>如果赞成票达多数
&lt;ul>
&lt;li>如果未启用 lease，则成为 Leader；&lt;/li>
&lt;li>否则，进入 ElectionAck 状态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果反对票达多数，则成为&lt;code>Follower&lt;/code>；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>给拉票候选人投赞成票条件：&lt;/p>
&lt;ul>
&lt;li>无 leader（或未启用 lease）;&lt;/li>
&lt;li>未给其他节点投过票；&lt;/li>
&lt;li>该候选人的 term 和 index 均为最新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="选举确认electionack">选举确认（ElectionAck）&lt;/h3>
&lt;p>如果启用 Lease，节点获得多数票后，不会直接当选，需先进入 ElectionAck 状态，对选举进行确认；&lt;/p>
&lt;p>在 ElectionAck 状态，ElectionAck 节点将向其他节点发送选举确认请求消息(ReqMsgElectAck)，待其他节点回复确认消息(RespMsgElectAck)后，统计确认票数，如果确认票数达到法定票数，才当选为领导人(Leader)。&lt;/p>
&lt;ul>
&lt;li>Follower 节点收到 ReqMsgElectAck 消息，将重置选举计数器，并将发送节点设为 Leader 后，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>Candidate 节点收到 ReqMsgElectAck 消息，将自己转变成 Follower，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>其他 ElectAck 节点收到 ReqMsgElectAck 消息，同样将自己转变成 Follower，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>ElectAck 节点收到 RespMsgElectAck 消息后，记录确认消息(ack)数。如果确认消息数大于等于法定当选票数，则当选为 Leader。并立即广播 append；&lt;/li>
&lt;/ul>
&lt;h2 id="日志复制流程">日志复制流程&lt;/h2>
&lt;h4 id="任何节点收到消息">任何节点收到消息：&lt;/h4>
&lt;ul>
&lt;li>如果是 LocalMsgHup 消息：
&lt;ul>
&lt;li>如果是非 Leader，且有副本节点，
&lt;ul>
&lt;li>如果包含配置变更消息且 comitted &amp;gt; applied, 则忽略；&lt;/li>
&lt;li>否则，举行选举；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果是 Leader 节点，则忽略；&lt;/li>
&lt;li>返回；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>否则，判断消息任期(Term):
&lt;ul>
&lt;li>如果 Term==0， 忽略；&lt;/li>
&lt;li>如果消息任期(m.Term) &amp;gt; 节点任期(r.term), 则继续判断
&lt;ul>
&lt;li>如果为请求投票消息(ReqMsgVote)，判断 lease：
&lt;ul>
&lt;li>如果是 Follower 节点，且启用了 lease，且消息不是来自旧 Leader 节点，则给旧 Leader 回复 LeaseMsgOffline 消息，通知旧 Leader Lease 下线；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变成 Follower。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果消息里任期小于节点任期(m.Term&amp;lt;r.term)，则忽略；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>转入不同角色状态处理；&lt;/li>
&lt;/ul>
&lt;h4 id="角色状态消息处理">角色状态消息处理&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>Follower&lt;/p>
&lt;ul>
&lt;li>LocalPropMsg：
&lt;ul>
&lt;li>如果没有 Leader，则不处理（报警提示）；&lt;/li>
&lt;li>如果有 Leader，转发 Leader 处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgAppend：
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;li>执行 append 操作：
&lt;ul>
&lt;li>如果消息 index 小于本节点 committed，则回复 RespMsgAppend 本节点 committe index；&lt;/li>
&lt;li>否则，尝试 append
&lt;ul>
&lt;li>如果 append 成功，则回复 RespMsgAppend（index = lastIndex）；&lt;/li>
&lt;li>否则，回复 RespMsgAppend，Reject=true；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgHeartBeat：
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqCheckQuorum:
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;li>回应发送者 RespCheckQuorum 消息；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgVote:
&lt;ul>
&lt;li>如果满足投票条件，则重置选举计数器，并回复发送者 RespMsgVote（赞成票，Reject=false）；&lt;/li>
&lt;li>否则回复发送者 RespMsgVote（反对票，Reject=true）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LeaseMsgTimeout
&lt;ul>
&lt;li>如果消息来自 Leader，则重置选举计数器，并发送 LocalMsgHup 消息;&lt;/li>
&lt;li>否则忽略；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Candidate&lt;/p>
&lt;ul>
&lt;li>LocalMsgProp:
&lt;ul>
&lt;li>忽略&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgAppend：
&lt;ul>
&lt;li>先转变为 Follower；&lt;/li>
&lt;li>再执行 append:&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgHeartBeat：
&lt;ul>
&lt;li>转变为 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgElectAck
&lt;ul>
&lt;li>先转变为 Follower；&lt;/li>
&lt;li>回复发送者 RespMsgElectAck 消息(Reject=false)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgVote：
&lt;ul>
&lt;li>回复发送者 RespMsgVote 消息, 投反对票(Reject=true)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RespMsgVote:
&lt;ul>
&lt;li>统计收到的赞成票数；&lt;/li>
&lt;li>如果赞成票已达多数：
&lt;ul>
&lt;li>如果启用 LeaseCheck，则转变为 ElectionAck 状态；&lt;/li>
&lt;li>否则未启用 LeaseCheck，则当选为 Leader，并广播 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果反对票已达多数，则变成 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Leader&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LocalMsgProp:&lt;/p>
&lt;ul>
&lt;li>空消息或没有副本节点，则忽略该消息；&lt;/li>
&lt;li>否则，检查是否有配置变更消息；&lt;/li>
&lt;li>append；&lt;/li>
&lt;li>向副本节点广播 append。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgVote:&lt;/p>
&lt;ul>
&lt;li>向发送者回复 RespMsgVote，投反对票(Reject=true);&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgAppend:&lt;/p>
&lt;ul>
&lt;li>更新复制信道(pr)状态；&lt;/li>
&lt;li>如果 Reject, 则 pr 可能要回退，并转变到探测状态，在发送 append&lt;/li>
&lt;li>否则，更新信道状态，并尝试 commit：
&lt;ul>
&lt;li>如果 commit 成功，则广播 append；&lt;/li>
&lt;li>如果信道暂停过，则发送 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgHeartBeat:&lt;/p>
&lt;h2 id="更新信道状态">更新信道状态；&lt;/h2>
&lt;/li>
&lt;li>
&lt;p>LeaseMsgOffline:&lt;/p>
&lt;ul>
&lt;li>给所有副本节点发送 LeaseMsgTimeOut 消息；&lt;/li>
&lt;li>转变为 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgSnapShot:&lt;/p>
&lt;ul>
&lt;li>如果信道状态不是 replicaStateSnapshot, 则忽略；&lt;/li>
&lt;li>如果消息被拒绝，则快照失败，信道转入探测状态；&lt;/li>
&lt;li>否则，更新信道并继续探测；&lt;/li>
&lt;li>信道暂停；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespCheckQuorum:&lt;/p>
&lt;ul>
&lt;li>接收 Ack；&lt;/li>
&lt;li>如果收到确认节点数+1(本节点)，则 readOnly-&amp;gt;advance;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ElectionAck&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LocalMsgProp:&lt;/p>
&lt;ul>
&lt;li>忽略&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgAppend:&lt;/p>
&lt;ul>
&lt;li>转变为 Follower；&lt;/li>
&lt;li>执行 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgHeartBeat:&lt;/p>
&lt;ul>
&lt;li>变成 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgElectAck:&lt;/p>
&lt;ul>
&lt;li>变成 Follower；&lt;/li>
&lt;li>回复 ResqMsgElectAck;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgVote:&lt;/p>
&lt;ul>
&lt;li>回复 RespMsgVote，投反对票(Reject=true)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespCheckQuorum:&lt;/p>
&lt;ul>
&lt;li>recvAck&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgElectAck:&lt;/p>
&lt;ul>
&lt;li>统计 ack 数；&lt;/li>
&lt;li>如果确认数&amp;gt;=法定票数，则成为 Leader，并广播 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="计时器tick">计时器(Tick)&lt;/h3>
&lt;p>计时器和消息一起用于驱动 raft 状态机的状态变更，主要包括三种种计时器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>心跳计数器(tickHeartBeat)：用于 Leader 向 Follower 发送存活信号。&lt;/p>
&lt;p>用于 Leader 节点，其频率&amp;raquo;选举计时器，约为选举计数器频率的 10 倍,用于 Leader 和 Follower 节点间确认信道状态。流程如下：&lt;/p>
&lt;ul>
&lt;li>心跳计数器+1，选举计数器+1；&lt;/li>
&lt;li>如果选举计数器到达阈值：
&lt;ul>
&lt;li>重置选举计数器为 0；&lt;/li>
&lt;li>如果启用 lease 且 lease 失效，则 Leader 状态转变为 Follower 状态；
&lt;ul>
&lt;li>如果是非 Leader 节点，忽略；&lt;/li>
&lt;li>如果心跳计数器到达阈值：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重置心跳计数器为 0；&lt;/li>
&lt;li>检查所有副本状态，如果不是快照状态，则副本继续；&lt;/li>
&lt;li>广播 ReadOnly；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>选举计时器(tickElection)：&lt;/p>
&lt;p>用于 Follower 和 Candidate 节点，用来计算一个任期是超时时间，如果一个任期内选举计时器超时，则将触发重新选举操作，流程如下：&lt;/p>
&lt;ul>
&lt;li>如果节点无法；&lt;/li>
&lt;li>选举计数器+1；&lt;/li>
&lt;li>判断是否超时：
&lt;ul>
&lt;li>如果超时，则重重置选举计数器为 0；状态机输入 LocalMsgHup 消息，中断当前任期；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>当选确认计数器(tickElectAck)：&lt;/p>
&lt;p>当选确认计数器主要用作当选确认状态节点中，流程如下：&lt;/p>
&lt;ul>
&lt;li>选举计数器+1；&lt;/li>
&lt;li>如果选举计数器超时，则：
&lt;ul>
&lt;li>重置选举计数器为 0；&lt;/li>
&lt;li>状态机输入 LocalMsgHup 消息，中断当前任期；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/47117804">线性一致性和 Raft&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/35697913">Raft 的 PreVote 实现机制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/50455478">Etcd 之 Lease read&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5af066f1f265da0b715634b9">Raft 协议精解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI3NDIxNTQyOQ==&amp;amp;mid=2247484499&amp;amp;idx=1&amp;amp;sn=79acb9b4b2f8baa3296f2288c4a0a45b&amp;amp;scene=0#wechat_redirect">TiKV 源码解析系列 - Lease Read&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/solotzg/article/details/80669924">Raft TLA+形式化验证&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>MarkDown</title><link>https://justice.bj.cn/post/70.tool/markdown/</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/70.tool/markdown/</guid><description>&lt;h1 id="markdown">MarkDown&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Markdown（标记向下）是一种&lt;a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80" title="轻量级标记语言">轻量级标记语言&lt;/a>，创始人为&lt;a href="https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF" title="约翰·格鲁伯">约翰·格鲁伯&lt;/a>。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的&lt;a href="https://zh.wikipedia.org/wiki/XHTML" title="XHTML">XHTML&lt;/a>（或者&lt;a href="https://zh.wikipedia.org/wiki/HTML" title="HTML">HTML&lt;/a>）文档。&lt;a href="https://zh.wikipedia.org/wiki/Markdown#cite_note-md-4">[4]&lt;/a>这种语言吸收了很多在&lt;a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6" title="电子邮件">电子邮件&lt;/a>中已有的纯文本标记的特性。&lt;/p>
&lt;hr>
&lt;h2 id="基础语法">基础语法&lt;/h2>
&lt;hr>
&lt;h3 id="标题">标题&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="gh"># 一级标题
&lt;/span>&lt;span class="gh">&lt;/span>
&lt;span class="gu">## 二级标题
&lt;/span>&lt;span class="gu">&lt;/span>
&lt;span class="gu">### 三级标题
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h3 id="文本格式">文本格式&lt;/h3>
&lt;p>&lt;strong>粗体&lt;/strong>&lt;/p>
&lt;p>&lt;em>斜体&lt;/em>&lt;/p>
&lt;p>&lt;u>下划线&lt;/u>&lt;/p>
&lt;p>&lt;del>删除线&lt;/del>&lt;/p>
&lt;p>&lt;mark>高亮&lt;/mark>&lt;/p>
&lt;p>行内代码：&lt;code>int i = 0;&lt;/code>&lt;/p>
&lt;p>行内数学公式：$ a=x^2$&lt;/p>
&lt;p>&lt;a href="http://www.github.com">超链接&lt;/a>&lt;/p>
&lt;h3 id="代码块">代码块&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="列表">列表&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>无序列表项 1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无序列表项 2&lt;/p>
&lt;ul>
&lt;li>子列表项 1&lt;/li>
&lt;li>子列表项 2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>有序列表项 1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有序列表项 2&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>&lt;input disabled="" type="checkbox"> 检查项 1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;input disabled="" type="checkbox"> 检查项 2&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="表格">表格&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>表头&lt;/th>
&lt;th style="text-align:center">表头栏&lt;/th>
&lt;th style="text-align:left">左对齐&lt;/th>
&lt;th style="text-align:right">右对齐&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:right">&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:right">&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:right">&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="图">图&lt;/h2>
&lt;hr>
&lt;h3 id="流程图">流程图&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">st=&amp;gt;start: 选举开始
Hup=&amp;gt;operation: 发送LocalMsgHup消息
e=&amp;gt;end: 结束
st-&amp;gt;Hup-&amp;gt;e
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h3 id="时序图">时序图&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">sequenceDiagram
participant Executor
participant Reactor
activate Executor
Executor-&amp;gt;&amp;gt;Reactor: Pending Future
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/Markdown">https://zh.wikipedia.org/wiki/Markdown&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>堆排序</title><link>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/13.algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="堆排序">堆排序&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>堆排序是借助于堆这个数据结构来实现排序的一种算法。&lt;/p>
&lt;h3 id="堆heap的性质">堆(heap)的性质&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>堆&lt;/strong>是一个&lt;strong>完全二叉树&lt;/strong>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的每个非叶子结点值均大于(大顶堆)/小于(小顶堆)其左右子节点值；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆的&lt;strong>根节点&lt;/strong>为所有节点中的最大值(大顶堆)/最小值(小顶堆)；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/05/22-20-35-03-2021-05-22-20-34-57-image.png" alt="">&lt;/p>
&lt;h2 id="堆排序-1">堆排序&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>堆排序利用堆节点的性质 2，每次从堆中排出堆顶元素，从而最终得到有序的序列；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于堆是一个完全二叉树，所以可以用数组来组织；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于完全二叉树性质，数组中根节点索引($i_o$)和其左右子节点($i_l,i_r$)满足如下关系：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>$$
i_l = 2 * i_o + 1 \&lt;br>
i_r = 2 * i_o + 2
$$&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp" alt="">&lt;/p>
&lt;h2 id="复杂性分析">复杂性分析&lt;/h2>
&lt;h3 id="时间复杂度">时间复杂度&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Avg: $O(nlogn)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Max: $O(n^2)$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Min: $O(n)$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="空间复杂度">空间复杂度&lt;/h3>
&lt;h2 id="实现">实现&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">heap_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span class="s1"> 堆调整, 将nums数组从start开始,长度为length的数组调整为堆
&lt;/span>&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span>
&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">big&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">#初始化堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1"># 循环取出堆顶元素, 放到数组尾部, 并调整堆&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">_heap_adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>算法简介</title><link>https://justice.bj.cn/post/13.algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 26 Sep 2021 20:37:02 +0800</pubDate><guid>https://justice.bj.cn/post/13.algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="算法简介">算法简介&lt;/h1>
&lt;hr>
&lt;h2 id="series-">title: 算法基础
description:
toc: true
authors: []
tags: []
categories: []
series: []&lt;/h2>
&lt;h1 id="算法基础">算法基础&lt;/h1>
&lt;h2 id="算法定义">算法定义&lt;/h2>
&lt;h2 id="算法评估">算法评估&lt;/h2>
&lt;h3 id="空间复杂度">空间复杂度&lt;/h3>
&lt;h3 id="时间复杂度">时间复杂度&lt;/h3>
&lt;h2 id="常用算法">常用算法&lt;/h2>
&lt;h3 id="排序">排序&lt;/h3>
&lt;ul>
&lt;li>比较类
&lt;ul>
&lt;li>冒泡排序&lt;/li>
&lt;li>选择排序&lt;/li>
&lt;li>插入排序&lt;/li>
&lt;li>归并排序&lt;/li>
&lt;li>希尔排序&lt;/li>
&lt;li>快速排序&lt;/li>
&lt;li>堆排序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非比较类
&lt;ul>
&lt;li>计数排序&lt;/li>
&lt;li>桶排序&lt;/li>
&lt;li>基数排序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="查找">查找&lt;/h3>
&lt;ul>
&lt;li>顺序查找&lt;/li>
&lt;li>二分查找&lt;/li>
&lt;li>插值查找&lt;/li>
&lt;li>斐波那契查找&lt;/li>
&lt;li>树表查找&lt;/li>
&lt;li>哈希查找&lt;/li>
&lt;li>分块查找&lt;/li>
&lt;li>快速幂&lt;/li>
&lt;li>伐木问题&lt;/li>
&lt;li>局部最小值&lt;/li>
&lt;li>最小 K 个数(O(n))&lt;/li>
&lt;/ul>
&lt;h3 id="贪心法">贪心法&lt;/h3>
&lt;ul>
&lt;li>股票买卖&lt;/li>
&lt;li>最长非重复子串&lt;/li>
&lt;li>跳跃游戏&lt;/li>
&lt;li>最大子数组&lt;/li>
&lt;li>数组主元素(出现次数&amp;gt;数组大小一半的元素)&lt;/li>
&lt;/ul>
&lt;h3 id="分治法">分治法&lt;/h3>
&lt;ul>
&lt;li>遍历 BPS/DPS&lt;/li>
&lt;li>N 皇后问题&lt;/li>
&lt;li>单词接龙&lt;/li>
&lt;li>爬楼梯(Climb Stair)&lt;/li>
&lt;li>数独&lt;/li>
&lt;li>路径和(Path Sum)&lt;/li>
&lt;/ul>
&lt;h3 id="动态规划">动态规划&lt;/h3>
&lt;ul>
&lt;li>背包问题(Package)&lt;/li>
&lt;li>最长公共子序列(Longest Common SubSequence)&lt;/li>
&lt;li>最长公共子串(Longest Common SubArray)&lt;/li>
&lt;li>最长递增子序列(Longest Increment SubSequence)&lt;/li>
&lt;li>最长连续递增子序列(Longest ICS)&lt;/li>
&lt;li>最大连续子数组和/积&lt;/li>
&lt;li>不同子序列数()&lt;/li>
&lt;li>BST 个数()&lt;/li>
&lt;li>最小路径和&lt;/li>
&lt;li>爬楼梯&lt;/li>
&lt;li>单词划分&lt;/li>
&lt;li>编辑距离&lt;/li>
&lt;li>回文分割&lt;/li>
&lt;li>数字三角形&lt;/li>
&lt;li>约瑟夫问题&lt;/li>
&lt;/ul>
&lt;h2 id="其他">其他&lt;/h2>
&lt;ul>
&lt;li>最长回文子串: Manacher 算法&lt;/li>
&lt;li>最长公共前缀: KMP 算法&lt;/li>
&lt;/ul></description></item><item><title>Bit/Byte</title><link>https://justice.bj.cn/post/12.data_struct/01.%E6%AF%94%E7%89%B9/</link><pubDate>Sun, 26 Sep 2021 20:31:22 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/01.%E6%AF%94%E7%89%B9/</guid><description>&lt;h1 id="bitbyte">Bit/Byte&lt;/h1>
&lt;hr>
&lt;h2 id="series-">title: 比特/字节
description:
toc: true
authors: []
tags: []
categories: []
series: []&lt;/h2>
&lt;h1 id="bitbyte-1">Bit/Byte&lt;/h1>
&lt;h2 id="bit">bit&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>bit是内存中最小的数据单位，为一个数据位；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>8个bit组成一个byte。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="字符串相关算法">字符串相关算法&lt;/h2>
&lt;ul>
&lt;li>字符串匹配&lt;/li>
&lt;li>字符串转换&lt;/li>
&lt;li>公共前缀&lt;/li>
&lt;/ul></description></item><item><title>红黑树</title><link>https://justice.bj.cn/post/12.data_struct/tree/rb-tree/</link><pubDate>Fri, 10 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/rb-tree/</guid><description>&lt;h1 id="红黑树rb-tree">红黑树(RB-Tree)&lt;/h1>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>红黑树是一种二叉平衡树。&lt;/p>
&lt;h2 id="性质">性质&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个节点要么是黑色，要么是红色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Root 节点是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个叶子节点（NIL）是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个红色结点的两个子结点一定都是黑色。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="旋转">旋转&lt;/h2>
&lt;ul>
&lt;li>右旋&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-07-rbtree-right-rotate.webp" alt="">&lt;/p>
&lt;ul>
&lt;li>左旋&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-29-rbtree-left-rotate.webp" alt="loading-ag-18088">&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/63272157">https://zhuanlan.zhihu.com/p/63272157&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/92761639">https://zhuanlan.zhihu.com/p/92761639&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>LSMTree日志结构合并树</title><link>https://justice.bj.cn/post/12.data_struct/tree/lsm-tree/</link><pubDate>Thu, 09 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/lsm-tree/</guid><description>&lt;h1 id="日志结构合并树lsm-tree">日志结构合并树(LSM-Tree)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;code>LSM-Tree&lt;/code>全称Log Structured Merge Tree，是Google在2006年开源其BigTable中引入的一种数据结构。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种分层，有序，面向磁盘的数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其核心思想是充分了利用了磁盘批量的顺序写要远比随机写性能高出很多的特性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LSM-Tree大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于写多读少的场景;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sstable">SSTable&lt;/h2>
&lt;p>LSM-Tree核心的数据结构是SSTable，全称是Sorted String Table；&lt;/p>
&lt;p>SSTable是一种拥有持久化，有序且不可变的的键值存储结构，它的key和value都是任意的字节数组，并且了提供了按指定key查找和指定范围的key区间迭代遍历的功能。SSTable内部包含了一系列可配置大小的Block块，典型的大小是64KB，关于这些Block块的index存储在SSTable的尾部，&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-12-38-2021-09-04-10-12-33-image.png" alt="">&lt;/p>
&lt;h2 id="整体结构">整体结构&lt;/h2>
&lt;p>LSM-Tree里，SSTable有一份在内存里面，其他的多级在磁盘上，如下图是一份完整的LSM-Tree图示&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-08-25-2021-09-04-10-08-20-image.png" alt="">&lt;/p>
&lt;h2 id="写流程">写流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>当收到一个写请求时，会先把该条数据记录在WAL Log里面，用作故障恢复；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当写完WAL Log后，会把该条数据写入内存的SSTable里面（删除是墓碑标记，更新是新记录一条的数据），也称Memtable。注意为了维持有序性在内存里面可以采用红黑树或者跳跃表相关的数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当Memtable超过一定的大小后，会在内存里面冻结，变成不可变的Memtable，同时为了不阻塞写操作需要新生成一个Memtable继续提供服务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把内存里面不可变的Memtable给dump到到硬盘上的SSTable层中，此步骤也称为Minor Compaction，这里需要注意在L0层的SSTable是没有进行合并的，所以这里的key range在多个SSTable中可能会出现重叠，在层数大于0层之后的SSTable，不存在重叠key；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当每层的磁盘上的SSTable的体积超过一定的大小或者个数，也会周期的进行合并。此步骤也称为Major Compaction，这个阶段会真正 的清除掉被标记删除掉的数据以及多版本数据的合并，避免浪费空间，注意由于SSTable都是有序的，我们可以直接采用merge sort进行高效合并。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="读流程">读流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>当收到一个读请求的时候，会直接先在内存里面查询，如果查询到就返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果没有查询到就会依次下沉，知道把所有的Level层查询一遍得到最终结果。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="优化">优化&lt;/h2>
&lt;h3 id="压缩">压缩&lt;/h3>
&lt;p>SSTable 是可以启用压缩功能的，并且这种压缩不是将整个 SSTable 一起压缩，而是根据 locality 将数据分组，每个组分别压缩，这样的好处当读取数据的时候，我们不需要解压缩整个文件而是解压缩部分 Group 就可以读取。&lt;/p>
&lt;h3 id="缓存">缓存&lt;/h3>
&lt;p>因为SSTable在写入磁盘后，除了Compaction之外，是不会变化的，所以我可以将Scan的Block进行缓存，从而提高检索的效率&lt;/p>
&lt;h2 id="索引bloom-filters">索引，Bloom filters&lt;/h2>
&lt;p>正常情况下，一个读操作是需要读取所有的 SSTable 将结果合并后返回的，但是对于某些 key 而言，有些 SSTable 是根本不包含对应数据的，因此，我们可以对每一个 SSTable 添加 Bloom Filter，因为布隆过滤器在判断一个SSTable不存在某个key的时候，那么就一定不会存在，利用这个特性可以减少不必要的磁盘扫描。&lt;/p>
&lt;h3 id="合并">合并&lt;/h3>
&lt;p>这个在前面的写入流程中已经介绍过，通过定期合并瘦身， 可以有效的清除无效数据，缩短读取路径，提高磁盘利用空间。但Compaction操作是非常消耗CPU和磁盘IO的，尤其是在业务高峰期，如果发生了Major Compaction，则会降低整个系统的吞吐量，这也是一些NoSQL数据库，比如Hbase里面常常会禁用Major Compaction，并在凌晨业务低峰期进行合并的原因。&lt;/p>
&lt;h2 id="lsm-tree-vs-btree">LSM-Tree vs B+Tree&lt;/h2>
&lt;p>传统关系型数据采用的底层数据结构是B+树，那么同样是面向磁盘存储的数据结构LSM-Tree相比B+树有什么异同之处呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LSM-Tree的设计思路是，将数据拆分为几百M大小的Segments，并是顺序写入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>B+Tree则是将数据拆分为固定大小的Block或Page, 一般是4KB大小，和磁盘一个扇区的大小对应，Page是读写的最小单位。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在数据的更新和删除方面，B+Tree可以做到原地更新和删除，这种方式对数据库事务支持更加友好，因为一个key只会出现一个Page页里面，但由于LSM-Tree只能追加写，并且在L0层key的rang会重叠，所以对事务支持较弱，只能在Segment Compaction的时候进行真正地更新和删除。&lt;/p>
&lt;p>因此LSM-Tree的优点是支持高吞吐的写（可认为是O（1）），这个特点在分布式系统上更为看重，当然针对读取普通的LSM-Tree结构，读取是O（N）的复杂度，在使用索引或者缓存优化后的也可以达到O（logN）的复杂度。&lt;/p>
&lt;p>而B+tree的优点是支持高效的读（稳定的OlogN），但是在大规模的写请求下（复杂度O(LogN)），效率会变得比较低，因为随着insert的操作，为了维护B+树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。&lt;/p>
&lt;p>还有一点需要提到的是基于LSM-Tree分层存储能够做到写的高吞吐，带来的副作用是整个系统必须频繁的进行compaction，写入量越大，Compaction的过程越频繁。而compaction是一个compare &amp;amp; merge的过程，非常消耗CPU和存储IO，在高吞吐的写入情形下，大量的compaction操作占用大量系统资源，必然带来整个系统性能断崖式下跌，对应用系统产生巨大影响，当然我们可以禁用自动Major Compaction，在每天系统低峰期定期触发合并，来避免这个问题。&lt;/p>
&lt;p>阿里为了优化这个问题，在X-DB引入了异构硬件设备FPGA来代替CPU完成compaction操作，使系统整体性能维持在高水位并避免抖动，是存储引擎得以服务业务苛刻要求的关键。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/developer/article/1441835">深入理解什么是LSM-Tree - 云+社区 - 腾讯云&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>B树</title><link>https://justice.bj.cn/post/12.data_struct/tree/b-tree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/b-tree/</guid><description>&lt;h1 id="b-tree">B-Tree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>B 树又叫平衡多路查找树。主要应用于数据库，文件等&lt;/p>
&lt;p>一棵 m 阶的 B 树 (m 叉树)的特性如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>树中每个结点最多含有 m 个孩子（m&amp;gt;=2）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中 ceil(x)是一个取上限的函数）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为 null)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个非终端结点中包含有 n 个关键字信息： (P1，K1，P2，K2，P3，&amp;hellip;&amp;hellip;，Kn，Pn+1)。其中：
       a)   Ki (i=1&amp;hellip;n)为关键字，且关键字按顺序升序排序 K(i-1)&amp;lt; Ki。 
       b)   Pi 为指向子树根的接点，且指针 P(i)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。 
       c)   关键字的个数 n 必须满足： [ceil(m / 2)-1]&amp;lt;= n &amp;lt;= m-1。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-56-17-2020-04-21-13-16-05-image.png" alt="">&lt;/p>
&lt;p>来模拟下查找文件 29 的过程：&lt;/p>
&lt;p>(1) 根据根结点指针找到文件目录的根磁盘块 1，将其中的信息导入内存。【磁盘 IO 操作 1 次】&lt;/p>
&lt;p>(2) 此时内存中有两个文件名 17，35 和三个存储其他磁盘页面地址的数据。根据算法我们发现 17&amp;lt;29&amp;lt;35，因此我们找到指针 p2。&lt;/p>
&lt;p>(3) 根据 p2 指针，我们定位到磁盘块 3，并将其中的信息导入内存。【磁盘 IO 操作 2 次】&lt;/p>
&lt;p>(4) 此时内存中有两个文件名 26，30 和三个存储其他磁盘页面地址的数据。根据算法我们发现 26&amp;lt;29&amp;lt;30，因此我们找到指针 p2。&lt;/p>
&lt;p>(5) 根据 p2 指针，我们定位到磁盘块 8，并将其中的信息导入内存。【磁盘 IO 操作 3 次】&lt;/p>
&lt;p>(6) 此时内存中有两个文件名 28，29。根据算法我们查找到文件 29，并定位了该文件内存的磁盘地址。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md">The-Art-Of-Programming-By-July/03.02.md at master · julycoding/The-Art-Of-Programming-By-July · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>MassTree</title><link>https://justice.bj.cn/post/12.data_struct/tree/masstree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/masstree/</guid><description>&lt;h1 id="masstree">MassTree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>masstree 来源于 2012 年发表的论文(&lt;a href="https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf">Cache craftiness for fast multicore key-value storage&lt;/a>)，&lt;strong>可以理解为 B+ Tree 和 Radix Tree 的混合体&lt;/strong>，即将键切分成多个部分，每个部分为一个节点；每个节点内部又是一个 B+ Tree，兼顾空间和性能。&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>Masstree 将变长键划分成多个固长部分，每个固长部分可以通过 int 类型表示，而不是 char 类型。由于处理器处理 int 类型比较操作的速度远远快于 char 数组的比较，因此 Masstree 通过 int 类型的比较进一步加速了查找过程。固定长度可以设置为 CPU 缓存行长度，以增加 CPU 缓存效率。&lt;/li>
&lt;li>每个节点是一个 B+ Tree，因此 CPU 在查询的时候可以将节点所代表的 B+ Tree 加载到 CPU 缓存中，以增加 CPU 缓存命中率。&lt;/li>
&lt;li>其并发控制用到了 Read-Copy-Update(RCU)。读不因任何数据更新而阻塞，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据。因此读不会造成 CPU 缓存无效。&lt;/li>
&lt;/ul>
&lt;h2 id="结构">结构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-10-57-34-image-20190528102500578-9312132.png" alt="image-20190528102500578">&lt;/p>
&lt;h2 id="mass-tree-算法">&lt;strong>Mass Tree 算法&lt;/strong>&lt;/h2>
&lt;h2 id="并发策略">&lt;strong>并发策略&lt;/strong>&lt;/h2>
&lt;p>Mass Tree 的并发策略和 OLFIT Tree 是相似的：&lt;/p>
&lt;ol>
&lt;li>fine-grained locking，即节点锁，解决 write-write 竞争，同一时刻只有一个线程可以对当前节点进行写操作&lt;/li>
&lt;li>optimistic concurrency control，即节点  &lt;code>version&lt;/code> (uint32_t)，解决 read-write 竞争，读开始前和读结束后都需要获取当前节点的最新 version，来判断在读过程中当前节点是否发生了写操作（插入或分裂），同时对节点的写操作都需要先修改 version，在插入 key 之前需要设置  &lt;code>inserting&lt;/code>  标记，插入完成之后将 insert 的 vinsert + 1；在分裂之前需要设置  &lt;code>splitting&lt;/code>  标记，分裂完成之后将 split 的 vsplit + 1。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-00-01-2020-11-14-10-59-56-image.png" alt="">&lt;/p>
&lt;p>和  &lt;code>permutation&lt;/code>  一样，&lt;code>version&lt;/code>  也被划分成了多个域，除了带有 insert 和 split 信息之外，还包含一个 lock bit，用于加锁；一个 root bit，用于指示否是根节点；一个 border bit，用于指示是否是 border node；一位 deleted 位，用于指示这个节点是否被标记为删除。&lt;/p>
&lt;h2 id="下降流程">&lt;strong>下降流程&lt;/strong>&lt;/h2>
&lt;p>对于每次插入，获取，删除操作，都需要从 root（可能是整棵树的根节点，也可能是某棵子树的根节点） 下降到对应的叶节点（border node）。&lt;/p>
&lt;p>首先，在开始读取节点之前，必须获得节点的 stable version（图中橙色方块），即  &lt;code>version&lt;/code>  中的  &lt;code>inserting&lt;/code>  和  &lt;code>splitting&lt;/code>  位都为 0。&lt;/p>
&lt;p>其次，在下降之前，需要获取最新的 root，因为在开始下降前，根节点可能分裂了，导致其发生了改变（图中蓝色方块）。&lt;/p>
&lt;p>最后，如果当前节点已经是叶节点，那么可以返回，否则需要进行下降，读取内部结点根据  &lt;code>key[x, x+8)&lt;/code>(8 字节) 获得下降节点之后，分为 3 种情况处理：&lt;/p>
&lt;ol>
&lt;li>case 1 那行伪代码可以这样用 C 语言表示：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">before&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node_get_stable_version&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// read node here
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node_get_version&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// no need to be stable, just latest version
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">before&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">LOCK_BIT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">before&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">after&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1">// neither insert nor split happened
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>节点在我们读取期间没有发生任何变化，我们可以安全地进行下降；&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>节点发生了变化，而且是分裂，那么我们需要从根节点重新进行下降（内部节点没有相互连接起来，所以不能像 Blink Tree 那样获取右节点）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点发生了变化，但只是插入，只需要重新对当前节点进行下降&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>注意第二个黄色方块，这一行非常关键，如果你细看下的话，它似乎可以挪到 case 1 的 if 语句里面，但实际上不能这样做。因为如果当前节点的孩子节点发生了分裂，但是还没来得及将新节点插入到当前节点，对调这两行代码，可能会导致下降到错误的节点。&lt;/p>
&lt;/blockquote>
&lt;h2 id="插入流程">&lt;strong>插入流程&lt;/strong>&lt;/h2>
&lt;p>作者只给出了读取伪代码，这里给出插入伪代码。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-02-06-2020-11-14-11-01-59-image.png" alt="">&lt;/p>
&lt;p>当我们通过  &lt;code>findborder&lt;/code>  下降到叶节点后，需要对其加锁（图中蓝色方块），但是此时并不能直接将 key 进行插入，当两个写线程同时下降到同一个叶节点时，只有一个线程可以进行写入，所以加锁后需要查看在加锁前是否有其他线程对这个节点进行了写入，如果有的话需要查看是否需要右移，这里的逻辑和 Blink Tree 是一样的。&lt;/p>
&lt;p>当我们成功加锁并且定位到正确的叶节点之后，可以进行写入，结果有 4 种：&lt;/p>
&lt;ol>
&lt;li>插入 key 成功或 key 已经存在；&lt;/li>
&lt;li>需要下降到下一层，同时需要增加索引的偏移；&lt;/li>
&lt;li>存在索引冲突，比如 &amp;ldquo;12345678AA&amp;rdquo; 和 &amp;ldquo;12345678BB&amp;rdquo;，此时需要创建一棵子树，存放 &amp;ldquo;AA&amp;rdquo; 和 &amp;ldquo;BB&amp;rdquo;，同时需要把原来存放 &amp;ldquo;AA&amp;rdquo; 的地方替换成这棵子树的根节点&lt;/li>
&lt;li>节点已满，需要分裂之后再次插入（见下一小节）&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>橙色方块在下面删除流程中介绍&lt;/p>
&lt;/blockquote>
&lt;h2 id="实现">实现&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/UncP/aili">UncP/aili&lt;/a>，没有实现删除操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/rmind/masstree">https://github.com/rmind/masstree&lt;/a>，采用了激进生成子树的策略，缺点就是 cache locality 在有些情况下不好。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>论文作者的实现：&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/kohler/masstree-beta">https://github.com/kohler/masstree-beta&lt;/a>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="总结">&lt;strong>总结&lt;/strong>&lt;/h2>
&lt;ol>
&lt;li>Trie 和 B+ 两种索引树的结合，使得在下降过程中的重试不需要从整棵树的根节点开始，同时加快拥有相同前缀的 key 的处理速度&lt;/li>
&lt;li>具体的内部结点与外部节点的结构&lt;/li>
&lt;li>fine-grained locking 写以及 lock-free 读&lt;/li>
&lt;li>比较具体的节点删除机制&lt;/li>
&lt;li>较小的节点减少了线程的竞争&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>需要指出的是这个算法不支持性能线性扩展，不过这并不是问题。&lt;/p>
&lt;/blockquote>
&lt;p>这个算法实现起来很有&lt;strong>挑战性&lt;/strong>，个人认为主要有两个方面，第一个是对于&lt;strong>树结构的把握&lt;/strong>，Mass Tree 是 Trie 和 B+ 树的结合。第二个是对于&lt;strong>并发下可见性的理解&lt;/strong>，”先改哪个域后改哪个域“，”谁先可见谁后可见“，”谁何时可见“，“在哪加以及加不加 memory barrier”等等这样的问题需要花很多时间考虑，而且出现 bug 非常难调试。&lt;/p>
&lt;p>Mass Tree 性能比我预想中要好很多，对于均匀分布的 10 字节 key 随机插入，数据量 1000 万，在我的机器上 4 个线程可以到 500 万以上的 tps；对于分布集中的测试数据，可以到 1000 万以上。其实&lt;strong>对于内存索引来说，cache miss 对性能造成的影响有时候是远远大于线程竞争的&lt;/strong>，所以尽管数据分布非常集中（线程竞争更多），仍然可以获得更高的性能。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf">https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kohler/masstree-beta">https://github.com/kohler/masstree-beta&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/52624601">https://zhuanlan.zhihu.com/p/52624601&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>MerkleTree</title><link>https://justice.bj.cn/post/12.data_struct/tree/merkle-tree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/merkle-tree/</guid><description>&lt;h1 id="merkle-tree">Merkle Tree&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Merkle Tree 是一种 Hash Tree，由 Ralph Merkle 在 1979 年发明。&lt;/p>
&lt;p>Merkle Tree 的每个非叶节点通过其子节点的标记或者值（子节点为叶节点）的哈希值来进行标注，为大型的数据结构提供了高效安全的验证手段。&lt;/p>
&lt;p>Merkle Tree 可以理解为哈希列表和哈希链表的泛化产物。&lt;/p>
&lt;h2 id="结构">结构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/05-20-37-06-2020-12-05-20-34-44-image.png" alt="">&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>MT 是一种树，大多数是二叉树，也可以多叉树；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Merkle Tree 的叶子节点的 value 是数据集合的单元数据或者单元数据 HASH。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非叶子节点的 value 是根据它下面所有的叶子节点值，然后按照 Hash 算法计算而得出的；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>数字签名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>P2P 网络&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可信计算&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPFS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BitCoin/Ethereum&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/fengzhiwu/p/5524324.html">Merkle Tree 学习&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Radix Tree</title><link>https://justice.bj.cn/post/12.data_struct/tree/radixtree/</link><pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate><guid>https://justice.bj.cn/post/12.data_struct/tree/radixtree/</guid><description>&lt;h1 id="基数树radix-tree">基数树(Radix Tree)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Radix tree(也被称为 radix trie，或者 compact prefix tree)是一种空间优化的前缀树(prefix tree)数据结构。&lt;/p>
&lt;p>针对这对这样的稀疏长整型数据查找，能高速且节省空间地完成映射&lt;/p>
&lt;img title="" src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-32-55-2021-09-04-10-32-52-image.png" alt="" data-align="left">
&lt;h2 id="应用场景">应用场景&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>IP 路由；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>倒排索引；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IDR（ID Radix）机制；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Linux 基数树（radix tree），内存管理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Redis Radix tree；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://ivanzz1001.github.io/records/post/data-structure/2018/11/18/ds-radix-tree" title="数据结构之Radix Tree">数据结构之 Radix Tree&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://sourcelink.top/2019/09/26/linux-kernel-radix-tree-analysis/">详解 Linux 内核 Radix 树算法的实现 - 黎棉麒的独立博客&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/developer/article/1597128">图解 Redis 中的 Radix 树 - 云+社区 - 腾讯云&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>AWS常用概念</title><link>https://justice.bj.cn/post/30.architech/aws-s3/aws-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 15 Jun 2020 05:42:31 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/aws-s3/aws-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</guid><description>&lt;h1 id="aws常用概念">AWS常用概念&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>每个&lt;strong>Region&lt;/strong>都是完全独立的。每个&lt;strong>Availability Zone&lt;/strong>都是隔离的，但是Region中的可用区通过低延迟链接连接。&lt;strong>Local Zone&lt;/strong>是一种AWS基础架构部署，可将所选服务放置在更接近最终用户的位置。&lt;strong>Local Zone&lt;/strong>是与您所在区域不同位置的区域的扩展。它为AWS基础架构提供了高带宽主干，非常适合对延迟敏感的应用程序，例如机器学习。下图说明了区域，可用区域和本地区域之间的关系。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-08-59-25-2020-03-03-12-48-56-image.png" alt="">&lt;/p>
&lt;p>Amazon EC2资源是以下资源之一：全局，与Region，&lt;strong>Availability Zone&lt;/strong>或&lt;strong>Local Zone&lt;/strong>绑定&lt;/p>
&lt;h2 id="region">Region&lt;/h2>
&lt;p>每个Amazon EC2 &lt;strong>Region&lt;/strong>都旨在与其他Amazon EC2 &lt;strong>Region&lt;/strong>隔离。这样可以实现最大的容错能力和稳定性。&lt;/p>
&lt;p>当您查看您的资源时，您只会看到与您指定的区域相关联的资源。这是因为区域彼此隔离，并且我们不会自动在区域之间复制资源。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Accumulo</title><link>https://justice.bj.cn/post/30.architech/accumulo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/accumulo/</guid><description>&lt;h1 id="accumulo">Accumulo&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>Apache Accumulo&lt;/strong> 由 NSA 开源一个可靠、可伸缩、高性能的排序分布式的 Key-Value 数据库。基于单元访问控制以及可定制的服务器端处理。Accumulo 使用 Google BigTable 设计思路，基于 Apache Hadoop、Zookeeper 和 Thrift 构建。它与 HBase 很像，但也有不少创新点，比如基于 cell 的访问控制，称为 iterator 的服务器端编程机制，可以在整个流程中对各种函数编码。Accumulo 设有自动负载平衡和分区，数据压缩和细粒度的安全标签。&lt;/p>
&lt;h2 id="特性">特性&lt;/h2>
&lt;ul>
&lt;li>BigTable 的复制品，也是跑在 Hadoop 的上层；&lt;/li>
&lt;li>单元级安全保证；&lt;/li>
&lt;li>允许使用比内存容量更大的数据列；&lt;/li>
&lt;li>通过 C++ 的 STL 可保持数据从 JAVA 环境的内存映射出来；&lt;/li>
&lt;li>使用 Hadoop 的 Map/reduce 模型；&lt;/li>
&lt;li>支持在服务器端编程；&lt;/li>
&lt;li>支持 multi-volume；&lt;/li>
&lt;/ul>
&lt;h2 id="和-hbase-对比">和 HBase 对比&lt;/h2>
&lt;ul>
&lt;li>安全性方面都支持 cell 级别的安全控制；&lt;/li>
&lt;li>hbase 使用 coprocessor，accumulo 使用的 iterator 来提供服务端定制功能；&lt;/li>
&lt;li>hbase 可跨数据中心复制，对灾难的恢复支持更好；&lt;/li>
&lt;li>一致性模型：hbase 使用的日志复制，accumulo 使用的 mvcc；&lt;/li>
&lt;li>accumulo 可支持附加索引，hbase 只支持 row key 索引；&lt;/li>
&lt;li>accumulo 的 cf 不用事先制定，hbase 需要事先制定；&lt;/li>
&lt;li>accumulo 支持 locality group，hbase 不支持；&lt;/li>
&lt;li>accumulo 支持多 cf，hbase 的 cf 尽量少；&lt;/li>
&lt;/ul>
&lt;h2 id="bigtable-vs-accumulo-vs-hbase">BigTable vs Accumulo vs HBase&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Bigtable&lt;/th>
&lt;th style="text-align:left">Accumulo&lt;/th>
&lt;th style="text-align:left">Hbase&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">Tablet&lt;/td>
&lt;td style="text-align:left">Tablet&lt;/td>
&lt;td style="text-align:left">Region&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Tablet Server&lt;/td>
&lt;td style="text-align:left">Tablet Server&lt;/td>
&lt;td style="text-align:left">Region Server&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Minor Compaction&lt;/td>
&lt;td style="text-align:left">Minor Compaction&lt;/td>
&lt;td style="text-align:left">Flush&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Merging Compaction&lt;/td>
&lt;td style="text-align:left">Major Compaction&lt;/td>
&lt;td style="text-align:left">Minor Compaction&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Major Compaction&lt;/td>
&lt;td style="text-align:left">(Full) Majro Compaction&lt;/td>
&lt;td style="text-align:left">Major Compaction&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Commit Log&lt;/td>
&lt;td style="text-align:left">WAL&lt;/td>
&lt;td style="text-align:left">WAL&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">GFS&lt;/td>
&lt;td style="text-align:left">HDFS&lt;/td>
&lt;td style="text-align:left">HDFS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">MemTable&lt;/td>
&lt;td style="text-align:left">MemTable&lt;/td>
&lt;td style="text-align:left">MemStore&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">SSTable&lt;/td>
&lt;td style="text-align:left">RFile&lt;/td>
&lt;td style="text-align:left">HFile&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Chubby&lt;/td>
&lt;td style="text-align:left">ZooKeeper&lt;/td>
&lt;td style="text-align:left">ZooKeeper&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">MapReduce&lt;/td>
&lt;td style="text-align:left">Hadoop MapReduce&lt;/td>
&lt;td style="text-align:left">Hadoop MapReduce&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="应用生态">应用生态&lt;/h2>
&lt;p>Accumulo 最早由 NSA 2007 年开始开发，于 2011 年 9 月提交 Apache 基金会成为开源项目，Accumulo 数据库系统是 NSA 架构的核心（PRISM 棱镜项目的核心），大多数 NSA 的关键分析应用都运行在 Accumulo 上。NSA 开发 Accumulo 的工程师 2012 年离开 NSA，创办了基于 accumulo 的网络安全软件公司 Sqrrl，并于 2017 年 12 月被 Amazon 收购。&lt;/p>
&lt;p>Accumulo 基于 Hadoop 生态，是 bigtable 的一种安全增加实现，因此很适合用于政府及大公司的大规模数据分析中。到 2014 年，已经有几十家不同类型的美国企业安装了 Accumulo 技术系统，其中，美国 20 强企业中已有 3 家安装，50 强企业中有 5 家安装，还有不少企业已表示对此有兴趣。国内公司使用的 accumulo 较少；&lt;/p>
&lt;p>Accumulo 和 hbase 的重合度较高，彼此基本可以相互替代。想较于 hbase，其社区活跃度较低，文档较少，github： stark:384, fork:205 (hbase: star:2K, fork 1.5K )；&lt;/p>
&lt;h2 id="使用场景">使用场景&lt;/h2>
&lt;p>Accumulo 源于 NSA，因此很适用用于构建安全、实时的大数据应用系统，包括[^1]：&lt;/p>
&lt;ul>
&lt;li>实时检测分析；&lt;/li>
&lt;li>图数据；&lt;/li>
&lt;li>物联网应用；&lt;/li>
&lt;li>Sessionization；&lt;/li>
&lt;/ul>
&lt;h2 id="典型应用">典型应用&lt;/h2>
&lt;ul>
&lt;li>Sqrrl 威胁追踪平台：基于 accumulo 的可靠、安全、 多租户、 近实时数据分析系统，支持机构对几十 PB 级的数据分析，被很多美国政府和军方机构使用。&lt;/li>
&lt;li>Apache Fluo： Twitter  &lt;a href="https://research.google.com/pubs/pub36726.html">Google Percolator&lt;/a>的开源实现，允许用户对存储在  &lt;a href="https://www.oschina.net/p/accumulo">Apache Accumulo&lt;/a>  中的大型数据集进行增量更新，而无需重新处理所有的数据。与批处理和流处理框架不同的是，Fluo 提供了更低的延迟，并且可以在极大的数据集上运行。在将新数据与现有数据相结合时，与批处理框架（例如 Spark，MapReduce）相比，Fluo 可明显减少延迟。其增量更新是使用事务实现的，允许数千个更新同时发生而不会破坏数据。&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>一个典型的 Accumulo 系统包括一套 ZK 系统，多个 client，多个 TabletServers，一台 master 服务器，一个或多个 gc 收集进程，若干 monitor 进程，一个或多个 Tracer 进程。底层数据存储于 hadoop 的 hdfs 中。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-38-45-image-20180626155114401.png" alt="image-20180626155114401">&lt;/p>
&lt;p>组件包括：&lt;/p>
&lt;ul>
&lt;li>Client：Accumulo includes a client library that is linked to every application. The client library contains logic for finding servers managing a particular tablet, and communicating with TabletServers to write and retrieve key-value pairs.&lt;/li>
&lt;li>zookeeper：检测进程的存活、任务的协调、灾备和配置的存储；&lt;/li>
&lt;li>Master：主服务，主要保存元数据的存储，分区分配，动态迁移及表操作；&lt;/li>
&lt;li>Tablet Server：提供数据读写的入口；&lt;/li>
&lt;li>Garbage Collector：对 RFile 进行合并清理；&lt;/li>
&lt;li>Tracer：追踪组件。支持分布式时间 API；&lt;/li>
&lt;li>Monitor：提供实例状态健康监控信息；&lt;/li>
&lt;li>hdfs：用于数据存储；&lt;/li>
&lt;/ul>
&lt;h2 id="数据模型data-model">数据模型(Data Model)&lt;/h2>
&lt;p>Accumulo 提供比简单键值存储更丰富的数据模型，但不是完全关系数据库。数据表示为键值对，其中键和值由以下元素组成：&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-38-52-image-20180625120614505.png" alt="image-20180625120614505">&lt;/p>
&lt;p>Key 和 Value 的所有元素都以字节数组表示，除了 Timestamp，它是一个 Long。 Accumulo 按照元素排序键，按字典顺序升序排列。时间戳按降序排列，以便相同 Key 的更高版本首先出现在顺序扫描中。表格由一组排序的键值对组成。&lt;/p>
&lt;h2 id="数据管理">数据管理&lt;/h2>
&lt;p>Accumulo 数据存储在表中，划分成多个 tablet。tablet 基于行边界进行划分，一行的所有列数据都在同一个 tablet 中。Master 将 tablet 分配到一个 Tablet Sever 中。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-38-59-image-20180625122144641.png" alt="image-20180625122144641">&lt;/p>
&lt;h2 id="相关图数据库">相关图数据库&lt;/h2>
&lt;h3 id="gaffer">Gaffer&lt;/h3>
&lt;ul>
&lt;li>Gaffer 是一个图形数据库框架。&lt;/li>
&lt;li>它允许在节点和边上存储包含丰富属性的非常大的图。有多种存储选项可供选择，包括 Accumulo，Hbase 和 Parquet。（Gaffer is a graph database framework. It allows the storage of very large graphs containing rich properties on the nodes and edges. Several storage options are available, including Accumulo, Hbase and Parquet.）&lt;/li>
&lt;li>最新版本：1.5.2（2018-6-7），社区活跃度较高（github：start 1419，fork：302）&lt;/li>
&lt;li>&lt;a href="https://github.com/gchq/Gaffer">https://github.com/gchq/Gaffer&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>特性&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>巨大节点/边上的快速查询；&lt;/li>
&lt;li>快速持续摄取数据；&lt;/li>
&lt;li>边和节点上存储任意 Java 对象；&lt;/li>
&lt;li>内在提供的自动，可配置的聚合统计属性（比如：count，histograms，sketches）&lt;/li>
&lt;li>丰富的时间汇总、数据过滤和转换功能；&lt;/li>
&lt;li>良好的数据访问控制；&lt;/li>
&lt;li>查询支持 hook ；&lt;/li>
&lt;li>自动、基于规则的数据删除（用于过期数据删除）；&lt;/li>
&lt;li>使用 spark 提供更快速、灵活的数据分析；&lt;/li>
&lt;li>REST API&lt;/li>
&lt;/ul>
&lt;h3 id="graphulo">Graphulo&lt;/h3>
&lt;ul>
&lt;li>MIT 开源项目；&lt;/li>
&lt;li>Apache Accumulo 数据库的 Java 库工具，用来支持数据库内的图算法分析；&lt;/li>
&lt;li>提供服务器端稀疏矩阵数学原语，支持更高级别的图算法和分析。&lt;/li>
&lt;li>&lt;a href="https://github.com/Accla/graphulo/">https://github.com/Accla/graphulo/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="lumify">lumify&lt;/h3>
&lt;ul>
&lt;li>基于 accumulo 的开源大数据集成、分析、可视化平台；&lt;/li>
&lt;li>&lt;a href="http://www.altamiracorp.com/index.php/lumify/">http://www.altamiracorp.com/index.php/lumify/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="accumulograph">AccumuloGraph&lt;/h3>
&lt;p>以[Apache Accumulo]作为后端的 TinkerPop 图数据库 Blueprints Api 的实现，最新版本 0.2.1，已停更；&lt;/p>
&lt;h2 id="关键流程">关键流程&lt;/h2>
&lt;h3 id="写流程">写流程&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-39-05-image-20180626144601503.png" alt="image-20180626144601503">&lt;/p>
&lt;ol>
&lt;li>写 Memory Map；&lt;/li>
&lt;li>写 WAL;&lt;/li>
&lt;li>写返回；&lt;/li>
&lt;/ol>
&lt;h3 id="读流程">读流程&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-39-13-image-20180626144644956.png" alt="image-20180626144644956">&lt;/p>
&lt;h2 id="性能对比accumulo-vs-hbase">性能对比（Accumulo vs HBase）&lt;/h2>
&lt;p>&lt;a href="http://accumulosummit.com/2015/program/talks/hdfs-short-circuit-local-read-performance-benchmarking-with-apache-accumulo-and-apache-hbase/">HDFS Short Circuit Local Read Performance Benchmarking with Apache Accumulo and Apache HBase（2015 accumulo summit ）&lt;/a>&lt;/p>
&lt;h3 id="吞吐量">吞吐量&lt;/h3>
&lt;ul>
&lt;li>读&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-39-18-image-20180627182851723.png" alt="image-20180627182851723">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>写&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-39-24-299541F8-59F2-48CC-9FAA-427A09F9274D.jpeg" alt="299541F8-59F2-48CC-9FAA-427A09F9274D">&lt;/p>
&lt;p>accumulo 支持 bigtable 的 locality group 特性，读写性能受 column 的数量影响较小，hbase 在列较少时读写性能优于 accumulo，但当列增大时，读写性能均有下降&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="延迟">延迟&lt;/h3>
&lt;ul>
&lt;li>accumulo&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-39-30-image-20180627175550283.png" alt="image-20180627175550283">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>hbase&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-39-37-image-20180627175718775.png" alt="image-20180627175718775">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="快速入门">快速入门&lt;/h2>
&lt;h3 id="安装">安装&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ wget http://mirrors.shu.edu.cn/apache/accumulo/1.9.1/accumulo-1.9.1-bin.tar.gz
$ &lt;span class="nb">cd&lt;/span> /export/servers/
$ tar xf accumulo-1.9.1-bin.tar.gz
$ &lt;span class="nb">cd&lt;/span> accumulo-1.9.1
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="配置">配置&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ bin/bootstrap_config.sh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>The agency needed a scalable, secure database with which to store and analyze the never-ending stream of data it collects as part of its mandate “&lt;a href="http://www.fas.org/irp/congress/1999_hr/99-07-01mcnamara.htm">to understand the secret communications of our foreign adversaries&lt;/a>.1” BigTable was the best database it could find to meet its requirements, but even it lacked cell-level security. As such, engineers at the NSA developed and natively incorporated cell-level security capabilities into its reverse-engineered version of BigTable, and Accumulo was born.&lt;/li>
&lt;li>&lt;a href="http://bigdata-guide.blogspot.com/2014/01/hbase-versus-cassandra-versus-accumulo.html">http://bigdata-guide.blogspot.com/2014/01/hbase-versus-cassandra-versus-accumulo.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/accumulo-wikisearch">https://github.com/apache/accumulo-wikisearch&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.pdl.cmu.edu/SDI/2013/slides/big_graph_nsa_rd_2013_56002v1.pdf">http://www.pdl.cmu.edu/SDI/2013/slides/big_graph_nsa_rd_2013_56002v1.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quabase.sei.cmu.edu/mediawiki/index.php/Accumulo_Data_Model_Features">https://quabase.sei.cmu.edu/mediawiki/index.php/Accumulo_Data_Model_Features&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quabase.sei.cmu.edu/mediawiki/index.php/Accumulo">https://quabase.sei.cmu.edu/mediawiki/index.php/Accumulo&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arstechnica.com/information-technology/2013/06/what-the-nsa-can-do-with-big-data/2/">https://arstechnica.com/information-technology/2013/06/what-the-nsa-can-do-with-big-data/2/&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://accumulosummit.com/2015/program/talks/hdfs-short-circuit-local-read-performance-benchmarking-with-apache-accumulo-and-apache-hbase/">http://accumulosummit.com/2015/program/talks/hdfs-short-circuit-local-read-performance-benchmarking-with-apache-accumulo-and-apache-hbase/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1063206">https://cloud.tencent.com/developer/article/1063206&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gigaom.com/2013/06/07/under-the-covers-of-the-nsas-big-data-effort/">https://gigaom.com/2013/06/07/under-the-covers-of-the-nsas-big-data-effort/&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cena.com.cn/ia/20140919/56653.html">http://www.cena.com.cn/ia/20140919/56653.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cbdio.com/BigData/2016-09/01/content_5199203.htm">http://www.cbdio.com/BigData/2016-09/01/content_5199203.htm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openfoundry.org/tw/foss-news/8453-nas-proposes-security-nosql-database-accumulo?tmpl=component&amp;amp;print=1&amp;amp;layout=default&amp;amp;page=">NSA 向 Apache 提交安全的 NoSQL 資料庫&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.ippon.tech/use-cassandra-mongodb-hbase-accumulo-mysql/">https://blog.ippon.tech/use-cassandra-mongodb-hbase-accumulo-mysql/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cloudera.com/products/open-source/apache-hadoop/apache-accumulo.htmlh">https://www.cloudera.com/products/open-source/apache-hadoop/apache-accumulo.htmlh&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://wikibon.org/blog/breaking-analysis-accumulo-why-the-world-needs-another-nosql-database/">http://wikibon.org/blog/breaking-analysis-accumulo-why-the-world-needs-another-nosql-database/&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Alluxio</title><link>https://justice.bj.cn/post/30.architech/alluxio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/alluxio/</guid><description>&lt;h1 id="alluxio">Alluxio&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Alluxio是一个开源的基于内存的分布式存储系统, 为计算框架和存储系统构建了桥梁，使应用程序能够通过一个公共接口连接到许多存储系统。 项目源自 UC Berkeley 的 &lt;a href="https://amplab.cs.berkeley.edu/software/">AMPLab&lt;/a>（见&lt;a href="https://www.alluxio.org/resources/white-papers">论文&lt;/a>）&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-47-16-image-20190515093053597.png" alt="image-20190515093053597">&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>分布式共享缓存&lt;/li>
&lt;li>可插拔存储&lt;/li>
&lt;li>存储分层&lt;/li>
&lt;li>统一命名空间&lt;/li>
&lt;li>Hadoop兼容&lt;/li>
&lt;li>多种回收策略&lt;/li>
&lt;li>支持fuse&lt;/li>
&lt;li>支持kv&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-47-09-image-20190515113141895.png" alt="image-20190515113141895">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>master&lt;/strong>：负责监控各个Worker以及管理全局的文件系统元数据，比如文件系统树等&lt;/li>
&lt;li>&lt;strong>worker&lt;/strong>：负责管理本节点数据存储服务（本地的MEM、SSD和HDD）&lt;/li>
&lt;li>&lt;strong>client&lt;/strong>：向用户和应用提供访问接口，以及向Master和Worker发送请求&lt;/li>
&lt;li>&lt;strong>ufs&lt;/strong>：定期备份数据&lt;/li>
&lt;/ul>
&lt;h2 id="ha">HA&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-47-01-image-20190515160825686.png" alt="image-20190515160825686">&lt;/p>
&lt;h2 id="使用场景">使用场景&lt;/h2>
&lt;ul>
&lt;li>分层存储：提供MEM-SSD-HDD 分层存储；&lt;/li>
&lt;li>多存储系统聚合：Alluxio支持不同的底层存储，并提供统一的接口。例如GlusterFS、(secure) HDFS、NFS、Amazon S3、AliyunOSS、OpenStack Swift、Google Cloud Storage。&lt;/li>
&lt;li>Hadoop生态缓存加速：alluxio能和hadoop很好兼容，直接替换hdfs接口，为hadoop生态提供缓存加速功能（具体加速效果和具体业务有关）；&lt;/li>
&lt;li>计算层需要反复访问远程（比如在云端，或跨机房）的数据；&lt;/li>
&lt;li>计算层需要同时访问多个独立的持久化数据源（比如同时访问S3和HDFS中的数据）；&lt;/li>
&lt;li>多个独立的大数据应用（比如不同的Spark Job）需要高速有效的共享数据；&lt;/li>
&lt;li>当计算层有着较为严重的内存资源、以及JVM GC压力，或者较高的任务失败率时，Alluxio作为输入输出数据的Off heap存储可以极大缓解这一压力，并使计算消耗的时间和资源更可控可预测。&lt;/li>
&lt;/ul>
&lt;h2 id="配置">配置&lt;/h2>
&lt;ul>
&lt;li>分层存储&lt;/li>
&lt;/ul>
&lt;p>$ALLUXIO_HOME/conf/alluxio-site.conf&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">alluxio.worker.tieredstore.levels&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span>
alluxio.worker.tieredstore.level0.alias&lt;span class="o">=&lt;/span>MEM
alluxio.worker.tieredstore.level0.dirs.path&lt;span class="o">=&lt;/span>/mnt/ramdisk
alluxio.worker.tieredstore.level0.dirs.quota&lt;span class="o">=&lt;/span>100GB
alluxio.worker.tieredstore.level0.watermark.high.ratio&lt;span class="o">=&lt;/span>0.9
alluxio.worker.tieredstore.level0.watermark.low.ratio&lt;span class="o">=&lt;/span>0.7
alluxio.worker.tieredstore.level1.alias&lt;span class="o">=&lt;/span>HDD
alluxio.worker.tieredstore.level1.dirs.path&lt;span class="o">=&lt;/span>/mnt/hdd1,/mnt/hdd2,/mnt/hdd3
alluxio.worker.tieredstore.level1.dirs.quota&lt;span class="o">=&lt;/span>2TB,5TB,500GB
alluxio.worker.tieredstore.level1.watermark.high.ratio&lt;span class="o">=&lt;/span>0.9
alluxio.worker.tieredstore.level1.watermark.low.ratio&lt;span class="o">=&lt;/span>0.7
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="数据读写">数据读写&lt;/h2>
&lt;h3 id="读">读&lt;/h3>
&lt;ul>
&lt;li>缓存命中
&lt;ul>
&lt;li>本地缓存命中：一旦客户端发现访问的数据在本地存在，则会直接通过一种“短路读”的方式，直接访问本地文件系统进行访问，从而绕开TCP网络传输过程。&lt;/li>
&lt;li>远程缓存命中：直接读取远程节点上的缓存，同时为了以后潜在的读取访问操作，将远程缓存进行一个拷贝在发起请求的worker节点上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缓存非命中：worker会读取底层文件系统，然后加到内存里，方便下次缓存的命中。
&lt;ul>
&lt;li>Partial Caching：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="写">写&lt;/h3>
&lt;ul>
&lt;li>不持久化：直接更新到内存，可能因为机器crash导致数据丢失。&lt;/li>
&lt;li>持久化
&lt;ul>
&lt;li>同步持久化&lt;/li>
&lt;li>异步持久化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://blog.csdn.net/Androidlushangderen/article/details/81142285">https://blog.csdn.net/Androidlushangderen/article/details/81142285&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Anna</title><link>https://justice.bj.cn/post/30.architech/anna/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/anna/</guid><description>&lt;h1 id="anna">Anna&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Anna是伯克利 RISE 实验室推出了KV存储数据库，提供了惊人的存取速度、超强的伸缩性和史无前例的一致性保证。anna基于无协调 actor 模型，每个 actor 对应一个线程，对任何一个共享状态都有自己的一份私有拷贝，并通过异步广播将更新通知给其他 actor。在多核服务器上，这种模型比传统的共享内存模型的性能要高出一个数量级。&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;p>&lt;a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">Anna&lt;/a> 的key和节点的分布也是一致性哈希。采用 &lt;a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip&lt;/a> 算法来处理actor的容灾和扩缩容。按文中的意思似乎数据分片的同步也采用的是 &lt;a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip&lt;/a> 。不过在这一点上 &lt;a href="http://publicatio.bibl.u-szeged.hu/1529/1/gossip11.pdf">gossip&lt;/a> 对分布式系统的局部分片扩容天生是比 &lt;a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos&lt;/a> 和 &lt;a href="https://raft.github.io/">Raft&lt;/a> 要好很多。&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/13-09-47-31-image-20190528100256465.png" alt="image-20190528100256465">&lt;/p>
&lt;p>Anna 服务器由一系列独立的线程组成，每个线程运行无协调的 actor。每个线程对应一个 CPU 核心，线程数量不超过 CPU 的总核数。客户端代理负责将远程请求分发给 actor，每个 actor 都有一个私有的哈希表，这些哈希表存放在共享内存中。线程间的变更通过内存广播进行交换，而服务器间的变更则通过 protobuf 进行交换。&lt;/p>
&lt;p>这种线程和 CPU 核心一对一的模型避免了上下文切换开销。actor 之间不共享键值状态，通过一致性哈希对键空间进行分区，并使用多主复制机制在 actor 之间复制数据分区，而且复制系数是可配置的。actor 基于时间戳将键的更新通知给其他 actor 副本，每个 actor 有自己的私有状态，这个状态保存在一个叫作“格子”的数据结构中，确保在消息发生延迟、重排或重复时仍然能够保证一致性。&lt;/p>
&lt;h2 id="性能测评">性能测评&lt;/h2>
&lt;ul>
&lt;li>Anna 与 TBB、Masstree 和 Ideal&lt;/li>
&lt;li>Anna 与Redis&lt;/li>
&lt;li>Anna 与 Cassandra&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3WmGpZkEuSz-ox_2CPCsqg">https://mp.weixin.qq.com/s/3WmGpZkEuSz-ox_2CPCsqg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ucbrise/anna">https://github.com/ucbrise/anna&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/entry/5aaa708b51882555627d04b4">https://juejin.im/entry/5aaa708b51882555627d04b4&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf">http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item></channel></rss>