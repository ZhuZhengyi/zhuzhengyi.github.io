<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Justice的小站</title>
    <link>http://justice.bj.cn/</link>
    <description>Recent content on Justice的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 16 Oct 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://justice.bj.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Chapter 1</title>
      <link>http://justice.bj.cn/docs/example-doc/chapter-1/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://justice.bj.cn/docs/example-doc/chapter-1/</guid>
      
        <description>&lt;p&gt;This is chapter 1 of example doc.&lt;/p&gt;
&lt;h2 id=&#34;proin-pretium-lorem-a-justo-euismod-condimentum&#34;&gt;Proin pretium lorem a justo euismod condimentum&lt;/h2&gt;
&lt;p&gt;Donec tortor nunc, feugiat non porttitor tristique, dictum vitae nibh. Integer vel mollis ante. Cras sed elementum nulla, vel placerat lectus. Cras ligula diam, blandit sed vehicula eu, aliquet vel leo. Curabitur sagittis nunc vel nulla tempor sagittis. Phasellus elementum mi malesuada libero vehicula sodales eget id augue. Duis consequat egestas tortor, vitae volutpat nibh gravida ultricies. Morbi maximus sed felis posuere luctus. Cras ultrices condimentum purus, eget iaculis nulla. Cras vulputate est in justo sodales varius. Maecenas auctor velit vel urna sodales, et sodales enim maximus. Proin tempus, metus sit amet ultrices luctus, justo eros finibus nibh, a volutpat ipsum lectus in leo. Pellentesque at dictum metus.&lt;/p&gt;
&lt;h3 id=&#34;vivamus-dapibus-nunc-ac-fringilla-pellentesque&#34;&gt;Vivamus dapibus nunc ac fringilla pellentesque&lt;/h3&gt;
&lt;p&gt;Pellentesque porttitor a tortor et egestas. Phasellus aliquet mattis velit in elementum. Suspendisse viverra turpis in risus tincidunt, et malesuada elit eleifend. Sed eu elit arcu. Cras tincidunt mauris purus, vehicula aliquam elit tincidunt eget. Nunc at justo quis augue sagittis auctor sed eu magna. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nunc non nibh mattis, tempus tortor sed, iaculis metus. Morbi quis leo dignissim, viverra massa sit amet, faucibus ex. In hac habitasse platea dictumst. Vivamus tristique sem ac tortor venenatis, vel auctor metus vulputate. Maecenas facilisis odio et enim euismod, et ullamcorper enim congue. Nullam ut dolor eget urna aliquet bibendum sit amet a odio. Aenean vitae diam vel metus imperdiet ullamcorper consectetur ac mauris. Maecenas sed lorem vitae nibh porta venenatis.&lt;/p&gt;
&lt;h2 id=&#34;in-eu-nisl-ac-ante-finibus-accumsan-vitae-vitae-eros&#34;&gt;In eu nisl ac ante finibus accumsan vitae vitae eros&lt;/h2&gt;
&lt;p&gt;Mauris odio nulla, porta in lacinia vel, faucibus quis turpis. Nunc congue faucibus nisi eget feugiat. Integer nec magna purus. Mauris at elit in risus mollis pretium. Morbi at elementum elit, eu condimentum quam. Maecenas maximus eget turpis ac tristique. Nunc scelerisque mi ex, eu pulvinar ante accumsan vitae.&lt;/p&gt;
&lt;h2 id=&#34;aliquam-vitae-augue-egestas&#34;&gt;Aliquam vitae augue egestas&lt;/h2&gt;
&lt;p&gt;Vivamus eget orci ac magna efficitur tincidunt et non urna. Cras mattis molestie nibh, ac posuere lectus bibendum a. Praesent consectetur vulputate dolor eget porta. Fusce ultrices ipsum in tortor consectetur, finibus maximus odio aliquet. Nunc dui odio, fringilla eget quam sed, gravida pretium lorem. Curabitur felis libero, commodo eget pharetra eu, blandit eu lectus. Nunc laoreet nisi purus, in dignissim nibh elementum ut. Nunc sit amet elementum urna. Pellentesque auctor imperdiet lorem, ut egestas arcu. Donec sed magna nec neque molestie aliquet non nec lorem. Phasellus sed libero tortor.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Chapter 1</title>
      <link>http://justice.bj.cn/docs/example-doc/nested-chapter/chapter-1/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://justice.bj.cn/docs/example-doc/nested-chapter/chapter-1/</guid>
      
        <description>&lt;p&gt;This is chapter 1 of nested chapter.&lt;/p&gt;
&lt;h2 id=&#34;ut-aliquam-dui-convallis-purus-interdum&#34;&gt;Ut aliquam dui convallis purus interdum&lt;/h2&gt;
&lt;p&gt;In nec aliquet nisi. Vestibulum varius dui eu ante tempor maximus. Pellentesque at ipsum libero. Sed non augue enim. Sed accumsan arcu sed aliquam maximus. Donec fringilla sem at cursus placerat. Nulla commodo enim nunc, at luctus libero facilisis ut. Quisque id leo at velit pharetra imperdiet vel et felis. Nunc eu tincidunt nulla. Nunc consectetur ligula ut hendrerit malesuada. Sed commodo aliquam elit, at dapibus tellus pellentesque non. Sed vel massa pulvinar, sollicitudin justo sit amet, porta lacus. Quisque eleifend placerat placerat. Phasellus nisl eros, consectetur sit amet mi eget, fringilla luctus purus.&lt;/p&gt;
&lt;h3 id=&#34;morbi-eu-mi-convallis&#34;&gt;Morbi eu mi convallis&lt;/h3&gt;
&lt;p&gt;Sed sed est nulla. Etiam fermentum sed lectus ac molestie. Vestibulum elementum lectus quis interdum semper. Nam id tempus nisl. Nullam in tempor sapien. Integer volutpat nibh vel libero ornare hendrerit. Vestibulum non condimentum nulla. Nulla vel finibus mi. Cras consequat ligula augue, ac vulputate est tincidunt eu. Maecenas nec nibh consequat, egestas nisl non, iaculis nunc. Maecenas eu dolor tortor. Cras in bibendum diam. Vivamus mattis ultricies diam, in dignissim ante scelerisque vel. In euismod dictum ligula, sed scelerisque ipsum volutpat at. Nam lacus elit, porttitor et orci quis, malesuada sagittis risus.&lt;/p&gt;
&lt;h2 id=&#34;aenean-sit-amet-lorem-sit-amet&#34;&gt;Aenean sit amet lorem sit amet&lt;/h2&gt;
&lt;p&gt;Sed eget erat faucibus, malesuada risus at, mollis est. Suspendisse et fringilla nisl, vel placerat ipsum. Proin ut est ornare, molestie ligula et, pretium orci. Aliquam id justo in eros vulputate volutpat. Vivamus sed tellus id quam laoreet fermentum nec ut dui. Ut neque nibh, facilisis dapibus tempor at, egestas non urna. Lorem ipsum dolor sit amet, consectetur adipiscing elit. In maximus, mauris id tempor dapibus, ligula velit pharetra justo, vel molestie sem mauris nec nulla. Suspendisse purus magna, pretium sodales pretium id, consectetur et arcu. Fusce commodo vel nibh quis efficitur. Duis feugiat felis ac mi semper, at sollicitudin tellus ullamcorper. Morbi eget efficitur dui. Nam erat diam, ultrices non mollis in, vestibulum ut lectus. Nunc at dui sed metus vestibulum fringilla. Curabitur vitae mauris vitae neque efficitur molestie eget at nisi. Morbi vel vehicula libero, nec tincidunt augue.&lt;/p&gt;
&lt;h3 id=&#34;maecenas-faucibus-est-ac-orci-fermentum-cursus&#34;&gt;Maecenas faucibus est ac orci fermentum cursus&lt;/h3&gt;
&lt;p&gt;Proin vestibulum pellentesque ipsum, non lobortis arcu volutpat at. Integer neque diam, luctus a turpis non, posuere elementum ex. Donec eget sagittis purus. Maecenas non laoreet quam. Quisque luctus porta pellentesque. Vestibulum auctor commodo tortor non imperdiet. Fusce sed tincidunt nunc. Aenean diam diam, mattis a enim nec, suscipit dignissim neque. Quisque at est quis tortor lobortis vehicula vitae vitae quam. Nam maximus rutrum felis, non feugiat nisl vestibulum quis.&lt;/p&gt;
&lt;h3 id=&#34;suspendisse-suscipit-tellus-at-nibh-tincidunt&#34;&gt;Suspendisse suscipit tellus at nibh tincidunt&lt;/h3&gt;
&lt;p&gt;Nulla pellentesque, leo eget interdum interdum, sem felis consequat massa, id aliquet eros leo sit amet urna. Phasellus quis odio ut odio porttitor consequat quis a velit. Quisque purus velit, faucibus vel efficitur in, sagittis quis neque. Morbi pretium suscipit odio, vel tincidunt nunc dictum aliquam. Quisque non arcu at urna scelerisque semper ac et tortor. Aliquam a dapibus justo. Vestibulum tempus nunc eu condimentum ultrices. Aenean nec egestas nulla, ut congue libero. Aliquam ut mattis urna, in sollicitudin odio. Aenean ac tristique felis, a consequat erat. Aliquam luctus eros ut porttitor efficitur. Nam cursus elit id arcu semper, at sodales velit vulputate. Suspendisse potenti.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Chapter 2</title>
      <link>http://justice.bj.cn/docs/example-doc/chapter-2/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://justice.bj.cn/docs/example-doc/chapter-2/</guid>
      
        <description>&lt;p&gt;This is chapter 2 of example doc.&lt;/p&gt;
&lt;h2 id=&#34;integer-nec-dolor-pharetra&#34;&gt;Integer nec dolor pharetra&lt;/h2&gt;
&lt;p&gt;Integer eget arcu velit. Suspendisse tristique magna nec turpis accumsan ultricies. Duis congue urna non nisl eleifend suscipit. Mauris commodo diam quis nunc dignissim volutpat. Morbi vitae aliquet neque, ut semper arcu. Vivamus ac nunc in velit vehicula auctor. Cras eget congue augue. Vestibulum ipsum ante, consectetur id ligula vitae, iaculis finibus libero. Phasellus elementum libero eget nisi imperdiet consectetur. Sed vitae dui non augue tristique mollis sed aliquet enim. Duis nunc ligula, volutpat a luctus non, fringilla eu mi. Nam pulvinar, dolor a scelerisque tristique, erat nisi interdum mi, et posuere dui odio sed lacus. Nulla facilisi. Mauris auctor erat urna, ut tempus eros rutrum ac. Proin luctus ultricies massa ac finibus.&lt;/p&gt;
&lt;h3 id=&#34;suspendisse-in-enim-ut-purus-ullamcorper-pellentesque&#34;&gt;Suspendisse in enim ut purus ullamcorper pellentesque&lt;/h3&gt;
&lt;p&gt;Morbi ullamcorper sit amet magna eu congue. Sed id lectus risus. Quisque porta feugiat ex, id volutpat tortor molestie sed. Suspendisse consequat pellentesque iaculis. Etiam venenatis ac nunc iaculis placerat. Duis vitae commodo ipsum. Cras fermentum pharetra sapien, vestibulum faucibus erat luctus ac. Phasellus at tellus convallis, feugiat ipsum vitae, dignissim arcu. Suspendisse accumsan tortor ac iaculis tempor. Pellentesque dignissim vehicula nisi, auctor vulputate lectus fringilla ut. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Duis et lorem odio. Cras arcu ipsum, pellentesque nec purus at, lobortis placerat lacus.&lt;/p&gt;
&lt;h2 id=&#34;aenean-consequat-ante-vel-interdum-fermentum&#34;&gt;Aenean consequat ante vel interdum fermentum&lt;/h2&gt;
&lt;p&gt;Morbi nisl neque, rutrum quis tristique ac, accumsan eget diam. Vestibulum iaculis neque justo, vel hendrerit diam dictum ac. Maecenas pretium blandit quam in hendrerit. Quisque consectetur, velit vel eleifend scelerisque, orci arcu efficitur neque, quis suscipit ex augue sit amet ex. Morbi fermentum tellus arcu, quis porta sem mollis eget. Praesent sit amet dictum odio, sed aliquam orci. Duis ac purus eget odio dictum aliquet. Proin finibus, sem non commodo venenatis, ex nunc tempor justo, sit amet pulvinar purus leo egestas est. Curabitur molestie arcu eget sem tristique congue. Praesent congue sollicitudin felis viverra interdum. Proin at odio dapibus, sodales mauris ut, elementum tortor. Fusce sed luctus velit. Vestibulum scelerisque, lectus ac aliquet pretium, ligula turpis lobortis elit, ut dictum urna nunc in orci. Etiam scelerisque augue varius felis luctus molestie. Nunc interdum leo quis faucibus ultricies.&lt;/p&gt;
&lt;h3 id=&#34;integer-volutpat-tortor-ut-vulputate-venenatis&#34;&gt;Integer volutpat tortor ut vulputate venenatis&lt;/h3&gt;
&lt;p&gt;Nullam finibus mollis vestibulum. Quisque eu venenatis purus, facilisis pulvinar sapien. Praesent ultrices eros sit amet pellentesque vulputate. In non malesuada ex, quis sagittis sem. Phasellus dapibus massa scelerisque libero venenatis, ut vulputate felis rutrum. Nam efficitur porttitor sem, sed ullamcorper turpis mattis a. Pellentesque quis est neque. Integer elit metus, auctor in tempor accumsan, egestas vitae arcu.&lt;/p&gt;
&lt;h3 id=&#34;vestibulum-fermentum-massa&#34;&gt;Vestibulum fermentum massa&lt;/h3&gt;
&lt;p&gt;Maecenas molestie egestas purus a gravida. Aliquam erat volutpat. Aenean varius turpis id purus accumsan, quis pellentesque turpis fringilla. Duis quis lacus a nisi rhoncus ullamcorper eget id augue. Praesent dapibus vel lectus ac consequat. Sed nec vehicula magna. Aenean viverra convallis dolor dignissim auctor. Ut semper, quam et sodales vehicula, tellus sapien consequat magna, feugiat vehicula libero nulla eget lorem. Proin libero purus, condimentum eu viverra id, placerat et nibh. Donec feugiat nunc quis erat congue tristique. Sed ut mauris quis eros malesuada placerat. Pellentesque imperdiet dui vitae dui pellentesque, sit amet rutrum risus pretium.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Chapter 2</title>
      <link>http://justice.bj.cn/docs/example-doc/nested-chapter/chapter-2/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://justice.bj.cn/docs/example-doc/nested-chapter/chapter-2/</guid>
      
        <description>&lt;p&gt;This is chapter 2 of nested chapter.&lt;/p&gt;
&lt;h2 id=&#34;vivamus-facilisis-risus-ac-eros-porttitor&#34;&gt;Vivamus facilisis risus ac eros porttitor&lt;/h2&gt;
&lt;p&gt;Proin quis sapien porta, dictum magna eget, sodales erat. Nunc eu nisl at elit molestie placerat. Nulla nec massa non lectus malesuada vehicula. Suspendisse quis arcu elit. Praesent est ipsum, pharetra ac malesuada a, ultricies vel sem. Aenean arcu neque, bibendum a tincidunt eget, efficitur ac sapien. Vestibulum eu suscipit massa. Aenean non libero molestie, tristique purus eget, bibendum tellus. Donec id nisl laoreet elit sodales viverra nec et risus. Nullam tortor dolor, auctor convallis vulputate porta, egestas cursus lacus. Sed rhoncus ipsum accumsan magna cursus, sit amet fringilla sapien feugiat. Aliquam facilisis viverra risus, eget varius erat convallis quis.&lt;/p&gt;
&lt;h2 id=&#34;integer-feugiat-orci-a-diam-cursus-tincidunt-id-a-urna&#34;&gt;Integer feugiat orci a diam cursus tincidunt id a urna&lt;/h2&gt;
&lt;p&gt;Suspendisse tristique sem erat, vitae fringilla purus euismod vel. Nam magna dui, scelerisque at nibh et, faucibus dapibus nibh. Nulla facilisi. Quisque a diam sed mauris pretium volutpat. Nam nec mollis dolor, in ultrices arcu. Suspendisse ut placerat ex, dictum fringilla libero. Quisque mollis aliquet tellus in congue.&lt;/p&gt;
&lt;h2 id=&#34;maecenas-eu-ipsum-at-lectus-commodo-eleifend-nec-vel-ante&#34;&gt;Maecenas eu ipsum at lectus commodo eleifend nec vel ante&lt;/h2&gt;
&lt;p&gt;Nulla sit amet dolor sed elit semper accumsan. Nunc suscipit sapien eget nulla imperdiet gravida. Pellentesque dignissim metus eget felis tempor, at elementum ipsum vulputate. In pretium accumsan neque ut pulvinar. Donec rhoncus at elit id vulputate. Maecenas massa libero, porttitor et lacus eget, gravida auctor tellus. Cras lacus urna, hendrerit et tincidunt efficitur, rutrum id nisi. Nunc quis accumsan ex, eget rutrum sem. Vivamus vel dui eget leo luctus consectetur. Sed tellus elit, aliquet quis commodo in, fermentum sit amet ante. Curabitur nec ornare tortor. Sed et tempus mi. Pellentesque sollicitudin porttitor mi eget hendrerit. Maecenas lobortis turpis ut quam placerat pharetra.&lt;/p&gt;
&lt;h2 id=&#34;maecenas-a-lorem-in-sem-feugiat-ultricies&#34;&gt;Maecenas a lorem in sem feugiat ultricies&lt;/h2&gt;
&lt;p&gt;Donec tincidunt interdum magna quis dictum. Integer non sollicitudin justo, id volutpat leo. Donec quis enim porttitor, hendrerit nisi non, accumsan orci. Nulla consectetur porta mauris, et pharetra nunc efficitur eu. Pellentesque eu consectetur tellus. In ac nunc ac turpis fermentum tempor vel vel nisl. Aenean convallis turpis ac ipsum mollis, eget venenatis lacus eleifend. Vestibulum sapien mauris, rutrum sit amet mi ut, volutpat mollis nunc. Praesent lobortis, orci efficitur molestie tempor, metus ante dignissim felis, ut interdum elit leo vitae lectus. Curabitur ex nunc, ornare at mi eu, eleifend molestie lectus. Duis pretium sapien in mauris pulvinar, ut auctor turpis tempus. Maecenas gravida nec dolor vel interdum. Ut posuere aliquam arcu et congue. Morbi scelerisque, leo vel luctus facilisis, est erat ultrices mauris, eget facilisis nisl libero a ligula. Mauris sit amet hendrerit sem. Etiam imperdiet, dolor id fermentum finibus, arcu est malesuada dui, at hendrerit nisi nibh ut mi.&lt;/p&gt;
&lt;h2 id=&#34;quisque-convallis-sem-sit-amet-magna-aliquam-interdum&#34;&gt;Quisque convallis sem sit amet magna aliquam interdum&lt;/h2&gt;
&lt;p&gt;Vestibulum a odio vitae sapien tempor sollicitudin. In eu mi ex. Phasellus sollicitudin, augue vitae congue vestibulum, sem mi ullamcorper nibh, sagittis tincidunt ligula turpis vitae arcu. Phasellus orci felis, tristique id scelerisque eu, ornare vel mauris. Curabitur suscipit venenatis facilisis. Phasellus et est et purus posuere accumsan et ut quam. Donec in odio eu enim facilisis scelerisque. Sed eget condimentum elit, quis pretium ipsum. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Suspendisse sit amet tortor ligula. Mauris lectus odio, cursus a diam a, ultricies posuere justo. Sed ultrices tempor mi, semper commodo quam lobortis at. Donec consectetur pretium nisl, eget dapibus nibh maximus scelerisque.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>红黑树</title>
      <link>http://justice.bj.cn/post/12.data_struct/tree/rb-tree/</link>
      <pubDate>Fri, 10 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/tree/rb-tree/</guid>
      
        <description>&lt;h1 id=&#34;红黑树rb-tree&#34;&gt;红黑树(RB-Tree)&lt;/h1&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;红黑树是一种二叉平衡树。&lt;/p&gt;
&lt;h2 id=&#34;性质&#34;&gt;性质&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个节点要么是黑色，要么是红色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Root 节点是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个叶子节点（NIL）是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个红色结点的两个子结点一定都是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任意一结点到每个叶子结点的路径都包含数量相同的黑结点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;旋转&#34;&gt;旋转&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;右旋&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-07-rbtree-right-rotate.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左旋&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-57-29-rbtree-left-rotate.webp&#34; alt=&#34;loading-ag-18088&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/63272157&#34;&gt;https://zhuanlan.zhihu.com/p/63272157&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/92761639&#34;&gt;https://zhuanlan.zhihu.com/p/92761639&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>LSMTree日志结构合并树</title>
      <link>http://justice.bj.cn/post/12.data_struct/tree/lsm-tree/</link>
      <pubDate>Thu, 09 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/tree/lsm-tree/</guid>
      
        <description>&lt;h1 id=&#34;日志结构合并树lsm-tree&#34;&gt;日志结构合并树(LSM-Tree)&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LSM-Tree&lt;/code&gt;全称Log Structured Merge Tree，是Google在2006年开源其BigTable中引入的一种数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种分层，有序，面向磁盘的数据结构；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其核心思想是充分了利用了磁盘批量的顺序写要远比随机写性能高出很多的特性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LSM-Tree大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于写多读少的场景;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sstable&#34;&gt;SSTable&lt;/h2&gt;
&lt;p&gt;LSM-Tree核心的数据结构是SSTable，全称是Sorted String Table；&lt;/p&gt;
&lt;p&gt;SSTable是一种拥有持久化，有序且不可变的的键值存储结构，它的key和value都是任意的字节数组，并且了提供了按指定key查找和指定范围的key区间迭代遍历的功能。SSTable内部包含了一系列可配置大小的Block块，典型的大小是64KB，关于这些Block块的index存储在SSTable的尾部，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-12-38-2021-09-04-10-12-33-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;整体结构&#34;&gt;整体结构&lt;/h2&gt;
&lt;p&gt;LSM-Tree里，SSTable有一份在内存里面，其他的多级在磁盘上，如下图是一份完整的LSM-Tree图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-08-25-2021-09-04-10-08-20-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;写流程&#34;&gt;写流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当收到一个写请求时，会先把该条数据记录在WAL Log里面，用作故障恢复；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当写完WAL Log后，会把该条数据写入内存的SSTable里面（删除是墓碑标记，更新是新记录一条的数据），也称Memtable。注意为了维持有序性在内存里面可以采用红黑树或者跳跃表相关的数据结构；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当Memtable超过一定的大小后，会在内存里面冻结，变成不可变的Memtable，同时为了不阻塞写操作需要新生成一个Memtable继续提供服务；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把内存里面不可变的Memtable给dump到到硬盘上的SSTable层中，此步骤也称为Minor Compaction，这里需要注意在L0层的SSTable是没有进行合并的，所以这里的key range在多个SSTable中可能会出现重叠，在层数大于0层之后的SSTable，不存在重叠key；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当每层的磁盘上的SSTable的体积超过一定的大小或者个数，也会周期的进行合并。此步骤也称为Major Compaction，这个阶段会真正 的清除掉被标记删除掉的数据以及多版本数据的合并，避免浪费空间，注意由于SSTable都是有序的，我们可以直接采用merge sort进行高效合并。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;读流程&#34;&gt;读流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当收到一个读请求的时候，会直接先在内存里面查询，如果查询到就返回；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有查询到就会依次下沉，知道把所有的Level层查询一遍得到最终结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;h3 id=&#34;压缩&#34;&gt;压缩&lt;/h3&gt;
&lt;p&gt;SSTable 是可以启用压缩功能的，并且这种压缩不是将整个 SSTable 一起压缩，而是根据 locality 将数据分组，每个组分别压缩，这样的好处当读取数据的时候，我们不需要解压缩整个文件而是解压缩部分 Group 就可以读取。&lt;/p&gt;
&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;
&lt;p&gt;因为SSTable在写入磁盘后，除了Compaction之外，是不会变化的，所以我可以将Scan的Block进行缓存，从而提高检索的效率&lt;/p&gt;
&lt;h2 id=&#34;索引bloom-filters&#34;&gt;索引，Bloom filters&lt;/h2&gt;
&lt;p&gt;正常情况下，一个读操作是需要读取所有的 SSTable 将结果合并后返回的，但是对于某些 key 而言，有些 SSTable 是根本不包含对应数据的，因此，我们可以对每一个 SSTable 添加 Bloom Filter，因为布隆过滤器在判断一个SSTable不存在某个key的时候，那么就一定不会存在，利用这个特性可以减少不必要的磁盘扫描。&lt;/p&gt;
&lt;h3 id=&#34;合并&#34;&gt;合并&lt;/h3&gt;
&lt;p&gt;这个在前面的写入流程中已经介绍过，通过定期合并瘦身， 可以有效的清除无效数据，缩短读取路径，提高磁盘利用空间。但Compaction操作是非常消耗CPU和磁盘IO的，尤其是在业务高峰期，如果发生了Major Compaction，则会降低整个系统的吞吐量，这也是一些NoSQL数据库，比如Hbase里面常常会禁用Major Compaction，并在凌晨业务低峰期进行合并的原因。&lt;/p&gt;
&lt;h2 id=&#34;lsm-tree-vs-btree&#34;&gt;LSM-Tree vs B+Tree&lt;/h2&gt;
&lt;p&gt;传统关系型数据采用的底层数据结构是B+树，那么同样是面向磁盘存储的数据结构LSM-Tree相比B+树有什么异同之处呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LSM-Tree的设计思路是，将数据拆分为几百M大小的Segments，并是顺序写入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B+Tree则是将数据拆分为固定大小的Block或Page, 一般是4KB大小，和磁盘一个扇区的大小对应，Page是读写的最小单位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在数据的更新和删除方面，B+Tree可以做到原地更新和删除，这种方式对数据库事务支持更加友好，因为一个key只会出现一个Page页里面，但由于LSM-Tree只能追加写，并且在L0层key的rang会重叠，所以对事务支持较弱，只能在Segment Compaction的时候进行真正地更新和删除。&lt;/p&gt;
&lt;p&gt;因此LSM-Tree的优点是支持高吞吐的写（可认为是O（1）），这个特点在分布式系统上更为看重，当然针对读取普通的LSM-Tree结构，读取是O（N）的复杂度，在使用索引或者缓存优化后的也可以达到O（logN）的复杂度。&lt;/p&gt;
&lt;p&gt;而B+tree的优点是支持高效的读（稳定的OlogN），但是在大规模的写请求下（复杂度O(LogN)），效率会变得比较低，因为随着insert的操作，为了维护B+树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。&lt;/p&gt;
&lt;p&gt;还有一点需要提到的是基于LSM-Tree分层存储能够做到写的高吞吐，带来的副作用是整个系统必须频繁的进行compaction，写入量越大，Compaction的过程越频繁。而compaction是一个compare &amp;amp; merge的过程，非常消耗CPU和存储IO，在高吞吐的写入情形下，大量的compaction操作占用大量系统资源，必然带来整个系统性能断崖式下跌，对应用系统产生巨大影响，当然我们可以禁用自动Major Compaction，在每天系统低峰期定期触发合并，来避免这个问题。&lt;/p&gt;
&lt;p&gt;阿里为了优化这个问题，在X-DB引入了异构硬件设备FPGA来代替CPU完成compaction操作，使系统整体性能维持在高水位并避免抖动，是存储引擎得以服务业务苛刻要求的关键。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1441835&#34;&gt;深入理解什么是LSM-Tree - 云+社区 - 腾讯云&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>BIT-树状数组</title>
      <link>http://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      
        <description>&lt;h1 id=&#34;树状数组bit&#34;&gt;树状数组(BIT)&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;树状数组&lt;/strong&gt;或&lt;strong&gt;二元索引树&lt;/strong&gt;（英语：Binary Indexed Tree），又以其发明者命名为 FenwickFenwick 树。最早由 PeterM.FenwickPeterM.Fenwick 于 1994 年以 《A New Data Structure for Cumulative Frequency Tables&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84#cite_note-1&#34;&gt;[1]&lt;/a&gt;》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以 (logn)O(log⁡n) 的时间&lt;strong&gt;得到任意前缀和（区间和）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;问题引入&#34;&gt;问题引入&lt;/h2&gt;
&lt;p&gt;数组的单点修改&lt;code&gt;update&lt;/code&gt;和区间求和&lt;code&gt;range_sum&lt;/code&gt;问题。&lt;/p&gt;
&lt;p&gt;使用普通数组，&lt;code&gt;update&lt;/code&gt;时间复杂度为$O(1)$,&lt;code&gt;range_sum&lt;/code&gt;时间复杂度为$O(n)$.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-26-2020-11-23-10-34-42-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用前缀和数组，&lt;code&gt;update&lt;/code&gt;时间复杂度为 O(n),&lt;code&gt;range_sum&lt;/code&gt;时间复杂度为$O(1)$.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-36-52-2020-11-23-10-36-20-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;树状数组是上述方法的一个折中，&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;range_sum&lt;/code&gt;时间复杂度均为$O(log_2n)$。&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;树状数组就是这样一种结构，它巧妙地利用了&lt;strong&gt;二进制&lt;/strong&gt;（实际上，树状数组的英文名 BIT，直译过来就是&lt;strong&gt;二进制下标树&lt;/strong&gt;）。例如 11，转化为二进制数就是$(1011)_2$ ，如果我们要求前 11 项和，可以分别查询 $ ((0000)_2, (1000)_2] $ , $ ( (1000)_2, (1010)_2 ] $, $ ( (1010)_2, (1101)_2 ] $ 的和再相加。这三个区间怎么来的呢？其实就是&lt;strong&gt;不断地去掉二进制数最右边的一个 1&lt;/strong&gt;的过程（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-37-2020-11-23-10-53-33-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;二进制数最右边的一个 1，连带着它之后的 0 为&lt;code&gt;lowbit(x)&lt;/code&gt;（稍后再来看如何实现）。那么我们用$C_i$维护区间$ (A_i - lowbit(A_i), A_i] $ 的区间和，这样显然查询前 n 项和时需要合并的区间数是少于 $ log_2n $的。树状数组的结构大概像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/23-10-56-30-2020-11-23-10-56-25-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt; 可用如下公式表示：&lt;/p&gt;
&lt;p&gt;$$
C[i] = A[i - 2^k+1] + A[i - 2^k+2] + &amp;hellip; + A[i]
$$&lt;/p&gt;
&lt;p&gt;其中: $k$表示 i 的二进制中从最低位到高位连续零的长度。&lt;/p&gt;
&lt;h2 id=&#34;lowbit&#34;&gt;lowbit&lt;/h2&gt;
&lt;p&gt;一个数的二进制表示中最低的一位&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lowbit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;优缺点&#34;&gt;优缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：修改和查询的复杂度都是$O(logN)$，相比线段树系数要少很多，比传统数组要快，而且容易写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：是遇到复杂的区间问题还是不能解决，功能还是有限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;一般用于解决大部分基于区间上的更新以及求和问题。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define low(i) ((i)&amp;amp;(-i))
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//单点修改
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;low&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//询问区间[1,pos]的权值和
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;range_query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/Last--Whisper/p/13823614.html&#34;&gt;树状数组（BIT）—— 一篇就够了 - Last_Whisper - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/93795692&#34;&gt;https://zhuanlan.zhihu.com/p/93795692&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>BlobFS</title>
      <link>http://justice.bj.cn/post/40.storage/spdk/blobfs%E6%BA%90%E7%A0%81/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/40.storage/spdk/blobfs%E6%BA%90%E7%A0%81/</guid>
      
        <description>&lt;h1 id=&#34;blobfs&#34;&gt;BlobFS&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;blobfs 是 spdk 中基于 blobstore 块设备实现的一个简易的文件系统。&lt;/p&gt;
&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ yum install -y libaio libaio-devel ncurses ncureses-devel CUnit fuse3 fuse3-devel jq
$ pip3 install meson
$ wget https://sourceforge.net/projects/cunit/files/latest/download

$ git clone https://github.com/spdk/spdk
$ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; spdk
$ git submodule update --init

$ sh scripts/pkgdep.sh
$ wget -O /tmp/ninja-linux.zip https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-linux.zip &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; unzip /tmp/ninja-linux.zip &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mv ninja /usr/local/bin/
$ ./configure --with-fuse
$ wget http://mirror.centos.org/centos/8/BaseOS/x86_64/os/Packages/libaio-devel-0.3.112-1.el8.x86_64.rpm -o /tmp/
$ sudo rpm -ivh /tmp/
$ make -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;挂载-blobfs&#34;&gt;挂载 blobfs&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#iommu 设置&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#/etc/default/grub中，增加&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;GRUB_CMDLINE_LINUX&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;xxx default_hugepagesz=1G hugepagesz=1G hugepages=16 hugepagesz=2M hugepages=2048 intel_iommu=on&amp;#34;&lt;/span&gt;
$ grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg &lt;span class=&#34;c1&#34;&gt;#uefi&lt;/span&gt;
$ grub2-mkconfig -o /boot/grub2/grub.cfg   &lt;span class=&#34;c1&#34;&gt;#no uefi&lt;/span&gt;

$ mkdir -p /mnt/huge1G
$ &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;nodev /mnt/huge1G hugetlbfs pagesize=1GB 0 0&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; /etc/fstab

&lt;span class=&#34;c1&#34;&gt;# 设置hugepage&lt;/span&gt;
$ &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt; &amp;gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages
$ mount -t hugetlbfs none /mnt/huge1G -o &lt;span class=&#34;nv&#34;&gt;pagesize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1G

&lt;span class=&#34;c1&#34;&gt;# 加载vfio-pci 驱动模块&lt;/span&gt;
$ modprobe vfio-pci
$ modprobe

&lt;span class=&#34;c1&#34;&gt;# 查看nvme 设备&lt;/span&gt;
$ lspci -nn &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;Non-Volatile&amp;#34;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#&amp;gt; 84:00.0 Non-Volatile memory controller [0108]: Intel Corporation NVMe Datacenter SSD [3DNAND, Beta Rock Controller] [8086:0a54]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# [[[[&amp;lt;domain&amp;gt;]:]&amp;lt;bus&amp;gt;]:][&amp;lt;device&amp;gt;][.[&amp;lt;func&amp;gt;]]：0000:84:00.0&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# [&amp;lt;vendor&amp;gt;]:[&amp;lt;device&amp;gt;]： 8086:0a54&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 解绑nvme驱动&lt;/span&gt;
$ &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0000:84:00.0&amp;#34;&lt;/span&gt; &amp;gt;/sys/bus/pci/devices/0000:84:00.0/driver/unbind

&lt;span class=&#34;c1&#34;&gt;# 绑定到vfio驱动&lt;/span&gt;
$ &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8086&lt;/span&gt; 0a54 &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; tee /sys/bus/pci/drivers/vfio-pci/new_id
&lt;span class=&#34;c1&#34;&gt;#&amp;gt; 绑定成功后，检查&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#&amp;gt; - lsblk 看不到nvme盘&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#&amp;gt; - vfio下面多了一个设备文件：ls /dev/vfio/4&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 或者绑定到uio&lt;/span&gt;
$ &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8086&lt;/span&gt; 0a54 &amp;gt; /sys/bus/pci/drivers/uio_pci_generic/new_id

&lt;span class=&#34;c1&#34;&gt;# 驱动准备完成&lt;/span&gt;
$ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; &amp;lt;SPDK_HOME&amp;gt;

&lt;span class=&#34;c1&#34;&gt;# 生成nvme配置文件&lt;/span&gt;
$ scripts/gen_nvme.sh --json-with-subsystems &amp;gt; nvme.json

&lt;span class=&#34;c1&#34;&gt;# 查看状态&lt;/span&gt;
$ sudo scripts/setup.sh status

&lt;span class=&#34;c1&#34;&gt;# 设置hugepage&lt;/span&gt;
$ &lt;span class=&#34;nv&#34;&gt;HUGEMEM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5120&lt;/span&gt; scripts/setup.sh

&lt;span class=&#34;c1&#34;&gt;# 生成配置文件&lt;/span&gt;
$ scripts/gen_nvme.sh --json-with-subsystems &amp;gt; nvme.json

&lt;span class=&#34;c1&#34;&gt;# 初始化blobfs&lt;/span&gt;
$ ./test/blobfs/mkfs/mkfs ./nvme.json Nvme0n1

&lt;span class=&#34;c1&#34;&gt;# 挂载至/mnt/fuse&lt;/span&gt;
$ ./test/blobfs/fuse/fuse ./nvme.json Nvme0n1 /mnt/fuse
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;源码解读&#34;&gt;源码解读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;lib&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;module/blobfs&lt;/code&gt;目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;module&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/module/blobfs/bdev/blobfs_bdev.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 检测bdev设备是否存在blobfs，若存在，则加载blobfs
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spdk_blobfs_bdev_detect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spdk_blobfs_bdev_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 挂载
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spdk_blobfs_bdev_mount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bdev_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mountpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spdk_blobfs_bdev_op_complete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cb_fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cb_arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// include 目录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/include/blobfs.h
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// lib 目录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/lib/blobfs.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// module目录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/module/blobfs/bdev/blobfs_bdev.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/module/blobfs/bdev/blobfs_bdev_rpc.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/module/blobfs/bdev/blobfs_fuse.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/module/blobfs/bdev/blobfs_fuse.h
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// test目录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/test/blobfs/blobfs.sh        //blobfs 功能测试启动脚本
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/test/blobfs/fuse/fuse.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// spdk/test/blobfs/mkfs/mkfs.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// spdk/test/blobfs/rocksdb/
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;blobfs-patch&#34;&gt;blobfs patch&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://review.spdk.io/gerrit/c/spdk/spdk/+/5420&#34;&gt;https://review.spdk.io/gerrit/c/spdk/spdk/+/5420&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;patch&#34;&gt;Patch&lt;/h2&gt;
&lt;h3 id=&#34;5420-random-write&#34;&gt;5420: random write&lt;/h3&gt;
&lt;p&gt;新 API&lt;code&gt;spdk_file_randomwrite()&lt;/code&gt;用于支持文件随机写。原有代码仅支持追加写，在追加写和随机读之间有一个内存缓存。&lt;/p&gt;
&lt;p&gt;为了支持随机写特性，需要进行如下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将缓存中的数据刷入到后端 blobstore 中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有的缓存&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>B树</title>
      <link>http://justice.bj.cn/post/12.data_struct/tree/b-tree/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/tree/b-tree/</guid>
      
        <description>&lt;h1 id=&#34;b-tree&#34;&gt;B-Tree&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;B 树又叫平衡多路查找树。主要应用于数据库，文件等&lt;/p&gt;
&lt;p&gt;一棵 m 阶的 B 树 (m 叉树)的特性如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;树中每个结点最多含有 m 个孩子（m&amp;gt;=2）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中 ceil(x)是一个取上限的函数）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为 null)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个非终端结点中包含有 n 个关键字信息： (P1，K1，P2，K2，P3，&amp;hellip;&amp;hellip;，Kn，Pn+1)。其中：
       a)   Ki (i=1&amp;hellip;n)为关键字，且关键字按顺序升序排序 K(i-1)&amp;lt; Ki。 
       b)   Pi 为指向子树根的接点，且指针 P(i)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。 
       c)   关键字的个数 n 必须满足： [ceil(m / 2)-1]&amp;lt;= n &amp;lt;= m-1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/21-09-56-17-2020-04-21-13-16-05-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;来模拟下查找文件 29 的过程：&lt;/p&gt;
&lt;p&gt;(1) 根据根结点指针找到文件目录的根磁盘块 1，将其中的信息导入内存。【磁盘 IO 操作 1 次】&lt;/p&gt;
&lt;p&gt;(2) 此时内存中有两个文件名 17，35 和三个存储其他磁盘页面地址的数据。根据算法我们发现 17&amp;lt;29&amp;lt;35，因此我们找到指针 p2。&lt;/p&gt;
&lt;p&gt;(3) 根据 p2 指针，我们定位到磁盘块 3，并将其中的信息导入内存。【磁盘 IO 操作 2 次】&lt;/p&gt;
&lt;p&gt;(4) 此时内存中有两个文件名 26，30 和三个存储其他磁盘页面地址的数据。根据算法我们发现 26&amp;lt;29&amp;lt;30，因此我们找到指针 p2。&lt;/p&gt;
&lt;p&gt;(5) 根据 p2 指针，我们定位到磁盘块 8，并将其中的信息导入内存。【磁盘 IO 操作 3 次】&lt;/p&gt;
&lt;p&gt;(6) 此时内存中有两个文件名 28，29。根据算法我们查找到文件 29，并定位了该文件内存的磁盘地址。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md&#34;&gt;The-Art-Of-Programming-By-July/03.02.md at master · julycoding/The-Art-Of-Programming-By-July · GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Disruptor</title>
      <link>http://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/%E9%AB%98%E6%95%88%E6%97%A0%E9%94%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97disruptor/</guid>
      
        <description>&lt;h1 id=&#34;disruptor-一种高效无锁内存队列&#34;&gt;Disruptor: 一种高效无锁内存队列&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Disruptor 是 LMAX 公司开源的一个高效的内存无锁队列。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>kafka时间轮算法</title>
      <link>http://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/%E6%97%B6%E9%97%B4%E8%BD%AE/</guid>
      
        <description>&lt;h1 id=&#34;kafka-时间轮算法&#34;&gt;Kafka 时间轮算法&lt;/h1&gt;
&lt;p&gt;Kafka中存在一些定时任务(DelayedOperation)，如DelayedFetch、DelayedProduce、DelayedHeartbeat等，在Kafka中，定时任务的添加、轮转、执行、消亡等是通过时间轮来实现的。(时间轮并不是Kafka独有的设计，而是一种通用的实现方式，Netty中也有用到时间轮的方式)&lt;/p&gt;
&lt;h2 id=&#34;1时间轮是什么&#34;&gt;1. 时间轮是什么&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/36/36293d8f2a75cd09852f9189092cbe9e.jpeg?x-oss-process=image/resize,p_80/auto-orient,1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/cb/cb615fcfbc43cd42a73b65644701d2a2.jpeg?x-oss-process=image/resize,p_80/auto-orient,1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Kafka时间轮由多个环形数组组成，每个环形数组包含20个时间单位，表示一个时间维度（一轮），如：第一层时间轮，数组中的每个元素代表1ms，一圈就是20ms，当延迟时间大于20ms时，就“进位”到第二层时间轮，第二层中，每“一格”表示20ms，依此类推…&lt;/p&gt;
&lt;p&gt;对于一个延迟任务，大体包含三个过程：进入时间轮、降级和到期执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进入时间轮&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据延迟时间计算对应的时间轮“层次”（如钟表中的“小时级”还是“分钟级”还是“秒级”，实际上是一个不断“升级”的过程，直到找到合适的“层次”）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算在该轮中的位置，并插入该位置（每个bucket是一个双向链表，可能包含多个延迟任务，这也是时间轮提高效率的一大原因，后面会提到）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若该bucket是首次插入，需要将该bucket加入DelayQueue中（DelayQueue的引入是为了解决“空推进”，后面会提到）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/7b/7b74698c1815c0f86af8d1820da6b838.jpeg?x-oss-process=image/resize,p_80/auto-orient,1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;降级&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;当时间“推进”到某个bucket时，说明该bucket中的任务在当前时间轮中的时间已经走完，需要进行“降级”，即进入更小粒度的时间轮中，reinsert的过程和进入时间轮是类似的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/d4/d4af2f2054bf00f89bcbf4e36044aa56.jpeg?x-oss-process=image/resize,p_80/auto-orient,1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;到期执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;在reinsert的过程中，若发现已经到期，则执行这些任务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/19/19bb4299ca84652634ea5eade9471905.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;整体过程大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/e9/e901a56d80092cda0bdbb4260ed21a91.jpeg?x-oss-process=image/resize,p_80/auto-orient,1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2时间的推进&#34;&gt;2. 时间的“推进”&lt;/h2&gt;
&lt;p&gt;一种直观的想法是，像现实中的钟表一样，“一格一格”地走，这样就需要有一个线程一直不停的执行，而大多数情况下，时间轮中的bucket大部分是空的，指针的“推进”就没有实质作用，因此，为了减少这种“空推进”，Kafka引入了DelayQueue，以bucket为单位入队，每当有bucket到期，即queue.poll能拿到结果时，才进行时间的“推进”，减少了 ExpiredOperationReaper 线程空转的开销。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/5e/5e190488738e81a0ab996eb2c155e54f.jpeg?x-oss-process=image/resize,p_80/auto-orient,1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3为什么要用时间轮&#34;&gt;3. 为什么要用时间轮&lt;/h2&gt;
&lt;p&gt;用到延迟任务时，比较直接的想法是DelayQueue、ScheduledThreadPoolExecutor 这些，而时间轮相比之下，最大的优势是在时间复杂度上：&lt;/p&gt;
&lt;p&gt;时间复杂度对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/cc/ccc843d13e25a1fec3e375b14e6658ac.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，理论上，当任务较多时，TimingWheel的时间性能优势会更明显&lt;/p&gt;
&lt;p&gt;总结一下Kafka时间轮性能高的几个主要原因：&lt;/p&gt;
&lt;p&gt;（1）时间轮的结构+双向列表bucket，使得插入操作可以达到O(1)的时间复杂度&lt;/p&gt;
&lt;p&gt;（2）Bucket的设计让多个任务“合并”，使得同一个bucket的多次插入只需要在delayQueue中入队一次，同时减少了delayQueue中元素数量，堆的深度也减小，delayqueue的插入和弹出操作开销也更小&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>MassTree</title>
      <link>http://justice.bj.cn/post/12.data_struct/tree/masstree/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/tree/masstree/</guid>
      
        <description>&lt;h1 id=&#34;masstree&#34;&gt;MassTree&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;masstree 来源于 2012 年发表的论文(&lt;a href=&#34;https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf&#34;&gt;Cache craftiness for fast multicore key-value storage&lt;/a&gt;)，&lt;strong&gt;可以理解为 B+ Tree 和 Radix Tree 的混合体&lt;/strong&gt;，即将键切分成多个部分，每个部分为一个节点；每个节点内部又是一个 B+ Tree，兼顾空间和性能。&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Masstree 将变长键划分成多个固长部分，每个固长部分可以通过 int 类型表示，而不是 char 类型。由于处理器处理 int 类型比较操作的速度远远快于 char 数组的比较，因此 Masstree 通过 int 类型的比较进一步加速了查找过程。固定长度可以设置为 CPU 缓存行长度，以增加 CPU 缓存效率。&lt;/li&gt;
&lt;li&gt;每个节点是一个 B+ Tree，因此 CPU 在查询的时候可以将节点所代表的 B+ Tree 加载到 CPU 缓存中，以增加 CPU 缓存命中率。&lt;/li&gt;
&lt;li&gt;其并发控制用到了 Read-Copy-Update(RCU)。读不因任何数据更新而阻塞，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据。因此读不会造成 CPU 缓存无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-10-57-34-image-20190528102500578-9312132.png&#34; alt=&#34;image-20190528102500578&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;mass-tree-算法&#34;&gt;&lt;strong&gt;Mass Tree 算法&lt;/strong&gt;&lt;/h2&gt;
&lt;h2 id=&#34;并发策略&#34;&gt;&lt;strong&gt;并发策略&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Mass Tree 的并发策略和 OLFIT Tree 是相似的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fine-grained locking，即节点锁，解决 write-write 竞争，同一时刻只有一个线程可以对当前节点进行写操作&lt;/li&gt;
&lt;li&gt;optimistic concurrency control，即节点  &lt;code&gt;version&lt;/code&gt; (uint32_t)，解决 read-write 竞争，读开始前和读结束后都需要获取当前节点的最新 version，来判断在读过程中当前节点是否发生了写操作（插入或分裂），同时对节点的写操作都需要先修改 version，在插入 key 之前需要设置  &lt;code&gt;inserting&lt;/code&gt;  标记，插入完成之后将 insert 的 vinsert + 1；在分裂之前需要设置  &lt;code&gt;splitting&lt;/code&gt;  标记，分裂完成之后将 split 的 vsplit + 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-00-01-2020-11-14-10-59-56-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;和  &lt;code&gt;permutation&lt;/code&gt;  一样，&lt;code&gt;version&lt;/code&gt;  也被划分成了多个域，除了带有 insert 和 split 信息之外，还包含一个 lock bit，用于加锁；一个 root bit，用于指示否是根节点；一个 border bit，用于指示是否是 border node；一位 deleted 位，用于指示这个节点是否被标记为删除。&lt;/p&gt;
&lt;h2 id=&#34;下降流程&#34;&gt;&lt;strong&gt;下降流程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于每次插入，获取，删除操作，都需要从 root（可能是整棵树的根节点，也可能是某棵子树的根节点） 下降到对应的叶节点（border node）。&lt;/p&gt;
&lt;p&gt;首先，在开始读取节点之前，必须获得节点的 stable version（图中橙色方块），即  &lt;code&gt;version&lt;/code&gt;  中的  &lt;code&gt;inserting&lt;/code&gt;  和  &lt;code&gt;splitting&lt;/code&gt;  位都为 0。&lt;/p&gt;
&lt;p&gt;其次，在下降之前，需要获取最新的 root，因为在开始下降前，根节点可能分裂了，导致其发生了改变（图中蓝色方块）。&lt;/p&gt;
&lt;p&gt;最后，如果当前节点已经是叶节点，那么可以返回，否则需要进行下降，读取内部结点根据  &lt;code&gt;key[x, x+8)&lt;/code&gt;(8 字节) 获得下降节点之后，分为 3 种情况处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;case 1 那行伪代码可以这样用 C 语言表示：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;before&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node_get_stable_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// read node here
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;after&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node_get_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// no need to be stable, just latest version
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;before&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;after&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LOCK_BIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;before&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;after&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// neither insert nor split happened
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;节点在我们读取期间没有发生任何变化，我们可以安全地进行下降；&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;节点发生了变化，而且是分裂，那么我们需要从根节点重新进行下降（内部节点没有相互连接起来，所以不能像 Blink Tree 那样获取右节点）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;节点发生了变化，但只是插入，只需要重新对当前节点进行下降&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意第二个黄色方块，这一行非常关键，如果你细看下的话，它似乎可以挪到 case 1 的 if 语句里面，但实际上不能这样做。因为如果当前节点的孩子节点发生了分裂，但是还没来得及将新节点插入到当前节点，对调这两行代码，可能会导致下降到错误的节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;插入流程&#34;&gt;&lt;strong&gt;插入流程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;作者只给出了读取伪代码，这里给出插入伪代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/14-11-02-06-2020-11-14-11-01-59-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当我们通过  &lt;code&gt;findborder&lt;/code&gt;  下降到叶节点后，需要对其加锁（图中蓝色方块），但是此时并不能直接将 key 进行插入，当两个写线程同时下降到同一个叶节点时，只有一个线程可以进行写入，所以加锁后需要查看在加锁前是否有其他线程对这个节点进行了写入，如果有的话需要查看是否需要右移，这里的逻辑和 Blink Tree 是一样的。&lt;/p&gt;
&lt;p&gt;当我们成功加锁并且定位到正确的叶节点之后，可以进行写入，结果有 4 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入 key 成功或 key 已经存在；&lt;/li&gt;
&lt;li&gt;需要下降到下一层，同时需要增加索引的偏移；&lt;/li&gt;
&lt;li&gt;存在索引冲突，比如 &amp;ldquo;12345678AA&amp;rdquo; 和 &amp;ldquo;12345678BB&amp;rdquo;，此时需要创建一棵子树，存放 &amp;ldquo;AA&amp;rdquo; 和 &amp;ldquo;BB&amp;rdquo;，同时需要把原来存放 &amp;ldquo;AA&amp;rdquo; 的地方替换成这棵子树的根节点&lt;/li&gt;
&lt;li&gt;节点已满，需要分裂之后再次插入（见下一小节）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;橙色方块在下面删除流程中介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//github.com/UncP/aili&#34;&gt;UncP/aili&lt;/a&gt;，没有实现删除操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//github.com/rmind/masstree&#34;&gt;https://github.com/rmind/masstree&lt;/a&gt;，采用了激进生成子树的策略，缺点就是 cache locality 在有些情况下不好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;论文作者的实现：&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//github.com/kohler/masstree-beta&#34;&gt;https://github.com/kohler/masstree-beta&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Trie 和 B+ 两种索引树的结合，使得在下降过程中的重试不需要从整棵树的根节点开始，同时加快拥有相同前缀的 key 的处理速度&lt;/li&gt;
&lt;li&gt;具体的内部结点与外部节点的结构&lt;/li&gt;
&lt;li&gt;fine-grained locking 写以及 lock-free 读&lt;/li&gt;
&lt;li&gt;比较具体的节点删除机制&lt;/li&gt;
&lt;li&gt;较小的节点减少了线程的竞争&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;需要指出的是这个算法不支持性能线性扩展，不过这并不是问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个算法实现起来很有&lt;strong&gt;挑战性&lt;/strong&gt;，个人认为主要有两个方面，第一个是对于&lt;strong&gt;树结构的把握&lt;/strong&gt;，Mass Tree 是 Trie 和 B+ 树的结合。第二个是对于&lt;strong&gt;并发下可见性的理解&lt;/strong&gt;，”先改哪个域后改哪个域“，”谁先可见谁后可见“，”谁何时可见“，“在哪加以及加不加 memory barrier”等等这样的问题需要花很多时间考虑，而且出现 bug 非常难调试。&lt;/p&gt;
&lt;p&gt;Mass Tree 性能比我预想中要好很多，对于均匀分布的 10 字节 key 随机插入，数据量 1000 万，在我的机器上 4 个线程可以到 500 万以上的 tps；对于分布集中的测试数据，可以到 1000 万以上。其实&lt;strong&gt;对于内存索引来说，cache miss 对性能造成的影响有时候是远远大于线程竞争的&lt;/strong&gt;，所以尽管数据分布非常集中（线程竞争更多），仍然可以获得更高的性能。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf&#34;&gt;https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kohler/masstree-beta&#34;&gt;https://github.com/kohler/masstree-beta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/52624601&#34;&gt;https://zhuanlan.zhihu.com/p/52624601&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>MerkleTree</title>
      <link>http://justice.bj.cn/post/12.data_struct/tree/merkle-tree/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/tree/merkle-tree/</guid>
      
        <description>&lt;h1 id=&#34;merkle-tree&#34;&gt;Merkle Tree&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Merkle Tree 是一种 Hash Tree，由 Ralph Merkle 在 1979 年发明。&lt;/p&gt;
&lt;p&gt;Merkle Tree 的每个非叶节点通过其子节点的标记或者值（子节点为叶节点）的哈希值来进行标注，为大型的数据结构提供了高效安全的验证手段。&lt;/p&gt;
&lt;p&gt;Merkle Tree 可以理解为哈希列表和哈希链表的泛化产物。&lt;/p&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/05-20-37-06-2020-12-05-20-34-44-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MT 是一种树，大多数是二叉树，也可以多叉树；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Merkle Tree 的叶子节点的 value 是数据集合的单元数据或者单元数据 HASH。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非叶子节点的 value 是根据它下面所有的叶子节点值，然后按照 Hash 算法计算而得出的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数字签名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P2P 网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可信计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPFS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BitCoin/Ethereum&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/fengzhiwu/p/5524324.html&#34;&gt;Merkle Tree 学习&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>ProtoBuf</title>
      <link>http://justice.bj.cn/post/12.data_struct/protobuf/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/protobuf/</guid>
      
        <description>&lt;h1 id=&#34;protobuf&#34;&gt;ProtoBuf&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;语言无关、平台无关&lt;/strong&gt;。即 ProtoBuf 支持 Java、C++、Python 等多种语言，支持多个平台&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高效&lt;/strong&gt;。即比 XML 更小（3 ~ 10 倍）、更快（20 ~ 100 倍）、更为简单&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性、兼容性好&lt;/strong&gt;。你可以更新数据结构，而不影响和破坏原有的旧程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编码结构&#34;&gt;编码结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/12/03-12-46-03-2020-12-03-12-45-56-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建 .proto 文件，定义数据结构&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 例1: 在 xxx.proto 文件中定义 Example1 message
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Example1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;optional&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stringVal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;optional&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bytesVal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EmbeddedMessage&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;int32Val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stringVal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;optional&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EmbeddedMessage&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;embeddedExample1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;repeatedInt32Val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;repeatedStringVal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;protoc 编译 .proto 文件生成读写接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ protoc -I&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$SRC_DIR&lt;/span&gt; --cpp_out&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$DST_DIR&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$SRC_DIR&lt;/span&gt;/xxx.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调用接口实现序列化、反序列化以及读写&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Radix Tree</title>
      <link>http://justice.bj.cn/post/12.data_struct/tree/radixtree/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/tree/radixtree/</guid>
      
        <description>&lt;h1 id=&#34;基数树radix-tree&#34;&gt;基数树(Radix Tree)&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Radix tree(也被称为 radix trie，或者 compact prefix tree)是一种空间优化的前缀树(prefix tree)数据结构。&lt;/p&gt;
&lt;p&gt;针对这对这样的稀疏长整型数据查找，能高速且节省空间地完成映射&lt;/p&gt;
&lt;img title=&#34;&#34; src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2021/09/04-10-32-55-2021-09-04-10-32-52-image.png&#34; alt=&#34;&#34; data-align=&#34;left&#34;&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IP 路由；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倒排索引；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDR（ID Radix）机制；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 基数树（radix tree），内存管理；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis Radix tree；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://ivanzz1001.github.io/records/post/data-structure/2018/11/18/ds-radix-tree&#34; title=&#34;数据结构之Radix Tree&#34;&gt;数据结构之 Radix Tree&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://sourcelink.top/2019/09/26/linux-kernel-radix-tree-analysis/&#34;&gt;详解 Linux 内核 Radix 树算法的实现 - 黎棉麒的独立博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1597128&#34;&gt;图解 Redis 中的 Radix 树 - 云+社区 - 腾讯云&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>RoaringBitmap</title>
      <link>http://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/31.roaringbitmap/</guid>
      
        <description>&lt;h1 id=&#34;roaringbitmap高效压缩位图的原理与应用&#34;&gt;RoaringBitmap:高效压缩位图的原理与应用&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;RoaringBitmap（简称为 RBM）是 2016 年由 S. Chambi、D. Lemire、O. Kaser 等人在论文中提出的一种高效位图压缩算法，用于解决稀疏位图空间占用效率问题。&lt;/p&gt;
&lt;h2 id=&#34;主要思想&#34;&gt;主要思想&lt;/h2&gt;
&lt;p&gt;将 32 位无符号整数按照高 16 位分桶，即最多可能有 216=65536 个桶，称为&lt;code&gt;container&lt;/code&gt;。存储数据时，按照数据的高 16 位找到 container（找不到就会新建一个），再将低 16 位放入 container 中。也就是说，一个 RBM 就是很多 container 的集合。如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/195230-7b71d0d9abe6e906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中示出了三个 container：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高 16 位为 0000H 的 container，存储有前 1000 个 62 的倍数。&lt;/li&gt;
&lt;li&gt;高 16 位为 0001H 的 container，存储有[216, 216+100)区间内的 100 个数。&lt;/li&gt;
&lt;li&gt;高 16 位为 0002H 的 container，存储有[2×216, 3×216)区间内的所有偶数，共 215 个。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;container 是 RBM 新创造的概念，自然也是提高效率的核心。为了更高效地存储和查询数据，不同情况下会采用不同类型的 container，下面深入讲解一下 container 的细节。&lt;/p&gt;
&lt;h3 id=&#34;container&#34;&gt;Container&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ArrayContainer: 当桶内数据的基数不大于 4096 时，会采用它来存储，其本质上是一个 unsigned short 类型的有序数组。数组初始长度为 4，随着数据的增多会自动扩容（但最大长度就是 4096）。另外还维护有一个计数器，用来实时记录基数。上图中的前两个 container 基数都没超过 4096，所以均为 ArrayContainer。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BitmapContainer: 当桶内数据的基数大于 4096 时，会采用它来存储，其本质就是上一节讲过的普通位图，用长度固定为 1024 的 unsigned long 型数组表示，亦即位图的大小固定为 216 位（8KB）。它同样有一个计数器。上图中的第三个 container 基数远远大于 4096，所以要用 BitmapContainer 存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RunContainer: RunContainer 在图中并未示出，初始的 RBM 实现中也没有它，而是在本节开头的第二篇论文中新加入的。它使用可变长度的 unsigned short 数组存储用行程长度编码（RLE）压缩后的数据。举个例子，连续的整数序列&lt;code&gt;11, 12, 13, 14, 15, 27, 28, 29&lt;/code&gt;会被 RLE 压缩为两个二元组&lt;code&gt;11, 4, 27, 2&lt;/code&gt;，表示 11 后面紧跟着 4 个连续递增的值，27 后面跟着 2 个连续递增的值。由此可见，RunContainer 的压缩效果可好可坏。考虑极端情况：如果所有数据都是连续的，那么最终只需要 4 字节；如果所有数据都不连续（比如全是奇数或全是偶数），那么不仅不会压缩，还会膨胀成原来的两倍大。所以，RBM 引入 RunContainer 是作为其他两种 container 的折衷方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来简要看看它们的复杂度和转换方法。&lt;/p&gt;
&lt;h2 id=&#34;时空分析&#34;&gt;时空分析&lt;/h2&gt;
&lt;p&gt;增删改查的时间复杂度方面，BitmapContainer 只涉及到位运算，显然为 O(1)。而 ArrayContainer 和 RunContainer 都需要用二分查找在有序数组中定位元素，故为 O(logN)。&lt;/p&gt;
&lt;p&gt;空间占用（即序列化时写出的字节流长度）方面，BitmapContainer 是恒定为 8192B 的。ArrayContainer 的空间占用与基数（c）有关，为(2 + 2c)B；RunContainer 的则与它存储的连续序列数（r）有关，为(2 + 4r)B。以上节图中的 RBM 为例，它一共存储了 33868 个 unsigned int，只占用了 10396 个字节的空间，可以说是非常高效了。&lt;/p&gt;
&lt;h4 id=&#34;container-的创建与转换&#34;&gt;Container 的创建与转换&lt;/h4&gt;
&lt;p&gt;在创建一个新 container 时，如果只插入一个元素，RBM 默认会用 ArrayContainer 来存储。如果插入的是元素序列的话，则会先根据上面的方法计算 ArrayContainer 和 RunContainer 的空间占用大小，并选择较小的那一种进行存储。&lt;/p&gt;
&lt;p&gt;当 ArrayContainer 的容量超过 4096 后，会自动转成 BitmapContainer 存储。4096 这个阈值很聪明，低于它时 ArrayContainer 比较省空间，高于它时 BitmapContainer 比较省空间。也就是说 ArrayContainer 存储稀疏数据，BitmapContainer 存储稠密数据，可以最大限度地避免内存浪费。&lt;/p&gt;
&lt;p&gt;RBM 还可以通过调用特定的 API（名为 optimize）比较 ArrayContainer/BitmapContainer 与等价的 RunContainer 的内存占用情况，一旦 RunContainer 占用较小，就转换之。也就是说，上图例子中的第二个 ArrayContainer 可以转化为只有一个二元组&lt;code&gt;0, 100&lt;/code&gt;的 RunContainer，占用空间进一步下降到 10200 字节。&lt;/p&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;官方提供了 RBM 的多种语言实现，Java、C/C++、Python、Go、C#等等一应俱全。Java 版本的 GitHub repo 见&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Flemire%2FRoaringBitmap&#34;&gt;这里&lt;/a&gt;。代码比较多，但思路很清晰，看官如果对位运算比较熟悉的话读起来不难，故本文就不再长篇大论地讲源码了。值得注意的几点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个 RBM 做集合操作时，不同种类 container 之间位运算的处理方式，如 ArrayContainer AND BitmapContainer，BitmapContainer OR RunContainer 等；&lt;/li&gt;
&lt;li&gt;对 64 位整数的支持（32 位有时会不够用哈）；&lt;/li&gt;
&lt;li&gt;能够将 RBM 数据写到堆外，即内存映射；&lt;/li&gt;
&lt;li&gt;支持 Kryo 序列化方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RBM 的应用范围极广，下面只简单列举几个有代表性的应用，并给出 reference。&lt;/p&gt;
&lt;h4 id=&#34;lucene&#34;&gt;Lucene&lt;/h4&gt;
&lt;p&gt;为了加速搜索，Lucene 会将常用的查询过滤条件产生的结果集缓存到内存中，方便复用，称为 filter cache。结果集其实就是文档 ID（整形数）的集合。从 Lucene 5 开始，使用了 RBM 优化过的文档 ID 集合 RoaringDocIdSet 作为 filter cache，详情可以参见&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fblog%2Fframe-of-reference-and-roaring-bitmaps&#34;&gt;《Frame of Reference and Roaring Bitmaps》&lt;/a&gt;。该文除了介绍 RBM 外，还介绍了压缩倒排索引的 Frame of Reference（FOR）编码，值得一读。&lt;/p&gt;
&lt;h4 id=&#34;spark&#34;&gt;Spark&lt;/h4&gt;
&lt;p&gt;在 Spark Core 的 MapStatus 组件（用来跟踪 ShuffleMapTask 的输出结果块）中，利用了 RBM 来存储块是否非空的状态。今后会在 Spark 连载里讲到它，所以现在看看&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fapache%2Fspark%2Fblob%2Fmaster%2Fcore%2Fsrc%2Fmain%2Fscala%2Forg%2Fapache%2Fspark%2Fscheduler%2FMapStatus.scala&#34;&gt;该类的源码&lt;/a&gt;就可以了，不难理解。&lt;/p&gt;
&lt;h4 id=&#34;greenplum&#34;&gt;Greenplum&lt;/h4&gt;
&lt;p&gt;我司是 Greenplum 大户，虽然本鶸现在不负责数仓相关的事情了，但是偶尔还是要向 GP 提供一些数据。GP 配合 RoaringBitmap 非常适合做海量用户的近实时画像，每个 RBM 代表一维标签即可，根据标签圈选用户也很方便。GP 原生并未支持 RBM 类型数据，需要安装一个扩展插件，见&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fzeromax007%2Fgpdb-roaringbitmap%3Fspm%3Da2c4e.10696291.0.0.a68919a4RFqCuW&#34;&gt;这里&lt;/a&gt;。关于 GP 与 RBM 的整合与使用，有两篇不错的参考文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F405191&#34;&gt;https://yq.aliyun.com/articles/405191&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=http%3A%2F%2Fmysql.taobao.org%2Fmonthly%2F2018%2F08%2F09&#34;&gt;http://mysql.taobao.org/monthly/2018/08/09&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redis&#34;&gt;Redis&lt;/h4&gt;
&lt;p&gt;我们在 Redis 里经常使用位图存储数据（Redis 原生以字符串的形式支持位图），当然也就会遇到稀疏位图浪费存储空间的问题。但要让 Redis 支持 RBM，需要引入专门的 module，项目地址见&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Faviggiano%2Fredis-roaring&#34;&gt;这里&lt;/a&gt;。它的设计思想与 Java 版 RBM 几乎相同，不再废话了。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://roaringbitmap.org/&#34;&gt;https://roaringbitmap.org/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1402.6407.pdf&#34;&gt;《Better bitmap performance with Roaring bitmaps》&lt;/a&gt;与&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Farxiv.org%2Fpdf%2F1603.06549.pdf&#34;&gt;《Consistently faster and smaller compressed bitmaps with Roaring》&lt;/a&gt;中提出，&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>TAILQ-双向有尾队列</title>
      <link>http://justice.bj.cn/post/12.data_struct/tailq/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/tailq/</guid>
      
        <description>&lt;h1 id=&#34;tailq-双向有尾队列&#34;&gt;TAILQ: 双向有尾队列&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TAILQ&lt;/strong&gt;(双向有尾队列)是 FreeBSD/linux 内核对双向队列操作的一种抽象，在/usr/include/sys/queue.h 文件中实现各种定义。&lt;/p&gt;
&lt;p&gt;尾队列能实现操作队列需要的各种操作：插入元素，删除元素，遍历队列等。优点是插入元素很快。&lt;/p&gt;
&lt;p&gt;在一些著名的开源库中(如&lt;strong&gt;DPDK&lt;/strong&gt;,&lt;strong&gt;libevent&lt;/strong&gt;)有广泛的应用&lt;/p&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;双向有尾队列有一个表头和表尾，表头指向节点 1 和尾节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2021/06/03-10-55-36-2021-06-03-10-55-30-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TAILQ&lt;/strong&gt;队列有&lt;strong&gt;HEAD&lt;/strong&gt;和&lt;strong&gt;ENTRY&lt;/strong&gt;两种基本的数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 队列元素
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define TAILQ_ENTRY(type)         \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;struct {                          \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type *tqe_next;        \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type **tqe_prev;       \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;}
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tailq_entry&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
　　&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
　　&lt;span class=&#34;n&#34;&gt;TAILQ_ENTRY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;int_node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 队列头
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define  TAILQ_HEAD(name, type)        \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;struct name {                          \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type *tqh_first;     &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/*队列第一个元素的地址*/&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;       \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type **tqh_last;     &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**/&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;       \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;}
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STAILQ_HEAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_tailq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;tailq_entry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;queue_head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意：数据结构中的&lt;strong&gt;filed&lt;/strong&gt;都是&lt;strong&gt;type&lt;/strong&gt;类型的指针(或者是二级指针)，这里的&lt;strong&gt;type&lt;/strong&gt;是用户的队列元素类型，&lt;/p&gt;
&lt;p&gt;将&lt;strong&gt;ENTRY&lt;/strong&gt;结构内嵌到用户的&lt;strong&gt;QUEUE_ITEM&lt;/strong&gt;结构中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;QUEUE_ITEM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;和-linux-list-区别&#34;&gt;和 linux list 区别&lt;/h2&gt;
&lt;p&gt;和&lt;strong&gt;Linux&lt;/strong&gt;中&lt;strong&gt;list&lt;/strong&gt;的组织方式不一样，后者是单纯地将&lt;strong&gt;struct list_head&lt;/strong&gt;作为链表的一个挂接点，并没有用户的信息，具体差别可以看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/18-12-06-33-2020-11-18-12-04-56-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;tailq-队列的操作&#34;&gt;TAILQ 队列的操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TAILQ&lt;/strong&gt;提供了多种操作队列的&lt;strong&gt;API&lt;/strong&gt;,比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;TAILQ_HEAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_ENTRY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_EMPTY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_FIRST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_FOREACH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_INIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_INSERT_AFTER&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listelm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_INSERT_BEFORE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;listelm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;TAILQ_INSERT_TAIL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;field&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.....&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;tailq队列中为什么tqh_prev和tqh_last要使用二级指针&#34;&gt;*&lt;strong&gt;*TAILQ&lt;/strong&gt;队列中为什么&lt;strong&gt;tqh_prev&lt;/strong&gt;和&lt;strong&gt;tqh_last&lt;/strong&gt;要使用二级指针**&lt;/h3&gt;
&lt;p&gt;要搞清楚这个问题，我们可以考虑如果不使用二级指针会怎么样？ 就像定义成下面这样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define    FAKE_TAILQ_HEAD(name, type)                        \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;struct name {                                \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type *tqh_first;    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* first element */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;            \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type *tqh_last;    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* last element */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;        \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;}
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define FAKE_TAILQ_ENTRY(type)                                            \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;struct {                                                             \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type *tqe_next;  &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* next element */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;                       \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    struct type *tqe_prev;  &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/*   previous element*/&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;        \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/18-12-08-55-2020-11-18-12-08-37-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果我们想要删除队列的任意一个元素，对&lt;strong&gt;FAKE_TAILQ&lt;/strong&gt;，我们需要特殊处理该元素是第一个元素的情况(第一个元素的&lt;strong&gt;tqe_prev&lt;/strong&gt;指针为空)，而&lt;strong&gt;TAILQ&lt;/strong&gt;就没有这个烦恼！&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;*TAILQ&lt;/strong&gt;队列的遍历性能**&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;中的&lt;strong&gt;list&lt;/strong&gt;只将&lt;strong&gt;struct list_head&lt;/strong&gt;作为用户元素的挂接点，因此在正向遍历链表时，需要使用&lt;strong&gt;container_of&lt;/strong&gt;这类接口才能获取用户的数据，而&lt;strong&gt;TAILQ&lt;/strong&gt;由于&lt;strong&gt;tqe_next&lt;/strong&gt;指针直接指向用户元素的类型，所以理论上，正向遍历&lt;strong&gt;TAILQ&lt;/strong&gt;比&lt;strong&gt;list&lt;/strong&gt;更快.但逆向遍历时,由于&lt;strong&gt;TAILQ&lt;/strong&gt;的取用&lt;strong&gt;prev&lt;/strong&gt;元素的操作比&lt;strong&gt;next&lt;/strong&gt;麻烦的多，因此逆向遍历是比正向慢的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define    TAILQ_PREV(elm, headname, field)                \
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;    (*(((struct headname *)((elm)-&amp;gt;field.tqe_prev))-&amp;gt;tqh_last))
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.sunxidong.com/260.html&#34;&gt;https://www.sunxidong.com/260.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/fuzidage/p/14482501.html&#34;&gt;TAILQ 队列实现原理 - fuzidage - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>分布式哈希表</title>
      <link>http://justice.bj.cn/post/12.data_struct/40.%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8dht/</link>
      <pubDate>Wed, 08 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/40.%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8dht/</guid>
      
        <description>&lt;h1 id=&#34;分布式哈希表dht&#34;&gt;分布式哈希表(DHT)&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;分布式哈希表(DHT, Distributed Hash Table)是分布式系统中，用来将一个键（key）的集合分散到所有节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。&lt;/p&gt;
&lt;h2 id=&#34;dht&#34;&gt;DHT&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-49-2020-03-08-15-47-23-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;分布式哈希表的用于发点对点系统(P2P)，像是 Napster、Gnutella、BitTorrent 及 Freenet。这些系统使用分散在互联网上的各项资源以提供文件分享服务，特别在带宽及硬盘存储空间上受益良多。&lt;/p&gt;
&lt;p&gt;这些系统使用不同的方法来解决如何找到拥有某数据的节点的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Napster 使用中央的索引服务器：每个节点加入网络的同时，会将他们所拥有的文件列表发送给服务器，这使得服务器可以进行搜索并将结果回传给进行查询的节点。但中央索引服务器让整个系统易受攻击，且可能造成法律问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gnutella 和相似的网络改用大量查询模式（flooding query model）：每次搜索都会把查询消息广播给网络上的所有节点。虽然这个方式能够防止单点故障（single point of failure），但比起 Napster 来说却极没效率；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Freenet 使用了完全分布式的系统，但它建置了一套使用经验法则的基于键的路由方法（key based routing）。在这个方法中，每个文件与一个键相结合，而拥有相似键的文件会倾向被相似的节点构成的集合所保管。于是查询消息就可以根据它所提供的键被路由到该集合，而不需要经过所有的节点。然而，Freenet 并不保证存在网络上的数据在查询时一定会被找到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式哈希表为了达到 Gnutella 与 Freenet 的分散性（decentralization）以及 Napster 的效率与正确结果，使用了较为结构化的基于键的路由方法。不过分布式哈希表也有个 Freenet 有的缺点，就是只能作精确搜索，而不能只提供部分的关键字；但这个功能可以在分布式哈希表的上层实现。&lt;/p&gt;
&lt;p&gt;最初的四项分布式哈希表技术——内容可定址网络（Content addressable network，CAN）、Chord（Chord project）、Pastry（Pastry (DHT)），以及 Tapestry (DHT)（Tapestry (DHT)）皆同时于 2001 年发表。从那时开始，相关的研究便一直十分活跃。在学术领域以外，分布式哈希表技术已经被应用在 BitTorrent 及 CoralCDN（Coral Content Distribution Network）等。&lt;/p&gt;
&lt;p&gt;分布式散列表本质上强调以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;离散性&lt;/strong&gt;：构成系统的节点并没有任何中央式的协调机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伸缩性&lt;/strong&gt;：即使有成千上万个节点，系统仍然应该十分有效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要达到以上的目标，有一个关键的技术：任一个节点只需要与系统中的部分节点沟通，当成员改变的时候，只有一部分的工作（例如数据或键的发送，哈希表的改变等）必须要完成。&lt;/p&gt;
&lt;p&gt;分布式散列表的结构可以分成几个主要的组件。其基础是一个抽象的&lt;code&gt;键空间&lt;/code&gt;（keyspace），例如说所有&lt;strong&gt;160&lt;/strong&gt;位长的字符串集合。&lt;code&gt;键空间分区&lt;/code&gt;（keyspace partitioning）将&lt;code&gt;键空间&lt;/code&gt;分区成数个，并指定到在此系统的节点中。而&lt;code&gt;延展网络&lt;/code&gt;则连接这些节点，并让他们能够借由在&lt;code&gt;键空间&lt;/code&gt;内的任一值找到拥有该值的节点。&lt;/p&gt;
&lt;p&gt;假设&lt;code&gt;键空间&lt;/code&gt;是一个 160 位长的字符串集合。为了在分布式散列表中存储一个文件，名称为&lt;code&gt;filename&lt;/code&gt;且内容为&lt;code&gt;data&lt;/code&gt;，我们计算出&lt;code&gt;filename&lt;/code&gt;的 SHA1 散列值——一个 160 位的键&lt;code&gt;k&lt;/code&gt;——并将消息&lt;code&gt;put(k,data)&lt;/code&gt;送给分布式散列表中的任意参与节点。此消息在延展网络中被路由，直到抵达在键空间分区中被指定负责存储关键值&lt;code&gt;k&lt;/code&gt;的节点。而&lt;code&gt;(k,data)&lt;/code&gt;即存储在该节点。其他的节点只需要重新计算&lt;code&gt;filename&lt;/code&gt;的散列值&lt;code&gt;k&lt;/code&gt;，然后提交消息&lt;code&gt;get(k)&lt;/code&gt;给分布式哈希表中的任意参与节点，以此来找与&lt;code&gt;k&lt;/code&gt;相关的数据。此消息也会在延展网络中被路由到负责存储&lt;code&gt;k&lt;/code&gt;的节点。而此节点则会负责传回存储的数据&lt;code&gt;data&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;基本上，就是一种映射 key 和节点的算法以及路由的算法。&lt;/p&gt;
&lt;p&gt;其一为保证任何的路由路径长度必须尽量短，因而请求能快速地被完成；&lt;br&gt;
其二为任一节点的邻近节点数目（又称最大节点度（Degree (graph theory)））必须尽量少，因此维护的花费不会过多。&lt;/p&gt;
&lt;h2 id=&#34;分布式哈希与一致性哈希&#34;&gt;分布式哈希与一致性哈希&lt;/h2&gt;
&lt;p&gt;分布式哈希和一致性哈希有什么区别呢？lintong 的&lt;a href=&#34;https://www.jianshu.com/p/7beeb52376cc&#34;&gt;分布式哈希与一致性哈希&lt;/a&gt;  一文对它做了清晰而简洁的解释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式哈希&lt;/strong&gt;: 将哈希表分散在不同的节点上，并且能提供相应的方法来查找， 比如 DHT 算法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性哈希&lt;/strong&gt;: 当节点宕机或者扩容的时候，需要重新哈希，一致性哈希实现的 DHT 避免对大量的数据重新哈希, 比如&lt;a href=&#34;https://en.wikipedia.org/wiki/Chord_(peer-to-peer)&#34;&gt;Chord DHT&lt;/a&gt;. 所以一致性哈希是 DHT 的一种实现，避免在节点变化的时候出现的全部重新哈希的现象.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其它的 DHT 的分区实现(Keyspace partitioning)还有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rendezvous hashing&lt;/strong&gt;: 最高随机权重哈希。每个 client 都会获得服务节点相同的指示符&lt;code&gt;{S1, S2, ..., Sn }&lt;/code&gt;， 对于键&lt;code&gt;k&lt;/code&gt;, client 使用相同的哈希函数计算服务节点的权重&lt;code&gt;w1 = h(S1, k), w2 = h(S2, k), ..., wn = h(Sn, k)&lt;/code&gt;，然后总是选择最高权重的节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Locality-preserving hashing&lt;/strong&gt;: 相近的键总是指派给相近的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kademlia-算法&#34;&gt;Kademlia 算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Kademlia&lt;/strong&gt;是一种通过 DHT 的协议算法，它是由 Petar 和 David 在 2002 年为 P2P 网络而设计的。Kademlia 规定了网络的结构，也规定了通过节点查询进行信息交换的方式。&lt;br&gt;
Kademlia 网络节点之间使用&lt;strong&gt;UDP&lt;/strong&gt;进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点 ID）来进行身份标识。节点 ID 不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。&lt;/p&gt;
&lt;p&gt;当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia 算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的 ID 与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点 ID 的时候搜索便会停止。&lt;/p&gt;
&lt;p&gt;这种搜索值的方法是非常高效的：与其他的分布式哈希表的实现类似，在一个包含 n 个节点的系统的值的搜索中，Kademlia 仅访问&lt;code&gt;O(log(n))&lt;/code&gt;个节点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kademlia&lt;/code&gt;简称为&lt;code&gt;Kad&lt;/code&gt;,它使用了一个精妙的算法，来计算节点之间的&amp;quot;距离&amp;quot; (这里的距离不是地理空间的距离，而是路由的跳数)，这个算法就是&lt;code&gt;XOR&lt;/code&gt;操作(异或)，因为这个操作和距离的计算类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) == (B ⊕ A)&lt;/code&gt;: XOR 符合“交换律”，具备对称性。A 和 B 的距离从哪一个节点计算都是相同的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ A) == 0&lt;/code&gt;: 反身性，自己和自己的距离为零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) &amp;gt; 0&lt;/code&gt;: 两个不同的 key 之间的距离必大于零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) + (B ⊕ C) &amp;gt;= (A ⊕ C)&lt;/code&gt;: 三角不等式, A 经过 B 到 C 的距离总是大于 A 直接到 C 的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(精妙啊!是如何想起和距离计算联系在一起的？)&lt;/p&gt;
&lt;p&gt;Kad 使用 160 位的哈希算法（比如 SHA1），完整的 key 用二进制表示有 160 位，这样可以容纳 2160 个节点，可以说是不计其数了。&lt;/p&gt;
&lt;p&gt;Kad 把 key 映射到一个二叉树，每一个 key 都是这个二叉树的&lt;code&gt;叶子&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;映射规则&#34;&gt;&lt;strong&gt;映射规则&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先把 key 以二进制形式表示，然后从高位到低位依次处理。&lt;/li&gt;
&lt;li&gt;二进制的第 n 个位就对应了二叉树的第 n 层&lt;/li&gt;
&lt;li&gt;如果该位是 1，进入左子树，是 0 则进入右子树（这只是人为约定，反过来处理也可以）&lt;/li&gt;
&lt;li&gt;全部位都处理完后，这个 key 就对应了二叉树上的某个叶子&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉树的拆分规则&#34;&gt;&lt;strong&gt;二叉树的拆分规则&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-21-16-2020-03-08-15-50-47-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对每一个节点，都可以&lt;strong&gt;按照自己的视角&lt;/strong&gt;对整个二叉树进行拆分成最多 160 个子树。&lt;/p&gt;
&lt;p&gt;拆分的规则是：先从根节点开始，把&lt;strong&gt;不包含&lt;/strong&gt;自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的第二层子树；以此类推，直到最后只剩下自己。&lt;/p&gt;
&lt;p&gt;Kad 默认的散列值空间是  &lt;code&gt;m=160&lt;/code&gt;（散列值有 160 bit），因此拆分出来的子树&lt;strong&gt;最多&lt;/strong&gt;有 160 个（考虑到实际的节点数&lt;strong&gt;远远小于&lt;/strong&gt;2160，子树的个数会明显小于 160）。&lt;/p&gt;
&lt;p&gt;对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的&lt;strong&gt;任何一个&lt;/strong&gt;节点。&lt;/p&gt;
&lt;h3 id=&#34;拆子树&#34;&gt;&lt;strong&gt;拆子树&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（节点可能宕机或者退出），光知道&lt;strong&gt;一个&lt;/strong&gt;显然是不够的，需要知道&lt;strong&gt;多个&lt;/strong&gt;才比较保险。&lt;/p&gt;
&lt;p&gt;所以 Kad 论文中给出了一个&lt;code&gt;K-桶（K-bucket）&lt;/code&gt;的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的  &lt;code&gt;K&lt;/code&gt;  个节点。这里所说的  &lt;code&gt;K&lt;/code&gt;  值是一个&lt;strong&gt;系统级&lt;/strong&gt;的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 8）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;K 桶&lt;/strong&gt;其实就是&lt;strong&gt;路由表&lt;/strong&gt;。对于某个节点而言，如果&lt;strong&gt;以它自己为视角&lt;/strong&gt;拆分了  &lt;strong&gt;n&lt;/strong&gt;  个子树，那么它就需要维护  &lt;strong&gt;n&lt;/strong&gt;  个路由表，并且每个路由表的&lt;strong&gt;上限&lt;/strong&gt;是 K。&lt;/p&gt;
&lt;p&gt;说 K 只是一个&lt;strong&gt;上限&lt;/strong&gt;，是因为有两种情况使得 K 桶的尺寸会小于 K:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;距离越近的子树就越小。如果整个子树&lt;strong&gt;可能存在的&lt;/strong&gt;节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。(这是由于 K 桶对应的距离越近，节点数越少)&lt;/li&gt;
&lt;li&gt;有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果选择这 K 个节点呢？&lt;br&gt;
Kademlia 选择把那些长时间在线的节点存入 K 桶，这一方法增长了未来某一时刻有效节点的数量，同时也提供了更为稳定的网络。当某个 K 桶已满，而又发现了相应于该桶的新节点的时候，那么，就首先检查 K 桶中最早访问的节点，假如该节点仍然存活，那么新节点就被安排到一个附属列表中（作为一个替代缓存）.只有当 K 桶中的某个节点停止响应的时候，替代 cache 才被使用。换句话说，新发现的节点只有在老的节点消失后才被使用。&lt;/p&gt;
&lt;h3 id=&#34;kademlia-协议&#34;&gt;&lt;strong&gt;Kademlia 协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kademlia 协议共有四种消息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PING&lt;/strong&gt;消息: 用来测试节点是否仍然在线。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STORE&lt;/strong&gt;消息: 在某个节点中存储一个键值对。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIND_NODE&lt;/strong&gt;消息: 消息请求的接收者将返回自己桶中离请求键值最近的 K 个节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIND_VALUE&lt;/strong&gt;消息: 与 FIND_NODE 一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一个 RPC 消息中都包含一个发起者加入的随机值，这一点确保响应消息在收到的时候能够与前面发送的请求消息匹配。&lt;/p&gt;
&lt;h3 id=&#34;定位节点&#34;&gt;&lt;strong&gt;定位节点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;节点查询可以异步进行，也可以同时进行，同时查询的数量由 α 表示，一般是 3。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由查询发起者从自己的 k-桶中筛选出若干距离目标 ID 最近的节点，并向这些节点同时发送异步查询请求；&lt;/li&gt;
&lt;li&gt;被查询节点收到请求之后，将从自己的 k-桶中找出自己所知道的距离查询目标 ID 最近的若干个节点，并返回给发起者；&lt;/li&gt;
&lt;li&gt;发起者在收到这些返回信息之后，更新自己的结果列表，再次从自己所有已知的距离目标较近的节点中挑选出若干没有请求过的，并重复步骤 1；&lt;/li&gt;
&lt;li&gt;上述步骤不断重复，直至无法获得比查询者当前已知的 k 个节点更接近目标的活动节点为止。&lt;/li&gt;
&lt;li&gt;在查询过程中，没有及时响应的节点将立即被排除；查询者必须保证最终获得的 k 个最节点都是活动的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;定位资源&#34;&gt;&lt;strong&gt;定位资源&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;通过把资源信息与键进行映射，资源即可进行定位，杂凑表是典型的用来映射的手段。由于以前的 STORE 消息，存储节点将会有对应 STORE 所存储的相关资源的信息。定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，定位资源与定位离键最近的节点的过程相似。&lt;/p&gt;
&lt;p&gt;考虑到节点未必都在线的情况，资源的值被存在多个节点上（节点中的 K 个），并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的 K 个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。&lt;/p&gt;
&lt;h3 id=&#34;加入网络&#34;&gt;&lt;strong&gt;加入网络&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;新节点 A 必须知道某个引导节点 B，并把它加入到自己相应的 K-桶中&lt;/li&gt;
&lt;li&gt;生成一个随机的节点 ID,直到离开网络，该节点会一直使用该 ID 号&lt;/li&gt;
&lt;li&gt;向 B（A 目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的 ID 是自己（就是查询自己）&lt;/li&gt;
&lt;li&gt;B 收到该请求之后，会先把 A 的 ID 加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B 会找到 K 个最接近 A 的节点，并返回给 A&lt;/li&gt;
&lt;li&gt;A 收到这 K 个节点的 ID 之后，把他们加入自己的 K-桶&lt;/li&gt;
&lt;li&gt;然后 A 会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至 A 建立了足够详细的路由表。&lt;/li&gt;
&lt;li&gt;这种“自我定位”将使得 Kad 的其他节点（收到请求的节点）能够使用 A 的 ID 填充他们的 K-桶，同时也能够使用那些查询过程的中间节点来填充 A 的 K-桶。这已过程既让 A 获得了详细的路由表，也让其它节点知道了 A 节点的加入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;kad-在-p2p-网络中的应用&#34;&gt;kad 在 p2p 网络中的应用&lt;/h2&gt;
&lt;p&gt;Kademlia 可在文件分享网络中使用，通过制作 Kademlia 关键字搜索，我们能够在文件分享网络中找到我们需要的文件以供我们下载。由于没有中央服务器存储文件的索引，这部分工作就被平均地分配到所有的客户端中去：&lt;/p&gt;
&lt;p&gt;假如一个节点希望分享某个文件，它先根据文件的内容来处理该文件，通过运算，把文件的内容散列成一组数字，该数字在文件分享网络中可被用来标识文件。这组散列数字必须和节点 ID 有同样的长度，&lt;br&gt;
然后，该节点便在网络中搜索 ID 值与文件的散列值相近的节点，并把它自己的 IP 地址存储在那些搜索到的节点上，也就是说，它把自己作为文件的源进行了发布。正在进行文件搜索的客户端将使用 Kademlia 协议来寻找网络上 ID 值与希望寻找的文件的散列值最近的那个节点，然后取得存储在那个节点上的文件源列表。&lt;br&gt;
由于一个键可以对应很多值，即同一个文件可以有多个源，每一个存储源列表的节点可能有不同的文件的源的信息，这样的话，源列表可以从与键值相近的 K 个节点获得。&lt;/p&gt;
&lt;p&gt;文件的散列值通常可以从其他的一些特别的 Internet 链接的地方获得，或者被包含在从其他某处获得的索引文件中。&lt;br&gt;
文件名的搜索可以使用关键词来实现，文件名可以分割成连续的几个关键词，这些关键词都可以散列并且可以和相应的文件名和文件散列储存在网络中。搜索者可以使用其中的某个关键词，联系 ID 值与关键词散列最近的那个节点，取得包含该关键词的文件列表。由于在文件列表中的文件都有相关的散列值，通过该散列值就可利用上述通常取文件的方法获得要搜索的文件。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E9%9B%9C%E6%B9%8A%E8%A1%A8&#34;&gt;https://zh.wikipedia.org/wiki/分散式雜湊表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Distributed_hash_table&#34;&gt;https://en.wikipedia.org/wiki/Distributed_hash_table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://baike.baidu.com/item/DHT/1007999&#34;&gt;DHT（一种分布式存储方法）_百度百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/7beeb52376cc&#34;&gt;分布式哈希与一致性哈希 - 简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html&#34;&gt;https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://colobu.com/2018/03/26/distributed-hash-table/&#34;&gt;https://colobu.com/2018/03/26/distributed-hash-table/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>跳表</title>
      <link>http://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Tue, 07 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/20.%E8%B7%B3%E8%A1%A8/</guid>
      
        <description>&lt;h1 id=&#34;跳表skiplist&#34;&gt;跳表(skiplist)&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;跳表&lt;/code&gt;(SkipList)由 William Pugh 于 1990 年发明。他在 Communications of the ACM June 1990, 33(6) 668-676 上发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了跳表的数据结构和插入删除操作。&lt;/p&gt;
&lt;p&gt;跳表是平衡树的一种替代的数据结构，和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法，跳表的插入和删除的工作是比较简单的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-04-2020-03-06-11-41-30-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思想&#34;&gt;核心思想&lt;/h2&gt;
&lt;p&gt;通过对普通有序链表扩充层级指针，实现节点的快速访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/12-21-20-11-image-20190504154638969.png&#34; alt=&#34;image-20190504154638969&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;实现要点&#34;&gt;实现要点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新增节点通过随机数决定指针的层级；&lt;/li&gt;
&lt;li&gt;通过调节因子决定随机层级，从而控制层级指针的疏密；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// member 对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 分值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 后退指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;backward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 层
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistLevel&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 前进指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 这个层跨越的节点数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&#34;&gt;http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html&#34;&gt;跳跃表 — Redis 设计与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>http://justice.bj.cn/post/12.data_struct/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://justice.bj.cn/post/12.data_struct/readme/</guid>
      
        <description>&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;./00.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md&#34;&gt;基础数据结构&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;./01.%E6%AF%94%E7%89%B9.md&#34;&gt;比特/字节&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;./%E6%95%B0%E7%BB%84.md&#34;&gt;数组&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;./05.%E6%A0%91.md&#34;&gt;树&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./Tree/B-Tree.md&#34;&gt;B 树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./Tree/RB-Tree.md&#34;&gt;红黑树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./Tree/TrieTree.md&#34;&gt;字典树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./Tree/Segment-Tree.md&#34;&gt;线段树&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>
