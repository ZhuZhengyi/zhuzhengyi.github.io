<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 06 Sep 2023 22:56:21 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>1008.前序遍历构造二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1008.symmetric-tree/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1008.symmetric-tree/</guid><description>&lt;h1 id="1008前序遍历构造二叉搜索树">1008.前序遍历构造二叉搜索树&lt;/h1>
&lt;p>给定一个整数数组，它表示BST(即 二叉搜索树 )的 先序遍历 ，构造树并返回其根。&lt;/p>
&lt;p>保证 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。&lt;/p>
&lt;p>二叉搜索树 是一棵二叉树，其中每个节点， Node.left 的任何后代的值 严格小于 Node.val , Node.right 的任何后代的值 严格大于 Node.val。&lt;/p>
&lt;p>二叉树的 前序遍历 首先显示节点的值，然后遍历Node.left，最后遍历Node.right。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>&lt;a href="https://assets.leetcode.com/uploads/2019/03/06/1266.png">https://assets.leetcode.com/uploads/2019/03/06/1266.png&lt;/a>&lt;/p>
&lt;p>输入：preorder = [8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]&lt;/p>
&lt;p>示例 2:&lt;/p>
&lt;p>输入: preorder = [1,3]
输出: [1,null,3]&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>1 &amp;lt;= preorder.length &amp;lt;= 100
1 &amp;lt;= preorder[i] &amp;lt;= 10^8
preorder 中的值 互不相同
&lt;/code>&lt;/pre></description></item><item><title>101.对称二叉树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/101.symmetric-tree/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/101.symmetric-tree/</guid><description>&lt;h1 id="101对称二叉树">101.对称二叉树&lt;/h1>
&lt;p>给你一个二叉树的根节点 root ， 检查它是否轴对称。&lt;/p>
&lt;p>示例 1：
&lt;a href="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg">https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg&lt;/a>&lt;/p>
&lt;p>输入：root = [1,2,2,3,4,4,3]
输出：true&lt;/p>
&lt;p>示例 2：
&lt;a href="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg">https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg&lt;/a>&lt;/p>
&lt;p>输入：root = [1,2,2,null,3,null,3]
输出：false&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>树中节点数目在范围 [1, 1000] 内
-100 &amp;lt;= Node.val &amp;lt;= 100
&lt;/code>&lt;/pre>
&lt;p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？&lt;/p></description></item><item><title>1027.最长等差数列</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1027.longest-arithmetic-subsequence/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1027.longest-arithmetic-subsequence/</guid><description>&lt;h1 id="1027最长等差数列">1027.最长等差数列&lt;/h1>
&lt;p>给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。&lt;/p>
&lt;p>回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], &amp;hellip;, nums[ik] ，且 0 &amp;lt;= i1 &amp;lt; i2 &amp;lt; &amp;hellip; &amp;lt; ik &amp;lt;= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 &amp;lt;= i &amp;lt; seq.length - 1) 的值都相同，那么序列 seq 是等差的。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>输入：nums = [3,6,9,12]
输出：4
解释：
整个数组是公差为 3 的等差数列。&lt;/p>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：nums = [9,4,7,2,10]
输出：3
解释：
最长的等差子序列是 [4,7,10]。&lt;/p>
&lt;p>示例 3：&lt;/p>
&lt;p>输入：nums = [20,1,15,3,10,5,8]
输出：4
解释：
最长的等差子序列是 [20,15,10,5]。&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>2 &amp;lt;= nums.length &amp;lt;= 1000
0 &amp;lt;= nums[i] &amp;lt;= 500
&lt;/code>&lt;/pre></description></item><item><title>103.二叉树的锯齿形层序遍历</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/103.binary-tree-zigzag-level-order-traversal/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/103.binary-tree-zigzag-level-order-traversal/</guid><description>&lt;h1 id="103二叉树的锯齿形层序遍历">103.二叉树的锯齿形层序遍历&lt;/h1>
&lt;p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p>
&lt;p>示例 1：
&lt;a href="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg">https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg&lt;/a>&lt;/p>
&lt;p>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]&lt;/p>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：root = [1]
输出：[[1]]&lt;/p>
&lt;p>示例 3：&lt;/p>
&lt;p>输入：root = []
输出：[]&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>树中节点数目在范围 [0, 2000] 内
-100 &amp;lt;= Node.val &amp;lt;= 100
&lt;/code>&lt;/pre></description></item><item><title>1037.有效的回旋镖</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1037.valid-boomerang/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1037.valid-boomerang/</guid><description>&lt;h1 id="1037有效的回旋镖">1037.有效的回旋镖&lt;/h1>
&lt;p>给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。&lt;/p>
&lt;p>回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>输入：points = [[1,1],[2,3],[3,2]]
输出：true&lt;/p>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：points = [[1,1],[2,2],[3,3]]
输出：false&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>points.length == 3
points[i].length == 2
0 &amp;lt;= xi, yi &amp;lt;= 100
&lt;/code>&lt;/pre></description></item><item><title>1061.按字典序排列最小的等效字符串</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1061.lexicographically-smallest-equivalent-string/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1061.lexicographically-smallest-equivalent-string/</guid><description>&lt;h1 id="1061按字典序排列最小的等效字符串">1061.按字典序排列最小的等效字符串&lt;/h1>
&lt;p>给出长度相同的两个字符串s1 和 s2 ，还有一个字符串 baseStr 。&lt;/p>
&lt;p>其中 s1[i] 和 s2[i] 是一组等价字符。&lt;/p>
&lt;pre>&lt;code>举个例子，如果 s1 = &amp;quot;abc&amp;quot; 且 s2 = &amp;quot;cde&amp;quot;，那么就有 'a' == 'c', 'b' == 'd', 'c' == 'e'。
&lt;/code>&lt;/pre>
&lt;p>等价字符遵循任何等价关系的一般规则：&lt;/p>
&lt;pre>&lt;code> 自反性 ：'a' == 'a'
对称性 ：'a' == 'b' 则必定有 'b' == 'a'
传递性 ：'a' == 'b' 且 'b' == 'c' 就表明 'a' == 'c'
&lt;/code>&lt;/pre>
&lt;p>例如， s1 = &amp;ldquo;abc&amp;rdquo; 和 s2 = &amp;ldquo;cde&amp;rdquo; 的等价信息和之前的例子一样，那么 baseStr = &amp;ldquo;eed&amp;rdquo; , &amp;ldquo;acd&amp;rdquo; 或 &amp;ldquo;aab&amp;rdquo;，这三个字符串都是等价的，而 &amp;ldquo;aab&amp;rdquo; 是 baseStr 的按字典序最小的等价字符串&lt;/p>
&lt;p>利用 s1 和 s2 的等价信息，找出并返回 baseStr 的按字典序排列最小的等价字符串。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>输入：s1 = &amp;ldquo;parker&amp;rdquo;, s2 = &amp;ldquo;morris&amp;rdquo;, baseStr = &amp;ldquo;parser&amp;rdquo;
输出：&amp;ldquo;makkek&amp;rdquo;
解释：根据 A 和 B 中的等价信息，我们可以将这些字符分为 [m,p], [a,o], [k,r,s], [e,i] 共 4 组。每组中的字符都是等价的，并按字典序排列。所以答案是 &amp;ldquo;makkek&amp;rdquo;。&lt;/p>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：s1 = &amp;ldquo;hello&amp;rdquo;, s2 = &amp;ldquo;world&amp;rdquo;, baseStr = &amp;ldquo;hold&amp;rdquo;
输出：&amp;ldquo;hdld&amp;rdquo;
解释：根据 A 和 B 中的等价信息，我们可以将这些字符分为 [h,w], [d,e,o], [l,r] 共 3 组。所以只有 S 中的第二个字符 &amp;lsquo;o&amp;rsquo; 变成 &amp;rsquo;d'，最后答案为 &amp;ldquo;hdld&amp;rdquo;。&lt;/p>
&lt;p>示例 3：&lt;/p>
&lt;p>输入：s1 = &amp;ldquo;leetcode&amp;rdquo;, s2 = &amp;ldquo;programs&amp;rdquo;, baseStr = &amp;ldquo;sourcecode&amp;rdquo;
输出：&amp;ldquo;aauaaaaada&amp;rdquo;
解释：我们可以把 A 和 B 中的等价字符分为 [a,o,e,r,s,c], [l,p], [g,t] 和 [d,m] 共 4 组，因此 S 中除了 &amp;lsquo;u&amp;rsquo; 和 &amp;rsquo;d' 之外的所有字母都转化成了 &amp;lsquo;a&amp;rsquo;，最后答案为 &amp;ldquo;aauaaaaada&amp;rdquo;。&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>1 &amp;lt;= s1.length, s2.length, baseStr &amp;lt;= 1000
s1.length == s2.length
字符串s1, s2, and baseStr 仅由从 'a' 到 'z' 的小写英文字母组成。
&lt;/code>&lt;/pre></description></item><item><title>1123.最深叶节点的最近公共祖先</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1123.lowest-common-ancestor-of-deepest-leaves/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1123.lowest-common-ancestor-of-deepest-leaves/</guid><description>&lt;h1 id="1123最深叶节点的最近公共祖先">1123.最深叶节点的最近公共祖先&lt;/h1>
&lt;p>给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。&lt;/p>
&lt;p>回想一下：&lt;/p>
&lt;pre>&lt;code>叶节点 是二叉树中没有子节点的节点
树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1
如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。
&lt;/code>&lt;/pre>
&lt;p>示例 1：
&lt;a href="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png">https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png&lt;/a>&lt;/p>
&lt;p>输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4 的深度是 3 。&lt;/p>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点，它是它本身的最近公共祖先。&lt;/p>
&lt;p>示例 3：&lt;/p>
&lt;p>输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的叶节点是 2 ，最近公共祖先是它自己。&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>树中的节点数将在 [1, 1000] 的范围内。
0 &amp;lt;= Node.val &amp;lt;= 1000
每个节点的值都是 独一无二 的。
&lt;/code>&lt;/pre>
&lt;p>注意：本题与力扣 865 重复：https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/&lt;/p></description></item><item><title>2305.公平分发饼干</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/2305.fair-distribution-of-cookies/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/2305.fair-distribution-of-cookies/</guid><description>&lt;h1 id="2305公平分发饼干">2305.公平分发饼干&lt;/h1>
&lt;p>给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。&lt;/p>
&lt;p>分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。&lt;/p>
&lt;p>返回所有分发的最小不公平程度。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>输入：cookies = [8,15,10,20,8], k = 2
输出：31
解释：一种最优方案是 [8,15,8] 和 [10,20] 。&lt;/p>
&lt;ul>
&lt;li>第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。&lt;/li>
&lt;li>第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。
分发的不公平程度为 max(31,30) = 31 。
可以证明不存在不公平程度小于 31 的分发方案。&lt;/li>
&lt;/ul>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：cookies = [6,1,3,2,2,4,1,2], k = 3
输出：7
解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。&lt;/p>
&lt;ul>
&lt;li>第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。&lt;/li>
&lt;li>第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。&lt;/li>
&lt;li>第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。
分发的不公平程度为 max(7,7,7) = 7 。
可以证明不存在不公平程度小于 7 的分发方案。&lt;/li>
&lt;/ul>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>2 &amp;lt;= cookies.length &amp;lt;= 8
1 &amp;lt;= cookies[i] &amp;lt;= 105
2 &amp;lt;= k &amp;lt;= cookies.length
&lt;/code>&lt;/pre></description></item><item><title>最深叶节点的最近公共祖先</title><link>https://justice.bj.cn/post/leetcode/doc/1123.%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link><pubDate>Wed, 06 Sep 2023 22:56:21 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/doc/1123.%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid><description>&lt;h1 id="最深叶节点的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-deepest-leavesdescription-httpsleetcodecnproblemslowest-common-ancestor-of-deepest-leavesdescription">&lt;a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/" title="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/">最深叶节点的最近公共祖先&lt;/a>&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Category&lt;/th>
&lt;th>Difficulty&lt;/th>
&lt;th>Likes&lt;/th>
&lt;th>Dislikes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>algorithms&lt;/td>
&lt;td>Medium (71.90%)&lt;/td>
&lt;td>220&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tags&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://leetcode.com/tag/Unknown" title="https://leetcode.com/tag/Unknown">&lt;code>Unknown&lt;/code>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Companies&lt;/strong>&lt;/p>
&lt;p>&lt;code>Unknown&lt;/code>&lt;/p>
&lt;p>给你一个有根节点 &lt;code>root&lt;/code> 的二叉树，返回它 &lt;em>最深的叶节点的最近公共祖先&lt;/em> 。&lt;/p>
&lt;p>回想一下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>叶节点&lt;/strong> 是二叉树中没有子节点的节点&lt;/li>
&lt;li>树的根节点的 &lt;strong>深度&lt;/strong> 为 &lt;code>0&lt;/code>，如果某一节点的深度为 &lt;code>d&lt;/code>，那它的子节点的深度就是 &lt;code>d+1&lt;/code>&lt;/li>
&lt;li>如果我们假定 &lt;code>A&lt;/code> 是一组节点 &lt;code>S&lt;/code> 的 &lt;strong>最近公共祖先&lt;/strong>，&lt;code>S&lt;/code> 中的每个节点都在以 &lt;code>A&lt;/code> 为根节点的子树中，且 &lt;code>A&lt;/code> 的深度达到此条件下可能的最大值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4 的深度是 3 。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点，它是它本身的最近公共祖先。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的叶节点是 2 ，最近公共祖先是它自己。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>树中的节点数将在 &lt;code>[1, 1000]&lt;/code> 的范围内。&lt;/li>
&lt;li>&lt;code>0 &amp;lt;= Node.val &amp;lt;= 1000&lt;/code>&lt;/li>
&lt;li>每个节点的值都是 &lt;strong>独一无二&lt;/strong> 的。&lt;/li>
&lt;/ul>
&lt;p>**注意：**本题与力扣 865 重复：&lt;a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/" title="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台&lt;/a>&lt;/p>
&lt;hr>
&lt;p>&lt;a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/comments/" title="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/comments/">Discussion&lt;/a> | &lt;a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/solution/" title="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/solution/">Solution&lt;/a>&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// @lc code=start
&lt;/span>&lt;span class="c1">// Definition for a binary tree node.
&lt;/span>&lt;span class="c1">// #[derive(Debug, PartialEq, Eq)]
&lt;/span>&lt;span class="c1">// pub struct TreeNode {
&lt;/span>&lt;span class="c1">// pub val: i32,
&lt;/span>&lt;span class="c1">// pub left: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;,
&lt;/span>&lt;span class="c1">// pub right: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;,
&lt;/span>&lt;span class="c1">// }
&lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">// impl TreeNode {
&lt;/span>&lt;span class="c1">// #[inline]
&lt;/span>&lt;span class="c1">// pub fn new(val: i32) -&amp;gt; Self {
&lt;/span>&lt;span class="c1">// TreeNode {
&lt;/span>&lt;span class="c1">// val,
&lt;/span>&lt;span class="c1">// left: None,
&lt;/span>&lt;span class="c1">// right: None
&lt;/span>&lt;span class="c1">// }
&lt;/span>&lt;span class="c1">// }
&lt;/span>&lt;span class="c1">// }
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="n">cell&lt;/span>::&lt;span class="n">RefCell&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="n">rc&lt;/span>::&lt;span class="n">Rc&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// ## 解题思路
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// - 递归
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 1. 如果root为None, 则结果为None;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 2. 否则,root不为空, left, right分别为其左右子树根节点;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 3. 如果left, right均为None, 则当前节点为叶子节点, 返回该节点;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 4. 如果left为None, right不为None, 则最深叶节点的最近公共祖先一定在right中,
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 递归求取以right为根的lca;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 5. 如果left不为None, right为None, 则递归left;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 6. 否则left, right都不为None, 则须判断left,right的高度
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 6.1. 如果left_heigh == right_heigh, 则当前节点为lca;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sd">/// 6.2. 否则递归heigh大的那一个;
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">lca_deepest_leaves&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>: &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rc&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">RefCell&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rc&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">RefCell&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取树的高度
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">get_heigh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Rc&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">RefCell&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">i32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">match&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">get_heigh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">get_heigh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">match&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">match&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">lca_deepest_leaves&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">())),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">None&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">lca_deepest_leaves&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">())),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">left_heigh&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">get_heigh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">right_heigh&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">get_heigh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">left_heigh&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">right_heigh&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">left_heigh&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">right_heigh&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">lca_deepest_leaves&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Solution&lt;/span>::&lt;span class="n">lca_deepest_leaves&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Some&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()));&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// @lc code=end
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>1.两数之和</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1.two-sum/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1.two-sum/</guid><description>&lt;h1 id="1两数之和">1.两数之和&lt;/h1>
&lt;p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。&lt;/p>
&lt;p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p>
&lt;p>你可以按任意顺序返回答案。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。&lt;/p>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：nums = [3,2,4], target = 6
输出：[1,2]&lt;/p>
&lt;p>示例 3：&lt;/p>
&lt;p>输入：nums = [3,3], target = 6
输出：[0,1]&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>2 &amp;lt;= nums.length &amp;lt;= 104
-109 &amp;lt;= nums[i] &amp;lt;= 109
-109 &amp;lt;= target &amp;lt;= 109
只会存在一个有效答案
&lt;/code>&lt;/pre>
&lt;p>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？&lt;/p></description></item><item><title>10.正则表达式匹配</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/10.regular-expression-matching/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/10.regular-expression-matching/</guid><description>&lt;h1 id="10正则表达式匹配">10.正则表达式匹配&lt;/h1>
&lt;p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式匹配。&lt;/p>
&lt;pre>&lt;code>'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
&lt;/code>&lt;/pre>
&lt;p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>输入：s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;a&amp;rdquo;
输出：false
解释：&amp;ldquo;a&amp;rdquo; 无法匹配 &amp;ldquo;aa&amp;rdquo; 整个字符串。&lt;/p>
&lt;p>示例 2:&lt;/p>
&lt;p>输入：s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;a*&amp;rdquo;
输出：true
解释：因为 &amp;lsquo;*&amp;rsquo; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;lsquo;a&amp;rsquo;。因此，字符串 &amp;ldquo;aa&amp;rdquo; 可被视为 &amp;lsquo;a&amp;rsquo; 重复了一次。&lt;/p>
&lt;p>示例 3：&lt;/p>
&lt;p>输入：s = &amp;ldquo;ab&amp;rdquo;, p = &amp;ldquo;.&lt;em>&amp;rdquo;
输出：true
解释：&amp;quot;.&lt;/em>&amp;quot; 表示可匹配零个或多个（'*'）任意字符（'.'）。&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>1 &amp;lt;= s.length &amp;lt;= 20
1 &amp;lt;= p.length &amp;lt;= 20
s 只包含从 a-z 的小写字母。
p 只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符
&lt;/code>&lt;/pre></description></item><item><title>100.相同的树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/100.same-tree/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/100.same-tree/</guid><description>&lt;h1 id="100相同的树">100.相同的树&lt;/h1>
&lt;p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。&lt;/p>
&lt;p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p>
&lt;p> &lt;/p>
&lt;p>示例 1：
&lt;a href="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg">https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg&lt;/a>&lt;/p>
&lt;p>输入：p = [1,2,3], q = [1,2,3]
输出：true&lt;/p>
&lt;p>示例 2：
&lt;a href="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg">https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg&lt;/a>&lt;/p>
&lt;p>输入：p = [1,2], q = [1,null,2]
输出：false&lt;/p>
&lt;p>示例 3：
&lt;a href="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg">https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg&lt;/a>&lt;/p>
&lt;p>输入：p = [1,2,1], q = [1,1,2]
输出：false&lt;/p>
&lt;p> &lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>两棵树上的节点数目都在范围 [0, 100] 内
-104 4
&lt;/code>&lt;/pre></description></item><item><title>1008.前序遍历构造二叉搜索树</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/1008.construct-binary-search-tree-from-preorder-traversal/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/1008.construct-binary-search-tree-from-preorder-traversal/</guid><description>&lt;h1 id="1008前序遍历构造二叉搜索树">1008.前序遍历构造二叉搜索树&lt;/h1>
&lt;p>给定一个整数数组，它表示BST(即 二叉搜索树 )的 先序遍历 ，构造树并返回其根。&lt;/p>
&lt;p>保证 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。&lt;/p>
&lt;p>二叉搜索树 是一棵二叉树，其中每个节点， Node.left 的任何后代的值 严格小于 Node.val , Node.right 的任何后代的值 严格大于 Node.val。&lt;/p>
&lt;p>二叉树的 前序遍历 首先显示节点的值，然后遍历Node.left，最后遍历Node.right。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>&lt;a href="https://assets.leetcode.com/uploads/2019/03/06/1266.png">https://assets.leetcode.com/uploads/2019/03/06/1266.png&lt;/a>&lt;/p>
&lt;p>输入：preorder = [8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]&lt;/p>
&lt;p>示例 2:&lt;/p>
&lt;p>输入: preorder = [1,3]
输出: [1,null,3]&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>1 &amp;lt;= preorder.length &amp;lt;= 100
1 &amp;lt;= preorder[i] &amp;lt;= 10^8
preorder 中的值 互不相同
&lt;/code>&lt;/pre></description></item><item><title>180.连续出现的数字</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/180.consecutive-numbers/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/180.consecutive-numbers/</guid><description>&lt;h1 id="180连续出现的数字">180.连续出现的数字&lt;/h1>
&lt;p>表：Logs&lt;/p>
&lt;p>+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+
| Column Name | Type |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+
| id | int |
| num | varchar |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;+
在 SQL 中，id 是该表的主键。
id 是一个自增列。&lt;/p>
&lt;p>找出所有至少连续出现三次的数字。&lt;/p>
&lt;p>返回的结果表中的数据可以按 任意顺序 排列。&lt;/p>
&lt;p>结果格式如下面的例子所示：&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;p>输入：
Logs 表：
+&amp;mdash;-+&amp;mdash;&amp;ndash;+
| id | num |
+&amp;mdash;-+&amp;mdash;&amp;ndash;+
| 1 | 1 |
| 2 | 1 |
| 3 | 1 |
| 4 | 2 |
| 5 | 1 |
| 6 | 2 |
| 7 | 2 |
+&amp;mdash;-+&amp;mdash;&amp;ndash;+
输出：
Result 表：
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| ConsecutiveNums |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| 1 |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
解释：1 是唯一连续出现至少三次的数字。&lt;/p></description></item><item><title>2119.反转两次的数字</title><link>https://justice.bj.cn/post/leetcode/rust/src/question/2119.a-number-after-a-double-reversal/</link><pubDate>Tue, 05 Sep 2023 22:07:45 +0800</pubDate><guid>https://justice.bj.cn/post/leetcode/rust/src/question/2119.a-number-after-a-double-reversal/</guid><description>&lt;h1 id="2119反转两次的数字">2119.反转两次的数字&lt;/h1>
&lt;p>反转 一个整数意味着倒置它的所有位。&lt;/p>
&lt;pre>&lt;code>例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。
&lt;/code>&lt;/pre>
&lt;p>给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;p>输入：num = 526
输出：true
解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。&lt;/p>
&lt;p>示例 2：&lt;/p>
&lt;p>输入：num = 1800
输出：false
解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。&lt;/p>
&lt;p>示例 3：&lt;/p>
&lt;p>输入：num = 0
输出：true
解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。&lt;/p>
&lt;p>提示：&lt;/p>
&lt;pre>&lt;code>0 &amp;lt;= num &amp;lt;= 106
&lt;/code>&lt;/pre></description></item></channel></rss>