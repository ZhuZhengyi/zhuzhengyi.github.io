<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 06 Jun 2022 20:41:30 +0800</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>blockchain_rust</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Bblockchain/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Bblockchain/</guid><description>&lt;h1 id="blockchain_rust">blockchain_rust&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>blockchain_rust是github上一个基于rust的blockchain实现；&lt;/p>
&lt;h2 id="操作">操作&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ mkdir -p data/node&lt;span class="o">{&lt;/span>1,2,3&lt;span class="o">}&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ &lt;span class="nb">cd&lt;/span> data/node1
&lt;span class="c1">## 创建wallet&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 13teoDGrDNhMrgGHHRESv7bhcnJoXnicqE
&lt;span class="c1">## 创建block0&lt;/span>
&lt;span class="o">[&lt;/span>node1&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createblockchain 13teoDGrDNhMrgGHHRESv7bhcnJoXnicqE
Mining the block
00518dae1ee13a19da96d24f865654eed74dfb3188f4ae0fe56616c03535acb9
Done!
&lt;span class="c1">## 手动同步创世区块数据&lt;/span>
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span> &lt;span class="nb">cd&lt;/span> data/node2&lt;span class="p">;&lt;/span> cp -rf ../node1/data .
&lt;span class="o">[&lt;/span>node3&lt;span class="o">]&lt;/span> &lt;span class="nb">cd&lt;/span> data/node3&lt;span class="p">;&lt;/span> cp -rf ../node1/data .
&lt;span class="c1">## node2创建钱包&lt;/span>
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1JvjDQGrmzVLLAo9dPsXYNNednuNZrGrAm
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1JvjDQGrmzVLLAo9dPsXYNNednuNZrGrAm
&lt;span class="o">[&lt;/span>node2&lt;span class="o">]&lt;/span>$ ../../target/debug/blockchain_rust createwallet
Your new address: 1FztXwduMcABm6x2yxRWgozqT8g1dgeiFS
&lt;span class="c1">## 转账&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Linux系统调用之Futex</title><link>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8Bfutex/</guid><description>&lt;h1 id="linux系统调用之futex">Linux系统调用之Futex&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Futex（Fast Userspace muTexes）的缩写，由Hubertus Franke, Matthew Kirkwood, Ingo Molnar and Rusty Russell共同设计完成，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Futex是一种用户态和内核态混合的同步机制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>同步的进程间通过mmap共享一段内存，futex变量就位于这段共享 的内存中且操作是原子的，&lt;/li>
&lt;li>当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，
3. 如果没有竞争发生，则只修改futex,而不 用再执行系统调用了。
4. 如果futex变量告诉进程有竞争发生，则执行系统调用去完成相应的处理(wait 或者 wake up)。&lt;/li>
&lt;/ol>
&lt;p>futex 函数：&lt;/p>
&lt;ol>
&lt;li>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;/li>
&lt;li>不加timeout参数，它会一直被阻塞，直到FUTEX_WAKE:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/futex.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/time.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">futex&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">timespec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">uaddr2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cp">#define __NR_futex 240
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。&lt;br>
FUTEX_WAKE: 最多唤醒val个等待在uaddr上进程。&lt;/p>
&lt;p>可见FUTEX_WAIT和FUTEX_WAKE只是用来挂起或者唤醒进程，当然这部分工作也只能在内核态下完成。有些人尝试着直接使用futex系统调 用来实现进程同步，并寄希望获得futex的性能优势，这是有问题的。应该区分futex同步机制和futex系统调用。futex同步机制还包括用户态 下的操作，我们将在下节提到。&lt;/p>
&lt;h2 id="futex同步机制">Futex同步机制&lt;/h2>
&lt;p>所有的futex同步操作都应该从用户空间开始，首先创建一个futex同步变量，也就是位于共享内存的一个整型计数器。&lt;br>
当 进程尝试持有锁或者要进入互斥区的时候，对futex执行&amp;quot;down&amp;quot;操作，即原子性的给futex同步变量减1。如果同步变量变为0，则没有竞争发生， 进程照常执行。如果同步变量是个负数，则意味着有竞争发生，需要调用futex系统调用的futex_wait操作休眠当前进程。&lt;br>
当进程释放锁或 者要离开互斥区的时候，对futex进行&amp;quot;up&amp;quot;操作，即原子性的给futex同步变量加1。如果同步变量由0变成1，则没有竞争发生，进程照常执行。如 果加之前同步变量是负数，则意味着有竞争发生，需要调用futex系统调用的futex_wake操作唤醒一个或者多个等待进程。&lt;/p>
&lt;p>这里的原子性加减通常是用CAS(Compare and Swap)完成的，与平台相关。CAS的基本形式是：CAS(addr,old,new),当addr中存放的值等于old时，用new对其替换。在x86平台上有专门的一条指令来完成它: cmpxchg。&lt;/p>
&lt;p>可见: futex是从用户态开始，由用户态和核心态协调完成的。&lt;/p>
&lt;h2 id="进线程利用futex同步">进/线程利用futex同步&lt;/h2>
&lt;p>进程或者线程都可以利用futex来进行同步。&lt;br>
对于线程，情况比较简单，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量。&lt;br>
对 于进程，情况相对复杂，因为进程有独立的虚拟内存空间，只有通过mmap()让它们共享一段地址空间来使用futex变量。每个进程用来访问futex的 虚拟地址可以是不一样的，只要系统知道所有的这些虚拟地址都映射到同一个物理内存地址，并用物理内存地址来唯一标识futex变量。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.shuzhiduo.com/A/rV57P2rLdP/">linux内核级同步机制&amp;ndash;futex&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/farmerjohngit/myblog/issues/6">关于同步的一点思考-上 · Issue #6 · farmerjohngit/myblog · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Rust特性(trait)</title><link>https://justice.bj.cn/post/14.language/rust/20.rust%E7%89%B9%E6%80%A7trait/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/20.rust%E7%89%B9%E6%80%A7trait/</guid><description>&lt;h1 id="rust特性trait">Rust特性(trait)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>trait&lt;/code>(特性) 是一组方法的集合，实现trait的类型可以访问该 trait 中定义的其他方法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何类型都可以实现 trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="要点">要点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Trait&lt;/code>必须声明可见后才能使用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Trait本身并没有固定的大小，不能直接声明和使用Trait类型的变量，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>某个实现该Trait类型的实例的有效引用称为&lt;code>Trait Object&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有trait都有一个隐藏的类型&lt;code>Self&lt;/code>，代表当前实现此Trait的具体类型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数&lt;u>第一个参数&lt;/u>是&lt;code>self&lt;/code>且为&lt;code>Self&lt;/code>相关类型(&lt;code>Self, &amp;amp;Self, &amp;amp;mut Self, Box&amp;lt;Self&amp;gt;&lt;/code>)，则函数为&lt;strong>方法&lt;/strong>(method)，&lt;code>self&lt;/code>称为&lt;code>receiver&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有receiver参数的函数为&lt;strong>静态方法&lt;/strong>，可通过&lt;code>Type::Function()&lt;/code>方式调用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>匿名Trait无须名字，可直接在impl中实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以在trait的声明中定义默认方法；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展trait(extension trait), 可以为其它trait类型扩展出自定义trait的接口，impl块必须与trait或struct声明在同一个crate中（孤儿规则）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>继承：凡是实现了Subtrait(&lt;code>Creature&lt;/code>)的类型, 也必须实现父Trait(&lt;code>Visible&lt;/code>)的&lt;strong>所有方法&lt;/strong>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="孤儿规则orphan-rule">孤儿规则(orphan rule)&lt;/h2>
&lt;ul>
&lt;li>如果要实现外部定义的 &lt;code>trait&lt;/code> 需要先将其导入作用域；&lt;/li>
&lt;li>不允许对外部类型实现外部 &lt;code>trait&lt;/code>；&lt;/li>
&lt;li>可以对外部类型实现自定义的 &lt;code>trait&lt;/code>；&lt;/li>
&lt;li>可以对自定义类型上实现外部 &lt;code>trait&lt;/code>；&lt;/li>
&lt;/ul>
&lt;h2 id="示例">示例&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// trait声明
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//method1(self: Self);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//area(self: &amp;amp;Self);
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">larger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>: &lt;span class="kt">f64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// trait 实现
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">area&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="kt">f64&lt;/span>::&lt;span class="n">consts&lt;/span>::&lt;span class="n">PI&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 匿名trait
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Circle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">get_radius&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">f64&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="trait-泛型">Trait 泛型&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// where 从句
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>: &lt;span class="nc">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>: &lt;span class="nc">K&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>: &lt;span class="nb">Clone&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">K&lt;/span>: &lt;span class="nb">Clone&lt;/span> &lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Debug&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{:?}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="trait对象trait-object">Trait对象(Trait object)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>指向trait的指针就是&lt;code>Trait Object&lt;/code>，比如 &lt;code>&amp;amp;SomeTrait&lt;/code> 和 &lt;code>Box&amp;lt;SomeTrait&amp;gt;&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>&amp;amp;SomeTrait&lt;/code> 类型和普通的指针类型不同, 不仅包括指向真实对象的指针，还包括一个指向虚函数表的指针;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rust通过&lt;code>TraitObject&lt;/code>用来实现动态分发；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Trait Object&lt;/code>实际是一个胖指针&lt;code>fat pointer&lt;/code>, 占用两个机器字字节, 一个指向实际的实例对象, 一个指向虚基表&lt;code>vtable&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::raw
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">TraitObject&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>: &lt;span class="o">*&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vtable&lt;/span>: &lt;span class="o">*&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="supertrait">Supertrait&lt;/h2>
&lt;h2 id="关联类型">关联类型&lt;/h2>
&lt;p>关联类型是一个将类型占位符与trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>关联类型类似泛型，不同之处关联类型，无需标注类型，无须多次实现trait；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Iterator&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span> &lt;span class="nc">Item&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//关联类型
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Self&lt;/span>::&lt;span class="n">Item&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Iterator&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Counter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span> &lt;span class="nc">Item&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Self&lt;/span>::&lt;span class="n">Item&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// --snip--
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="常用trait">常用Trait&lt;/h2>
&lt;h3 id="default">Default&lt;/h3>
&lt;p>Default trait是针对无参构造函数的抽象&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::default::Default
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">default&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// Vec default
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">default&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="derive">Derive&lt;/h3>
&lt;p>Rust提供了一个特殊属性，以自动impl某些trait，编译阶段会自动展开为相应的impl块：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="cp">#[derive(Copy, Clone, Default)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Foo&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Rust支持自动derive的trait有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Debug&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Clone/Copy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hash&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PartialEq/Eq/PartialOrd/Ord&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Send/Sync&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Default&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FromPrimitive&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RustcEncodable/RustcDecodable&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="displaydebug">Display/Debug&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>实现&lt;code>Display&lt;/code>特性的类型，可用&lt;code>{}&lt;/code>格式控制打印；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现&lt;code>Debug&lt;/code>特性的类型，可用&lt;code>{:?},{:#?}&lt;/code>格式控制打印；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Display&lt;/code>一般给最终用户显示的，通常用utf-8格式字符输出；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Debug&lt;/code>特性主要用于调试，一般为byte字符，编译器提供自动derive功能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现&lt;code>Dispaly&lt;/code>特性的类型都自动实现了&lt;code>ToString&lt;/code>特性，可直接通过&lt;code>to_string()&lt;/code>格式化字符串；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//std::fmt::Display
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Display&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">fmt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Formatter&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//std::fmt::Debug
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Debug&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">fmt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Formatter&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="派生derive">派生(derive)&lt;/h2>
&lt;p>通过 &lt;code>#[derive]&lt;/code> &lt;a href="https://rustwiki.org/zh-CN/rust-by-example/attribute.html">属性&lt;/a>，编译器能够提供某些 trait 的基本实现。如果 需要更复杂的行为，这些 trait 也可以手动实现。&lt;/p>
&lt;p>下面是可以自动派生的 trait：&lt;/p>
&lt;ul>
&lt;li>比较 trait: &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html">&lt;code>Eq&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialEq.html">&lt;code>PartialEq&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html">&lt;code>Ord&lt;/code>&lt;/a>, &lt;a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialOrd.html">&lt;code>PartialOrd&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html">&lt;code>Clone&lt;/code>&lt;/a>, 用来从 &lt;code>&amp;amp;T&lt;/code> 创建副本 &lt;code>T&lt;/code>。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/core/marker/trait.Copy.html">&lt;code>Copy&lt;/code>&lt;/a>，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/hash/trait.Hash.html">&lt;code>Hash&lt;/code>&lt;/a>，从 &lt;code>&amp;amp;T&lt;/code> 计算哈希值（hash）。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/default/trait.Default.html">&lt;code>Default&lt;/code>&lt;/a>, 创建数据类型的一个空实例。&lt;/li>
&lt;li>&lt;a href="https://rustwiki.org/zh-CN/std/fmt/trait.Debug.html">&lt;code>Debug&lt;/code>&lt;/a>，使用 &lt;code>{:?}&lt;/code> formatter 来格式化一个值。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="cp">#[derive(PartialEq, PartialOrd)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">f64&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// `Inches`，可以打印的元组结构体
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#[derive(Debug)]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Inches&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">i32&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">impl&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Inches&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">to_centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Centimeters&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">Inches&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inches&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Centimeters&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inches&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">f64&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mf">2.54&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="ordpartialordeqpartialeq">Ord/PartialOrd/Eq/PartialEq&lt;/h3>
&lt;h2 id="标签trait">标签Trait&lt;/h2>
&lt;h3 id="sized">Sized&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Sized&lt;/code>是一种&lt;code>maker trait&lt;/code>，表示类型size是固定的 , 没有任何方法和联合类型，无法实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rust不能在变量里保存&lt;em>unsized&lt;/em>的值, 也不能把&lt;em>unsize&lt;/em>的值作为参数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有固定大小的类型都实现里&lt;code>std::marker::Sized&lt;/code>trait；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Sized trait只能用于绑定到类型参数, 也就是用于参数的类型声明(及检查), 例如 &lt;code>T: Sized&lt;/code>不能用于其它用途；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>?Sized&lt;/code>叫 &lt;em>questionably sized&lt;/em>, 允许固定大小, 也允许非固定大小类型.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>struct的最后一个字段允许是&lt;code>?Sized&lt;/code>类型, 但如果这样, struct本身就变为了unsized.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但如果写成泛型, 并传入一个Sized类型, 那么这个类型的struct仍然是Sized. 大小取决于泛型的参数类型:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="copyclone">Copy/Clone&lt;/h3>
&lt;p>Copy:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果一个类型 impl 了 Copy trait，意味着任何时候，我们可以通过简单的内存拷贝实现该类型的复制，而不会产生任何问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦一个类型实现了 Copy trait，那么它在变量绑定、函数参数传递、函数返回值传递等场景下，它都是 copy 语义，而不再是默认的 move 语义；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只有所有的成员都实现了 Copy trait，这个类型才有资格实现 Copy trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Clone:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Clone&lt;/code>是&lt;code>Sized&lt;/code>的sub-trait, 所以Self类型必须是Sized；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>clone&lt;/code>方法必须返回和&lt;code>self&lt;/code>独立无关的一份拷贝；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果所有的字段都实现了Clone, 那么&lt;code>struct&lt;/code>可以加上属性: &lt;code>#[derive(Clone)]&lt;/code>自动实现Clone trait；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>通常情况下clone的成本比较高, 但是对于&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code>和&lt;code>Arc&amp;lt;T&amp;gt;&lt;/code>这类的类型, Rust的对它们的clone只是简单的增加计数.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通常尽可能使用&lt;code>clone_from&lt;/code>来减少clone开销, 这会允许一些优化. 例如, String的clone, 被赋值的String如果capacity够大, 可以不需要释放内存, 直接把源的内容拷贝过来.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果所有的字段都实现了Clone, 那么&lt;code>struct&lt;/code>可以加上属性: &lt;code>#[derive(Clone)]&lt;/code>自动实现Clone trait&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>clone&lt;/code>方法不能失败(&lt;em>infallible&lt;/em>), 对于&lt;code>std::fs::File&lt;/code>这样的类型, 有&lt;code>try_clone&lt;/code>方法, 返回&lt;code>std::io::Result&amp;lt;File&amp;gt;&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Clone&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">clone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">clone_from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">source&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="nc">Self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="frominto">From/Into&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>From&lt;/code>: 对于类型为 &lt;code>U&lt;/code> 的对象 &lt;code>foo&lt;/code>，如果它实现了 &lt;code>From&amp;lt;T&amp;gt;&lt;/code>，那么，可以通过 &lt;code>let foo = U::from(bar)&lt;/code> 来生成自己&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Into&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">into&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">T&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">From&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>: &lt;span class="nb">Sized&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nc">Self&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 静态方法
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// as_ref和Borrow的区别 ?
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// as_ref 是转引用函数, 将具有所有权对象转换成引用对象,
&lt;/span>&lt;span class="c1">// 不改变被转换对象的基础上产生一个引用对象.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// as_ref 并不是所有类型都默认支持, 很多时候都需要自己去声明.
&lt;/span>&lt;span class="c1">// as_ref 是AsRef trait 的公共接口方法.
&lt;/span>&lt;span class="c1">// 只有那些实现了 as_ref 公共接口方法的类型才能使用as_ref.
&lt;/span>&lt;span class="c1">// 目前: Option, Box, Result 这三种类型默认提供支持as_ref.
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://wiki.jikexueyuan.com/project/rust-primer/">https://wiki.jikexueyuan.com/project/rust-primer/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://unpluggedcoder.me/2019/08/31/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BTraits&amp;amp;Generics/">https://unpluggedcoder.me/2019/08/31/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BTraits&amp;amp;Generics/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/21730929">https://zhuanlan.zhihu.com/p/21730929&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://unpluggedcoder.me/2019/09/01/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BUtility%20Traits/">https://unpluggedcoder.me/2019/09/01/Rust%E5%85%A5%E9%97%A8%E5%A4%B1%E8%B4%A5%E4%B9%8BUtility%20Traits/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://wiki.jikexueyuan.com/project/rust-primer/trait/trait-object.html">https://wiki.jikexueyuan.com/project/rust-primer/trait/trait-object.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/23791817">https://zhuanlan.zhihu.com/p/23791817&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>ToyDB</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Btoydb/</link><pubDate>Mon, 06 Jun 2022 20:41:30 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B9%8Btoydb/</guid><description>&lt;h1 id="toydb">ToyDB&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>&lt;code>toydb&lt;/code>是&lt;code>Erik Grinaker&lt;/code>为学习&lt;code>rust&lt;/code>语言而开发的分布式sql数据库，支持分布式事务模型;&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;code>toydb&lt;/code>主要由3部分组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>sqlengine&lt;/code>: 负责sql语句的解析、执行计划；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>raftengine&lt;/code>: 负责存储层的数据副本同步；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>storage&lt;/code>: 负责提供kv及mvcc存储；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/10/07-18-54-21-2021-10-07-18-54-16-image.png" alt="">&lt;/p>
&lt;h2 id="sql层">SQL层&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>SQL层主要负责将输入的sql语句字符串转化为执行计划，并通过raft交给各个副本的mvcc存储引擎执行；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SQL主要分为两个阶段：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>词法分析：sql语句&amp;mdash;&amp;mdash;-&amp;gt;token&amp;mdash;-&amp;gt;AST；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>生成执行计划：AST&amp;mdash;&amp;ndash;&amp;gt;planner&amp;mdash;&amp;ndash;&amp;gt;优化&amp;mdash;&amp;ndash;&amp;gt;执行；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL语句 &amp;ndash;&amp;gt; 词法分析 &amp;mdash;-&amp;gt; 语法分析&amp;mdash;&amp;gt;生成执行计划&amp;mdash;&amp;gt;&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-16-00-47-2021-06-18-16-00-44-image.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-15-38-36-2021-06-18-15-38-32-image.png" alt="">&lt;/p>
&lt;h3 id="词法分析lexer">词法分析(Lexer)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Lexer 也称为分词，从左向右扫描SQL，将其分割成一个个的toke(词元)，在将token组装为AST(Abstract Tree);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Lexer的实现一般都是构造DFA(确定性有限状态自动机)来实现的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>状态转移图如下，这是一个能够识别标识符，数字和一般运算符的词法解析器。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/06/18-14-44-04-2021-06-18-14-44-00-image.png" alt="">&lt;/p>
&lt;h3 id="语法分析parser">语法分析(Parser)&lt;/h3>
&lt;p>Parser阶段有两种类型方法来实现:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是自顶向下分析法，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一种是自底向上分析法，&lt;/p>
&lt;p>简单介绍一下两种类型分析法的处理思路。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="执行计划">执行计划&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">SQL String ---词法分析&amp;lt;Lexer&amp;gt;--&amp;gt; Token --&amp;lt;语法分析&amp;gt;--&amp;gt; AST Statement
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="sql-engine">Sql Engine&lt;/h2>
&lt;h3 id="parser解释器">Parser(解释器)&lt;/h3>
&lt;h3 id="planner">Planner&lt;/h3>
&lt;h3 id="executor">Executor&lt;/h3>
&lt;h2 id="storage存储">Storage(存储)&lt;/h2>
&lt;h3 id="memory">Memory&lt;/h3>
&lt;h2 id="mvcc">MVCC&lt;/h2>
&lt;h2 id="raft-engine">Raft Engine&lt;/h2>
&lt;p>&lt;code>toydb&lt;/code> 通过raft来实现各节点间数据的一致性，其自带的raft模块由rust语言提供的一个简单的实现。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2021/10/08-13-34-25-2021-10-08-13-34-19-image.png" alt="">&lt;/p>
&lt;p>Raft内部有2个状态机：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>复制状态机(): 主要用于日志复制，保证各个副本日志的落盘及一致；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指令状态机(&lt;code>State&lt;/code>): 主要作用是根据日志执行指令；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>由于复制状态机的Raft协议可以保证日志序列的唯一性，所以由日志驱动的不同副本的指令状态机将拥有相同的输入指令序列，在初始状态相同的情况下，指令状态机将会得到相同的输出，以此就保证了各个副本外部最终状态的一致性；&lt;/p>
&lt;ul>
&lt;li>
&lt;p>复制状态机是raft协议的核心；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指令状态机由raft日志驱动来改变外界状态，是raft协议和外界交互的接口；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="evenloop">EvenLoop&lt;/h2>
&lt;p>&lt;code>Raft&lt;/code> 的主驱动是&lt;code>EvenLoop&lt;/code>。节点启动时，会开启一个&lt;code>evenloop&lt;/code>后台异步任务，持续监听&lt;code>tick&lt;/code>, &lt;code>tcp_in_tx&lt;/code>, &lt;code>client_rx&lt;/code>, &lt;code>node_rx&lt;/code>这4个事件源上的消息&lt;code>Msg&lt;/code>，以此来驱动整个状态机的运行：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>tick&lt;/code>事件由定时器产生，转入相应rolenode的&lt;code>tick&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>tcp_in_tx&lt;/code>事件由其他节点peer产生，交由&lt;code>raft&lt;/code> 状态机&lt;code>step&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>node_rx&lt;/code>事件由节点内部产生，需根据事件消息的接收对象(&lt;code>to&lt;/code>)分别处理；&lt;/p>
&lt;ul>
&lt;li>发往副本（&lt;code>to&lt;/code>为&lt;code>Address::Peer&lt;/code>, &lt;code>Address::Peers&lt;/code>）的消息，放入&lt;code>tcp_tx&lt;/code>交由&lt;code>TcpSender&lt;/code>进行发送；&lt;/li>
&lt;li>发往&lt;code>Client&lt;/code>（&lt;code>Address::Client&lt;/code>） 且事件类型为&lt;code>Event::ClientResponse&lt;/code>的消息, 根据&lt;code>id&lt;/code>从&lt;code>requests&lt;/code>表中找到该消息响应rx&lt;code>response_tx&lt;/code>，通过&lt;code>response_tx&lt;/code>将消息响应回复给&lt;code>Client&lt;/code>;&lt;/li>
&lt;li>其他消息为非法消息, 报错并退出；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>client_rx&lt;/code>事件由客户端产生，处理如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>先为事件生成uuid作为唯一id；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以id为key, 将消息响应rx&lt;code>request_rx&lt;/code>放入&lt;code>requests&lt;/code> 哈希表中，该表用于后续消息响应时处理消息返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>生成一个&lt;code>ClientRequest&lt;/code>类型的消息 ，交由&lt;code>Rolenode&lt;/code>的&lt;code>step&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Evenloop&lt;/code>接收到消息后，通过&lt;code>tick()&lt;/code>, &lt;code>step()&lt;/code>来驱动复制状态机执行日志复制操作。&lt;/p>
&lt;p>各节点收到&lt;code>ClientRequest&lt;/code>后处理流程&lt;code>Step()&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>将&lt;code>ClientRequest&lt;/code>消息放入&lt;code>queued_reqs&lt;/code>队列中进行缓存，等待变为&lt;code>Leader&lt;/code>后，再依次处理；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果没有&lt;code>Leader&lt;/code>， 则也将消息放入&lt;code>queued_reqs&lt;/code>中缓存；// queud_reqs 后续处理?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果有&lt;code>Leader&lt;/code>, 则将消息(id, from)放入&lt;code>proxied_reqs&lt;/code>中记录下来，然后转发到&lt;code>Leader&lt;/code>，由&lt;code>Leader&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Leader&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Request::Query&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过&lt;code>state_tx&lt;/code>，向状态机发送&lt;code>Instruction::Query&lt;/code>指令，状态机将指令插入到&lt;code>queries&lt;/code>中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>state_tx&lt;/code>, 向状态机发送&lt;code>Instruction::Vote&lt;/code>指令, 统计；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若存在副本，则向副本发送&lt;code>Event::Heartbeat&lt;/code>消息，和&lt;code>Follower&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Request::Mutate&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将消息记录到本地log中;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制log到各个Follower；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接收到多数&lt;code>Follower&lt;/code>的确认消息后，commit消息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>给状态机发送&lt;code>Instruction::Notify&lt;/code>指令；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>peers&lt;/code>为空，提交；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Request::Status&lt;/code>消息：&lt;/p>
&lt;ul>
&lt;li>根据当前节点状态，生成&lt;code>Instruction::Status&lt;/code>，通过&lt;code>state_tx&lt;/code>交由状态机执行；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="指令状态机">指令状态机&lt;/h3>
&lt;p>指令状态机由&lt;code>Driver::drive()&lt;/code>驱动。每个Raft Node新建时，会开启一个driver后台任务，该任务从&lt;code>state_rx&lt;/code>接收指令，交由&lt;code>execute&lt;/code>处理，各指令处理流程如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Instruction::Abort&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Apply&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Notify&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果指令&lt;code>index&lt;/code>大于状态机已经&lt;code>applied_index&lt;/code>, 将(index, (address, id))插入到状态机&lt;code>notify&lt;/code>哈希表中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>否则指令已被应用过，通过&lt;code>node_tx&lt;/code>给Raft Node 发送&lt;code>ClientResponse&lt;/code>消息，由Raft Node将错误消息返回给客户端；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Query&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Status&lt;/code>:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Instruction::Vote&lt;/code>:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="源码">源码&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Log&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Log&lt;/code>(日志)是Raft状态机&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="sd">/// The replicated Raft log
&lt;/span>&lt;span class="sd">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">store&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">dyn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">log&lt;/span>::&lt;span class="n">Store&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commit_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">super&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commit_term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Driver&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//状态机接口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">trait&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">State&lt;/span>: &lt;span class="nb">Send&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">applied_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">u64&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">mutate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//修改状态机状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">Result&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//查询状态机
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//状态机驱动
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Driver&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">state_rx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedReceiver&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Instruction&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//状态机指令输入口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//raft协议消息输出口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">applied_index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">notify&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//通知客户端更改被采用
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queries&lt;/span>: &lt;span class="nc">BTreeMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BTreeMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//等待处理的客户端查询指令，
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 状态机指令
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">enum&lt;/span> &lt;span class="nc">Instruction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Abort&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//取消
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Apply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">entry&lt;/span>: &lt;span class="nc">Entry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//应用
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Notify&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span> &lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//通知
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">command&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">quorum&lt;/span>: &lt;span class="kt">u64&lt;/span> &lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//查询
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Status&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">status&lt;/span>: &lt;span class="nb">Box&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Status&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//状态机状态
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Vote&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">address&lt;/span>: &lt;span class="nc">Address&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//投票
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="raft角色">Raft角色&lt;/h3>
&lt;h4 id="leader">Leader&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// 节点共有属性
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">RoleNode&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//节点id
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peers&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">term&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">log&lt;/span>: &lt;span class="nc">Log&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pre_vote&lt;/span>: &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">node_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//和node之间发送Msg通道
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">state_tx&lt;/span>: &lt;span class="nc">mpsc&lt;/span>::&lt;span class="n">UnboundedSender&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Instruction&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//节点往状态机驱动发送状态机指令通道
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queued_reqs&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Event&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">proxied_reqs&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">u8&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Address&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">role&lt;/span>: &lt;span class="nc">R&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// leader专有属性字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Leader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">heartbeat_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//心跳计数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peer_next_index&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//复制到副本的下一个index
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">peer_last_index&lt;/span>: &lt;span class="nc">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">u64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//已知复制到副本的最后index
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// follower专有字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Follower&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader&lt;/span>: &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader_seen_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leader_seen_timeout&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">voted_for&lt;/span>: &lt;span class="nb">Option&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// candidate专有字段
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Candidate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">election_ticks&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">election_timeout&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">votes&lt;/span>: &lt;span class="kt">u64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://github.com/erikgrinaker/toydb">GitHub - erikgrinaker/toydb: Distributed SQL database in Rust, written as a learning project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/erikgrinaker/toydb/blob/master/docs/architecture.md">toydb/architecture.md at master · erikgrinaker/toydb · GitHub&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>AF_XDP</title><link>https://justice.bj.cn/post/21.linux/af_xdp/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/af_xdp/</guid><description>&lt;h1 id="af_xdp">AF_XDP&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>&lt;strong>AF_XDP&lt;/strong>是一种用于高性能包处理的地址簇(Address Family)。&lt;/p>
&lt;p>使用XDP程序中的&lt;strong>XDP_REDIRECT&lt;/strong>操作，可以使用&lt;code>bpf_redirect_map（）&lt;/code>函数将入口帧重定向到其他启用XDP的网络设备。 AF_XDP套接字使XDP程序可以将帧重定向到用户空间应用程序中的内存缓冲区。&lt;/p>
&lt;p>可以通过&lt;code>socket()&lt;/code>系统调用创建AF_XDP socket (XSK)。每个XSK涉及两个ring：RX ring和TX ring。一个socket可以从RX ring上接收报文，并发送到TX ring。这两个rings分别通过socket选项&lt;code>XDP_RX_RING&lt;/code> 和&lt;code>XDP_TX_RING&lt;/code>进行注册。每个socket必须至少具有其中一个ring。RX或TX ring描述符指向内存域中的data buffer，称为UMEM。RX和TX可以共享相同的UMEM，这样一个报文无需在RX和TX之间进行拷贝。此外，如果一个报文由于重传需要保留一段时间，则指向该报文的描述符可以指向另外一个报文，这样就避免了数据的拷贝。基本流程&lt;a href="https://www.dpdk.org/wp-content/uploads/sites/35/2018/10/pm-06-DPDK-PMD-for-AF_XDP.pdf">如下&lt;/a>：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-39-2020-09-30-17-18-13-image.png" alt="">&lt;/p>
&lt;p>UMEM包含一系列大小相同的chunks，ring中的描述符通过引用帧的地址来引用该帧，该地址为整个UMEM域的偏移量。用户空间会使用合适的方式(malloc，mmap，大页内存等)为UMEM分配内存，然后使用使用新的socket选项&lt;code>XDP_UMEM_REG&lt;/code>将内存域注册到内核中。UMEM也包含两个ring：FILL ring和COMPLETION ring。应用会使用FILL ring下发addr，让内核填写RX包数据。一旦接收到报文，RX ring会引用这些帧。COMPLETION ring包含内核传输完的帧地址，且可以被用户空间使用，用于TX或RX。因此COMPLETION ring中的帧地址为先前使用TX ring传输的地址。总之，RX和FILL ring用于RX路径，TX和COMPLETION ring用于TX路径。&lt;/p>
&lt;p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。&lt;/p>
&lt;p>最后会使用bind()调用将socket绑定到一个设备以及该设备指定的队列id上，绑定没有完成前无法传输流量。&lt;/p>
&lt;p>可以在多个进程间共享UMEM 。如果一个进程需要更新UMEM，则会跳过注册UMEM和其对应的两个ring的过程。在bind调用中设置&lt;code>XDP_SHARED_UMEM&lt;/code> 标志，并提交该进程期望共享UMEM的XSK，以及新创建的XSK socket。新进程会在其共享UMEM的RX ring中接收到帧地址引用。注意，由于ring的结构是单生产者/单消费者的，新的进程的socket必须创建独立的RX和TX ring。同样的原因，每个UMEM也只能有一个FILL和COMPLETION ring。每个进程都需要正确地处理好UMEM。&lt;/p>
&lt;p>那么报文是怎么从XDP程序分发到XSKs的呢？通过名为&lt;code>XSKMAP&lt;/code>(完整名为BPF_MAP_TYPE_XSKMAP`) BPF map。用户空间的应用可以将一个XSK放到该map的任意位置，然后XDP程序就可以将一个报文重定向到该map中指定的索引中，此时XDP会校验map中的XSK确实绑定到该设备和ring号。如果没有，则会丢弃该报文。如果map中的索引为空，也会丢弃该报文。因此，当前的实现中强制要求必须加载一个XDP程序(以及保证XSKMAP存在一个XSK)，这样才能通过XSK将流量传送到用户空间。&lt;/p>
&lt;p>AF_XDP可以运行在两种模式上：&lt;code>XDP_SKB&lt;/code>和&lt;code>XDP_DRV&lt;/code>。如果驱动不支持XDP，则在加载XDP程序是需要明确指定使用XDP_SKB，&lt;code>XDP_SKB&lt;/code>模式使用SKB和通用的XDP功能，并将数据复制到用户空间，是一种适用于任何网络设备的回退模式。 如果驱动支持XDP，将使用AF_XDP代码提供更好的性能，但仍然会将数据拷贝到用户空间的操作。&lt;/p>
&lt;h5 id="术语">术语&lt;/h5>
&lt;h6 id="umem-umem是一个虚拟的连续内存域分割为相同大小的帧">UMEM: UMEM是一个虚拟的连续内存域，分割为相同大小的帧。&lt;/h6>
&lt;p>一个UMEM会关联一个netdev以及该netdev的队列id。通过&lt;code>XDP_UMEM_REG&lt;/code> socket选项进行创建和配置(chunk大小，headroom，开始地址和大小)。通过&lt;code>bind()&lt;/code>系统调用将一个UMEM绑定到一个netdev和队列id。umem的基本结构如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-11-49-1334952-20200807102005413-1869804955.png" alt="">&lt;/p>
&lt;p>一个AF_XDP为一个链接到一个独立的UMEM的socket，但一个UMEM可以有多个AF_XDP socket。为了共享一个通过socket A创建的UMEM，socket B可以将结构体&lt;code>sockaddr_xdp&lt;/code>中的成员sxdp_flags设置为&lt;code>XDP_SHARED_UMEM&lt;/code>，并将A的文件描述符传递给结构体&lt;code>sockaddr_xdp&lt;/code>的成员&lt;code>sxdp_shared_umem_fd&lt;/code>。&lt;/p>
&lt;p>UMEM有两个单生产者/单消费者ring，用于在内核和用户空间应用程序之间转移UMEM帧。&lt;/p>
&lt;h6 id="rings">Rings&lt;/h6>
&lt;p>有4类不同类型的ring：FILL, COMPLETION, RX 和TX，所有的ring都是单生产者/单消费者，因此用户空间的程序需要显示地同步对这些rings进行读/写的多进程/线程。&lt;/p>
&lt;p>UMEM使用2个ring：FILL和COMPLETION。每个关联到UMEM的socket必须有1个RX队列，1个TX队列或同时拥有2个队列。如果配置了4个socket(同时使用TX和RX)，那么此时会有1个FILL ring，1个COMPLETION ring，4个TX ring和4个RX ring。&lt;/p>
&lt;p>ring是基于首(生产者)尾(消费者)的结构。一个生产者会在结构体xdp_ring的producer成员指出的ring索引处写入数据，并增加生产者索引；一个消费者会结构体xdp_ring的consumer成员指出的ring索引处读取数据，并增加消费者索引。&lt;/p>
&lt;p>可以通过_RING setsockopt系统调用配置和创建ring，使用mmap()，并结合合适的偏移量，将其映射到用户空间&lt;/p>
&lt;p>ring的大小需要是2次幂。&lt;/p>
&lt;h6 id="umem-fill-ring">UMEM Fill Ring&lt;/h6>
&lt;p>FILL ring用于将UMEM帧从用户空间传递到内核空间，同时将UMEM地址传递给ring。例如，如果UMEM的大小为64k，且每个chunk的大小为4k，那么UMEM包含16个chunk，可以传递的地址为0到64k。&lt;/p>
&lt;p>传递给内核的帧用于ingress路径(RX rings)。&lt;/p>
&lt;p>用户应用也会在该ring中生成UMEM地址。注意，如果以对齐的chunk模式运行应用，则内核会屏蔽传入的地址。即，如果一个chunk大小为2k，则会屏蔽掉log2(2048) LSB的地址，意味着2048, 2050 和3000都将引用相同的chunk。如果用户应用使用非对其的chunk模式运行，那么传入的地址将保持不变。&lt;/p>
&lt;h6 id="umem-completion-ring">UMEM Completion Ring&lt;/h6>
&lt;p>COMPLETION Ring用于将UMEM帧从内核空间传递到用户空间，与FILL ring相同，使用了UMEM索引。&lt;/p>
&lt;p>已经发送的从内核空间传递到用户空间的帧还可以被用户空间使用。&lt;/p>
&lt;p>用户应用会消费该ring种的UMEM地址。&lt;/p>
&lt;h6 id="rx-ring">RX Ring&lt;/h6>
&lt;p>RX ring位于socket的接收侧，ring中的每个表项都是一个&lt;code>xdp_desc&lt;/code> 结构的描述符。该描述符包含UMEM偏移量(地址)以及数据的长度。&lt;/p>
&lt;p>如果没有帧从FILL ring传递给内核，则RX ring中不会出现任何描述符。&lt;/p>
&lt;p>用户程序会消费该ring中的&lt;code>xdp_desc&lt;/code>描述符。&lt;/p>
&lt;h6 id="tx-ring">TX Ring&lt;/h6>
&lt;p>TX Ring用于发送帧。在填充&lt;code>xdp_desc&lt;/code>(索引，长度和偏移量)描述符后传递给该ring。&lt;/p>
&lt;p>如果要启动数据传输，则必须调用&lt;code>sendmsg()&lt;/code>，未来可能会放宽这种限制。&lt;/p>
&lt;p>用户程序会给TX ring生成&lt;code>xdp_desc&lt;/code> 描述符。&lt;/p>
&lt;h5 id="xskmap--bpf_map_type_xskmap">XSKMAP / BPF_MAP_TYPE_XSKMAP&lt;/h5>
&lt;p>在XDP侧会用到类型为&lt;code>BPF_MAP_TYPE_XSKMAP&lt;/code> 的BPF map，并结合&lt;code>bpf_redirect_map()&lt;/code>将ingress帧传递给socket。&lt;/p>
&lt;p>用户应用会通过&lt;code>bpf()&lt;/code>系统调用将socket插入该map。&lt;/p>
&lt;p>注意，如果一个XDP程序尝试将帧重定向到一个与队列配置和netdev不匹配的socket时，会丢弃该帧。即，如果一个AF_XDP socket绑定到一个名为eth0，队列为17的netdev上时，只有当XDP程序指定到eth0且队列为17时，才会将数据传递给该socket。参见&lt;code>samples/bpf/&lt;/code>获取例子&lt;/p>
&lt;h5 id="配置标志位和socket选项">配置标志位和socket选项&lt;/h5>
&lt;h6 id="xdp_copy-和xdp_zero_copy-bind标志">XDP_COPY 和XDP_ZERO_COPY bind标志&lt;/h6>
&lt;p>当绑定到一个socket时，内核会首先尝试使用零拷贝进行拷贝。如果不支持零拷贝，则会回退为使用拷贝模式。即，将所有的报文拷贝到用户空间。但如果想强制指定一种特定的模式，则可以使用如下标志：如果给bind调用传递了&lt;code>XDP_COPY&lt;/code>，则内核将强制进入拷贝模式；如果没有使用拷贝模式，则bind调用会失败，并返回错误。相反地，&lt;code>XDP_ZERO_COPY&lt;/code> 将强制socket使用零拷贝或调用失败。&lt;/p>
&lt;h6 id="xdp_shared_umem-bind-标志">XDP_SHARED_UMEM bind 标志&lt;/h6>
&lt;p>该表示可以使多个socket绑定到系统的UMEM，但仅能使用系统的队列id。这种模式下，每个socket都有其各自的RX和TX ring，但UMEM只能有一个FILL ring和一个COMPLETION ring。为了使用这种模式，需要创建第一个socket，并使用正常模式进行绑定。然后创建第二个socket，含一个RX和一个TX(或二者之一)，但不会创建FILL 或COMPLETION ring(与第一个socket共享)。在bind调用中，设置&lt;code>XDP_SHARED_UMEM&lt;/code>选项，并在sxdp_shared_umem_fd中提供初始socket的fd。以此类推。&lt;/p>
&lt;p>那么当接收到一个报文后，应该上送到那个socket呢？答案是由XDP程序来决定。将所有的socket放到XDP_MAP中，然后将报文发送给数组中索引对应的socket。下面展示了一个简单的以轮询方式分发报文的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/bpf.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;bpf_helpers.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#define MAX_SOCKS 16
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BPF_MAP_TYPE_XSKMAP&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">max_entries&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MAX_SOCKS&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">__uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">xsks_map&lt;/span> &lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;.maps&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">rr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;xdp_sock&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">xdp_sock_prog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">xdp_md&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">rr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">MAX_SOCKS&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">bpf_redirect_map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">xsks_map&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">XDP_DROP&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，由于只有一个FILL和一个COMPLETION ring，且是单生产者单消费者的ring，需要确保多处理器或多线程不会同时使用这些ring。libbpf没有提供原子同步功能。&lt;/p>
&lt;p>当多个socket绑定到相同的umem时，libbpf会使用这种模式。然而，需要注意的是，需要在&lt;code>xsk_socket__create&lt;/code>调用中提供&lt;code>XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD&lt;/code> libbpf_flag，然后将其加载到自己的XDP程序中(因为libbpf没有内置路由流量功能)。&lt;/p>
&lt;h6 id="xdp_use_need_wakeup-bind标志">XDP_USE_NEED_WAKEUP bind标志&lt;/h6>
&lt;p>该选择支持在FILL ring和TX ring中设置一个名为&lt;code>need_wakeup&lt;/code>的标志，用户空间作为这些ring的生产者。当在bind调用中设置了该选项，如果需要明确地通过系统调用唤醒内核来继续处理报文时，会设置&lt;code>need_wakeup&lt;/code> 标志。&lt;/p>
&lt;p>如果将该标志设置给FILL ring，则应用需要调用&lt;code>poll()&lt;/code>，以便在RX ring上继续接收报文。如，当内核检测到FILL ring中没有足够的buff，且NIC的RX HW RING中也没有足够的buffer时会发生这种情况。此时会关中断，这样NIC就无法接收到任何报文(由于没有足够的buffer)，由于设置了need_wakeup，这样用户空间就可以在FILL ring上增加buffer，然后调用&lt;code>poll()&lt;/code>，这样内核驱动就可以将这些buffer添加到HW ring上继续接收报文。&lt;/p>
&lt;p>如果将该标志设置给TX ring，意味着应用需要明确地通知内核发送位于TX ring上的报文。可以通过调用&lt;code>poll()&lt;/code>，或调用&lt;code>sendto()&lt;/code>完成。&lt;/p>
&lt;p>可以在&lt;em>samples/bpf/xdpsock_user.c&lt;/em>中找到例子。在TX路径上使用libbpf辅助函数的例子如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">xsk_ring_prod__needs_wakeup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">my_tx_ring&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">sendto&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xsk_socket__fd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xsk_handle&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MSG_DONTWAIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>建议启用该模式，由于减少了TX路径上的系统调用的数目，因此可以在应用和驱动运行在同一个(或不同)core的情况下提升性能。&lt;/p>
&lt;h6 id="xdp_rxtxumem_fillumem_completion_ring-setsockopts">XDP_{RX|TX|UMEM_FILL|UMEM_COMPLETION}_RING setsockopts&lt;/h6>
&lt;p>这些socket选项分别设置RX, TX, FILL和COMPLETION ring的描述符数量(必须至少设置RX或TX ring的描述符大小)。如果同时设置了RX和TX，就可以同时接收和发送来自应用的流量；如果仅设置了其中一个，就可以节省相应的资源。如果需要将一个UMEM绑定到socket，需要同时设置FILL ring和COMPLETION ring。如果使用了&lt;code>XDP_SHARED_UMEM&lt;/code>标志，无需为除第一个socket之外的socket创建单独的UMEM，所有的socket将使用共享的UMEM。注意ring为单生产者单消费者结构，因此多进程无法同时访问同一个ring。参见&lt;code>XDP_SHARED_UMEM&lt;/code>章节。&lt;/p>
&lt;p>使用libbpf时，可以通过给&lt;code>xsk_socket__create&lt;/code>函数的rx和tx参数设置NULL来创建Rx-only和Tx-only的socket。&lt;/p>
&lt;p>如果创建了一个Tx-only的socket，建议不要在FILL ring中放入任何报文，否则，驱动可能会认为需要接收数据(但实际上并不是这样的)，进而影响性能。&lt;/p>
&lt;h6 id="xdp_umem_reg-setsockopt">XDP_UMEM_REG setsockopt&lt;/h6>
&lt;p>该socket选项会给一个socket注册一个UMEM，其对应的区域包含了可以容纳报文的buffer。该调用会使用一个指向该区域开始处的指针，以及该区域的大小。此外，还有一个UMEM可以切分的chunk大小参数(目前仅支持2K或4K)。如果一个UMEM区域的大小为128K，且chunk大小为2K，意味着该UMEM域最大可以有128K / 2K = 64个报文，且最大的报文大小为2K。&lt;/p>
&lt;p>还有一个选项可以在UMEM中设置每个buffer的headroom。如果设置为N字节，意味着报文会从buffer的第N个字节开始，为应用保留前N个字节。最后一个选项为标志位字段，会在每个UMEM标志中单独处理。&lt;/p>
&lt;h6 id="xdp_statistics-getsockopt">XDP_STATISTICS getsockopt&lt;/h6>
&lt;p>获取一个socket丢弃信息，用于调试。支持的信息为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">xdp_statistics&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">rx_dropped&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped for reasons other than invalid desc */&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">rx_invalid_descs&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped due to invalid descriptor */&lt;/span>
&lt;span class="n">__u64&lt;/span> &lt;span class="n">tx_invalid_descs&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Dropped due to invalid descriptor */&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h6 id="xdp_options-getsockopt">XDP_OPTIONS getsockopt&lt;/h6>
&lt;p>获取一个XDP socket的选项。目前仅支持&lt;code>XDP_OPTIONS_ZEROCOPY&lt;/code>，用于检查是否使用了零拷贝。&lt;/p>
&lt;blockquote>
&lt;p>从AF_XDP的特性上可以看到其&lt;a href="https://pantheon.tech/what-is-af_xdp/">局限性&lt;/a>：不能使用XDP将不同的流量重定向的多个AF_XDP socket上，原因是每个AF_XDP socket必须绑定到物理接口的TX队列上。大多数的物理和仿真HW的每个接口仅支持一个RX/TX队列，因此当该接口上绑定了一个AF_XDP后，后续的绑定操作都将失败。仅有少数HW支持多RX/TX队列，且通常仅有2/4/8个队列，无法扩展给cloud中的上百个容器使用。&lt;/p>
&lt;/blockquote>
&lt;p>更多细节参见AF_XDP&lt;a href="https://www.kernel.org/doc/html/latest/networking/af_xdp.html">官方文档&lt;/a>以及这篇&lt;a href="http://vger.kernel.org/lpc_net2018_talks/lpc18_paper_af_xdp_perf-v2.pdf">论文&lt;/a>。&lt;/p>
&lt;h2 id="tchttpsdocsciliumioenlatestbpftc-traffic-control">&lt;a href="https://docs.cilium.io/en/latest/bpf/#tc-traffic-control">TC&lt;/a>&lt;/h2>
&lt;p>除了XDP，BPF还可以在网络数据路径的内核tc(traffic control)层之外使用。上文已经给出了XDP和TC的区别。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>ingress&lt;/code> hook：&lt;code>__netif_receive_skb_core() -&amp;gt; sch_handle_ingress()&lt;/code>&lt;/li>
&lt;li>&lt;code>egress&lt;/code> hook：&lt;code>__dev_queue_xmit() -&amp;gt; sch_handle_egress()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-12-21-1334952-20200809204246404-1470995812.png" alt="">&lt;/p>
&lt;/blockquote>
&lt;p>运行在tc层的BPF程序使用的是 &lt;code>cls_bpf&lt;/code> (cls即Classifiers的简称)分类器。在tc中，将BPF的附着点描述为一个&amp;quot;分类器&amp;quot;，这个词有点误导，因此它少描述了&lt;code>cls_bpf&lt;/code>的所支持的功能。即一个完整的可编程的报文处理器不仅可以读取&lt;code>skb&lt;/code>的元数据和报文数据，还可以对其进行任意修改，最后终止tc的处理，并返回裁定的action(见下)。&lt;code>cls_bpf&lt;/code>可以认为是一个自包含的，可以管理和执行tc BPF程序的实体。&lt;/p>
&lt;p>&lt;code>cls_bpf&lt;/code>可以包含一个或多个tc BPF程序。通常，在传统的tc方案中，分类器和action模块是分开的，每个分类器可以附加一个或多个action，一旦匹配到分类器时就会执行action。但在现代软件数据路径中使用这种模式的tc处理复杂的报文时会遇到扩展性问题。由于附加到cls_bpf的tc BPF程序是完全自包含的，因此可以有效地将解析和操作过程融合到一个单元中。幸好有了&lt;code>cls_bpf&lt;/code>的&lt;code>direct-action&lt;/code>模式，该模式下，仅需要返回tc action裁定结果并立即结束处理流即可，可以在网络数据流中实现可扩展的可编程报文处理流程，同时避免了action的线性迭代。&lt;code>cls_bpf&lt;/code>是tc层中唯一能够实现这种快速路径的“分类器”模块。&lt;/p>
&lt;p>与XDP BPF程序类似，tc BPF程序可以在运行时通过cls_bpf自动更新，而不会中断任何网络流或重启服务。&lt;/p>
&lt;p>&lt;code>cls_bpf&lt;/code>可以附加的tc ingress和egree钩子都通过一个名为&lt;code>sch_clsact&lt;/code>的伪qdisc进行管理。由于该伪qdisc可以同时管理ingress和egress的tc钩子，因此它是ingress qdisc的超集(也可直接替换)。对于&lt;code>__dev_queue_xmit()&lt;/code>中的tc的egress钩子，需要注意的是，它不是在内核的qdisc root锁下运行的。因此，tc ingress和egress钩子都以无锁的方式运行在快速路径中，且这两个钩子都禁用了抢占，并运行在RCU读取侧。&lt;/p>
&lt;p>通常在egress上会存在附着到网络设备上的qdisc，如&lt;code>sch_mq&lt;/code>，&lt;code>sch_fq&lt;/code>，&lt;code>sch_fq_codel&lt;/code>或&lt;code>sch_htb&lt;/code>，其中有些是可分类的qdisc(包含子类)，因此会要求一个报文分类机制来决定在哪里解复用数据包。该过程通过调用&lt;code>tcf_classify()&lt;/code>进行处理，进而调用tc分类器(如果存在)。&lt;code>cls_bpf&lt;/code>也可以附加并用于如下场景：一些在qdisc root锁下的操作可能会收到锁竞争的影响。&lt;code>sch_clsact&lt;/code> qdisc的egress钩子出现在更早的时间点，但它不属于这个锁的范围，因此作完全独立于常规的egress qdiscs。因此，对于&lt;code>sch_htb&lt;/code>这样的情况，&lt;code>sch_clsact&lt;/code> qdisc可以通过qdisc root锁之外的tc BPF执行繁重的包分类工作，通过在这些 tc BPF 程序中设置 &lt;code>skb-&amp;gt;mark&lt;/code> 或 &lt;code>skb-&amp;gt;priority&lt;/code> ，这样 &lt;code>sch_htb&lt;/code> 只需要一个简单的映射即可，不需要在root锁下执行代价高昂的报文分类工作，通过这种方式可以减少锁竞争。&lt;/p>
&lt;p>在sch_clsact结合cls_bpf的场景下支持offloaded tc BPF程序，这种情况下，先前加载的BPF程序是从SmartNIC驱动程序jit生成的，以便在NIC上以本机方式运行。只有在&lt;code>direct-action&lt;/code>模式下运行的&lt;code>cls_bpf&lt;/code>程序才支持offloaded。&lt;code>cls_bpf&lt;/code>仅支持offload一个单独的程序(无法offload多个程序)，且只有ingress支持offload BPF程序。&lt;/p>
&lt;p>一个&lt;code>cls_bpf&lt;/code>实例可以包含多个tc BPF程序，如果是这种情况，那么&lt;code>TC_ACT_UNSPEC&lt;/code>程序返回码可以继续执行列表中的下一个tc BPF程序。然而，这样做的缺点是，多个程序需要多次解析相同的报文，导致性能下降。&lt;/p>
&lt;h3 id="返回码">返回码&lt;/h3>
&lt;p>tc的ingress和egress钩子共享相同的action来返回tc BPF程序使用的裁定结果，定义在 &lt;code>linux/pkt_cls.h&lt;/code>系统头文件中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define TC_ACT_UNSPEC (-1)
&lt;/span>&lt;span class="cp">#define TC_ACT_OK 0
&lt;/span>&lt;span class="cp">#define TC_ACT_SHOT 2
&lt;/span>&lt;span class="cp">#define TC_ACT_STOLEN 4
&lt;/span>&lt;span class="cp">#define TC_ACT_REDIRECT 7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>系统头文件中还有一些以&lt;code>TC_ACT_*&lt;/code>开头的action变量，可以被两个钩子使用。但它们与上面的语义相同。即，从tc BPF的角度来看&lt;code>TC_ACT_OK&lt;/code>和&lt;code>TC_ACT_RECLASSIFY&lt;/code>的语义相同，三个&lt;code>TC_ACT_stelled&lt;/code>、&lt;code>TC_ACT_QUEUED&lt;/code>和&lt;code>TC_ACT_TRAP&lt;/code>操作码的语义也是相同的。因此，对于这些情况，我们只描述 &lt;code>TC_ACT_OK&lt;/code> 和 &lt;code>TC_ACT_STOLEN&lt;/code> 操作码。&lt;/p>
&lt;p>从&lt;code>TC_ACT_UNSPEC&lt;/code>开始，表示&amp;quot;未指定的action&amp;quot;，用于以下三种场景：i)当一个offloaded tc程序的tc ingress钩子运行在&lt;code>cls_bpf&lt;/code>的位置，则该offloaded程序将返回&lt;code>TC_ACT_UNSPEC&lt;/code>；ii)为了在多程序场景下继续执行&lt;code>cls_bpf&lt;/code>中的下一个BPF程序，后续的程序需要与步骤i中的offloaded tc BPF程序配合使用，但出现了一个非offloaded场景下运行的tc BPF程序；iii)&lt;code>TC_ACT_UNSPEC&lt;/code>还可以用于单个程序场景，用于告诉内核继续使用skb，不会产生其他副作用。&lt;code>TC_ACT_UNSPEC&lt;/code>与&lt;code>TC_ACT_OK&lt;/code>类似，两者都会将skb通过ingress向上传递到网络栈的上层，或者通过egress向下传递到网络设备驱动程序，以便在egress进行传输。与&lt;code>TC_ACT_OK&lt;/code>的唯一不同之处是，&lt;code>TC_ACT_OK&lt;/code>基于tc BPF程序设定的classid来设置&lt;code>skb-&amp;gt;tc_index&lt;/code>，而 &lt;code>TC_ACT_UNSPEC&lt;/code> 是通过 tc BPF 程序之外的 BPF上下文中的 &lt;code>skb-&amp;gt;tc_classid&lt;/code> 进行设置。&lt;/p>
&lt;p>&lt;code>TC_ACT_SHOT&lt;/code>通知内核丢弃报文，即网络栈上层将不会在ingress的skb中看到该报文，类似地，这类报文也不会在egress中发送。&lt;code>TC_ACT_SHOT&lt;/code>和&lt;code>TC_ACT_STOLEN&lt;/code>本质上是相似的，仅存在部分差异：&lt;code>TC_ACT_SHOT&lt;/code>会通知内核已经通过&lt;code>kfree_skb()&lt;/code>释放skb，且会立即给调用者返回&lt;code>NET_XMIT_DROP&lt;/code>；而TC_ACT_STOLEN会通过&lt;code>consume_skb()&lt;/code>释放skb,并给上层返回&lt;code>NET_XMIT_SUCCESS&lt;/code>，假装传输成功。perf的报文丢弃监控会记录&lt;code>kfree_skb()&lt;/code>的操作，因此不会记录任何因为&lt;code>TC_ACT_STOLEN&lt;/code>丢弃的报文，因为从语义上说，这些 &lt;code>skb&lt;/code> 是被消费或排队的而不是被丢弃的。&lt;/p>
&lt;p>最后&lt;code>TC_ACT_REDIRECT&lt;/code> action允许tc BPF程序通过&lt;code>bpf_redirect()&lt;/code>辅助函数将skb重定向到相同或不同的设备ingress或egress路径上。通过将报文导入其他设备的ingress或egress方向，可以最大化地实现BPF的报文转发功能。使用该方式不需要对目标网络设备做任何更改，也不需要在目标设备上运行另外一个&lt;code>cls_bpf&lt;/code>实例。&lt;/p>
&lt;h3 id="加载tc-bpf程序">加载tc BPF程序&lt;/h3>
&lt;p>假设有一个名为&lt;code>prog.o&lt;/code>的tc BPF程序，可以通过tc命令将该程序加载到网络设备山。与XDP不同，它不需要依赖驱动将BPF程序附加到设备上，下面会用到一个名为&lt;code>em1&lt;/code>的网络设备，并将程序附加到&lt;code>em1&lt;/code>的&lt;code>ingress&lt;/code>报文路径上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter add dev em1 ingress bpf da obj prog.o&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一步首先配置一个&lt;code>clsact&lt;/code> qdisc。如上文所述，clsact是一个伪造的qdisc，与&lt;code>ingress&lt;/code> qdisc类似，仅包含分类器和action，但不会提供实际的队列功能，它是附加bpf分类器所必需的。&lt;code>clsact&lt;/code> 提供了两个特殊的钩子，称为&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>，分类器可以附加到这两个钩子上。&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>钩子都位于网络数据路径的中央接收和发送位置，每个经过设备的报文都会经过此处。&lt;code>ingees&lt;/code>钩子通过内核的&lt;code>__netif_receive_skb_core() -&amp;gt; sch_handle_ingress()&lt;/code>进行调用，&lt;code>egress&lt;/code>钩子通过&lt;code>__dev_queue_xmit() -&amp;gt; sch_handle_egress()&lt;/code>进行调用。&lt;/p>
&lt;p>将程序附加到&lt;code>egress&lt;/code>钩子上的操作为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 egress bpf da obj prog.o&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>clsact&lt;/code> qdisc以无锁的方式处理来自&lt;code>ingress&lt;/code>和&lt;code>egress&lt;/code>方向的报文，且可以附加到一个无队列虚拟设备上，如连接到容器的&lt;code>veth&lt;/code>设备。&lt;/p>
&lt;p>在钩子之后，&lt;code>tc filter&lt;/code>命令选择使用&lt;code>bpf&lt;/code>的&lt;code>da&lt;/code>(direct-action)模式。推荐使用并指定da&lt;code>模式&lt;/code>，基本上意味着bpf分类器不再需要调用外部tc action模块，所有报文的修改，转发或其他action都可以通过附加的BPF程序来实现，因此处理速度更快。&lt;/p>
&lt;p>到此位置，已经附加bpf程序，一旦有报文传输到该设备后就会执行该程序。与XDP相同，如果不使用默认的section名称，则可以在加载期间进行指定，例如，下面指定的section名为&lt;code>foobar&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 egress bpf da obj prog.o sec foobar&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>iptables2的BPF加载器允许跨程序类型使用相同的命令行语法。&lt;/p>
&lt;p>附加的程序可以使用如下命令列出：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>ingress&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">1&lt;/span> tag c5f7825e5dac396f
&lt;span class="c1"># tc filter show dev em1 egress&lt;/span>
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf
filter protocol all pref &lt;span class="m">49152&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>egress&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">2&lt;/span> tag b2fd5adc0f262714
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>prog.o:[ingress]&lt;/code>的输出说明程序段&lt;code>ingress&lt;/code>通过文件&lt;code>prog.o&lt;/code>进行加载，且&lt;code>bpf&lt;/code>运行在&lt;code>direct-action&lt;/code>模式下。上面两种情况附加了程序&lt;code>id&lt;/code>和&lt;code>tag&lt;/code>，其中后者表示对指令流的hash，该hash可以与目标文件或带有堆栈跟踪的perf report等相关。最后，&lt;code>id&lt;/code>表示系统范围内的BPF程序的唯一标识符，可以使用&lt;code>bpftool&lt;/code>来查看或dump附加的BPF程序。&lt;/p>
&lt;p>tc可以附加多个BPF程序，它提供了其他可以链接在一起的分类器。但附加一个BPF程序已经可以完全满足需求，因为通过&lt;code>da&lt;/code>(&lt;code>direct-action&lt;/code>)模式可以在一个程序中实现所有的报文操作，意味着BPF程序将返回tc action裁定结果，如&lt;code>TC_ACT_OK&lt;/code>, &lt;code>TC_ACT_SHOT&lt;/code>等。为了获得最佳性能和灵活性，推荐使用这种方式。&lt;/p>
&lt;p>在上述&lt;code>show&lt;/code>命令中，在BPF的相关输出旁显示了&lt;code>pref 49152&lt;/code> 和&lt;code>handle 0x1&lt;/code>。如果没有通过命令行显式地提供，会自动生成的这两个输出。&lt;code>perf&lt;/code>表明了一个优先级数字，即当附加了多个分类器时，将会按照优先级上升的顺序执行这些分类器。&lt;code>handle&lt;/code>表示一个标识符，当一个&lt;code>perf&lt;/code>加载了系统分类器的多个实例时起作用。由于在BPF场景下，一个程序足矣，&lt;code>perf&lt;/code>和&lt;code>handle&lt;/code>通常可以忽略。&lt;/p>
&lt;p>只有在需要自动替换附加的BPF程序的情况下，才会推荐在初始化加载前指定&lt;code>pref&lt;/code>和&lt;code>handle&lt;/code>，这样在以后执行&lt;code>replace&lt;/code>操作时就不必在进行查询。创建方式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar&lt;/span>
&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">1&lt;/span> bpf
filter protocol all pref &lt;span class="m">1&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>foobar&lt;span class="o">]&lt;/span> direct-action id &lt;span class="m">1&lt;/span> tag c5f7825e5dac396f
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于原子替换，可以使用(来自文件&lt;code>prog.o&lt;/code>中的&lt;code>foobar&lt;/code> section的BPF程序)如下命令来更新现有的&lt;code>ingress&lt;/code>钩子上的程序&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，为了移除所有ingress和egress上附加的程序，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc filter del dev em1 ingress&lt;/span>
&lt;span class="c1"># tc filter del dev em1 egress&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了移除网络设备上的整个&lt;code>clsact&lt;/code> qdisc，即移除掉ingress和egress钩子上附加的所有程序，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc del dev em1 clsact&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果NIC和驱动也像XDP BPF程序一样支持offloaded，则tc BPF程序也可以是offloaded的。Netronome的nfp同时支持两种类型的BPF offload。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o&lt;/span>
Error: TC offload is disabled on net device.
We have an error talking to the kernel
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果出现了如上错误，则表示首先需要通过ethtool的&lt;code>hw-tc-offload&lt;/code>来启动tc硬件offload：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># ethtool -K em1 hw-tc-offload on&lt;/span>
&lt;span class="c1"># tc qdisc add dev em1 clsact&lt;/span>
&lt;span class="c1"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o&lt;/span>
&lt;span class="c1"># tc filter show dev em1 ingress&lt;/span>
filter protocol all pref &lt;span class="m">1&lt;/span> bpf
filter protocol all pref &lt;span class="m">1&lt;/span> bpf handle 0x1 prog.o:&lt;span class="o">[&lt;/span>classifier&lt;span class="o">]&lt;/span> direct-action skip_sw in_hw id &lt;span class="m">19&lt;/span> tag 57cd311f2e27366b
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>in_hw&lt;/code>标志表示程序已经offload到了NIC中。&lt;/p>
&lt;p>注意不能同时offload tc和XDP BPF，必须且只能选择其中之一。&lt;/p></description></item><item><title>eBPF简史(转)</title><link>https://justice.bj.cn/post/21.linux/ebpf%E7%AE%80%E5%8F%B2/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/ebpf%E7%AE%80%E5%8F%B2/</guid><description>&lt;h1 id="ebpf简史转">eBPF简史(转)&lt;/h1>
&lt;h2 id="源头一篇-1992-年的论文">源头：一篇 1992 年的论文&lt;/h2>
&lt;p>考虑到 BPF 的知名度，在介绍 eBPF 之前，笔者自觉还是有必要先来回答另一个问题：&lt;/p>
&lt;h2 id="什么是-bpf">什么是 BPF?&lt;/h2>
&lt;p>笔者在前文中说过了，BPF 的全称是 Berkeley Packet Filter，顾名思义，这是一个用于过滤(filter)网络报文(packet)的架构。&lt;/p>
&lt;p>其实 BPF 可谓是名气不大，作用不小的典范：如果笔者一开始提出 BPF 的同时还捎带上大名鼎鼎的 tcpdump 或 wireshark，估计绝大部分读者都会了然了：BPF 即为 tcpdump 抑或 wireshark 乃至网络监控(Network Monitoring)领域的基石。&lt;/p>
&lt;p>今天我们看到的 BPF 的设计，最早可以追溯到 1992 年刊行在 USENIX conference 上的一篇论文：The BSD Packet Filter: A New Architecture for User-level Packet Capture。由于最初版本的 BPF 是实现于 BSD 系统之上的，于是在论文中作者称之为&amp;quot;BSD Packet Filter&amp;quot;；后来由于 BPF 的理念渐成主流，为各大操作系统所接受，B 所代表的 BSD 便也渐渐淡去，最终演化成了今天我们眼中的 Berkeley Packet Filter。&lt;/p>
&lt;p>诚然，无论 BSD 和 Berkeley 如何变换，其后的 Packet Filter 总是不变的，这两个单词也基本概括了 BPF 的两大核心功能：&lt;/p>
&lt;ul>
&lt;li>过滤(Filter): 根据外界输入的规则过滤报文；&lt;/li>
&lt;li>复制(Copy)：将符合条件的报文由内核空间复制到用户空间；&lt;/li>
&lt;/ul>
&lt;p>以 tcpdump 为例：熟悉网络监控(network monitoring)的读者大抵都知道 tcpdump 依赖于 pcap 库，tcpdump 中的诸多核心功能都经由后者实现，其整体工作流程如下图所示：&lt;/p>
&lt;p>图 1. Tcpdump 工作流程&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-22-55-epbf-image001.png" alt="">&lt;/p>
&lt;p>由图 1 不难看出，位于内核之中的 BPF 模块是整个流程之中最核心的一环：它一方面接受 tcpdump 经由 libpcap 转码而来的滤包条件(Pseudo Machine Language) ，另一方面也将符合条件的报文复制到用户空间最终经由 libpcap 发送给 tcpdump。&lt;/p>
&lt;p>读到这里，估计有经验的读者已经能够在脑海里大致勾勒出一个 BPF 实现的大概了，图 2 引自文献 1，读者们可以管窥一下当时 BPF 的设计：&lt;/p>
&lt;p>图 2. BPF Overview&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-01-epbf002.png" alt="">&lt;/p>
&lt;p>时至今日，传统 BPF 仍然遵循图 2 的路数：途经网卡驱动层的报文在上报给协议栈的同时会多出一路来传送给 BPF，再经后者过滤后最终拷贝给用户态的应用。除开本文提及的 tcpdump，当时的 RARP 协议也可以利用 BPF 工作(Linux 2.2 起，内核开始提供 rarp 功能，因此如今的 RARP 已经不再需要 BPF 了)。&lt;/p>
&lt;p>整体来说，BPF 的架构还是相对浅显易懂的，不过要是深入细节的话就没那么容易了：因为其中的 filter 的设计（也是文献 1 中着墨最多的地方）要复杂那么一点点。&lt;/p>
&lt;h3 id="pseudo-machine-language">Pseudo Machine Language&lt;/h3>
&lt;p>估计在阅读本文之前，相当数量的读者都会误以为所谓的 Filter&lt;/p>
&lt;p>的是挂在 tcpdump 末尾处的 expression 吧，类似于图 1 中的&amp;quot;tcp and dst port 7070&amp;quot;这样。但倘若我们如下文这样在 tcpdump 的调用中加入一个-d，还会发现其中大有乾坤：&lt;/p>
&lt;p>清单 1 tcpdump -d&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">#以下代码可以在任意支持 tcpdump 的类 Unix 平台上运行，输出大同小异
bash-3.2$ sudo tcpdump -d -i lo tcp and dst port 7070
(000) ldh [12]
(001) jeq #0x86dd jt 2 jf 6 #检测是否为 ipv6 报文，若为假(jf)则按照 ipv4 报文处理(L006)
(002) ldb [20]
(003) jeq #0x6 jt 4 jf 15 #检测是否为 tcp 报文
(004) ldh [56]
(005) jeq #0x1b9e jt 14 jf 15 #检测是否目标端口为 7070(0x1b9e)，若为真(jt)则跳转 L014
(006) jeq #0x800 jt 7 jf 15 #检测是否为 ipv4 报文
(007) ldb [23]
(008) jeq #0x6 jt 9 jf 15 #检测是否为 tcp 报文
(009) ldh [20]
(010) jset #0x1fff jt 15 jf 11 #检测是否为 ip 分片(IP fragmentation)报文
(011) ldxb 4*([14]&amp;amp;0xf)
(012) ldh [x + 16] #找到 tcp 报文中 dest port 的所在位置
(013) jeq #0x1b9e jt 14 jf 15 #检测是否目标端口为 7070(0x1b9e)，若为真(jt)则跳转 L014
(014) ret #262144 #该报文符合要求
(015) ret #0 #该报文不符合要求
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据 man page，tcpdump 的-d 会将输入的 expression 转义为一段&amp;quot;human readable&amp;quot;的&amp;quot;compiled packet-matching code&amp;quot;。当然，如清单 1 中的内容，对于很多道行不深的读者来说，基本是&amp;quot;human unreadable&amp;quot;的，于是笔者专门加入了一些注释加以解释，但是相较于-dd 和-ddd 反人类的输出，这确可以称得上是&amp;quot;一目了然&amp;quot;的代码了。&lt;/p>
&lt;p>这段看起来类似于汇编的代码，便是 BPF 用于定义 Filter 的伪代码，亦即图 1 中 libpcap 和内核交互的 pseudo machine language(也有一种说法是，BPF 伪代码设计之初参考过当时大行其道的 RISC 令集的设计理念)，当 BPF 工作时，每一个进出网卡的报文都会被这一段代码过滤一遍，其中符合条件的(ret #262144)会被复制到用户空间，其余的(ret #0)则会被丢弃。&lt;/p>
&lt;p>BPF 采用的报文过滤设计的全称是 CFG(Computation Flow Graph)，顾名思义是将过滤器构筑于一套基于 if-else 的控制流(flow graph)之上，例如清单 1 中的 filter 就可以用图 3 来表示：&lt;/p>
&lt;p>图 3 基于 CFG 实现的 filter 范例&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-07-epbf003.png" alt="">&lt;/p>
&lt;p>CFG 模型最大的优势是快，参考文献 1 中就比较了 CFG 模型和基于树型结构构建出的 CSPF 模型的优劣，得出了基于 CFG 模型需要的运算量更小的结论；但从另一个角度来说，基于伪代码的设计却也增加了系统的复杂性：一方面伪指令集已经足够让人眼花缭乱的了；另一方面为了执行伪代码，内核中还需要专门实现一个虚拟机(pseudo-machine)，这也在一定程度上提高了开发和维护的门槛。&lt;/p>
&lt;p>当然，或许是为了提升系统的易用性，一方面 BPF 设计者们又额外在 tcpdump 中设计了我们今天常见的过滤表达式(实际实现于 libpcap，当然两者也都源于 Lawrence Berkeley Lab)，令过滤器真正意义上&amp;quot;Human Readable&amp;quot;了起来；另一方面，由于设计目标只是过滤字节流形式的报文，虚拟机及其伪指令集的设计相对会简单不少：整个虚拟机只实现了两个 32 位的寄存器，分别是用于运算的累加器 A 和通用寄存器 X；且指令集也只有寥寥 20 来个，如表 1 所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Category&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Opcodes&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Address modes&lt;/strong>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Load Instructions&lt;/strong>&lt;/td>
&lt;td>ldb&lt;/td>
&lt;td>[k]&lt;/td>
&lt;td>[x+k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ldh&lt;/td>
&lt;td>[k]&lt;/td>
&lt;td>[x+k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ld&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>#len&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>[k]&lt;/td>
&lt;td>[x+k]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ldx&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>#len&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>4 * ([k] &amp;amp; 0xf)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Store Instructions&lt;/strong>&lt;/td>
&lt;td>st&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>stx&lt;/td>
&lt;td>M[k]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>ALU Instruction&lt;/strong>&lt;/td>
&lt;td>add&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>sub&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>mul&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>div&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>and&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>or&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>lsh&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>rsh&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Branch Instruction&lt;/strong>&lt;/td>
&lt;td>jmp&lt;/td>
&lt;td>L&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jeq&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jgt&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jge&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>jset&lt;/td>
&lt;td>#k, Lt, Lf&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Misc Instruction&lt;/strong>&lt;/td>
&lt;td>tax&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>txa&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Return Instruction&lt;/strong>&lt;/td>
&lt;td>ret&lt;/td>
&lt;td>#k&lt;/td>
&lt;td>a&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>易用性方面的提升很大程度上弥补了 BPF 本身的复杂度带来的缺憾，很大程度上推动了 BPF 的发展，此后数年，BPF 逐渐称为大众所认同，包括 Linux 在内的众多操作系统都开始将 BPF 引入了内核。&lt;/p>
&lt;p>鉴于 Linux 上 BPF 如火如荼的大好形势，本文余下的部分笔者将基于 Linux 上的 BPF 实现进行展开。&lt;/p>
&lt;h3 id="lsf-linux-下的-bpf-实现">LSF: Linux 下的 BPF 实现&lt;/h3>
&lt;p>BPF 是在 1997 年首次被引入 Linux 的，当时的内核版本尚为 2.1.75。准确的说，Linux 内核中的报文过滤机制其实是有自己的名字的：Linux Socket Filter，简称 LSF。但也许是因为 BPF 名声太大了吧，连&lt;a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">内核文档&lt;/a>都不大买这个帐，直言 LSF 其实就是(aka)BPF。&lt;/p>
&lt;p>当然，LSF 和 BPF 除了名字上的差异以外，还是有些不同的，首当其冲的分歧就是接口：传统的 BSD 开启 BPF 的方式主要是靠打开(open)/dev/bpfX 设备，之后利用 ioctl 来进行控制；而 linux 则选择了利用套接字选项(sockopt)SO_ATTACH_FILTER/SO_DETACH_FILTER 来执行系统调用，篇幅所限，这部分内容笔者就不深入了，有兴趣的读者可以通过移步&lt;a href="http://man7.org/linux/man-pages/man7/socket.7.html">socket 的 manual page&lt;/a>或&lt;a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">内核 filter 文档&lt;/a>深入了解。这里笔者只给出一个例子来让读者们对 Linux 下的 BPF 的开发有一个直观的感受：&lt;/p>
&lt;h5 id="清单-2-bpf-sample">清单 2 BPF Sample&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;……&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// tcpdump -dd 生成出的伪代码块
&lt;/span>&lt;span class="c1">// instruction format:
&lt;/span>&lt;span class="c1">// opcode: 16bits; jt: 8bits; jf: 8bits; k: 32bits
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sock_filter&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">{&lt;/span> &lt;span class="mh">0x28&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x0000000c&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (000) ldh [12]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x000086dd&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (001) jeq #0x86dd jt 2 jf 6
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x30&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000014&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (002) ldb [20]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000006&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (003) jeq #0x6 jt 4 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x28&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000038&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (004) ldh [56]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000438&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (005) jeq #0x438 jt 14 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000800&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (006) jeq #0x800 jt 7 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x30&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000017&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (007) ldb [23]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000006&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (008) jeq #0x6 jt 9 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x28&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000014&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (009) ldh [20]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x45&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00001fff&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (010) jset #0x1fff jt 15 jf 11
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0xb1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x0000000e&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (011) ldxb 4*([14]&amp;amp;0xf)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x48&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000010&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (012) ldh [x + 16]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000438&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (013) jeq #0x438 jt 14 jf 15
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00040000&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (014) ret #262144
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mh">0x6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mh">0x00000000&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// (015) ret #0
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sock_fprog&lt;/span> &lt;span class="n">bpf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sock_filter&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">code&lt;/span> &lt;span class="p">};&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 1. 创建 raw socket
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AF_PACKET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SOCK_RAW&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">htons&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ETH_P_ALL&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 2. 将 socket 绑定给指定的 ethernet dev
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// ethernet dev 由 arg 1 传入
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">addr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sll_ifindex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">if_nametoindex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 3. 利用 SO_ATTACH_FILTER 将 bpf 代码块传入内核
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">setsockopt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SOL_SOCKET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SO_ATTACH_FILTER&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">bpf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bpf&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(;&lt;/span> &lt;span class="p">;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">recv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 4. 利用 recv()获取符合条件的报文
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ip_header&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">iphdr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">buf&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">ether_header&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">inet_ntop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AF_INET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">saddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">src_addr_str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">src_addr_str&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">inet_ntop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AF_INET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">daddr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dst_addr_str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dst_addr_str&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;IPv%d proto=%d src=%s dst=%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">version&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ip_header&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">protocol&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">src_addr_str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dst_addr_str&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>篇幅所限，清单 2 中笔者只列出了部分代码，代码分析也以注释为主。有兴趣的读者可以移步&lt;a href="https://raw.githubusercontent.com/windywolf/example/master/eBPF/bpfsample.c">这&lt;/a>&lt;a href="https://raw.githubusercontent.com/windywolf/example/master/eBPF/bpfsample.c">里&lt;/a>阅读完全版。&lt;/p>
&lt;p>由于主要是和过滤报文打交道，内核中(before 3.18)的 BPF 的绝大部分实现都被放在了&lt;a href="http://elixir.free-electrons.com/linux/v2.6.39.4/source/net/core/filter.c">net/core/filter.c&lt;/a>下，篇幅原因笔者就不对代码进行详述了，文件不长，600 来行(v2.6)，比较浅显易懂，有兴趣的读者可以移步品评一下。值得留意的函数有两个，sk_attach_filter()和sk_run_filter()：前者将 filter 伪代码由用户空间复制进内核空间；后者则负责在报文到来时执行伪码解析。&lt;/p>
&lt;h3 id="演进jit-for-bpf">演进：JIT For BPF&lt;/h3>
&lt;p>BPF 被引入 Linux 之后，除了一些小的性能方面的调整意外，很长一段时间都没有什么动静。直到 3.0 才首次迎来了比较大的革新：在一些特定硬件平台上，BPF 开始有了用于提速的 JIT(Just-In-Time) Compiler。&lt;/p>
&lt;p>最先实现 JIT 的是&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net">x&lt;/a>&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net">8&lt;/a>&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/x86/net">6&lt;/a>平台，其后包括&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/arm/net">arm&lt;/a>、&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/powerpc/net">ppc&lt;/a>、&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/390/net">S390&lt;/a>、&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/arch/mips/net">mips&lt;/a>等一众平台纷纷跟进，到今天 Linux 的主流平台中支持 JIT For BPF 的已经占了绝大多数了。&lt;/p>
&lt;p>BPF JIT 的接口还是简单清晰的：各平台的 JIT 编译函数都实现于&lt;a href="http://elixir.free-electrons.com/linux/v3.10.107/source/arch/x86/net/bpf_jit_comp.c#L147">bpf_jit_compile()&lt;/a>之中(3.16 之后，开始逐步改为&lt;a href="http://elixir.free-electrons.com/linux/v3.16/source/arch/x86/net/bpf_jit_comp.c#L869">bpf_int_jit_compile()&lt;/a>)，如果 CONFIG_BPF_JIT 被打开，则传入的 BPF 伪代码就会被传入该函数加以编译，编译结果被拿来替换掉默认的处理函数 sk_run_filter()。JIT 的实现不在本文讨论之列，其代码基本位于 arch/&lt;platform>/net 之下，有致力于优化的同学可以尝试学习一下。&lt;/p>
&lt;p>打开 BPF 的 JIT 很简单，只要向/proc/sys/net/core/bpf_jit_enable 写入 1 即可；对于有调试需求的开发者而言，如果写入 2 的话，还可以在内核 log 中看到载入 BPF 代码时候 JIT 生成的优化代码，内核开发者们还提供了一个更加方便的工具&lt;a href="http://elixir.free-electrons.com/linux/v4.12.8/source/tools/net">bpf_jit_disam&lt;/a>，可以将内核 log 中的二进制转换为汇编以便阅读。&lt;/p>
&lt;p>JIT Compiler 之后，针对 BPF 的小改进不断：如将 BPF 引入 seccomp(3.4)；添加一些 debug 工具如 bpf_asm 和 bpf_dbg(3.14)。不过比较革命性的大动作就要等到 3.17 了，这次的改进被称为 extended BPF，即 eBPF。&lt;/p>
&lt;h2 id="进化extended-bpf">进化：extended BPF&lt;/h2>
&lt;p>自 3.15 伊始，一个套源于 BPF 的全新设计开始逐渐进入人们的视野，并最终(3.17)被添置到了 kernel/bpf 下。这一全新设计最终被命名为了 extended BPF(eBPF)：顾名思义，有全面扩充既有 BPF 功能之意；而相对应的，为了后向兼容，传统的 BPF 仍被保留了下来，并被重命名为 classical BPF(cBPF)。&lt;/p>
&lt;p>相对于 cBPF，eBPF 带来的改变可谓是革命性的：一方面，它已经为内核追踪(Kernel Tracing)、应用性能调优/监控、流控(Traffic Control)等领域带来了激动人心的变革；另一方面，在接口的设计以及易用性上，eBPF 也有了较大的改进。&lt;/p>
&lt;p>Linux 内核代码的 samples 目录下有大量前人贡献的&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf">eBPF sample&lt;/a>，这里笔者先挑选其中相对简单的 sockex1 来帮助读者们建立一个 eBPF 的初步印象：&lt;/p>
&lt;h5 id="清单-3-sockex1_userc">清单 3 sockex1_user.c&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;…&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// 篇幅所限，清单 3 和 4 都只罗列出部分关键代码，有兴趣一窥全貌的读者可以移步 http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf深入学习
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">ac&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// 1. eBPF 的伪代码位于 sockex1_kern.o 中，这是一个由 llvm 生成的 elf 格式文件，指令集为 bpf;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">snprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;%s_kern.o&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">load_bpf_file&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// load_bpf_file()定义于 bpf_load.c，利用 libelf 来解析 sockex1_kern.o
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 并利用 bpf_load_program 将解析出的伪代码 attach 进内核;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 2. 因为 sockex1_kern.o 中 bpf 程序的类型为 BPF_PROG_TYPE_SOCKET_FILTER
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 所以这里需要用用 SO_ATTACH_BPF 来指明程序的 sk_filter 要挂载到哪一个套接字上
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open_raw_sock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;lo&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">setsockopt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SOL_SOCKET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SO_ATTACH_BPF&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">prog_fd&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">prog_fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]))&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 3. 利用 map 机制获取经由 lo 发出的 tcp 报文的总长度
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">IPPROTO_TCP&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bpf_map_lookup_elem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map_fd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tcp_cnt&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>清单 4 sockex1_kern.c&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;……&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="c1">// 预先定义好的 map 对象
&lt;/span>&lt;span class="c1">// 这里要注意好其实 map 是需要由用户空间程序调用 bpf_create_map()进行创建的
&lt;/span>&lt;span class="c1">// 在这里定义的 map 对象，实际上会在 load_bpf_file()解析 ELF 文件的同时被解析和创建出来
&lt;/span>&lt;span class="c1">// 这里的 SEC(NAME)宏表示在当前 obj 文件中新增一个段(section)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">bpf_map_def&lt;/span> &lt;span class="nf">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;maps&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">my_map&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BPF_MAP_TYPE_ARRAY&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">key_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">value_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">max_entries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">256&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;socket1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">bpf_prog1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">__sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">// 这个例子比较简单，仅仅是读取输入报文的包头中的协议位而已
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这里的 load_byte 实际指向了 llvm 的 built-in 函数 asm(llvm.bpf.load.byte)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 用于生成 eBPF 指令 BPF_LD_ABS 和 BPF_LD_IND
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">load_byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ETH_HLEN&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">offsetof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">iphdr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">protocol&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// ……
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 根据 key(&amp;amp;index，注意这是一个指向函数的引用)获取对应的 value
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bpf_map_lookup_elem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">my_map&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">__sync_fetch_and_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//这里的__sync_fetch_and_add 是 llvm 中的内嵌函数，表示 atomic 加操作
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 为了满足 GPL 毒药的需求，所有会注入内核的 BPF 代码都须显式的支持 GPL 协议
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">_license&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">SEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;license&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;GPL&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对比一下清单 3&amp;amp;4 以及清单 2 的代码片段，很容易看出一些 eBPF 显而易见的革新：&lt;/p>
&lt;ul>
&lt;li>用 C 写成的 BPF 代码(sockex1_kern.o)；&lt;/li>
&lt;li>基于 map 的内核与用户空间的交互方式；&lt;/li>
&lt;li>全新的开发接口；&lt;/li>
&lt;/ul>
&lt;p>除此之外，还有一些不那么明显的改进隐藏在内核之中：&lt;/p>
&lt;ul>
&lt;li>全新的伪指令集设计；&lt;/li>
&lt;li>In-kernel verifier;&lt;/li>
&lt;/ul>
&lt;p>由一个文件(net/core/filter.c)进化到一个目录(kernel/bpf)，eBPF 的蜕变三言两语间很难交代清楚，下面笔者就先基于上述的几点变化来帮助大家入个门，至于个中细节，就只能靠读者以后自己修行了。&lt;/p>
&lt;h3 id="再见了汇编">再见了汇编&lt;/h3>
&lt;p>利用高级语言书写 BPF 逻辑并经由编译器生成出伪代码来并不是什么新鲜的尝试，比如 libpcap 就是在代码中内嵌了一个小型编译器来分析 tcpdump 传入的 filter expression 从而生成 BPF 伪码的。只不过长久以来该功能一直没有能被独立出来或者做大做强，究其原因，主要还是由于传统的 BPF 所辖领域狭窄，过滤机制也不甚复杂，就算是做的出来，估计也不堪大用。&lt;/p>
&lt;p>然而到了 eBPF 的时代，情况终于发生了变化：现行的伪指令集较之过去已经复杂太多，再用纯汇编的开发方式已经不合时宜，于是，自然而然的，利用 C 一类的高级语言书写 BPF 伪代码的呼声便逐渐高涨了起来。&lt;/p>
&lt;p>目前，支持生成 BPF 伪代码的编译器只有 llvm 一家，即使是通篇使用 gcc 编译的 Linux 内核，samples 目录下的 bpf 范例也要借用 llvm 来编译完成。还是以 sockex1 为例，用户态下的代码 sockex_user.c 是利用 HOSTCC 定义的编译器编译的；但 sockex_kern.c 就需要用到 clang 和 llvm 了。在&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/samples/bpf/Makefile">samples/bpf/Makefile&lt;/a>中，可以看到：&lt;/p>
&lt;h5 id="清单-5-samplesbpfmakefile">清单 5 samples/bpf/Makefile&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-makefile" data-lang="makefile">&lt;span class="c"># ......
&lt;/span>&lt;span class="c"># List of programs to build
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">hostprogs-y&lt;/span> &lt;span class="o">:=&lt;/span> test_lru_dist
&lt;span class="nv">hostprogs-y&lt;/span> &lt;span class="o">+=&lt;/span> sockex1
&lt;span class="c"># ……
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">sockex1-objs&lt;/span> &lt;span class="o">:=&lt;/span> bpf_load.o &lt;span class="k">$(&lt;/span>LIBBPF&lt;span class="k">)&lt;/span> sockex1_user.o
&lt;span class="c"># ……
&lt;/span>&lt;span class="c"># 注意，这里有一个小 tip，就是如果在内核的 Makefile 中，
&lt;/span>&lt;span class="c"># 有某一个目标文件你不希望使用内核的通用编译规则的话(类似于本文的 sockex1_kern.o)，
&lt;/span>&lt;span class="c"># 可以像这里一样，并不把该文件加入任何 xxxprogs 或 xxx-objs，
&lt;/span>&lt;span class="c"># 而是直接放入 always，这样内核就会在本地 Makefile 中搜索编译规则了。
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">always&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">$(&lt;/span>hostprogs-y&lt;span class="k">)&lt;/span>
&lt;span class="err">&amp;lt;strong&amp;gt;always&lt;/span> &lt;span class="err">&amp;lt;/strong&amp;gt;&amp;lt;strong&amp;gt;+=&lt;/span> &lt;span class="err">sockex1_kern.o&amp;lt;/strong&amp;gt;&lt;/span>
&lt;span class="c"># ……
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nv">LLC&lt;/span> &lt;span class="o">?=&lt;/span> llc
&lt;span class="nv">CLANG&lt;/span> &lt;span class="o">?=&lt;/span> clang
&lt;span class="c"># ……
&lt;/span>&lt;span class="c"># sockex1_kern.o 就是使用了下述规则编译为 BPF 代码的，请注意笔者加粗的部分
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nf">$(obj)/%.o&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">src&lt;/span>&lt;span class="k">)&lt;/span>/%.&lt;span class="n">c&lt;/span>
&lt;span class="k">$(&lt;/span>&lt;span class="nv">CLANG&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">NOSTDINC_FLAGS&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">LINUXINCLUDE&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="k">$(&lt;/span>&lt;span class="nv">EXTRA_CFLAGS&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-D__KERNEL__&lt;/span> &lt;span class="err">-D__ASM_SYSREG_H&lt;/span> &lt;span class="err">-Wno-unused-value&lt;/span> &lt;span class="err">-Wno-pointer-sign&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-compare-distinct-pointer-types&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-gnu-variable-sized-type-not-at-end&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-address-of-packed-member&lt;/span> &lt;span class="err">-Wno-tautological-compare&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-Wno-unknown-warning-option&lt;/span> &lt;span class="err">\&lt;/span>
&lt;span class="err">-O2&lt;/span> &lt;span class="err">-emit-llvm&lt;/span> &lt;span class="err">-c&lt;/span> &lt;span class="k">$&amp;lt;&lt;/span> &lt;span class="err">-o&lt;/span> &lt;span class="err">-|&lt;/span>
&lt;span class="k">$(&lt;/span>&lt;span class="nv">LLC&lt;/span>&lt;span class="k">)&lt;/span> &lt;span class="nv">-march&lt;/span>&lt;span class="o">=&lt;/span>bpf -filetype&lt;span class="o">=&lt;/span>obj -o
&lt;span class="k">$@&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>能用 C 书写 BPF 自然是便利了许多，但也不代表余下的开发工作就是一片坦途了：首先 llvm 的输出是 elf 文件，这也意味着想要获取能传入内核的代码，我们还需要额外做一段解析 elf 的工作，这也是为什么 Sample 下的范例几乎无一例外地都链接了 libelf 库；其次，同时也是比较重要的一点，不要忘记 BPF 的代码是跑在内核空间中的，因此书写时必得煞费苦心一番才好，以防一个不小心就做出个把内核干趴下的漏洞来：下文中提及的 verifier 就是为了这一点而生，每一个被放进内核的 BPF 代码，都须要经过它的检验才行。&lt;/p>
&lt;h3 id="bpf-程序的类别以及-map-机制">BPF 程序的类别以及 Map 机制&lt;/h3>
&lt;p>清单 3 中我们看到 sockex1_kern.o 是由 load_bpf_file()函数载入内存的，但实际上 eBPF 提供用来将 BPF 代码载入内核的正式接口函数其实是 bpf_load_program()，该接口负责通过参数向内核提供三类信息：&lt;/p>
&lt;ul>
&lt;li>BPF 程序的类型、&lt;/li>
&lt;li>BPF 代码&lt;/li>
&lt;li>代码运行时所需要的存放 log 的缓存地址(位于用户空间)；&lt;/li>
&lt;/ul>
&lt;p>有意思的是，目前所有注入内核的 BPF 程序都需要附带 GPL 协议支持信息，bpf_load_program()的 license 参数就是用来载入协议字串的。&lt;/p>
&lt;p>由 eBPF 伊始，BPF 程序开始有分类了，通过 bpf_load_program 的参数 bpf_prog_type，我们可以看到 eBPF 支持的程序类型。这里笔者将一些常用的类型罗列于下表之中供读者参考：&lt;/p>
&lt;h4 id="表-2-常见-bpf_prog_type-定义">表 2 常见 bpf_prog_type 定义&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>bpf_prog_type&lt;/strong>&lt;/th>
&lt;th>&lt;strong>BPF prog 入口参数(R1)&lt;/strong>&lt;/th>
&lt;th>&lt;strong>程序类型&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_SOCKET_FILTER&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct __sk_buff&lt;/strong>&lt;/td>
&lt;td>用于过滤进出口网络报文，功能上和 cBPF 类似。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_KPROBE&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct pt_regs&lt;/strong>&lt;/td>
&lt;td>用于 kprobe 功能的 BPF 代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_TRACEPOINT&lt;/strong>&lt;/td>
&lt;td>这类 BPF 的参数比较特殊，根据 tracepoint 位置的不同而不同。&lt;/td>
&lt;td>用于在各个 tracepoint 节点运行。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_XDP&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct xdp_md&lt;/strong>&lt;/td>
&lt;td>用于控制 XDP(eXtreme Data Path)的 BPF 代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_PERF_EVENT&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct bpf_perf_event_data&lt;/strong>&lt;/td>
&lt;td>用于定义 perf event 发生时回调的 BPF 代码。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_CGROUP_SKB&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct __sk_buff&lt;/strong>&lt;/td>
&lt;td>用于在 network cgroup 中运行的 BPF 代码。功能上和 Socket_Filter 近似。具体用法可以参考范例 test_cgrp2_attach。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>BPF_PROG_TYPE_CGROUP_SOCK&lt;/strong>&lt;/td>
&lt;td>&lt;strong>struct bpf_sock&lt;/strong>&lt;/td>
&lt;td>另一个用于在 network cgroup 中运行的 BPF 代码，范例 test_cgrp2_sock2 中就展示了一个利用 BPF 来控制 host 和 netns 间通信的例子。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>深入对比清单 3(eBPF)和清单 2(cBPF)的实现的差异，还会发现一个比较明显的不同之处：BPF 代码进内核之后，cBPF 和内核通讯的方式是 recv()；而 eBPF 则将 socket 丢到一边，使用一种名为 map 的全新机制和内核通讯，其大致原理下图所示：&lt;/p>
&lt;h4 id="图-4-ebpf-的-map-机制">图 4 eBPF 的 map 机制&lt;/h4>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-22-epbf004.png" alt="">&lt;/p>
&lt;p>从图上看，这套设计本身不复杂：位于用户空间中的应用在内核中辟出一块空间建立起一个数据库用以和 eBPF 程序交互(bpf_create_map())；数据库本身以 Key-Value 的形式进行组织，无论是从用户空间还是内核空间都可以对其进行访问，两边有着相似的接口，最终在逻辑上也都殊途同归。&lt;/p>
&lt;p>不难发现，map 带来的最大优势是效率：相对于 cBPF 一言不合就把一个通信报文从内核空间丢出来的豪放，map 机制下的通讯耗费就要小家碧玉的多了：还是以 sockex1 为例，一次通信从内核中仅仅复制 4 个字节，而且还是已经处理好了可以直接拿来就用的，做过内核开发的人都知道这对于性能意味着什么。&lt;/p>
&lt;p>map 机制解决的另一个问题是通信数据的多样性问题。cBPF 所覆盖的功能范围很简单，无外乎是网络监控和 seccomp 两块，数据接口设计的粗放一点也就算了；而 eBPF 的利用范围则要广的多，性能调优、内核监控、流量控制什么的应有尽有，数据接口的多样性设计就显得很必要了。下表中就列出了现有 eBPF 中的 map 机制中常见的数据类型：&lt;/p>
&lt;h5 id="表-3-map-机制下的常见数据类型">表 3. map 机制下的常见数据类型&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Category&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Source&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Bpf_map_type&lt;/strong>&lt;/th>
&lt;th>&lt;strong>用途&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Array&lt;/strong>&lt;/td>
&lt;td>Arraymap.c&lt;/td>
&lt;td>BPF_MAP_TYPE_ARRAY BPF_MAP_TYPE_CGROUP_ARRAY BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF_MAP_TYPE_PERCPU_ARRAY BPF_MAP_TYPE_ARRAY_OF_MAPS&lt;/td>
&lt;td>实际就是数组，所以所有的 key 必须是整数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>BPF_MAP_TYPE_PROG_ARRAY&lt;/td>
&lt;td>该类型是一个特例，主要用于自定义函数，利用 JUMP_TAIL_CALL令跳转&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Hash&lt;/strong>&lt;/td>
&lt;td>Hashmap.c&lt;/td>
&lt;td>BPF_MAP_TYPE_HASH BPF_MAP_TYPE_PERCPU_HASH BPF_MAP_TYPE_LRU_HASH BPF_MAP_TYPE_LRU_PERCPU_HASH BPF_MAP_TYPE_HASH_OF_MAPS&lt;/td>
&lt;td>真正意义上的 map 数据类型，如果 key 值为整数以外的类型必须使用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Stack Trace&lt;/strong>&lt;/td>
&lt;td>Stackmap.c&lt;/td>
&lt;td>BPF_MAP_TYPE_STACK_TRACE&lt;/td>
&lt;td>真正意义上的 map 数据类型，如果 key 值为整数以外的类型必须使用存储特定应用在某一特定时间点的栈状态(包括内核态和用户态)，key 只有两个：分别为内核栈 id 和用户栈 id，利用 bpf_get_stackid()获取;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Longest Prefix Match Trie&lt;/strong>&lt;/td>
&lt;td>Lpm_trie.c&lt;/td>
&lt;td>BPF_MAP_TYPE_LPM_TRIE&lt;/td>
&lt;td>基于 Longest Prefix Match 前缀树实现，适宜处理以 CIBR 为键值时的情况&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="新的指令集">新的指令集&lt;/h3>
&lt;p>eBPF 对于既有 cBPF 令集的改动量之大，以至于基本上不能认为两者还是同一种语言了。个中变化，我们可以通过反汇编清单 4 的源代码(llvm-objdump &amp;ndash;disassemble)略知一二：&lt;/p>
&lt;p>清单 6 Disassemble of sockex1_kern.o&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-objectivec" data-lang="objectivec">&lt;span class="n">sockex1_kern&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">o&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="n">format&lt;/span> &lt;span class="n">ELF64&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">BPF&lt;/span>
&lt;span class="n">Disassembly&lt;/span> &lt;span class="n">of&lt;/span> &lt;span class="n">section&lt;/span> &lt;span class="nl">socket1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nl">bpf_prog1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">bf&lt;/span> &lt;span class="mi">16&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r6&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r1&lt;/span>
&lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">30&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mi">17&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u8&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">23&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="mi">2&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">63&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="n">fc&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r10&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r0&lt;/span>
&lt;span class="mi">3&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mo">04&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">4&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">55&lt;/span> &lt;span class="mo">01&lt;/span> &lt;span class="mi">08&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">04&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="k">goto&lt;/span> &lt;span class="mi">8&lt;/span>
&lt;span class="mi">5&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">bf&lt;/span> &lt;span class="n">a2&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">r10&lt;/span>
&lt;span class="mi">6&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mo">07&lt;/span> &lt;span class="mo">02&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">fc&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="n">ff&lt;/span> &lt;span class="n">r2&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">4&lt;/span>
&lt;span class="mi">7&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">18&lt;/span> &lt;span class="mo">01&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0ll&lt;/span>
&lt;span class="mi">9&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">85&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">01&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">call&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="mi">10&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">02&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">r0&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">goto&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;span class="mi">11&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">12&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">db&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u64&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">r0&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">r1&lt;/span>
&lt;span class="nl">LBB0_3&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="mi">13&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">b7&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">r0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="mi">14&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">95&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="mo">00&lt;/span> &lt;span class="n">exit&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们不用管这段汇编写了点儿什么，先跟清单 2 开头的那段 cBPF 代码对比一下两者的异同：&lt;/p>
&lt;ul>
&lt;li>寄存器：eBPF 支持更多的寄存器；
&lt;ul>
&lt;li>cBPF：A, X + stack, 32bit;&lt;/li>
&lt;li>eBPF：R1~R10 + stack, 64bit，显然，如此的设计主要针对现在大行其道的 64 位硬件，同时更多的寄存器设计也便于运行时和真实环境下的寄存器进行对应，以提高效率；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>opcode：两者的格式不同；
&lt;ul>
&lt;li>cBPF: op 16b, jt 8b, jf 8b, K 32b;&lt;/li>
&lt;li>eBPF: op 8b, dstReg 4b, srcReg 4b, off 16b, imm 32b;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他：sockex1_kern.o 设计的比较简单，但还是可以从中看出 eBPF 的一大改进：可以调用内核中预设好的函数（Call 1，这里指向的函数是 bpf_map_lookup_elem()，如果需要比较全的预设函数索引的话可以移步&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/include/uapi/linux/bpf.h#L494">这里&lt;/a>）。除此之外，eBPF 命令集中比较重要的新晋功能还有：
&lt;ul>
&lt;li>load/store 多样化：
&lt;ul>
&lt;li>cBPF：仅可以读 packet(即 skb)以及读写 stack；&lt;/li>
&lt;li>eBPF：可以读写包括 stack/map/context，也即 BPF prog 的传入参数可读写。换句话说，任意传入 BPF 代码的数据流均可以被修改；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>除开预设函数外，开发者还可以自定义 BPF 函数(JUMP_TAIL_CALL)；&lt;/li>
&lt;li>除了前向跳转外(Jump Forward，cBPF 支持)，还可以后向跳转(Jump Backword)；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>至于 eBPF 具体的指令表，因为过于庞杂这里笔者就不作文抄公了。不过 eBPF 中的几个寄存器的利用规则这里还是可以有的，否则要读懂清单 6 中的代码略有困难：&lt;/p>
&lt;ul>
&lt;li>R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；&lt;/li>
&lt;li>R1~R5：一般用于表示内核预设函数的参数；&lt;/li>
&lt;li>R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；&lt;/li>
&lt;li>R10：只读，用作栈指针(SP)；&lt;/li>
&lt;/ul>
&lt;h3 id="in-kernel-verifier">In-kernel Verifier&lt;/h3>
&lt;p>其实结合前面那么多的内容看下来不难发现 eBPF 其实近似于一种改头换面后的内核模块，只不过它比内核模块更短小精干，实现的功能也更新颖一些罢了，但无论是什么样的架构，只要存在注入的代码就会有安全隐患，eBPF 也不外如是——毕竟注入的代码是要在内核中运行的。&lt;/p>
&lt;p>为了最大限度的控制这些隐患，cBPF 时代就开始加入了&lt;a href="http://elixir.free-electrons.com/linux/v2.6.39.4/source/net/core/filter.c#L498">代码检查机制&lt;/a>以防止不规范的注入代码；到了 eBPF 时代则在载入程序(bpf_load_program())时加入了更复杂的&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L3544">verifier 机制&lt;/a>，在运行注入程序之前，先进行一系列的安全检查，最大限度的保证系统的安全。具体来说，verifier 机制会对注入的程序做两轮检查：&lt;/p>
&lt;ul>
&lt;li>首轮检查(First pass，实现于&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L2586">check_cfg()&lt;/a>)可以被认为是一次深度优先搜索，主要目的是对注入代码进行一次 DAG(Directed Acyclic Graph，有向无环图)检测，以保证其中没有循环存在；除此之外，一旦在代码中发现以下特征，verifier 也会拒绝注入：
&lt;ul>
&lt;li>代码长度超过上限，目前(内核版本 4.12)eBPF 的代码长度上限为 4K 条指令——这在 cBPF 时代很难达到，但别忘了 eBPF 代码是可以用 C 实现的；&lt;/li>
&lt;li>存在可能会跳出 eBPF 代码范围的 JMP，这主要是为了防止恶意代码故意让程序跑飞；&lt;/li>
&lt;li>存在永远无法运行(unreachable)的 eBPF 令，例如位于 exit 之后的指令；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>次轮检查(Second pass，实现于&lt;a href="http://elixir.free-electrons.com/linux/v4.12.6/source/kernel/bpf/verifier.c#L2896">do_check()&lt;/a>)较之于首轮则要细致很多：在本轮检测中注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，所有的指令的参数（寄存器）、访问的内存、调用的函数都会被仔细的捋一遍，任何的错误都会导致注入程序被退货。由于过分细致，本轮检查对于注入程序的复杂度也有所限制：首先程序中的分支(branch)不允许超过 1024 个；其次经检测的指令数也必须在 96K 以内。&lt;/li>
&lt;/ul>
&lt;h3 id="overview-ebpf-的架构">Overview: eBPF 的架构&lt;/h3>
&lt;p>诚然，eBPF 设计的复杂程度已是超越 cBPF 太多太多，笔者罗里吧嗦了大半天，其实也就是将将领着大家入门的程度而已，为了便于读者们能够把前文所述的碎片知识串到一起，这里笔者将 eBPF 的大体架构草绘一番，如下图所示，希望能帮助大家对 eBPF 构建一个整体的认识。&lt;/p>
&lt;h4 id="图-5-architecture-of-ebpf">图 5. Architecture of eBPF&lt;/h4>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-23-30-epbf005.png" alt="">&lt;/p>
&lt;h3 id="追求极简bpf-compiler-collectionbcc">追求极简：BPF Compiler Collection(BCC)&lt;/h3>
&lt;p>现在让我们将目光聚焦到 eBPF 的使用——相信这是大部分读者最感兴趣的部分，毕竟绝大多数人其实并没有多少机会参与 eBPF 的开发——重新回到清单 3&amp;amp;4 中的 sockex1：说句良心话，虽然现在可以用 C 来实现 BPF，但编译出来的却仍然是 ELF 文件，开发者需要手动析出真正可以注入内核的代码。这部分工作多少有些麻烦，如果可以有一个通用的方案一步到位的生成出 BPF 代码就好了，开发者的注意力应该放在其他更有价值的地方，不是吗？&lt;/p>
&lt;p>于是就有人设计了 BPF Compiler Collection(BCC)，BCC 是一个 python 库，但是其中有很大一部分的实现是基于 C 和 C++的，python 只不过实现了对 BCC 应用层接口的封装而已。&lt;/p>
&lt;p>使用 BCC 进行 BPF 的开发仍然需要开发者自行利用 C 来设计 BPF 程序——但也仅此而已，余下的工作，包括编译、解析 ELF、加载 BPF 代码块以及创建 map 等等基本可以由 BCC 一力承担，无需多劳开发者费心。&lt;/p>
&lt;p>限于篇幅关于 BCC 笔者不再过多展开，文章的最后笔者再给出一个基于 BCC 实现的 sockex1 的例子，读者可以感受一下使用 BCC 带给开发者们的便利性：&lt;/p>
&lt;h5 id="清单-7-a-sample-of-bcc">清单 7 A sample of BCC&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">bcc&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">BPF&lt;/span>
&lt;span class="c1"># 和清单 2 一样，篇幅所限，这里只贴一部分源码，完全版请移步 https://raw.githubusercontent.com/windywolf/example/master/eBPF/bccsample.py&lt;/span>
&lt;span class="n">interface&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ens160&amp;#34;&lt;/span>
&lt;span class="c1"># BCC 可以接受直接将 BPF 代码嵌入 python code 之中&lt;/span>
&lt;span class="c1"># 为了方便展示笔者使用了这一功能&lt;/span>
&lt;span class="c1"># 注意：prog 中的中文注释是由于笔者需要写作之故加入，如果读者想尝试运行这段代码，&lt;/span>
&lt;span class="c1"># 则请将中文全部删除，因为目前 BCC 还不支持在内嵌 C 代码中使用中文注释&lt;/span>
&lt;span class="n">prog&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span class="s2">#include &amp;lt;net/sock.h&amp;gt;
&lt;/span>&lt;span class="s2">#include &amp;lt;bcc/proto.h&amp;gt;
&lt;/span>&lt;span class="s2">// BCC 中专门为 map 定义了一系列的宏，以方便使用
&lt;/span>&lt;span class="s2">// 宏中的 struct 下还定义了相应的函数，让开发者可以如 C++一般操作 map
&lt;/span>&lt;span class="s2">// 这里笔者定义了一个 array 类型的 map，名为 my_map1
&lt;/span>&lt;span class="s2">BPF_ARRAY(my_map1, long);
&lt;/span>&lt;span class="s2">// BCC 下的 BPF 程序中不再需要定义把函数或变量专门放置于某个 section 下了
&lt;/span>&lt;span class="s2">int bpf_prog1(struct __sk_buff *skb)
&lt;/span>&lt;span class="s2">{
&lt;/span>&lt;span class="s2"> // ……
&lt;/span>&lt;span class="s2"> struct ethernet_t *eth = cursor_advance(cursor, sizeof(*eth));
&lt;/span>&lt;span class="s2"> // ……
&lt;/span>&lt;span class="s2"> struct ip_t *ip = cursor_advance(cursor, sizeof(*ip));
&lt;/span>&lt;span class="s2"> int index = ip-&amp;gt;nextp;
&lt;/span>&lt;span class="s2"> long zero = 0; // BCC 下的 bpf 书写还是有很多坑的
&lt;/span>&lt;span class="s2"> // 例如，这里如果不去定义一个局部变量 zero，
&lt;/span>&lt;span class="s2"> // 而是直接用常量 0 作为 lookup_or_init()的变量就会报错
&lt;/span>&lt;span class="s2"> // map 类下的各个方法的具体细节可以参照 reference_guide.md
&lt;/span>&lt;span class="s2"> value = my_map1.lookup_or_init(&amp;amp;index, &amp;amp;zero);
&lt;/span>&lt;span class="s2"> if (value)
&lt;/span>&lt;span class="s2"> __sync_fetch_and_add(value, skb-&amp;gt;len);
&lt;/span>&lt;span class="s2"> return 0;
&lt;/span>&lt;span class="s2">}
&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="n">bpf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BPF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">prog&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">debug&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 注入 bpf_prog1 函数&lt;/span>
&lt;span class="n">function&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bpf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">load_func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;bpf_prog1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BPF&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">SOCKET_FILTER&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 这是一段 SOCKET_FILTER 类型的 BPF，所以需要挂载到某一个 interface 上&lt;/span>
&lt;span class="n">BPF&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">attach_raw_socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">function&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">interface&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 利用 map 机制获取进出 interface 的各个协议的报文总长&lt;/span>
&lt;span class="n">bpf_map&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bpf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;my_map1&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nb">print&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;TCP : &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s2">, UDP : &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s2">, ICMP: &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="n">bpf_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">socket&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">IPPROTO_TCP&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="c1"># …&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="结束语">结束语&lt;/h2>
&lt;p>本文从 BPF 的源头开始，一路讲到了近年来刚刚杀青的 eBPF，虽说拘泥于篇幅，大多内容只能蜻蜓点水、浅尝辄止，但文中 BPF 的原理、设计、实现和应用均有所涉猎，勉强也能拿来入个门了。加之近年来基于 eBPF 的应用层出不穷，希望本文能激发读者们的奇思妙想，从而设计出更多基于 BPF 的优秀应用来。&lt;/p>
&lt;h2 id="参考资源">参考资源&lt;/h2>
&lt;ol>
&lt;li>[Steven McCanne, Van Jacobson] The BSD Packet Filter: A New Architecture for User-level Packet Capture, BPF 的源头，可在&lt;a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">这里&lt;/a>查阅；&lt;/li>
&lt;li>&lt;a href="http://www.tcpdump.org/tcpdump_man.html,">http://www.tcpdump.org/tcpdump_man.html,&lt;/a> tcpdump 的 manual page;&lt;/li>
&lt;li>&lt;a href="https://www.kernel.org/doc/Documentation/networking/filter.txt,">https://www.kernel.org/doc/Documentation/networking/filter.txt,&lt;/a> 内核的 BPF 文档；&lt;/li>
&lt;li>&lt;a href="http://man7.org/linux/man-pages/man7/socket.7.html,">http://man7.org/linux/man-pages/man7/socket.7.html,&lt;/a> Linux 套接字的 manual page，其中有对 Linux Kernel 中 BPF 接口的大致介绍，不过论及详细程度还是不及参考文献 3 的；&lt;/li>
&lt;li>&lt;a href="https://lwn.net/Articles/437981/">https://lwn.net/Articles/437981/&lt;/a>，LWN 上刊载的 JIT For BPF 首次被引入的消息：A JIT For Packet Filters;&lt;/li>
&lt;li>&lt;a href="https://lwn.net/Articles/603983/,">https://lwn.net/Articles/603983/,&lt;/a> LWN 上刊载的 eBPF 的介绍文献：Extending extended BPF。由于年代久远接口相关的内容已经落后于最新代码了，权作参考；&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc,">https://github.com/iovisor/bcc,&lt;/a> BCC 的源码，但由于编译需要比较多的依赖，如果想偷个懒的话可以移步&lt;a href="https://hub.docker.com/r/zlim/bcc/">这里&lt;/a>直接获取 docker image；&lt;/li>
&lt;li>&lt;a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">bcc/reference_guide.md at master · iovisor/bcc · GitHub&lt;/a>, BCC 开发指南；&lt;/li>
&lt;li>&lt;a href="http://elixir.free-electrons.com/linux/latest/source,">http://elixir.free-electrons.com/linux/latest/source,&lt;/a> Linux Kernel 源码阅读利器。&lt;/li>
&lt;/ol></description></item><item><title>Ext4文件系统架构分析(一)(转)</title><link>https://justice.bj.cn/post/21.linux/ext4%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/ext4%E4%BB%8B%E7%BB%8D/</guid><description>&lt;h2 id="ext4文件系统架构分析一转">Ext4文件系统架构分析(一)(转)&lt;/h2>
&lt;p>本文描述Ext4文件系统磁盘布局和元数据的一些分析，同样适用于Ext3和Ext2文件系统，除了它们不支持的Ext4的特性外。整个分析分两篇博文，分别概述布局和详细介绍各个布局的数据结构及组织寻址方式等。感兴趣的看官敬请留意和指导！&lt;/p>
&lt;h2 id="1-ext4文件系统布局综述">1. Ext4文件系统布局综述&lt;/h2>
&lt;p>一个Ext4文件系统被分成一系列块组。为减少磁盘碎片产生的性能瓶颈，块分配器尽量保持每个文件的数据块都在同一个块组中，从而减少寻道时间。以4KB的数据块为例，一个块组可以包含32768个数据块，也就是128MB。&lt;/p>
&lt;h2 id="11磁盘布局">1.1 磁盘布局&lt;/h2>
&lt;p>Ext4文件系统的标准磁盘布局如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-26-23-28989651_13764045230xDi.jpg" alt="">&lt;/p>
&lt;p>Ext4文件系统主要使用块组0中的超级块和块组描述符表，在其他一些特定块组中有超级块和块组描述符表的冗余备份。如果块组中不含冗余备份，那么块组就以数据块位图开始。当格式化磁盘成为Ext4文件系统的时候，mkfs将在块组描述符表后面分配预留GDT表数据块(“Reserve GDT blocks”)以用于将来扩展文件系统。紧接在预留GDT表数据块后的是数据块位图与inode表位图，这两个位图分别表示本块组内的数据块与inode表的使用，inode表数据块之后就是存储文件的数据块了。在这些各种各样的块中，超级块、GDT、块位图、Inode位图都是整个文件系统的元数据，当然inode表也是文件系统的元数据，但是inode表是与文件一一对应的，我更倾向于将inode当做文件的元数据，因为在实际格式化文件系统的时候，除了已经使用的十来个外，其他inode表中实际上是没有任何数据的，直到创建了相应的文件才会分配inode表，文件系统才会在inode表中写入与文件相关的inode信息。&lt;/p>
&lt;h2 id="12flexible块组flex_bg">1.2 Flexible 块组（flex_bg）&lt;/h2>
&lt;p>Flexible 块组（flex_bg）是从Ext4开始引入的新特性。在一个flex_bg中，几个块组在一起组成一个逻辑块组flex_bg。Flex_bg的第一个块组中的位图空间和inode表空间扩大为包含了flex_bg中其他块组上位图和inode表。&lt;/p>
&lt;p>比如flex_bg包含4个块组，块组0将按序包含超级块、块组描述符表、块组0-3的数据块位图、块组0-3的inode位图、块组0-3的inode表，块组0中的其他空间用于存储文件数据。同时，其他块组上的数据块位图、inode位图、inode表元数据就不存在了，但是SB和GDT还是存在的。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-26-33-28989651_1376404620OKyF.jpg" alt="">&lt;/p>
&lt;p>Flexible块组的作用是：&lt;/p>
&lt;ol>
&lt;li>聚集元数据，加速元数据载入；&lt;/li>
&lt;li>使得大文件在磁盘上尽量连续；&lt;/li>
&lt;/ol>
&lt;p>即使开启flex_bg特性，超级块和块组描述符的冗余备份仍然位于块组的开头。 Flex_bg中块组的个数由2^ext4_super_block.s_log_groups_per_flex 给出。&lt;/p>
&lt;h2 id="13元块组metablockgroups">1.3 元块组（Meta Block Groups）&lt;/h2>
&lt;p>通常，在每个冗余备份的超级块的后面是一个完整的(包含所有块组描述符的)块组描述符表的备份。这样会产生一个限制，以Ext4的块组描述符大小64 Bytes计算，文件系统中最多只能有2^21个块组，也就是文件系统最大为256TB。&lt;/p>
&lt;p>使用元块组Meta Block Groups特性，每个块组都包含该块组自己的描述符的冗余备份。因此可以创建2^33个块组，也就是文件系统最大1EB。48位数据块，每个块组128MB，因而可以创建2^33个块组。&lt;/p>
&lt;p>元块组实际上是可以用一个块组描述符块来进行描述的块组集，简单的说，它由一系列块组组成，同时这些块组对应的块组描述符存储在一个块中。它的出现使得Ext3和Ext4的磁盘布局有了一定的变化，以往超级块后紧跟的是变长的GDT块，现在是超级块依然决定于是否是3,5,7的幂，而一个块组描述符块则存储在元块组的第一个，第二个和最后一个块组的开始处(见下图)&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-26-40-28989651_1376404725HTsy.png" alt="">&lt;/p>
&lt;p>(1)  文件系统创建时。用户可以指定使用这种布局。 &lt;/p>
&lt;p>(2)  当文件系统增长而且预留的组描述符块耗尽时。目前超级块中有一个域s_first_meta_bg用于描述第一个使用元块组的块组。 &lt;/p>
&lt;p> 当增加新块组时，我们不需要给组描述符表预留空间，而是在当前文件系统后面直接添加新的元块组就可以了。&lt;/p>
&lt;h2 id="14lazy块组初始化">1.4 Lazy 块组初始化&lt;/h2>
&lt;p>如果块组中的相应标志已设置，那么块组中的inode位图和inode表将不被初始化。这样可以减少mkfs时间，如果开启了块组描述符校验和功能，甚至连块组都可以不初始化。&lt;/p>
&lt;h2 id="15特殊inodes">1.5 特殊inodes&lt;/h2>
&lt;p>Ext4预留了一些inode做特殊特性使用，见下表：&lt;/p>
&lt;p>表 1  Ext4的特殊inode&lt;/p>
&lt;p>Inode号    用途&lt;/p>
&lt;p>0      不存在0号inode&lt;/p>
&lt;p>1      损坏数据块链表&lt;/p>
&lt;p>2      根目录&lt;/p>
&lt;p>3      ACL索引&lt;/p>
&lt;p>4      ACL数据&lt;/p>
&lt;p>5      Boot  loader&lt;/p>
&lt;p>6      未删除的目录&lt;/p>
&lt;p>7      预留的块组描述符inode&lt;/p>
&lt;p>8      日志inode&lt;/p>
&lt;p>11     第一个非预留的inode，通常是lost+found目录&lt;/p>
&lt;h2 id="16数据块和inode分配策略">1.6 数据块和Inode分配策略&lt;/h2>
&lt;p>在机械磁盘上，保持相关的数据块相互接近可以总的磁头移动时间，因而可以加速磁盘IO。在SSD上虽然没有磁头转动，数据局部性可以增加每次IO请求的传输的数据大小，因而减少响应IO请求的传输次数。数据的局部性对单个擦除块的写入产生影响，可以加速文件重写的速度。因而尽可能减少碎片是必要的。inode和数据块的分配策略可以保证数据的局部集中。以下为inode和数据块的分配策略：&lt;/p>
&lt;p>(1)  多块分配可以减少磁盘碎片。当文件初次创建的时候，块分配器预测性地分配8KB的磁盘空间给文件。当文件关闭的时候，未使用的空间当然也就释放了。但是如果推测是正确的，那么文件数据将写到一个多个块的extent中。&lt;/p>
&lt;p>(2)  延迟分配。当一个文件需要更多的数据块引起写操作时，文件系统推迟决定新数据在磁盘上的存放位置，直到脏的buffer写到磁盘为止。&lt;/p>
&lt;p>(3)  尽量保持文件的数据块与其inode在同一个块组中。可以减少磁盘寻道时间.&lt;/p>
&lt;p>(4)  尽量保持同一个目录中的所有inodes与目录位于同一个块组中。这样的假设前提是一个目录中的文件是相关的。&lt;/p>
&lt;p>(5)  磁盘卷被分成128MB的块组。当在根目录中创建目录时，inode分配器扫描块组并将新目录放到它找到的使用负荷最小的块组中。这可以保证目录在磁盘上的分散性。&lt;/p>
&lt;p>(6)  即使上述机制无效，仍然可以使用e4defrag整理碎片文件。&lt;/p>
&lt;h2 id="17超级块">1.7 超级块&lt;/h2>
&lt;p>超级块记录整个文件系统的大量信息，如数据块个数、inode个数、支持的特性、管理信息，等待。&lt;/p>
&lt;p>如果设置sparse_super特性标志，超级块和块组描述符表的冗余备份仅存放在编号为0或3、5、7的幂次方的块组中。如果未设置sparse_super特性标志，冗余备份存在与所有的块组中。以下是2.6.32.18内核中对Ext4超级块的描述：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-11-28989651_1376493519z4rQ.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-15-28989651_1376493582Lvr6.png" alt="">&lt;/p>
&lt;p>3.0的内核中，Ext4的超级块加入了以下相关元数据：快照、文件系统错误处理相关、挂载选项、配额文件inode、超级块校验和等，见下图。目前没有深入研究这些新的元数据。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-21-28989651_1376493600Aq8i.png" alt="">&lt;/p>
&lt;h2 id="18块组描述符">1.8 块组描述符&lt;/h2>
&lt;p>一个块组中，具有固定位置的数据结构是超级块和块组描述符。其他数据结构位置都可以不固定。Flex_bg机制使用这个性质将几个块组聚合成一个flex块组，将flex_bg中所有位图和inode 表放到flex_bg的第一个块组中。详细情况可以参考我的上一篇Ext4分析博文的Flexible 块组（flex_bg）部分。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-25-28989651_1376493616YUiG.png" alt="">&lt;/p>
&lt;h2 id="19数据块位图与inode位图">1.9 数据块位图与inode位图&lt;/h2>
&lt;p>数据块位图跟踪块组中数据块使用情况。Inode位图跟踪块组中Inode使用情况。每个位图一个数据块，每一位用0或1表示一个块组中数据块或inode表中inode的使用情况。如果一个数据块大小是4KB的话，那一个位图块可以表示4&lt;em>1024&lt;/em>8个数据块的使用情况，这也是单个块组具有的最大数据块个数。这样可以算出一个块组大小是128MB。当然一个位图块也可以表示4&lt;em>1024&lt;/em>8个inode的使用情况，但是实际上一个块组中即使存满了文件，也不会用到这么多的inode，因为实际系统中基本不会出现所有文件大小都小于等于1个数据块大小的情况。实际上一个块组中有多少个inode，在块组描述符中是确定的，在文件系统格式化过程中也会看到这个数值，如果没记错的话，大概是每4个还是8个数据块分配一个inode空间。&lt;/p>
&lt;h2 id="110inode表">1.10 Inode表&lt;/h2>
&lt;p>为了找到与一个文件相关的信息，必须遍历目录文件找到与文件相关的目录项，然后加载inode找到该文件的元数据。Ext4在目录项中用一位存储了文件类型(通常存储在inode中)的拷贝，这对性能提升有益。Inode表的大小为ext4_super_block.s_inode_size * ext4_super_block.s_inodes_per_group Bytes。 &lt;br>
&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-33-28989651_13764936686K5v.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-27-41-28989651_13764936937EGO.png" alt="">&lt;/p>
&lt;h2 id="111查找inode">1.11 查找inode&lt;/h2>
&lt;p>每个块组包含ext4_super_block.s_inodes_per_group个inodes。因为0号inode不存在，可以通过如下的算式计算inode所在的块组：&lt;/p>
&lt;p>&lt;code>bg=(inode_num -1)/ ext4_super_block.s_inodes_per_group&lt;/code>&lt;/p>
&lt;p>inode在块组中inode表中的索引index可以通过如下的算式计算：&lt;/p>
&lt;p>&lt;code>index=(inode_num -1) % ext4_super_block.s_inodes_per_group&lt;/code>&lt;/p>
&lt;p>inode在inode表中的地址偏移为：&lt;/p>
&lt;p>&lt;code>offset=index * ext4_super_block.s_inode _size&lt;/code>&lt;/p>
&lt;h2 id="112inodei_block0s的内容">1.12 inode.i_block0[]s的内容&lt;/h2>
&lt;p>取决于文件类型，inode.i_blocks[]使用的方式不同。一般来说，常规文件和目录用inode.i_blocks[]作为文件数据块索引信息，特殊文件将inode.i_blocks[]用于特殊用途。常规文件用inode.i_blocks[]作为文件数据块索引信息的三级索引结构会在后面直接、间接块地址中详细介绍。&lt;/p>
&lt;h2 id="113-符号链接">1.13  符号链接&lt;/h2>
&lt;p>如果符号链接的目标字符串长度小于60字节，那么就将其存储在inode.i_blocks[]中，inode中inode.i_blocks[]占据的大小刚好是60KB。这里要注意到的是，有些文件其内容是跟文件的元数据放在一起的，因而就没有了数据块。也就是说不是每个文件数据都必然占据着一个数据块。&lt;/p>
&lt;h2 id="114直接间接块地址">1.14 直接/间接块地址&lt;/h2>
&lt;p> Ext2/Ext3中数据块映射方式如下表&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-28-43-28989651_1376493721DQi6.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-28-48-28989651_1376493732tfez.png" alt="">&lt;/p>
&lt;h2 id="115extent树">1.15   Extent 树&lt;/h2>
&lt;p>Ext4中用extent树代替了逻辑块映射。使用extents，用一个struct ext4_extent结构就可以映射多个数据块，减少元数据块的使用。如果设置了flex_bg，甚至可以用一个extent分配一个非常大的文件。使用extent特性，inode必须设置extents flag。&lt;/p>
&lt;p>Extents以树的方式安排。Extent树的每个节点都以一个ext4_extent_header开头，如果节点是内部节点(ext4_extent_header.eh_depth&amp;gt;0)，ext4_extent_header后面紧跟的是ext4_extent_header .eh_entries个索引项struct ext4_extent_idx，每个索引项指向该extent树中一个包含更多的节点的数据块。如果节点是叶子节点(ext4_extent_header.eh_depth==0)，ext4_extent_header后面紧跟的是ext4_extent_header .eh_entries个struct ext4_extent数据结构。这些ext4_extent结构指向文件数据块。Extent树的根结点存储在inode.i_blocks中，可以存储文件的前4个extents而不需额外的元数据块。&lt;/p>
&lt;p>ext4_extent_header：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-28-54-28989651_1376493751828X.png" alt="">&lt;/p>
&lt;p>struct ext4_extent_idx：extent树的内部节点，也称为索引节点。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201308/14/28989651_1376493761Or0J.jpg" alt="">&lt;/p>
&lt;p>ext4_extent：extent树的叶子节点。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-29-08-28989651_1376493772mVMU.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/11/22-14-29-03-28989651_13764937882FDI.png" alt="">&lt;/p>
&lt;h2 id="116extent树数据块校验和可能加入的新元数据">1.16 Extent树数据块校验和：可能加入的新元数据&lt;/h2>
&lt;p>由于extent树的根在inode中，因而Extent树数据块指extent树的除根据节点外的所有内部节点和叶子节点。Extent的树根节点和叶子节点的数据块中存储完xt4_extent_idx和xt4_extent数据结构后至少会留下4 ((2^x%12)&amp;gt;=4) bytes的空间。因而可以加入一个结构struct ext4_extent_tail，其中存储32位的校验和。位于inode中的4个extents无需校验和，因为inode已经做了校验和。&lt;/p>
&lt;h2 id="117目录项">1.17 目录项&lt;/h2>
&lt;p>Ext4文件系统中，一个目录差不多是一个平面文件，映射任意长度的字符串到文件系统中的一个inode。文件系统中存在多个目录项引用同一个inode——硬链接，这也是硬链接不能链接其他文件系统中的文件的原因。&lt;/p>
&lt;h2 id="118线性经典目录">1.18 线性（经典）目录&lt;/h2>
&lt;p>缺省地，目录文件中包含一个线性的目录项数组。未使用的目录项标记为inode =0。Ext4文件系统默认地使用struct ext4_dir_entry_2记录目录项，除非没有设置filetype特性标志。在没有设置filetype特性标志的情况下，使用struct ext4_dir_entry记录目录项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">struct&lt;/span> &lt;span class="n">ext4_dir_entry&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="n">__le32&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__le16&lt;/span> &lt;span class="n">rec_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__le16&lt;/span> &lt;span class="n">name_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">EXT4_NAME_LEN&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">ext4_dir_entry_2&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="n">__le32&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__le16&lt;/span> &lt;span class="n">rec_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__u8&lt;/span> &lt;span class="n">name_len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">__u8&lt;/span> &lt;span class="n">file_type&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">EXT4_NAME_LEN&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="119哈希树目录">1.19 哈希树目录&lt;/h2>
&lt;p>线性目录项不利于系统性能提升。因而从ext3开始加入了快速平衡树哈希目录项名称。如果在inode中设置EXT4_INDEX_FL标志，目录使用哈希的B树（hashed btree ，htree）组织和查找目录项。为了向后只读兼容Ext2，htree实际上隐藏在目录文件中。&lt;/p>
&lt;p>Ext2的惯例，树的根总是在目录文件的第一个数据块中。“.”和“..”目录项必须出现在第一个数据块的开头。因而这两个目录项在数据块的开头存放两个struct ext4_dir_entry_2结构，且它们不存到树中。根结点的其他部分包含树的元数据，最后一个hash-&amp;gt;block map查找到htree中更低的节点。如果dx_root.info.indirect_levels不为0，那么htree有两层；htree根结点的map指向的数据块是一个内部节点，由一个minor hash索引。Htree中的内部节点的minor_hash-&amp;gt;block map之后包含一个零化的(zeroed out) structext4_dir_entry_2找到叶子节点。叶子节点包括一个线性的struct ext4_dir_entry_2数组；所有这些项都哈希到相同的值。如果发生溢出，目录项简单地溢出到下一个叶子节点，哈希的least-significant位（内部节点的map）做相应设置。&lt;/p>
&lt;p>       以htree的方式遍历目录，计算要查找的目录文件名称的哈希值，然后使用哈希值找到对应的数据块号。如果树是flat，该数据块是目录项的线性数组，因而可被搜索到；否则，计算文件名称的minor hash，并使用minor hash查找相应的第三个数据块号。第三个数据块是目录项线性数组。&lt;/p>
&lt;p>**Htree的根 ：**struct dx_root&lt;br>
&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838358542Gih.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>Htree****的内部节点：&lt;/strong> struct dx_node&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838359310LhJ.jpg" alt="">&lt;/p>
&lt;p>Htree 树根和节点中都存在的 &lt;strong>Hash map&lt;/strong>**：** struct dx_entry&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383835946jC8F.jpg" alt="">&lt;/p>
&lt;h2 id="120扩展属性ea">1.20 扩展属性EA&lt;/h2>
&lt;p>扩展属性（xattrs）通常存储在磁盘上的一个单独的数据块中，通过inode.i_file_acl*引用。扩展属性的第一应用是存储文件的ACL以及其他安全数据(selinux)。使用user_xattr挂载选项就可为用户存储以“user”开头的所有扩展属性。这样的限制在3.0内核中已经消失。&lt;/p>
&lt;p>可以在两个地方找到扩展属性：一是在一个inode项结尾到下一个inode项开头的地方；二是inode.i_file_acl指向 的数据块之中，到3.0为止，这个数据块中不包含指向第二个扩展属性数据块的指针。理论上可以将每个属性值存储到一个单独的数据块中，但是3.0内核为止仍然没有这样做。&lt;/p>
&lt;p>当扩展属性不存储在一个inode之后的时候，就会有一个头部ext4_xattr_ibody_header&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836044J1Ee.jpg" alt="">&lt;/p>
&lt;p>扩展属性数据块的开头是ext4_xattr _header&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836053bZMK.jpg" alt="">&lt;/p>
&lt;p>紧跟在ext4_xattr_ibody_header或者ext4_xattr _header后面的是结构数组 struct ext4_xattr_entry&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838360603T4T.jpg" alt="">&lt;/p>
&lt;p>扩展属性值可以紧跟在ext4_xattr_entry项表后面。考虑4 bytes对齐。扩展属性值从扩展属性数据块的末尾开始向ext4_xattr _header / ext4_xattr_entry表的方向增长。当发生溢出时，溢出的部分放到一个单独的磁盘数据块上。&lt;/p>
&lt;h2 id="121日志jbd2">1.21 日志（JBD2）&lt;/h2>
&lt;p>文件系统在磁盘上保留一段小的连续区域(默认128MB)，作为尽可能需要快速写入磁盘的“重要”数据的存放地。一旦该重要数据事务完全写到磁盘，将其从磁盘写缓存中刷出。被提交的数据一份记录也被写到日志。一段时间后，日志在擦除提交记录前将事务写到它们在磁盘上的最终位置(可能包含大量的寻道或者大量的读-写-擦除)。&lt;/p>
&lt;p>从性能方面考虑，Ext4默认直接将文件系统元数据写到日志。因而不能保证文件数据块的一致性。&lt;/p>
&lt;p>       日志的inode为8。日志inode的前68 bytes复制了ext4 超级块。日志文件在文件系统中是普通文件，但是隐藏不可见。日志文件通常消耗一个完整的块组，可以通过mke2fs将日志文件放在磁盘的中间。&lt;/p>
&lt;p>Ext4和Ocfs2都使用JBD2。&lt;/p>
&lt;h3 id="1211布局">1.21.1 布局&lt;/h3>
&lt;p>日志布局&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836366A8dq.jpg" alt="">&lt;/p>
&lt;p>一个事务以描述符和一些数据或者block revocation链表开始。一个结束的事务总是以一个提交块结束。如果没有提交记录（或者校验和不匹配），事务在日志重演的时候将被丢弃。&lt;/p>
&lt;h3 id="1212-数据块头部">1.21.2  数据块头部&lt;/h3>
&lt;p>日志中的每个数据块的开头都是一个12 bytes的数据结构 struct journal_header_s&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836376fBf6.jpg" alt="">&lt;/p>
&lt;h3 id="1213-超级块">1.21.3  超级块&lt;/h3>
&lt;p>日志的超级块比Ext4的超级块简单。保存在日志的超级块中是日志的关键数据。日志超级块使用数据结构struct journal_superblock_s表示，大小为1024 bytes。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836388Dhwt.jpg" alt="">&lt;/p>
&lt;h3 id="1214-描述数据块descriptor-block">1.21.4  描述数据块Descriptor Block&lt;/h3>
&lt;p>Descriptor Block包含一个日志数据块tags的数组，这些tags描述了日志中接下来的数据块的最终位置。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836398lSZl.jpg" alt="">&lt;/p>
&lt;p>日志数据块tags具有如下格式：由数据结构struct journal_block_tag_s表示，可以是8，12，24或38bytes。&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_13838364075ta9.jpg" alt="">&lt;/p>
&lt;h3 id="1215-数据块data-block">1.21.5  数据块Data Block&lt;/h3>
&lt;p>存放的是通过日志写到磁盘的数据块。但是如果数据块的前4 bytes与jbd2的魔数匹配，那么这些4 bytes用0代替，并且在Descriptor Block中设置escaped。&lt;/p>
&lt;p>&lt;strong>1.21.6  Revocation Block&lt;/strong>&lt;/p>
&lt;p>Revocation block用于记录本事务中的数据块链表，取代任何潜在日志中的更陈旧的数据块这样可以加速恢复，因为陈旧的数据块不必写到磁盘。&lt;/p>
&lt;p>Revocation block使用 structjbd2_journal_revoke_header_s结构表示&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836484127L.jpg" alt="">&lt;/p>
&lt;h3 id="1217-提交块">1.21.7  提交块&lt;/h3>
&lt;p>提交快表明了一个事务已完整写到日志。一旦提交块到达日志，存储在该事务中的数据可以写到它们在磁盘中的最终位置。&lt;/p>
&lt;p>提交快由数据结构struct commit_header表示：&lt;/p>
&lt;p>&lt;img src="http://blog.chinaunix.net/attachment/201311/7/28989651_1383836493RAT5.jpg" alt="">&lt;/p></description></item><item><title>FUSE- linux用户空间文件系统(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bfuse/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bfuse/</guid><description>&lt;h1 id="fuse-linux用户空间文件系统转">FUSE: linux用户空间文件系统(转)&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>用户空间文件系统 是操作系统中的概念，指完全在用户态实现的文件系统。&lt;/p>
&lt;p>目前Linux通过内核模块对此进行支持。一些文件系统如ZFS，glusterfs使用FUSE实现。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/209af4d9f14a2bf12bd44e9d77b47eaa_1174x826.png" alt="">&lt;/p>
&lt;p>FUSE的工作原理如上图所示。&lt;/p>
&lt;p>假设基于FUSE的用户态文件系统hello挂载在/tmp/fuse目录下。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当应用层程序要访问/tmp/fuse下的文件时，通过glibc中的函数进行系统调用，处理这些系统调用的VFS中的函数会调用FUSE在内核中的文件系统；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核中的FUSE文件系统将用户的请求，发送给用户态文件系统hello；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户态文件系统收到请求后，进行处理，将结果返回给内核中的FUSE文件系统；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，内核中的FUSE文件系统将数据返回给用户态程序。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Linux IO 之 IO与网络模型</title><link>https://justice.bj.cn/post/21.linux/linux-io-%E4%B9%8B-io%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux-io-%E4%B9%8B-io%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="linux-io-之-io与网络模型">Linux IO 之 IO与网络模型&lt;/h1>
&lt;p>&lt;img src="https://img.kancloud.cn/3a/19/3a190c1c6a523a9dd47174ede0e7a557_703x536.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>atomic 原子变量: x86在多核环境下，多核竞争数据总线时，提供Lock指令进行锁总线操作。保证“读-修改-写”的操作在芯片级的原子性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>spinlock 自旋锁: 自旋锁将当前线程不停地执行循环体，而不改变线程的运行状态，在CPU上实现忙等，以此保证响应速度更快。这种类型的线程数不断增加时，性能明显下降。所以自旋锁保护的临界区必须小，操作过程必须短。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>semaphore 信号量: 信号量用于保护有限数量的临界资源，信号量在获取和释放时，通过自旋锁保护，当有中断会把中断保存到eflags寄存器，最后再恢复中断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mutex 互斥锁: 为了控制同一时刻只有一个线程进入临界区，让无法进入临界区的线程休眠。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rw-lock 读写锁: 读写锁，把读操作和写操作分别进行加锁处理，减小了加锁粒度，优化了读大于写的场景。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="preempt-抢占">preempt 抢占&lt;/h2>
&lt;ul>
&lt;li>时间片用完后调用schedule函数。&lt;/li>
&lt;li>由于IO等原因自己主动调用schedule。&lt;/li>
&lt;li>其他情况，当前进程被其他进程替换的时候。&lt;/li>
&lt;/ul>
&lt;h2 id="per-cpu-变量">per-cpu 变量&lt;/h2>
&lt;p>linux为解决cpu 各自使用的L2 cache 数据与内存中的不一致的问题。&lt;/p>
&lt;h2 id="rcu机制-read-copy-update">RCU机制 (Read, Copy, Update)&lt;/h2>
&lt;p>用于解决多个CPU同时读写共享数据的场景。它允许多个CPU同时进行写操作，不使用锁，并且实现垃圾回收来处理旧数据。&lt;br>
&lt;img src="https://img.kancloud.cn/eb/25/eb25aceb1f3a87e34bc659922a23fb7f_850x379.png" alt="">&lt;/p>
&lt;h2 id="内存屏障-memory-barrier">内存屏障 memory-barrier&lt;/h2>
&lt;p>程序运行过程中，对内存访问不一定按照代码编写的顺序来进行。&lt;/p>
&lt;ol>
&lt;li>编译器对代码进行优化。&lt;/li>
&lt;li>多cpu架构存在指令乱序访问内存的可能。&lt;/li>
&lt;/ol>
&lt;h1 id="io-与网络模型">I/O 与网络模型&lt;/h1>
&lt;p>介绍各种各样的I/O模型，包括以下场景：&lt;/p>
&lt;ol>
&lt;li>阻塞 &amp;amp; 非阻塞&lt;/li>
&lt;li>多路复用&lt;/li>
&lt;li>Signal IO&lt;/li>
&lt;li>异步 IO&lt;/li>
&lt;li>libevent&lt;/li>
&lt;/ol>
&lt;p>现实生活中的场景复杂，Linux CPU和IO行为，他们之间互相等待。例如，阻塞的IO可能会让CPU暂停。&lt;/p>
&lt;p>I/O模型很难说好与坏，只能说在某些场景下，更适合某些IO模型。其中，1、4 更适合块设备，2、3 更适用于字符设备。&lt;/p>
&lt;p>为什么硬盘没有所谓的 多路复用，libevent，signal IO？&lt;/p>
&lt;p>因为select(串口), epoll（socket） 这些都是在监听事件，所以各种各样的IO模型，更多是描述字符设备和网络socket的问题。但硬盘的文件，只有读写，没有 epoll这些。这些IO模型更多是在字符设备，网络socket的场景。&lt;/p>
&lt;h2 id="为什么程序要选择正确的io模型">为什么程序要选择正确的IO模型？&lt;/h2>
&lt;p>蓝色代表：cpu，红色代表：io&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/2362bcb8a9159af33c0ec6d3e701c3df_1876x1340.png" alt="">&lt;/p>
&lt;p>如上图，某个应用打开一个图片文件，先需要100ms初始化，接下来100ms读这个图片。那打开这个图片就需要200ms。&lt;/p>
&lt;p>但是 是否可以开两个线程，同时做这两件事？&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/561dc951ee90a91df7d4de84ec3e88ce_1538x1128.png" alt="">&lt;/p>
&lt;p>如上图，网络收发程序，如果串行执行，CPU和IO会需要互相等待。&lt;br>
为什么CPU和IO可以并行？因为一般硬件，IO通过DMA，cpu消耗比较小，在硬件上操作的时间更长。CPU和硬盘是两个不同的硬件。&lt;/p>
&lt;p>再比如开机加速中systemd使用的readahead功能:&lt;br>
第一次启动过程，读的文件，会通过Linux inotify监控linux内核文件被操作的情况，记录下来。第二次启动，后台有进程直接读这些文件，而不是等到需要的时候再读。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/7bcb94f8c0d49a964dabf226688164cc_1244x954.png" alt="">&lt;/p>
&lt;p>I/O模型会深刻影响应用的最终性能，阻塞 &amp;amp; 非阻塞 、异步 IO 是针对硬盘， 多路复用、signal io、libevent 是针对字符设备和 socket。&lt;/p>
&lt;h2 id="简单的io模型">简单的IO模型&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/97be9252cd80c3254efc34e477cfb28a_1242x742.png" alt="">&lt;/p>
&lt;p>当一个进程需要读 键盘、触屏、鼠标时，进程会阻塞。但对于大量并发的场景，阻塞IO无法搞定，也可能会被信号打断。&lt;/p>
&lt;p>内核程序等待IO，gobal fifo read不到&lt;/p>
&lt;p>一般情况select返回，会调用 if signal_pending，进程会返回 ERESTARTSYS；此时，进程的read 返回由singal决定。有可能返回（EINTR），也有可能不返回。&lt;/p>
&lt;h3 id="demo">demo:&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;errno.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sig_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">signum&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;int handler %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">signum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">ssize_t&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">sigaction&lt;/span> &lt;span class="n">oldact&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">sigaction&lt;/span> &lt;span class="n">act&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">act&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sa_handler&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sig_handler&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">act&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sa_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// act.sa_flags |= SA_RESTART;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sigemptyset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">act&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sa_mask&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">sigaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SIGUSR1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">act&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">oldact&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sigaction failed!/n&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">bzero&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">STDIN_FILENO&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">errno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">EINTR&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;retry after eintr&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">errno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">EINTR&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;read %d bytes, content is %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://box.kancloud.cn/d8477b6d3cf9bcc5804f316ea0246aef_719x709.png" alt="">&lt;/p>
&lt;p>一个阻塞的IO，在睡眠等IO时Ready，但中途被信号打断，linux响应信号，read/write请求阻塞。&lt;br>
配置信号时，在SA_FLAG是不是加“自动”，SA_RESTART指定 被阻塞的IO请求是否重发，并且应用中可以捕捉。加了SA_RESTART重发，就不会返回出错码EINTR。&lt;br>
没有加SA_RESTART重发，就会返回出错码（EINTR），这样可以检测read被信号打断时的返回。&lt;/p>
&lt;p>但Linux中有一些系统调用，即便你加了自动重发，也不能自动重发。man signal.&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/4708e2b53d43c11f9d32c0d590f0711a_2172x938.png" alt="">&lt;/p>
&lt;p>当使用阻塞IO时，要小心这部分。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/c92635e764196130ce6938048bed23f3_2258x1366.png" alt="">&lt;/p>
&lt;h2 id="多进程多线程模型">多进程、多线程模型&lt;/h2>
&lt;p>当有多个socket消息需要处理，阻塞IO搞不定，有一种可能是多个进程/线程，每当有一个连接建立（accept socket)，都会启动一个线程去处理新建立的连接。但是，这种模型性能不太好，创建多进程、多线程时会有开销。&lt;/p>
&lt;p>经典的C10K问题，意思是 在一台服务器上维护1w个连接，需要建立1w个进程或者线程。那么如果维护1亿用户在线，则需要1w台服务器。&lt;/p>
&lt;p>IO多路复用，则是解决以上问题的场景。&lt;/p>
&lt;p>总结：多进程、多线程模型企图把每一个fd放到不同的线程/进程处理，避免阻塞的问题，从而引入了进程创建\撤销，调度的开销。能否在一个线程内搞定所有IO? &amp;ndash; 这就是&lt;code>多路复用&lt;/code>的作用。&lt;/p>
&lt;h2 id="多路复用">多路复用&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/4ddb3f8f232beb837f294c27011cc050_2174x1226.png" alt="">&lt;/p>
&lt;h3 id="heading">&lt;/h3>
&lt;h3 id="异步io">异步IO&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/03f7f8364fe3a3f4db456252f83755b3_1454x906.png" alt="">&lt;/p>
&lt;p>Linux中&lt;/p>
&lt;p>不要把aio串起来，&lt;/p>
&lt;p>基于epoll等api进行上层的封装，再基于事件编程。某个事件成立了，就开始去做某件事。&lt;/p>
&lt;h3 id="libevent">libevent&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/503a1ac368ec755abf62083f1573099a_1150x798.png" alt="">&lt;/p>
&lt;p>就像MFC一样，界面上的按钮，VC会产生一个on_button，调对应的函数。是一种典型的事件循环。&lt;/p>
&lt;p>本质上还是用了epoll，只是基于事件编程。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/869403b17eca63bf85ec38d2a99be3b1_1146x812.png" alt="">&lt;/p>
&lt;p>点赞&lt;/p></description></item><item><title>Linux IO 之 文件系统的架构(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84/</guid><description>&lt;h1 id="linux-io-之-文件系统的架构转">Linux IO 之 文件系统的架构(转)&lt;/h1>
&lt;h3 id="vfs和文件系统总结">VFS和文件系统总结&lt;/h3>
&lt;p>一切都是文件： VFS&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/42fc84d8385cd6f0bf3c2573f2e58eea_1702x1054.png" alt="">&lt;/p>
&lt;p>文件系统的设计，类似 抽象基类，面向对象的思想。&lt;/p>
&lt;p>虚函数都必须由底层派生出的实例实现，使用成员函数 file_operations。在linux里面的文件操作，底层都要实现file_operations，抽象出owner，write，open，release。所以，无论是字符块，还是文件系统的文件，最终操作就必须是file_operations。&lt;/p>
&lt;p>例如，实现一个字符设备驱动，就是去实现file_operations。VFS_read时就会调用字符设备的file_operations。&lt;/p>
&lt;hr>
&lt;p>块设备的两种访问方法，一是访问裸分区，二是访问文件系统。&lt;/p>
&lt;p>当直接访问裸分区，是通过fs/block_dev.c 中的 file_operations def_blk_fops，也有read,write,open，一切继承到file_operations。如果是访问文件系统，就会通过实现 {ext4}_file_operations 来对接VFS对文件的操作。&lt;/p>
&lt;p>块设备驱动就不需要知道file_operations，无论是裸设备，还是文件系统的file。他们实现的file_operations是把linux中的各种设备，hook进 VFS的方法。&lt;/p>
&lt;h3 id="文件最终如何转化成对磁盘的访问">文件最终如何转化成对磁盘的访问？&lt;/h3>
&lt;p>file_operation 跟pagecache 以及硬盘的关系？&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/1072c5381bd5ae4a96ebd0ec110a1a25_1686x1186.png" alt="">&lt;/p>
&lt;p>整个文件系统里，除了放文件本身的数据，还包括文件的管理数据，包括&lt;/p>
&lt;ul>
&lt;li>
&lt;p>super block，保存在全局的 superblock结构中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>inode，是文件的唯一特定标识，文件系统使用bitmap来标识，inode是否使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>block bitmap，来表示这些block是否占用，它在改变文件大小，创建删除等操作时，都会改变。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>inode table/diagram ： bitmap 只是表示inode和block是否被占用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://box.kancloud.cn/f00f3c82d9785e742b49db1975721a00_1666x1202.png" alt="">&lt;/p>
&lt;h3 id="超级块目录inode">超级块、目录、inode&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>file_system_type 数据结构： 指的是 文件系统的类型，mount/umount 的时候会用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>superblock数据结构：包含super_operations，其中包含如何分配/销毁一个inode。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>inode 数据结构：包含 inode_operations 和 file_operations。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> file_operations里面记录这种类型的文件，包含哪些操作。
inode_operations里面包含如何生成新的inode，根据文件名字找到inode，如何mkdir,unlink.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>dentry 数据结构: 对应路径，目录在文件系统里面是一个特殊的文件，文件的内容是一个inode和文件的表格。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>file 数据结构:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://box.kancloud.cn/8d9afa6c6797f98151f5f2ef9835d096_796x509.png" alt="">&lt;/p>
&lt;ul>
&lt;li>inode表：包含文件的一些基本信息，大小，创建日期，属性。还有一些成员指向硬盘所在的位置。&lt;br>
申请slab区域，比如 ext4_inode_cache , ext3_inode_cache. 这些cache会创建单独的slab，这些slab和内存里的page一一对应。&lt;/li>
&lt;/ul>
&lt;p>ext2/ext4文件系统中存在间接映射表。&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/aedf91b68e0ddc9140f5cca3a57f162b_1574x1116.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/d2504c197b79aecf377855f29a810ba1_1498x1112.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/8116806badcf819ebf297c067976978c_1596x1094.png" alt="">&lt;/p>
&lt;p>硬盘里的inode diagram里的数据结构，在内存中会通过slab分配器，组织成 xxx_inode_cache，出现在meminfo的可回收的内存。 inode表也会记录每一个inode 在硬盘中摆放的位置。&lt;/p>
&lt;h3 id="目录的组织">目录的组织&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/43f11c7e2cc0fcc45e7891c932f82895_1464x1074.png" alt="">&lt;/p>
&lt;p>目录在硬盘里是一个特殊的文件，和之前的file结构体不同。目录在硬盘中对应一个inode，记录文件的名字和inode号。查找一个文件时，文件系统的 根inode和目录，根据根目录和根inode，找到根目录所在硬盘的位置。再去做字符串匹配，能够找到 /A/B/ 。inode表也会记录每一个inode 在硬盘中摆放的位置。&lt;/p>
&lt;h3 id="发现并读取usrbinxxx的全流程">发现并读取/usr/bin/xxx的全流程&lt;/h3>
&lt;p>&lt;img src="https://box.kancloud.cn/44f2fbe905a636b07986d3b69f795351_1680x1066.png" alt="">&lt;/p>
&lt;p>如上图，当你在硬盘查找 /usr/bin/emacs文件时，从根的inode和dentry，根据/的inode表，找到/ 目录文件所在的硬盘中的位置，读硬盘/目录文件的内容，发现 usr 对应inode 2, bin 对应inode 3, share 对应inode4。再去查inode表，inode 2所在硬盘的位置，即/usr 目录文件所在硬盘的位置。读出内容包括 var 对应 inode 10, bin 对应inode 11, opt对应inode 12，。&lt;/p>
&lt;p>这个过程会查找很多inode和 dentry，这些都会通过 icache 和dcache缓存。&lt;/p>
&lt;h2 id="符号链接-与-硬链接">符号链接 与 硬链接&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/b52f2fdfec772ded1282a69aa9e56b53_1216x794.png" alt="">&lt;/p>
&lt;p>文件名是特殊目录文件的内容，比如 A目录下有b\c\d，其实就是 A这个目录文件，里面对应目录b,c,d和对应inode的表。&lt;/p>
&lt;p>硬链接：在硬盘中是同一个inode存在，在目录文件中多了一个目录和inode对应。&lt;/p>
&lt;p>符号链接：是linux中是真实存在的实体文件，文件内容指向 其他文件。符号链接和文件是不同的inode。&lt;/p>
&lt;ol>
&lt;li>硬链接不能跨本地文件系统&lt;/li>
&lt;li>硬链接不能针对目录&lt;/li>
&lt;li>针对目录的软链接，用rm -fr 删除不了目录里的内容&lt;/li>
&lt;li>针对目录的软链接，&amp;ldquo;cd ..&amp;ldquo;进的是软链接所在目录的上级目录&lt;/li>
&lt;li>可以对文件执行unlink或rm，但是不能对目录执行unlink&lt;/li>
&lt;/ol>
&lt;h2 id="文件系统中的icache-和-dcache">文件系统中的icache 和 dcache&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/4200715ec3487a8ffb56d2281824275b_1204x806.png" alt="">&lt;/p>
&lt;p>文件系统在实现时，在vfs这一层的 inode cache 和 dentry cache，不管硬盘的系统，跨所有文件系统的通用信息。&lt;/p>
&lt;p>针对这些cache，这些可以回收的slab，linux提供了专门的slab shrink- 收缩函数。&lt;br>
最后所有可回收的内存，都必须通过&lt;code>LRU算法&lt;/code>去回收。&lt;br>
有些自己申请的 reclaim的内存，由于没有写 shrink函数，所以就无法进行内存的回收。&lt;/p>
&lt;h2 id="文件读写如何通过file_operation-和pagecache的关系">文件读写如何通过file_operation 和pagecache的关系，&lt;/h2>
&lt;p>&lt;img src="https://box.kancloud.cn/71ce1fb31cdeed119f972c8b1771972c_1524x1100.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/6ed93b05cf6600220d744a0dcae115f9_1126x724.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://box.kancloud.cn/bdbb3ff0a3278c93493379a0f6076fc8_1202x730.png" alt="">&lt;/p>
&lt;h2 id="heading">&lt;/h2></description></item><item><title>Linux 网络包发送过程(转)</title><link>https://justice.bj.cn/post/21.linux/linux-%E7%BD%91%E7%BB%9C%E5%8F%91%E5%8C%85%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux-%E7%BD%91%E7%BB%9C%E5%8F%91%E5%8C%85%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3/</guid><description>&lt;h1 id="linux-网络包发送过程转">Linux 网络包发送过程(转)&lt;/h1>
&lt;p>在开始今天的文章之前，我先来请大家思考几个小问题。&lt;/p>
&lt;ul>
&lt;li>问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？&lt;/li>
&lt;li>问2：为什么你服务器上的 /proc/softirqs 里 NET_RX 要比 NET_TX 大的多的多？&lt;/li>
&lt;li>问3：发送网络数据的时候都涉及到哪些内存拷贝操作？&lt;/li>
&lt;/ul>
&lt;p>这些问题虽然在线上经常看到，但我们似乎很少去深究。如果真的能透彻地把这些问题理解到位，我们对性能的掌控能力将会变得更强。&lt;/p>
&lt;p>带着这三个问题，我们开始今天对 Linux 内核网络发送过程的深度剖析。还是按照我们之前的传统，先从一段简单的代码作为切入。如下代码是一个典型服务器程序的典型的缩微代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AF_INET&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SOCK_STREAM&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>
&lt;span class="n">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>
&lt;span class="n">cfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">accept&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>
&lt;span class="c1">// 接收用户请求
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>
&lt;span class="c1">// 用户请求处理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dosometing&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="c1">// 给用户返回结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>今天我们来讨论上述代码中，调用 send 之后内核是怎么样把数据包发送出去的。本文基于Linux 3.10，网卡驱动采用Intel的igb网卡举例。&lt;/p>
&lt;h2 id="linux-网络发送过程总览">Linux 网络发送过程总览&lt;/h2>
&lt;p>飞哥觉得看 Linux 源码最重要的是得有整体上的把握，而不是一开始就陷入各种细节。&lt;/p>
&lt;p>我这里先给大家准备了一个总的流程图，简单阐述下 send 发送了的数据是如何一步一步被发送到网卡的。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-18543fabe38c2eddcb2f0eba9e0e79f4_720w.jpg" alt="">&lt;/p>
&lt;p>在这幅图中，我们看到用户数据被拷贝到内核态，然后经过协议栈处理后进入到了 RingBuffer 中。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知 CPU，然后清理 RingBuffer。&lt;/p>
&lt;p>因为文章后面要进入源码，所以我们再从源码的角度给出一个流程图。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-b511a062c2803ecfc6931bfdcf3f2b51_720w.jpg" alt="">&lt;/p>
&lt;p>虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。&lt;/p>
&lt;p>那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-4040c1e92f7b492c522848b786285e96_720w.jpg" alt="">&lt;/p>
&lt;p>注意，我们今天的主题虽然是发送数据，但是硬中断最终触发的软中断却是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ ！！！（T 是 transmit 的缩写，R 表示 receive）&lt;/p>
&lt;p>&lt;strong>意不意外，惊不惊喜？？？&lt;/strong>&lt;/p>
&lt;p>所以这就是开篇问题 1 的一部分的原因（注意，这只是一部分原因）。&lt;/p>
&lt;blockquote>
&lt;p>问1：在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？&lt;/p>
&lt;/blockquote>
&lt;p>传输完成最终会触发 NET_RX，而不是 NET_TX。 所以自然你观测 /proc/softirqs 也就能看到 NET_RX 更多了。&lt;/p>
&lt;p>好，现在你已经对内核是怎么发送网络包的有一个全局上的把握了。不要得意，我们需要了解的细节才是更有价值的地方，让我们继续！！&lt;/p>
&lt;p>&amp;mdash; 这里插入一份电子书资料&lt;/p>
&lt;p>飞哥经常会收到读者的私信，询问可否推荐一些书继续深入学习内功。所以我干脆就写了篇文章。把能搜集到的电子版也帮大家汇总了一下，取需！&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/BZv4WpKLB38KsACpJ9csNQ">答读者问，能否推荐几本有价值的参考书(含下载地址)&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-1fad277dcd9842c3db483dbb7a3fbfe9_720w.jpg" alt="">&lt;/p>
&lt;p>资料插播完毕，这回真的继续！！&lt;/p>
&lt;h2 id="二网卡启动准备">&lt;strong>二、网卡启动准备&lt;/strong>&lt;/h2>
&lt;p>现在的服务器上的网卡一般都是支持多队列的。每一个队列上都是由一个 RingBuffer 表示的，开启了多队列以后的的网卡就会对应有多个 RingBuffer。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-ce24c3abe8e58f9fd4d269bd64291347_720w.jpg" alt="">&lt;/p>
&lt;p>网卡在启动时最重要的任务之一就是分配和初始化 RingBuffer，理解了 RingBuffer 将会非常有助于后面我们掌握发送。因为今天的主题是发送，所以就以传输队列为例，我们来看下网卡启动时分配 RingBuffer 的实际过程。&lt;/p>
&lt;p>在网卡启动的时候，会调用到 __igb_open 函数，RingBuffer 就是在这里分配的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">__igb_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">netdev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">resuming&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_adapter&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">adapter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">netdev_priv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">netdev&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//分配传输描述符数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">err&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">igb_setup_all_tx_resources&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">adapter&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//分配接收描述符数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">err&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">igb_setup_all_rx_resources&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">adapter&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//开启全部队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">netif_tx_start_all_queues&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">netdev&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在上面 __igb_open 函数调用 igb_setup_all_tx_resources 分配所有的传输 RingBuffer, 调用 igb_setup_all_rx_resources 创建所有的接收 RingBuffer。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">igb_setup_all_tx_resources&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_adapter&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">adapter&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//有几个队列就构造几个 RingBuffer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">adapter&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">num_tx_queues&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">igb_setup_tx_resources&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">adapter&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>真正的 RingBuffer 构造过程是在 igb_setup_tx_resources 中完成的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">igb_setup_tx_resources&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_ring&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//1.申请 igb_tx_buffer 数组内存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_tx_buffer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tx_buffer_info&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">vzalloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//2.申请 e1000_adv_tx_desc DMA 数组内存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">count&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">union&lt;/span> &lt;span class="n">e1000_adv_tx_desc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ALIGN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">desc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dma_alloc_coherent&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dma&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GFP_KERNEL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//3.初始化队列成员
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next_to_use&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next_to_clean&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从上述源码可以看到，实际上一个 RingBuffer 的内部不仅仅是一个环形队列数组，而是有两个。&lt;/p>
&lt;p>1）igb_tx_buffer 数组：这个数组是内核使用的，通过 vzalloc 申请的。&lt;br>
2）e1000_adv_tx_desc 数组：这个数组是网卡硬件使用的，硬件是可以通过 DMA 直接访问这块内存，通过 dma_alloc_coherent 分配。&lt;/p>
&lt;p>这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-3385217f1469def5689fc0057739df64_720w.jpg" alt="">&lt;/p>
&lt;p>最后调用 netif_tx_start_all_queues 开启队列。另外，对于硬中断的处理函数 igb_msix_ring 其实也是在 __igb_open 中注册的。&lt;/p>
&lt;h2 id="三accept-创建新-socket">&lt;strong>三、accept 创建新 socket&lt;/strong>&lt;/h2>
&lt;p>在发送数据之前，我们往往还需要一个已经建立好连接的 socket。&lt;/p>
&lt;p>我们就以开篇服务器缩微源代码中提到的 accept 为例，当 accept 之后，进程会创建一个新的 socket 出来，然后把它放到当前进程的打开文件列表中，专门用于和对应的客户端通信。&lt;/p>
&lt;p>假设服务器进程通过 accept 和客户端建立了两条连接，我们来简单看一下这两条连接和进程的关联关系。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-52d6007054ead81044fef43870b3cadb_720w.jpg" alt="">&lt;/p>
&lt;p>其中代表一条连接的 socket 内核对象更为具体一点的结构图如下。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-c2bdf3847e53d464b53478491968f6ff_720w.jpg" alt="">&lt;/p>
&lt;p>为了避免喧宾夺主，accept 详细的源码过程这里就不介绍了，感兴趣请参考 &lt;strong>&lt;a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/OmRdUgO1guMX76EdZn11UQ">《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》&lt;/a>&lt;/strong>。一文中的第一部分。&lt;/p>
&lt;p>今天我们还是把重点放到数据发送过程上。&lt;/p>
&lt;h2 id="四发送数据真正开始">&lt;strong>四、发送数据真正开始&lt;/strong>&lt;/h2>
&lt;h3 id="41-send-系统调用实现">&lt;strong>4.1 send 系统调用实现&lt;/strong>&lt;/h3>
&lt;p>send 系统调用的源码位于文件 net/socket.c 中。在这个系统调用里，内部其实真正使用的是 sendto 系统调用。整个调用链条虽然不短，但其实主要只干了两件简单的事情，&lt;/p>
&lt;ul>
&lt;li>第一是在内核中把真正的 socket 找出来，在这个对象里记录着各种协议栈的函数地址。&lt;/li>
&lt;li>第二是构造一个 struct msghdr 对象，把用户传入的数据，比如 buffer地址、数据长度啥的，统统都装进去.&lt;/li>
&lt;/ul>
&lt;p>剩下的事情就交给下一层，协议栈里的函数 inet_sendmsg 了，其中 inet_sendmsg 函数的地址是通过 socket 内核对象里的 ops 成员找到的。大致流程如图。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-33dbbf07ba4846e60c8edb671d00c07f_720w.jpg" alt="">&lt;/p>
&lt;p>有了上面的了解，我们再看起源码就要容易许多了。源码如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/socket.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">SYSCALL_DEFINE4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">send&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">__user&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size_t&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">sys_sendto&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">SYSCALL_DEFINE6&lt;/span>&lt;span class="p">(......)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//1.根据 fd 查找到 socket
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sockfd_lookup_light&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">fput_needed&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//2.构造 msghdr
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">msghdr&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">iovec&lt;/span> &lt;span class="n">iov&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">iov&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">iov_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buff&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">iov&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">iov_len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">msg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">msg_iovlen&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">msg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">msg_iov&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">iov&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">msg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">msg_flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="c1">//3.发送数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sock_sendmsg&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。&lt;/p>
&lt;p>在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。&lt;/p>
&lt;p>接着调用了 sock_sendmsg =&amp;gt; __sock_sendmsg ==&amp;gt; __sock_sendmsg_nosec。在__sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/socket.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">__sock_sendmsg_nosec&lt;/span>&lt;span class="p">(...)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">sock&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ops&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sendmsg&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">iocb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过第三节里的 socket 内核对象结构图，我们可以看到，这里调用的是 sock-&amp;gt;ops-&amp;gt;sendmsg 实际执行的是 inet_sendmsg。这个函数是 AF_INET 协议族提供的通用发送函数。&lt;/p>
&lt;h3 id="42-传输层处理">&lt;strong>4.2 传输层处理&lt;/strong>&lt;/h3>
&lt;h3 id="1传输层拷贝">&lt;strong>1）传输层拷贝&lt;/strong>&lt;/h3>
&lt;p>在进入到协议栈 inet_sendmsg 以后，内核接着会找到 socket 上的具体协议发送函数。对于 TCP 协议来说，那就是 tcp_sendmsg（同样也是通过 socket 内核对象找到的）。&lt;/p>
&lt;p>在这个函数中，内核会申请一个内核态的 skb 内存，将用户待发送的数据拷贝进去。注意这个时候不一定会真正开始发送，如果没有达到发送条件的话很可能这次调用直接就返回了。大概过程如图：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-ffad55e8c65199c7c6604bd394088e41_720w.jpg" alt="">&lt;/p>
&lt;p>我们来看 inet_sendmsg 函数的源码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/af_inet.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">inet_sendmsg&lt;/span>&lt;span class="p">(......)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">sk&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sk_prot&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sendmsg&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">iocb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个函数中会调用到具体协议的发送函数。同样参考第三节里的 socket 内核对象结构图，我们看到对于 TCP 协议下的 socket 来说，来说 sk-&amp;gt;sk_prot-&amp;gt;sendmsg 指向的是 tcp_sendmsg（对于 UPD 来说是 udp_sendmsg）。&lt;/p>
&lt;p>tcp_sendmsg 这个函数比较长，我们分多次来看它。 先看这一段&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/tcp.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tcp_sendmsg&lt;/span>&lt;span class="p">(...)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(...){&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(...){&lt;/span>
&lt;span class="c1">//获取发送队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">skb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tcp_write_queue_tail&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//申请skb 并拷贝
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">......&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//file: include/net/tcp.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">tcp_write_queue_tail&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sock&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">skb_peek_tail&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sk_write_queue&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>理解对 socket 调用 tcp_write_queue_tail 是理解发送的前提。如上所示，这个函数是在获取 socket 发送队列中的最后一个 skb。 skb 是 struct sk_buff 对象的简称，用户的发送队列就是该对象组成的一个链表。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-bb693e4a2fdae5870609d9b76133c0ad_720w.jpg" alt="">&lt;/p>
&lt;p>我们再接着看 tcp_sendmsg 的其它部分。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/tcp.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">tcp_sendmsg&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">kiocb&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">iocb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sock&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">msghdr&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//获取用户传递过来的数据和标志
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">iov&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">msg_iov&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//用户数据地址
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">iovlen&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">msg_iovlen&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//数据块数为1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">flags&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">msg_flags&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//各种标志
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">//遍历用户层的数据块
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">iovlen&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//待发送数据块的地址
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">__user&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">from&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">iov&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">iov_base&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">seglen&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//需要申请新的 skb
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">copy&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//申请 skb，并添加到发送队列的尾部
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">skb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sk_stream_alloc_skb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">select_size&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sg&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="n">sk&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sk_allocation&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//把 skb 挂到socket的发送队列上
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">skb_entail&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// skb 中有足够的空间
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">skb_availroom&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//拷贝用户空间的数据到内核空间，同时计算校验和
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//from是用户空间的数据地址
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">skb_add_data_nocache&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">from&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">copy&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数比较长，不过其实逻辑并不复杂。其中 msg-&amp;gt;msg_iov 存储的是用户态内存的要发送的数据的 buffer。接下来在内核态申请内核内存，比如 skb，并把用户内存里的数据拷贝到内核态内存中。&lt;strong>这就会涉及到一次或者几次内存拷贝的开销&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-cbd951cef795058fe8379ac46765d172_720w.jpg" alt="">&lt;/p>
&lt;p>至于内核什么时候真正把 skb 发送出去。在 tcp_sendmsg 中会进行一些判断。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">//file: net/ipv4/tcp.c
int tcp_sendmsg(...)
{
while(...){
while(...){
//申请内核内存并进行拷贝
//发送判断
if (forced_push(tp)) {
tcp_mark_push(tp, skb);
__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);
} else if (skb == tcp_send_head(sk))
tcp_push_one(sk, mss_now);
}
continue;
}
}
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>只有满足 forced_push(tp) 或者 skb == tcp_send_head(sk) 成立的时候，内核才会真正启动发送数据包。其中 forced_push(tp) 判断的是未发送的数据数据是否已经超过最大窗口的一半了。&lt;/p>
&lt;p>条件都不满足的话，&lt;strong>这次的用户要发送的数据只是拷贝到内核就算完事了！&lt;/strong>&lt;/p>
&lt;h3 id="2传输层发送">&lt;strong>2）传输层发送&lt;/strong>&lt;/h3>
&lt;p>假设现在内核发送条件已经满足了，我们再来跟踪一下实际的发送过程。 对于上小节函数中，当满足真正发送条件的时候，无论调用的是 __tcp_push_pending_frames 还是 tcp_push_one 最终都实际会执行到 tcp_write_xmit。&lt;/p>
&lt;p>所以我们直接从 tcp_write_xmit 看起，这个函数处理了传输层的拥塞控制、滑动窗口相关的工作。满足窗口要求的时候，设置一下 TCP 头然后将 skb 传到更低的网络层进行处理。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-18f6157c989ac8838e7048941260809d_720w.jpg" alt="">&lt;/p>
&lt;p>我们来看下 tcp_write_xmit 的源码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/tcp_output.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">tcp_write_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sock&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mss_now&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nonagle&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">push_one&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gfp_t&lt;/span> &lt;span class="n">gfp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//循环获取待发送 skb
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">skb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tcp_send_head&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//滑动窗口相关
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cwnd_quota&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tcp_cwnd_test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">tcp_snd_wnd_test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mss_now&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">tcp_mss_split_point&lt;/span>&lt;span class="p">(...);&lt;/span>
&lt;span class="n">tso_fragment&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">...);&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="c1">//真正开启发送
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tcp_transmit_skb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gfp&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到我们之前在网络协议里学的滑动窗口、拥塞控制就是在这个函数中完成的，这部分就不过多展开了，感兴趣同学自己找这段源码来读。我们今天只看发送主过程，那就走到了 tcp_transmit_skb。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/tcp_output.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">tcp_transmit_skb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sock&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">clone_it&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">gfp_t&lt;/span> &lt;span class="n">gfp_mask&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//1.克隆新 skb 出来
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">likely&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">clone_it&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">skb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">skb_clone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gfp_mask&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//2.封装 TCP 头
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">th&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tcp_hdr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">th&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">source&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inet&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">inet_sport&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">th&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dest&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">inet&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">inet_dport&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">th&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">window&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="n">th&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">urg&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="c1">//3.调用网络层发送接口
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">err&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">icsk&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">icsk_af_ops&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">queue_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">inet&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">cork&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fl&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一件事是先克隆一个新的 skb，这里重点说下为什么要复制一个 skb 出来呢？&lt;/p>
&lt;p>是因为 skb 后续在调用网络层，最后到达网卡发送完成的时候，这个 skb 会被释放掉。而我们知道 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 skb 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 skb 的一个拷贝。等收到 ACK 再真正删除。&lt;/p>
&lt;p>第二件事是修改 skb 中的 TCP header，根据实际情况把 TCP 头设置好。这里要介绍一个小技巧，skb 内部其实包含了网络协议中所有的 header。在设置 TCP 头的时候，只是把指针指向 skb 的合适位置。后面再设置 IP 头的时候，在把指针挪一挪就行，避免频繁的内存申请和拷贝，效率很高。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-cfce7d6f807c3325de9ef21df529e4c3_720w.jpg" alt="">&lt;/p>
&lt;p>tcp_transmit_skb 是发送数据位于传输层的最后一步，接下来就可以进入到网络层进行下一层的操作了。调用了网络层提供的发送接口icsk-&amp;gt;icsk_af_ops-&amp;gt;queue_xmit()。&lt;/p>
&lt;p>在下面的这个源码中，我们的知道了 queue_xmit 其实指向的是 ip_queue_xmit 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/tcp_ipv4.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">inet_connection_sock_af_ops&lt;/span> &lt;span class="n">ipv4_specific&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">queue_xmit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ip_queue_xmit&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">send_check&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tcp_v4_send_check&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>自此，传输层的工作也就都完成了。 数据离开了传输层，接下来将会进入到内核在网络层的实现里。&lt;/p>
&lt;h3 id="43-网络层发送处理">&lt;strong>4.3 网络层发送处理&lt;/strong>&lt;/h3>
&lt;p>Linux 内核网络层的发送的实现位于 net/ipv4/ip_output.c 这个文件。传输层调用到的 ip_queue_xmit 也在这里。（从文件名上也能看出来进入到 IP 层了，源文件名已经从 tcp_xxx 变成了 ip_xxx。）&lt;/p>
&lt;p>在网络层里主要处理路由项查找、IP 头设置、netfilter 过滤、skb 切分（大于 MTU 的话）等几项工作，处理完这些工作后会交给更下层的邻居子系统来处理。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-0070e8bac1946baba239c56a27555a00_720w.jpg" alt="">&lt;/p>
&lt;p>我们来看网络层入口函数 ip_queue_xmit 的源码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/ip_output.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">ip_queue_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">flowi&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">fl&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//检查 socket 中是否有缓存的路由表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">rt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">rtable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">__sk_dst_check&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rt&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//没有缓存则展开查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//则查找路由项， 并缓存到 socket 中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">rt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ip_route_output_ports&lt;/span>&lt;span class="p">(...);&lt;/span>
&lt;span class="n">sk_setup_caps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">rt&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dst&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//为 skb 设置路由表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">skb_dst_set_noref&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">rt&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dst&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//设置 IP header
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">iph&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ip_hdr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">iph&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">protocol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sk&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sk_protocol&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">iph&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ttl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ip_select_ttl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inet&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">rt&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dst&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">iph&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">frag_off&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="c1">//发送
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ip_local_out&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>ip_queue_xmit 已经到了网络层，在这个函数里我们看到了网络层相关的功能路由项查找，如果找到了则设置到 skb 上（没有路由的话就直接报错返回了）。&lt;/p>
&lt;p>在 Linux 上通过 route 命令可以看到你本机的路由配置。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-026979a5417056df4cd921841ce4cb61_720w.png" alt="">&lt;/p>
&lt;p>在路由表中，可以查到某个目的网络应该通过哪个 Iface（网卡），哪个 Gateway（网卡）发送出去。查找出来以后缓存到 socket 上，下次再发送数据就不用查了。&lt;/p>
&lt;p>接着把路由表地址也放到 skb 里去。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: include/linux/skbuff.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//保存了一些路由相关信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">_skb_refdst&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来就是定位到 skb 里的 IP 头的位置上，然后开始按照协议规范设置 IP header。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-f75b423219d405ff7c6885b10ee11c0a_720w.jpg" alt="">&lt;/p>
&lt;p>再通过 ip_local_out 进入到下一步的处理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/ip_output.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">ip_local_out&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//执行 netfilter 过滤
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">err&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">__ip_local_out&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//开始发送数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">likely&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">err&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dst_output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 ip_local_out =&amp;gt; __ip_local_out =&amp;gt; nf_hook 会执行 netfilter 过滤。如果你使用 iptables 配置了一些规则，那么这里将检测是否命中规则。 &lt;strong>如果你设置了非常复杂的 netfilter 规则，在这个函数这里将会导致你的进程 CPU 开销会极大增加&lt;/strong>。&lt;/p>
&lt;p>还是不多展开说，继续只聊和发送有关的过程 dst_output。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: include/net/dst.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">dst_output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">skb_dst&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此函数找到到这个 skb 的路由表（dst 条目） ，然后调用路由表的 output 方法。这又是一个函数指针，指向的是 ip_output 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/ip_output.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">ip_output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//统计
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">.....&lt;/span>
&lt;span class="c1">//再次交给 netfilter，完毕后回调 ip_finish_output
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">NF_HOOK_COND&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">NFPROTO_IPV4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">NF_INET_POST_ROUTING&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">ip_finish_output&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IPCB&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">flags&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">IPSKB_REROUTED&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 ip_output 中进行一些简单的，统计工作，再次执行 netfilter 过滤。过滤通过之后回调 ip_finish_output。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/ip_output.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">ip_finish_output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//大于 mtu 的话就要进行分片了
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">len&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ip_skb_dst_mtu&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">skb_is_gso&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ip_fragment&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ip_finish_output2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ip_finish_output2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 ip_finish_output 中我们看到，&lt;strong>如果数据大于 MTU 的话，是会执行分片的。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>实际 MTU 大小确定依赖 MTU 发现，以太网帧为 1500 字节。之前 QQ 团队在早期的时候，会尽量控制自己数据包尺寸小于 MTU，通过这种方式来优化网络性能。因为分片会带来两个问题：1、需要进行额外的切分处理，有额外性能开销。2、只要一个分片丢失，整个包都得重传。所以避免分片既杜绝了分片开销，也大大降低了重传率。&lt;/p>
&lt;/blockquote>
&lt;p>在 ip_finish_output2 中，终于发送过程会进入到下一层，邻居子系统中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/ipv4/ip_output.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">ip_finish_output2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//根据下一跳 IP 地址查找邻居项，找不到就创建一个
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">nexthop&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">__force&lt;/span> &lt;span class="n">u32&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">rt_nexthop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ip_hdr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">daddr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">neigh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">__ipv4_neigh_lookup_noref&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nexthop&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">unlikely&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">neigh&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">neigh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">__neigh_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">arp_tbl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">nexthop&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//继续向下层传递
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dst_neigh_output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dst&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">neigh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="44-邻居子系统">&lt;strong>4.4 邻居子系统&lt;/strong>&lt;/h3>
&lt;p>邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是对网络层提供一个封装，让网络层不必关心下层的地址信息，让下层来决定发送到哪个 MAC 地址。&lt;/p>
&lt;p>而且这个邻居子系统并不位于协议栈 net/ipv4/ 目录内，而是位于 net/core/neighbour.c。因为无论是对于 IPv4 还是 IPv6 ，都需要使用该模块。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-980285236de5b4b2efcf7176d1d6f9d9_720w.jpg" alt="">&lt;/p>
&lt;p>在邻居子系统里主要是查找或者创建邻居项，在创造邻居项的时候，有可能会发出实际的 arp 请求。然后封装一下 MAC 头，将发送过程再传递到更下层的网络设备子系统。大致流程如图。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-c2fffa7864d22f96118c7ce39ead1057_720w.jpg" alt="">&lt;/p>
&lt;p>理解了大致流程，我们再回头看源码。在上面小节 ip_finish_output2 源码中调用了 __ipv4_neigh_lookup_noref。它是在 arp 缓存中进行查找，其第二个参数传入的是路由下一跳 IP 信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: include/net/arp.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">extern&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">neigh_table&lt;/span> &lt;span class="n">arp_tbl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">neighbour&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">__ipv4_neigh_lookup_noref&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">u32&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">neigh_hash_table&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">nht&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rcu_dereference_bh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arp_tbl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">nht&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//计算 hash 值，加速查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">hash_val&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arp_hashfn&lt;/span>&lt;span class="p">(......);&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rcu_dereference_bh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nht&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">hash_buckets&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">hash_val&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">n&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rcu_dereference_bh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dev&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">dev&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u32&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">primary_key&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果查找不到，则调用 __neigh_create 创建一个邻居。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/neighbour.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">neighbour&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">__neigh_create&lt;/span>&lt;span class="p">(......)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//申请邻居表项
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">neighbour&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">n1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">neigh_alloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tbl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//构造赋值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">memcpy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">primary_key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pkey&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key_len&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">n&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">n&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">parms&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">neigh_setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//最后添加到邻居 hashtable 中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">rcu_assign_pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nht&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">hash_buckets&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">hash_val&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有了邻居项以后，此时仍然还不具备发送 IP 报文的能力，因为目的 MAC 地址还未获取。 调用 dst_neigh_output 继续传递 skb。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: include/net/dst.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">dst_neigh_output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">dst_entry&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dst&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">neighbour&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>调用 output，实际指向的是 neigh_resolve_output。在这个函数内部有可能会发出 arp 网络请求。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/neighbour.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">neigh_resolve_output&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="c1">//注意：这里可能会触发 arp 请求
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">neigh_event_send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">neigh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//neigh-&amp;gt;ha 是 MAC 地址
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dev_hard_header&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ntohs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">protocol&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="n">neigh&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ha&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//发送
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dev_queue_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当获取到硬件 MAC 地址以后，就可以封装 skb 的 MAC 头了。最后调用 dev_queue_xmit 将 skb 传递给 Linux 网络设备子系统。&lt;/p>
&lt;h3 id="45-网络设备子系统">&lt;strong>4.5 网络设备子系统&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-6fa56c1f95237a49703f6a0161daa7e3_720w.jpg" alt="">&lt;/p>
&lt;p>邻居子系统通过 dev_queue_xmit 进入到网络设备子系统中来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">dev_queue_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//选择发送队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">txq&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">netdev_pick_tx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//获取与此队列关联的排队规则
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">q&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rcu_dereference_bh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">txq&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">qdisc&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//如果有队列，则调用__dev_xmit_skb 继续处理数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">enqueue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">rc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">__dev_xmit_skb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">txq&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">out&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//没有队列的是回环设备和隧道设备
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">......&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>开篇第二节网卡启动准备里我们说过，网卡是有多个发送队列的（尤其是现在的网卡）。上面对 netdev_pick_tx 函数的调用就是选择一个队列进行发送。&lt;/p>
&lt;p>netdev_pick_tx 发送队列的选择受 XPS 等配置的影响，而且还有缓存，也是一套小复杂的逻辑。这里我们只关注两个逻辑，首先会获取用户的 XPS 配置，否则就自动计算了。代码见 netdev_pick_tx =&amp;gt; __netdev_pick_tx。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/flow_dissector.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">u16&lt;/span> &lt;span class="nf">__netdev_pick_tx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//获取 XPS 配置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">new_index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_xps_queue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//自动计算队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">new_index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">new_index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">skb_tx_hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">);}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后获取与此队列关联的 qdisc。在 linux 上通过 tc 命令可以看到 qdisc 类型，例如对于我的某台多队列网卡机器上是 mq disc。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">#tc qdisc
qdisc mq 0: dev eth0 root
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>大部分的设备都有队列（回环设备和隧道设备除外），所以现在我们进入到 __dev_xmit_skb。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">__dev_xmit_skb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">Qdisc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">netdev_queue&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">txq&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//1.如果可以绕开排队系统
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">flags&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">TCQ_F_CAN_BYPASS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">qdisc_qlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>
&lt;span class="n">qdisc_run_begin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//2.正常排队
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//入队
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">enqueue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">//开始发送
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">__qdisc_run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上述代码中分两种情况，1 是可以 bypass（绕过）排队系统的，另外一种是正常排队。我们只看第二种情况。&lt;/p>
&lt;p>先调用 q-&amp;gt;enqueue 把 skb 添加到队列里。然后调用 __qdisc_run 开始发送。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/sched/sch_generic.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">__qdisc_run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Qdisc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">quota&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">weight_p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//循环从队列取出一个 skb 并发送
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">qdisc_restart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 如果发生下面情况之一，则延后处理：
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 1. quota 用尽
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 2. 其他进程需要 CPU
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">quota&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">need_resched&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//将触发一次 NET_TX_SOFTIRQ 类型 softirq
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">__netif_schedule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在上述代码中，我们看到 while 循环不断地从队列中取出 skb 并进行发送。注意，这个时候其实都占用的是用户进程的系统态时间(sy)。 只有当 quota 用尽或者其它进程需要 CPU 的时候才触发软中断进行发送。&lt;/p>
&lt;p>&lt;strong>所以这就是为什么一般服务器上查看 /proc/softirqs，一般 NET_RX 都要比 NET_TX 大的多的第二个原因&lt;/strong>。对于读来说，都是要经过 NET_RX 软中断，而对于发送来说，只有系统态配额用尽才让软中断上。&lt;/p>
&lt;p>我们来把精力在放到 qdisc_restart 上，继续看发送过程。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">qdisc_restart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Qdisc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//从 qdisc 中取出要发送的 skb
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">skb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dequeue_skb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">sch_direct_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">txq&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root_lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>qdisc_restart 从队列中取出一个 skb，并调用 sch_direct_xmit 继续发送。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/sched/sch_generic.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sch_direct_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">Qdisc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">netdev_queue&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">txq&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">spinlock_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">root_lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//调用驱动程序来发送数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dev_hard_start_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">txq&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="46-软中断调度">&lt;strong>4.6 软中断调度&lt;/strong>&lt;/h3>
&lt;p>在 4.5 咱们看到了如果系统态 CPU 发送网络包不够用的时候，会调用 __netif_schedule 触发一个软中断。该函数会进入到 __netif_reschedule，由它来实际发出 NET_TX_SOFTIRQ 类型软中断。&lt;/p>
&lt;p>软中断是由内核线程来运行的，该线程会进入到 net_tx_action 函数，在该函数中能获取到发送队列，并也最终调用到驱动程序里的入口函数 dev_hard_start_xmit。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-7b7da5c8cebe7a05ef2fddc3b98d7ec5_720w.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">__netif_reschedule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Qdisc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">sd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">__get_cpu_var&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">softnet_data&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next_sched&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">sd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output_queue_tailp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">sd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output_queue_tailp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next_sched&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="n">raise_softirq_irqoff&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">NET_TX_SOFTIRQ&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在该函数里在软中断能访问到的 softnet_data 里设置了要发送的数据队列，添加到了 output_queue 里了。紧接着触发了 NET_TX_SOFTIRQ 类型的软中断。（T 代表 transmit 传输）&lt;/p>
&lt;p>软中断的入口代码我这里也不详细扒了，感兴趣的同学参考**&lt;a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GoYDsfy9m0wRoXi_NCfCmg">《图解Linux网络包接收过程》&lt;/a>**一文中的 3.2 小节 - ksoftirqd内核线程处理软中断。&lt;/p>
&lt;p>我们直接从 NET_TX_SOFTIRQ softirq 注册的回调函数 net_tx_action讲起。用户态进程触发完软中断之后，会有一个软中断内核线程会执行到 net_tx_action。&lt;/p>
&lt;p>&lt;strong>牢记，这以后发送数据消耗的 CPU 就都显示在 si 这里了，不会消耗用户进程的系统时间了&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">net_tx_action&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">softirq_action&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//通过 softnet_data 获取发送队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">softnet_data&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">__get_cpu_var&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">softnet_data&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 如果 output queue 上有 qdisc
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output_queue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 将 head 指向第一个 qdisc
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output_queue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//遍历 qdsics 列表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">Qdisc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next_sched&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//发送数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">qdisc_run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>软中断这里会获取 softnet_data。前面我们看到进程内核态在调用 __netif_reschedule 的时候把发送队列写到 softnet_data 的 output_queue 里了。 软中断循环遍历 sd-&amp;gt;output_queue 发送数据帧。&lt;/p>
&lt;p>来看 qdisc_run，它和进程用户态一样，也会调用到 __qdisc_run。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: include/net/pkt_sched.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kr">inline&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">qdisc_run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Qdisc&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">qdisc_run_begin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">__qdisc_run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后一样就是进入 qdisc_restart =&amp;gt; sch_direct_xmit，直到驱动程序函数 dev_hard_start_xmit。&lt;/p>
&lt;h3 id="47-igb-网卡驱动发送">&lt;strong>4.7 igb 网卡驱动发送&lt;/strong>&lt;/h3>
&lt;p>我们前面看到，无论是对于用户进程的内核态，还是对于软中断上下文，都会调用到网络设备子系统中的 dev_hard_start_xmit 函数。在这个函数中，会调用到驱动里的发送函数 igb_xmit_frame。&lt;/p>
&lt;p>在驱动函数里，将 skb 会挂到 RingBuffer上，驱动调用完毕后，数据包将真正从网卡发送出去。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-dd72dd5d2ddcaa38bcde752bb5d073c4_720w.jpg" alt="">&lt;/p>
&lt;p>我们来看看实际的源码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: net/core/dev.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">dev_hard_start_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">netdev_queue&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">txq&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//获取设备的回调函数集合 ops
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">net_device_ops&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ops&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">netdev_ops&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//获取设备支持的功能列表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">features&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">netif_skb_features&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//调用驱动的 ops 里面的发送回调函数 ndo_start_xmit 将数据包传给网卡设备
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">skb_len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">rc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ops&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ndo_start_xmit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dev&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中 ndo_start_xmit 是网卡驱动要实现的一个函数，是在 net_device_ops 中定义的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: include/linux/netdevice.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device_ops&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">netdev_tx_t&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">ndo_start_xmit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 igb 网卡驱动源码中，我们找到了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">net_device_ops&lt;/span> &lt;span class="n">igb_netdev_ops&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">ndo_open&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">igb_open&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">ndo_stop&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">igb_close&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="n">ndo_start_xmit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">igb_xmit_frame&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也就是说，对于网络设备层定义的 ndo_start_xmit， igb 的实现函数是 igb_xmit_frame。这个函数是在网卡驱动初始化的时候被赋值的。具体初始化过程参见**&lt;a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GoYDsfy9m0wRoXi_NCfCmg">《图解Linux网络包接收过程》&lt;/a>**一文中的 2.4 节，网卡驱动初始化。&lt;/p>
&lt;p>所以在上面网络设备层调用 ops-&amp;gt;ndo_start_xmit 的时候，会实际上进入 igb_xmit_frame 这个函数中。我们进入这个函数来看看驱动程序是如何工作的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="n">netdev_tx_t&lt;/span> &lt;span class="nf">igb_xmit_frame&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">net_device&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">netdev&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="p">......&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">igb_xmit_frame_ring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">igb_tx_queue_mapping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">adapter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">netdev_tx_t&lt;/span> &lt;span class="nf">igb_xmit_frame_ring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">sk_buff&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_ring&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//获取TX Queue 中下一个可用缓冲区信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tx_buffer_info&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next_to_use&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">first&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">skb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">first&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">bytecount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">first&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">gso_segs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">//igb_tx_map 函数准备给设备发送的数据。
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">igb_tx_map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">hdr_len&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这里从网卡的发送队列的 RingBuffer 中取下来一个元素，并将 skb 挂到元素上。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-53210da030eea44896489582bbbc13f0_720w.jpg" alt="">&lt;/p>
&lt;p>igb_tx_map 函数处理将 skb 数据映射到网卡可访问的内存 DMA 区域。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">igb_tx_map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_ring&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_tx_buffer&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="n">u8&lt;/span> &lt;span class="n">hdr_len&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//获取下一个可用描述符指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tx_desc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">IGB_TX_DESC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//为 skb-&amp;gt;data 构造内存映射，以允许设备通过 DMA 从 RAM 中读取数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dma&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dma_map_single&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tx_ring&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">skb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">DMA_TO_DEVICE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//遍历该数据包的所有分片,为 skb 的每个分片生成有效映射
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">frag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">skb_shinfo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">frags&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];;&lt;/span> &lt;span class="n">frag&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">tx_desc&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">buffer_addr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cpu_to_le64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dma&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">tx_desc&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cmd_type_len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;span class="n">tx_desc&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">olinfo_status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//设置最后一个descriptor
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cmd_type&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">IGB_TXD_DCMD&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">tx_desc&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cmd_type_len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cpu_to_le32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cmd_type&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cm">/* Force memory writes to complete before letting h/w know there
&lt;/span>&lt;span class="cm"> * are new descriptors to fetch
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">wmb&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当所有需要的描述符都已建好，且 skb 的所有数据都映射到 DMA 地址后，驱动就会进入到它的最后一步，触发真实的发送。&lt;/p>
&lt;h3 id="48-发送完成硬中断">&lt;strong>4.8 发送完成硬中断&lt;/strong>&lt;/h3>
&lt;p>当数据发送完成以后，其实工作并没有结束。因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存。&lt;/p>
&lt;p>在**&lt;a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GoYDsfy9m0wRoXi_NCfCmg">《图解Linux网络包接收过程》&lt;/a>** 一文中的 3.1 和 3.2 小节，我们详细讲述过硬中断和软中断的处理过程。&lt;/p>
&lt;p>在发送硬中断里，会执行 RingBuffer 内存的清理工作，如图。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-4a1721e48e34c50390132f018c5ad1d4_720w.jpg" alt="">&lt;/p>
&lt;p>再回头看一下硬中断触发软中断的源码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">static&lt;/span> &lt;span class="nx">inline&lt;/span> &lt;span class="nx">void&lt;/span> &lt;span class="nf">____napi_schedule&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="nf">list_add_tail&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">napi&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">poll_list&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sd&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">poll_list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nf">__raise_softirq_irqoff&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">NET_RX_SOFTIRQ&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有个很有意思的细节，无论硬中断是因为是有数据要接收，还是说发送完成通知，&lt;strong>从硬中断触发的软中断都是 NET_RX_SOFTIRQ&lt;/strong>。 这个我们在第一节说过了，这是软中断统计中 RX 要高于 TX 的一个原因。&lt;/p>
&lt;p>好我们接着进入软中断的回调函数 igb_poll。在这个函数里，我们注意到有一行 igb_clean_tx_irq，参见源码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">igb_poll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">struct&lt;/span> &lt;span class="nx">napi_struct&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">napi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nx">budget&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//performs the transmit completion operations
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">q_vector&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">tx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ring&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">clean_complete&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">igb_clean_tx_irq&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">q_vector&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们来看看当传输完成的时候，igb_clean_tx_irq 都干啥了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">//file: drivers/net/ethernet/intel/igb/igb_main.c
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">igb_clean_tx_irq&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">igb_q_vector&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">q_vector&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//free the skb
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dev_kfree_skb_any&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tx_buffer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">skb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">//clear tx_buffer data
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">tx_buffer&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">skb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">dma_unmap_len_set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tx_buffer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// clear last DMA location and unmap remaining buffers */
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">tx_desc&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">eop_desc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>无非就是清理了 skb，解除了 DMA 映射等等。 到了这一步，传输才算是基本完成了。&lt;/p>
&lt;p>为啥我说是基本完成，而不是全部完成了呢？因为传输层需要保证可靠性，所以 skb 其实还没有删除。它得等收到对方的 ACK 之后才会真正删除，那个时候才算是彻底的发送完毕。&lt;/p>
&lt;h2 id="最后">&lt;strong>最后&lt;/strong>&lt;/h2>
&lt;p>用一张图总结一下整个发送过程&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-ecb73e1531032fea52e21644f2aa1413_720w.jpg" alt="">&lt;/p>
&lt;p>了解了整个发送过程以后，我们回头再来回顾开篇提到的几个问题。&lt;/p>
&lt;p>&lt;strong>1.我们在监控内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？&lt;/strong>&lt;/p>
&lt;p>在网络包的发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的事情都干了。 只有当内核态进程被切走前才会发起软中断。 发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。&lt;/p>
&lt;p>只有一少部分情况下才会触发软中断（NET_TX 类型），由软中断 ksoftirqd 内核进程来发送。&lt;/p>
&lt;p>所以，在监控网络 IO 对服务器造成的 CPU 开销的时候，不能仅仅只看 si，而是应该把 si、sy 都考虑进来。&lt;/p>
&lt;p>&lt;strong>2. 在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？&lt;/strong>&lt;/p>
&lt;p>之前我认为 NET_RX 是读取，NET_TX 是传输。对于一个既收取用户请求，又给用户返回的 Server 来说。 这两块的数字应该差不多才对，至少不会有数量级的差异。但事实上，飞哥手头的一台服务器是这样的：&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-519963353aadc56140fc233c7bdf6db0_720w.jpg" alt="">&lt;/p>
&lt;p>经过今天的源码分析，发现这个问题的原因有两个。&lt;/p>
&lt;p>第一个原因是当数据发送完成以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收，还是对于发送完毕，触发的软中断都是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。&lt;/p>
&lt;p>第二个原因是对于读来说，都是要经过 NET_RX 软中断的，都走 ksoftirqd 内核进程。而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出 NET_TX，让软中断上。&lt;/p>
&lt;p>综上两个原因，那么在机器上查看 NET_RX 比 NET_TX 大的多就不难理解了。&lt;/p>
&lt;p>&lt;strong>3.发送网络数据的时候都涉及到哪些内存拷贝操作？&lt;/strong>&lt;/p>
&lt;p>这里的内存拷贝，我们只特指待发送数据的内存拷贝。&lt;/p>
&lt;p>第一次拷贝操作是内核申请完 skb 之后，这时候会将用户传递进来的 buffer 里的数据内容都拷贝到 skb 中。如果要发送的数据量比较大的话，这个拷贝操作开销还是不小的。&lt;/p>
&lt;p>第二次拷贝操作是从传输层进入网络层的时候，每一个 skb 都会被克隆一个新的副本出来。网络层以及下面的驱动、软中断等组件在发送完成的时候会将这个副本删除。传输层保存着原始的 skb，在当网络对方没有 ack 的时候，还可以重新发送，以实现 TCP 中要求的可靠传输。&lt;/p>
&lt;p>第三次拷贝不是必须的，只有当 IP 层发现 skb 大于 MTU 时才需要进行。会再申请额外的 skb，并将原来的 skb 拷贝为多个小的 skb。&lt;/p>
&lt;blockquote>
&lt;p>这里插入个题外话，大家在网络性能优化中经常听到的零拷贝，我觉得这有点点夸张的成分。TCP 为了保证可靠性，第二次的拷贝根本就没法省。如果包再大于 MTU 的话，分片时的拷贝同样也避免不了。&lt;/p>
&lt;/blockquote>
&lt;p>看到这里，相信内核发送数据包对于你来说，已经不再是一个完全不懂的黑盒了。本文哪怕你只看懂十分之一，你也已经掌握了这个黑盒的打开方式。这在你将来优化网络性能时你就会知道从哪儿下手了。&lt;/p>
&lt;h2 id="参考">&lt;strong>参考&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/">Monitoring and Tuning the Linux Networking Stack: Sending Data&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_34258344/article/details/108956205">上述文章的一个翻译版本,只翻译了一半&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//ggaaooppeenngg.github.io/zh-CN/2017/08/07/neighboring-subsystem-%25E6%25B5%2585%25E6%259E%2590/">翻译的是另外一半，neighboring subsystem 浅析&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/network_ljr14/">LINUX内核网络数据包发送（四）——LINUX NETDEVICE 子系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/network_ljr13/">LINUX内核网络数据包发送（三）——IP协议层分析&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/dma_bjq/">LINUX网络子系统中DMA机制的实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_43722423/article/details/103276437">Linux socket 数据发送过程深入分析&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//man7.org/linux/man-pages/man2/send.2.html">send 函数&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//ivanzz1001.github.io/records/post/linux/2017/11/04/linux-msghdr">Linux msghdr结构讲解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/zhangskd/article/details/48207553">TCP的发送系列 — tcp_sendmsg()的实现（一）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/myguaiguai/p/12069485.html">参考：send和recv背后数据的收发过程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/luckywang1103/article/details/51422664">linux net子系统-协议层（传输层与网络层)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=http%3A//kerneltravel.net/blog/2020/network_ljr_no1/">LINUX内核网络（一）——初探内核网络&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Linux内存管理</title><link>https://justice.bj.cn/post/21.linux/linux%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="linux内存管理">Linux内存管理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>kernel的内存管理是个2层分层系统，从下往上依次为：&lt;/p>
&lt;ul>
&lt;li>第一层为全部物理内存：其管理器为伙伴系统，最小管理单位为page；&lt;/li>
&lt;li>第二层为slab page：其管理器为slab/slub，最小管理单位为2的m次幂的字节块；&lt;/li>
&lt;/ul>
&lt;h2 id="buddy算法基本原理">Buddy算法基本原理&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>伙伴算法（Buddy system）把所有的空闲页框分为11个块链表，每块链表中分布包含特定的连续页框地址空间，第0个块链表包含大小为2 ^ 0个连续的页框，第1个块链表中，每个链表元素包含2 ^ 1个页框大小的连续地址空间，….，第10个块链表中，每个链表元素包含2 ^ 10个页框大小的连续地址空间。每个链表中元素的个数在系统初始化时决定，在执行过程中，动态变化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>伙伴算法每次只能分配2的幂次页的空间，比如一次分配1页，2页，4页，8页，…，1024页(2^10)等等，每页(pageSize)大小一般为4K，因此，伙伴算法最多一次能够分配4M的内存空间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>两个内存块，大小相同，地址连续，同属于一个大块区域。（第0块和第1块是伙伴，第2块和第3块是伙伴，但第1块和第2块不是伙伴）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核空间分为三种区，DMA，NORMAL，HIGHMEM，对于每一种区，都有对应的伙伴算法。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2020/12/11-11-47-14-2020-12-11-11-47-08-image.png" alt="">&lt;/p>
&lt;h3 id="特点">特点&lt;/h3>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>较好的解决外部碎片问题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当需要分配若干个内存页面时，用于DMA的内存页面必须连续，伙伴算法很好的满足了这个要求&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只要请求的块不超过512个页面(2K)，内核就尽量分配连续的页面。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>合并的要求太过严格，只能是满足伙伴关系的块才能合并，比如第1块和第2块就不能合并。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>碎片问题：一个连续的内存中仅仅一个页面被占用，导致整块内存区都不具备合并的条件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浪费问题：伙伴算法只能分配2的幂次方内存区，当需要8K（2页）时，好说，当需要9K时，那就需要分配16K（4页）的内存空间，但是实际只用到9K空间，多余的7K空间就被浪费掉。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>算法的效率问题： 伙伴算法涉及了比较多的计算还有链表和位图的操作，开销还是比较大的，如果每次2 ^ n大小的伙伴块就会合并到2 ^ (n+1)的链表队列中，那么2 ^ n大小链表中的块就会因为合并操作而减少，但系统随后立即有可能又有对该大小块的需求，为此必须再从2 ^ (n+1)大小的链表中拆分，这样的合并又立即拆分的过程是无效率的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="slab算法">Slab算法&lt;/h2>
&lt;p>高速缓存Slab层
slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内存碎片，而且处理速度也太慢。
而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。
对象高速缓存的组织如右下图所示，高速缓存的内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。
在cache和object中加入slab分配器，是在时间和空间上的折中方案。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/ZhuZhengyi/notebook-images/master/2022/01/24-15-55-57-2022-01-24-15-55-52-image.png" alt="">&lt;/p>
&lt;h3 id="slab分配算法">slab分配算法&lt;/h3>
&lt;p>slab分配算法采用cache 存储内核对象。当创建cache 时，起初包括若干标记为空闲的对象。对象的数量与slab的大小有关。开始，所有对象都标记为空闲。当需要内核数据结构的对象时，可以直接从cache 上直接获取，并将对象初始化为使用。
下面考虑内核如何将slab分配给表示进程描述符的对象。在Linux系统中，进程描述符的类型是struct task_struct ，其大小约为1.7KB。当Linux 内核创建新任务时，它会从cache 中获得struct task_struct 对象所需要的内存。Cache 上会有已分配好的并标记为空闲的struct task_struct 对象来满足请求。
Linux 的slab 可有三种状态：
满的：slab 中的所有对象被标记为使用。
空的：slab 中的所有对象被标记为空闲。
部分：slab 中的对象有的被标记为使用，有的被标记为空闲。
slab 分配器首先从部分空闲的slab 进行分配。如没有，则从空的slab 进行分配。如没有，则从物理连续页上分配新的slab，并把它赋给一个cache ，然后再从新slab 分配空间。
————————————————
版权声明：本文为CSDN博主「aurorayqz」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/aurorayqz/article/details/79671785&lt;/p>
&lt;h3 id="内存碎片检查方法">内存碎片检查方法&lt;/h3>
&lt;p>buddyinfo是linuxbuddy系统管理物理内存的debug信息。在linux中使用buddy算法解决物理内存的外碎片问题，其把所有空闲的内存，以2的幂次方的形式，分成11个块链表，分别对应为1、2、4、8、16、32、64、128、256、512、1024个页块。而Linux支持NUMA技术，对于NUMA设备，NUMA系统的结点通常是由一组CPU和本地内存组成，每一个节点都有相应的本地内存，因此buddyinfo 中的Node0表示节点ID；而每一个节点下的内存设备，又可以划分为多个内存区域（zone），因此下面的显示中，对于Node0的内存，又划分类DMA、Normal区域。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># sudo cat /proc/buddyinfo&lt;/span>
Node 0, zone DMA &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">3&lt;/span>
Node 0, zone DMA32 &lt;span class="m">1380&lt;/span> &lt;span class="m">1417&lt;/span> &lt;span class="m">2611&lt;/span> &lt;span class="m">6972&lt;/span> &lt;span class="m">3703&lt;/span> &lt;span class="m">1978&lt;/span> &lt;span class="m">585&lt;/span> &lt;span class="m">7&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
Node 0, zone Normal &lt;span class="m">90233&lt;/span> &lt;span class="m">1147352&lt;/span> &lt;span class="m">1517090&lt;/span> &lt;span class="m">1219299&lt;/span> &lt;span class="m">740669&lt;/span> &lt;span class="m">285583&lt;/span> &lt;span class="m">49056&lt;/span> &lt;span class="m">2098&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
Node 1, zone Normal &lt;span class="m">159797&lt;/span> &lt;span class="m">625159&lt;/span> &lt;span class="m">907571&lt;/span> &lt;span class="m">870913&lt;/span> &lt;span class="m">650684&lt;/span> &lt;span class="m">360921&lt;/span> &lt;span class="m">124162&lt;/span> &lt;span class="m">20515&lt;/span> &lt;span class="m">867&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="c1"># extfrag_index文件中显示的数值是除以1000后的结果，当数值越接近1则表示碎片越多，数值越接近-1则表示碎片越少&lt;/span>
$ sudo cat /sys/kernel/debug/extfrag/extfrag_index
Node 0, zone DMA -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000
Node 0, zone DMA32 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 0.979 0.990
Node 0, zone Normal -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 0.989 0.995
Node 1, zone Normal -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 -1.000 0.993
&lt;span class="c1"># &lt;/span>
$ sudo cat /sys/kernel/debug/extfrag/unusable_index
Node 0, zone DMA 0.000 0.000 0.000 0.001 0.001 0.001 0.001 0.018 0.018 0.018 0.159
Node 0, zone DMA32 0.000 0.005 0.013 0.042 0.276 0.527 0.797 0.960 1.000 1.000 1.000
Node 0, zone Normal 0.000 0.000 0.068 0.211 0.439 0.714 0.923 0.994 0.999 1.000 1.000
Node 1, zone Normal 0.000 0.004 0.041 0.126 0.286 0.521 0.777 0.945 0.996 0.999 1.000
&lt;span class="c1"># 被动清理内存碎片, 内核配置需配置：CONFIG_COMPACTION=y&lt;/span>
$ sudo &lt;span class="nb">echo&lt;/span> &lt;span class="m">1&lt;/span> &amp;gt; /proc/sys/vm/compact_memory
&lt;span class="c1"># 主动清理, 清空cache/buffer/memory&lt;/span>
$ sudo sync
$ sudo &lt;span class="nb">echo&lt;/span> &lt;span class="m">3&lt;/span> &amp;gt; /proc/sys/vm/drop_caches
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/myhes/article/details/120788821">【小工具】 - linux内存碎片检查和清理_巨魔战将-CSDN博客&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/aurorayqz/article/details/79671785?spm=1001.2101.3001.6650.3&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-3.queryctrv2&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-3.queryctrv2&amp;amp;utm_relevant_index=6">Linux是如何避免内存碎片的_aurorayqz的博客-CSDN博客_内存碎片&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Linux文件系统基础知识(转)</title><link>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/21.linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="linux文件系统基础知识转">Linux文件系统基础知识(转)&lt;/h1>
&lt;h3 id="文件系统的基本组成">文件系统的基本组成&lt;/h3>
&lt;p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。&lt;/p>
&lt;p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。&lt;/p>
&lt;p>Linux 最经典的一句话是：「&lt;strong>一切皆文件&lt;/strong>」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。&lt;/p>
&lt;p>Linux 文件系统会为每个文件分配两个数据结构：&lt;strong>索引节点（&lt;em>index node&lt;/em>）和目录项（&lt;em>directory entry&lt;/em>）&lt;/strong>，它们主要用来记录文件的元信息和目录层次结构。&lt;/p>
&lt;ul>
&lt;li>索引节点，也就是 &lt;em>inode&lt;/em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、&lt;strong>数据在磁盘的位置&lt;/strong>等等。索引节点是文件的&lt;strong>唯一&lt;/strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以&lt;strong>索引节点同样占用磁盘空间&lt;/strong>。&lt;/li>
&lt;li>目录项，也就是 &lt;em>dentry&lt;/em>，用来记录文件的名字、&lt;strong>索引节点指针&lt;/strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，&lt;strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。&lt;/p>
&lt;p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。&lt;/p>
&lt;blockquote>
&lt;p>目录项和目录是一个东西吗？&lt;/p>
&lt;/blockquote>
&lt;p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。&lt;/p>
&lt;p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。&lt;/p>
&lt;p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。&lt;/p>
&lt;blockquote>
&lt;p>那文件数据是如何存储在磁盘的呢？&lt;/p>
&lt;/blockquote>
&lt;p>磁盘读写的最小单位是&lt;strong>扇区&lt;/strong>，扇区的大小只有 &lt;code>512B&lt;/code> 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。&lt;/p>
&lt;p>所以，文件系统把多个扇区组成了一个&lt;strong>逻辑块&lt;/strong>，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 &lt;code>4KB&lt;/code>，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。&lt;/p>
&lt;p>以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-9d77e25913894df26b0374ceae25c605_1440w.jpg" alt="">&lt;/p>
&lt;p>索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。&lt;/p>
&lt;p>另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。 - &lt;em>超级块&lt;/em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。 - &lt;em>索引节点区&lt;/em>，用来存储索引节点； - &lt;em>数据块区&lt;/em>，用来存储文件或目录数据；&lt;/p>
&lt;p>我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：&lt;/p>
&lt;ul>
&lt;li>超级块：当文件系统挂载时进入内存；&lt;/li>
&lt;li>索引节点区：当文件被访问时进入内存；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="虚拟文件系统">虚拟文件系统&lt;/h3>
&lt;p>文件系统的种类众多，而操作系统希望&lt;strong>对用户提供一个统一的接口&lt;/strong>，于是在用户层与文件系统层引入了中间层，这个中间层就称为&lt;strong>虚拟文件系统（&lt;em>Virtual File System，VFS&lt;/em>）。&lt;/strong>&lt;/p>
&lt;p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。&lt;/p>
&lt;p>在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-b92499b17ed11bc279689ecdb6efb4b6_1440w.jpg" alt="">&lt;/p>
&lt;p>Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：&lt;/p>
&lt;ul>
&lt;li>&lt;em>磁盘的文件系统&lt;/em>，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。&lt;/li>
&lt;li>&lt;em>内存的文件系统&lt;/em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 &lt;code>/proc&lt;/code> 和 &lt;code>/sys&lt;/code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。&lt;/li>
&lt;li>&lt;em>网络的文件系统&lt;/em>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。&lt;/li>
&lt;/ul>
&lt;p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。&lt;/p>
&lt;hr>
&lt;h3 id="文件的使用">文件的使用&lt;/h3>
&lt;p>我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-bb6dc369fbf16afbdb088c6c7c26d9cc_1440w.jpg" alt="">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">打开文件&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,...);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">写数据&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="err">关闭文件&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面简单的代码是读取一个文件的过程：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先用 &lt;code>open&lt;/code> 系统调用打开文件，&lt;code>open&lt;/code> 的参数中包含文件的路径名和文件名。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 &lt;code>write&lt;/code> 写数据，其中 &lt;code>write&lt;/code> 使用 &lt;code>open&lt;/code> 所返回的&lt;strong>文件描述符&lt;/strong>，并不使用文件名作为参数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用完文件后，要用 &lt;code>close&lt;/code> 系统调用关闭文件，避免资源的泄露。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong>文件描述符&lt;/strong>」，所以说文件描述符是打开文件的标识。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-4d1f24d7102933f32a560a1cbdfce6da_1440w.jpg" alt="">&lt;/p>
&lt;p>操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。&lt;/p>
&lt;p>所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。&lt;/p>
&lt;p>我们来分别看一下，读文件和写文件的过程：&lt;/p>
&lt;ul>
&lt;li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。&lt;/li>
&lt;li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。&lt;/li>
&lt;/ul>
&lt;p>所以说，&lt;strong>文件系统的基本操作单位是数据块&lt;/strong>。&lt;/p>
&lt;hr>
&lt;h3 id="文件的存储">文件的存储&lt;/h3>
&lt;p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p>
&lt;ul>
&lt;li>连续空间存放方式&lt;/li>
&lt;li>非连续空间存放方式&lt;/li>
&lt;/ul>
&lt;p>其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。&lt;/p>
&lt;p>不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。&lt;/p>
&lt;h3 id="连续空间存放方式">连续空间存放方式&lt;/h3>
&lt;p>连续空间存放方式顾名思义，&lt;strong>文件存放在磁盘「连续的」物理空间中&lt;/strong>。这种模式下，文件的数据都是紧密相连，&lt;strong>读写效率很高&lt;/strong>，因为一次磁盘寻道就可以读出整个文件。&lt;/p>
&lt;p>使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p>
&lt;p>所以，&lt;strong>文件头里需要指定「起始块的位置」和「长度」&lt;/strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p>
&lt;p>注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-7fc9cbf9c253d0ee84af8f61c605d50f_1440w.jpg" alt="">&lt;/p>
&lt;p>连续空间存放的方式虽然读写效率高，&lt;strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong>&lt;/p>
&lt;p>如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-5e0b69486a4e42554941c93a44d538e0_1440w.jpg" alt="">&lt;/p>
&lt;p>另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。&lt;/p>
&lt;p>那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。&lt;/p>
&lt;h3 id="非连续空间存放方式">非连续空间存放方式&lt;/h3>
&lt;p>非连续空间存放方式分为「链表方式」和「索引方式」。&lt;/p>
&lt;blockquote>
&lt;p>我们先来看看链表的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式存放是&lt;strong>离散的，不用连续的&lt;/strong>，于是就可以&lt;strong>消除磁盘碎片&lt;/strong>，可大大提高磁盘空间的利用率，同时&lt;strong>文件的长度可以动态扩展&lt;/strong>。根据实现的方式的不同，链表可分为「&lt;strong>隐式链表&lt;/strong>」和「&lt;strong>显式链接&lt;/strong>」两种形式。&lt;/p>
&lt;p>文件要以「&lt;strong>隐式链表&lt;/strong>」的方式存放的话，&lt;strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong>，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-b3d581a3d561f3386a497d5622180c81_1440w.jpg" alt="">&lt;/p>
&lt;p>隐式链表的存放方式的&lt;strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong>。隐式链接分配的&lt;strong>稳定性较差&lt;/strong>，系统在运行过程中由于软件或者硬件错误&lt;strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong>&lt;/p>
&lt;p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong>显式链接&lt;/strong>」，它指&lt;strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong>，该表在整个磁盘仅设置一张，&lt;strong>每个表项中存放链接指针，指向下一个数据块号&lt;/strong>。&lt;/p>
&lt;p>对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为&lt;strong>文件分配表（&lt;em>File Allocation Table，FAT&lt;/em>）&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-848b55299135f1775cb9fa5e6f9f9272_1440w.jpg" alt="">&lt;/p>
&lt;p>由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong>提高了检索速度&lt;/strong>，而且&lt;strong>大大减少了访问磁盘的次数&lt;/strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是&lt;strong>不适用于大磁盘&lt;/strong>。&lt;/p>
&lt;p>比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。&lt;/p>
&lt;blockquote>
&lt;p>接下来，我们来看看索引的方式。&lt;/p>
&lt;/blockquote>
&lt;p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。&lt;/p>
&lt;p>索引的实现是为每个文件创建一个「&lt;strong>索引数据块&lt;/strong>」，里面存放的是&lt;strong>指向文件数据块的指针列表&lt;/strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p>
&lt;p>另外，&lt;strong>文件头需要包含指向「索引数据块」的指针&lt;/strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。&lt;/p>
&lt;p>创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-1e6d2ef6d8782117779143843798b79e_1440w.jpg" alt="">&lt;/p>
&lt;p>索引的方式优点在于： - 文件的创建、增大、缩小很方便； - 不会有碎片的问题； - 支持顺序读写和随机读写；&lt;/p>
&lt;p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p>
&lt;p>如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p>
&lt;p>先来看看链表 + 索引的组合，这种组合称为「&lt;strong>链式索引块&lt;/strong>」，它的实现方式是&lt;strong>在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-ede534663e1c19169eb40cbe01384da2_1440w.jpg" alt="">&lt;/p>
&lt;p>还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong>多级索引块&lt;/strong>」，实现方式是&lt;strong>通过一个索引块来存放多个索引数据块&lt;/strong>，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-fb7d558d7b1d2d48fa4544adbead57bc_1440w.jpg" alt="">&lt;/p>
&lt;h3 id="unix-文件的实现方式">Unix 文件的实现方式&lt;/h3>
&lt;p>我们先把前面提到的文件实现方式，做个比较：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-e01c7af752461c0794a10f383dbe465b_1440w.jpg" alt="">&lt;/p>
&lt;p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-0c16919bcad17d1391f162e0363229b7_1440w.jpg" alt="">&lt;/p>
&lt;p>它是根据文件的大小，存放的方式会有所变化：&lt;/p>
&lt;ul>
&lt;li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；&lt;/li>
&lt;li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；&lt;/li>
&lt;li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；&lt;/li>
&lt;li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；&lt;/li>
&lt;/ul>
&lt;p>那么，文件头（&lt;em>Inode&lt;/em>）就需要包含 13 个指针：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>10 个指向数据块的指针；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第 11 个指向索引块的指针； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第 12 个指向二级索引块的指针； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第 13 个指向三级索引块的指针；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，这种方式能很灵活地支持小文件和大文件的存放：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于小文件使用直接查找的方式可减少索引数据块的开销； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。&lt;/p>
&lt;p>为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。&lt;/p>
&lt;hr>
&lt;h3 id="空闲空间管理">空闲空间管理&lt;/h3>
&lt;p>前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？&lt;/p>
&lt;p>那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：&lt;/p>
&lt;ul>
&lt;li>空闲表法&lt;/li>
&lt;li>空闲链表法&lt;/li>
&lt;li>位图法&lt;/li>
&lt;/ul>
&lt;h3 id="空闲表法">空闲表法&lt;/h3>
&lt;p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-1ec1e7e0b313a92e0028691ae97c9766_1440w.jpg" alt="">&lt;/p>
&lt;p>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。&lt;/p>
&lt;p>这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p>
&lt;h3 id="空闲链表法">空闲链表法&lt;/h3>
&lt;p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-a14c65a4ec2fbb470fba728b818a6d22_1440w.jpg" alt="">&lt;/p>
&lt;p>当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p>
&lt;p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p>
&lt;p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p>
&lt;h3 id="位图法">位图法&lt;/h3>
&lt;p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p>
&lt;p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">1111110011111110001110110111111100111 ...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p>
&lt;hr>
&lt;h3 id="文件系统的结构">文件系统的结构&lt;/h3>
&lt;p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。&lt;/p>
&lt;p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code>4 * 1024 * 8 = 2^15&lt;/code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code>2^15 * 4 * 1024 = 2^27&lt;/code> 个 byte，也就是 128M。&lt;/p>
&lt;p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p>
&lt;p>在 Linux 文件系统，把这个结构称为一个&lt;strong>块组&lt;/strong>，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p>
&lt;p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-d9e36f97b24b2a7f760a81d0b095c36d_1440w.jpg" alt="">&lt;/p>
&lt;p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>- &lt;em>超级块&lt;/em>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>- &lt;em>块组描述符&lt;/em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>- &lt;em>数据位图和 inode 位图&lt;/em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p> &lt;em>inode 列表&lt;/em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>数据块&lt;/em>，包含文件的有用数据。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>你可以会发现每个块组里有很多重复的信息，比如&lt;strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong>，这么做是有两个原因：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。 -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。&lt;/p>
&lt;hr>
&lt;h3 id="目录的存储">目录的存储&lt;/h3>
&lt;p>在前面，我们知道了一个普通文件是如何存储的，但还有一个特殊的文件，经常用到的目录，它是如何保存的呢？&lt;/p>
&lt;p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 &lt;code>vim&lt;/code> 打开它，它也有 inode，inode 里面也是指向一些块。&lt;/p>
&lt;p>和普通文件不同的是，&lt;strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong>&lt;/p>
&lt;p>在目录文件的块中，最简单的保存格式就是&lt;strong>列表&lt;/strong>，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p>
&lt;p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-89f1e2f2d2a2cb232920d2df16a5f3f4_1440w.jpg" alt="">&lt;/p>
&lt;p>通常，第一项是「&lt;code>.&lt;/code>」，表示当前目录，第二项是「&lt;code>..&lt;/code>」，表示上一级目录，接下来就是一项一项的文件名和 inode。&lt;/p>
&lt;p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p>
&lt;p>于是，保存目录的格式改成&lt;strong>哈希表&lt;/strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p>
&lt;p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。&lt;/p>
&lt;p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。&lt;/p>
&lt;hr>
&lt;h3 id="软链接和硬链接">软链接和硬链接&lt;/h3>
&lt;p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过&lt;strong>硬链接（&lt;em>Hard Link&lt;/em>）&lt;/strong> 和&lt;strong>软链接（&lt;em>Symbolic Link&lt;/em>）&lt;/strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。&lt;/p>
&lt;ul>
&lt;li>硬链接: &lt;strong>多个dentry中的inode指向一个文件&lt;/strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong>硬链接是不可用于跨文件系统的&lt;/strong>。由于多个&lt;code>dentry&lt;/code>都是指向一个 inode，那么&lt;strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-7cf8cec396a66dca2dd1fcd6dadab537_1440w.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>软链接相当于重新创建一个文件，这个文件有&lt;strong>独立的 inode&lt;/strong>，但是这个&lt;strong>文件的内容是另外一个文件的路径&lt;/strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所以&lt;strong>软链接是可以跨文件系统的&lt;/strong>，甚至&lt;strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-5606413e1b5d2c727399711d347617a2_1440w.jpg" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="文件-io">文件 I/O&lt;/h3>
&lt;p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有&lt;/p>
&lt;ul>
&lt;li>缓冲与非缓冲 I/O&lt;/li>
&lt;li>直接与非直接 I/O&lt;/li>
&lt;li>阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/li>
&lt;/ul>
&lt;p>接下来，分别对这些分类讨论讨论。&lt;/p>
&lt;h3 id="缓冲与非缓冲-io">缓冲与非缓冲 I/O&lt;/h3>
&lt;p>文件操作的标准库是可以实现数据的缓存，那么&lt;strong>根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>缓冲 I/O：利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。 -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非缓冲 I/O：直接通过系统调用访问文件，不经过标准库缓存。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里所说的「缓冲」特指标准库内部实现的缓冲。&lt;/p>
&lt;p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。&lt;/p>
&lt;h3 id="直接与非直接-io">直接与非直接 I/O&lt;/h3>
&lt;p>我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。&lt;/p>
&lt;p>那么，&lt;strong>根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。&lt;/li>
&lt;li>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。&lt;/li>
&lt;/ul>
&lt;p>如果你在使用文件操作类的系统调用函数时，指定了 &lt;code>O_DIRECT&lt;/code> 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。&lt;/p>
&lt;blockquote>
&lt;p>如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？&lt;/p>
&lt;/blockquote>
&lt;p>以下几种场景会触发内核缓存的数据写入磁盘：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在调用 &lt;code>write&lt;/code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户主动调用 &lt;code>sync&lt;/code>，内核缓存会刷到磁盘上； - 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上； -&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="阻塞与非阻塞-io-vs-同步与异步-io">阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/h3>
&lt;p>为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。&lt;/p>
&lt;p>先来看看&lt;strong>阻塞 I/O&lt;/strong>，当用户程序执行 &lt;code>read&lt;/code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，&lt;code>read&lt;/code> 才会返回。&lt;/p>
&lt;p>注意，&lt;strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程&lt;/strong>。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-7f73fdcaca316aa0f12d77b6873785e5_1440w.jpg" alt="">&lt;/p>
&lt;p>知道了阻塞 I/O ，来看看&lt;strong>非阻塞 I/O&lt;/strong>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，&lt;code>read&lt;/code> 调用才可以获取到结果。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-51e052e2beecef41da3aed3ebc2b80bd_1440w.jpg" alt="">&lt;/p>
&lt;p>注意，&lt;strong>这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。&lt;/strong>&lt;/p>
&lt;p>举个例子，访问管道或 socket 时，如果设置了 &lt;code>O_NONBLOCK&lt;/code> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。&lt;/p>
&lt;p>应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。&lt;/p>
&lt;p>为了解决这种傻乎乎轮询方式，于是 &lt;strong>I/O 多路复用&lt;/strong>技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。&lt;/p>
&lt;p>这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。&lt;/p>
&lt;p>下图是使用 select I/O 多路复用过程。注意，&lt;code>read&lt;/code> 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个&lt;strong>同步的过程&lt;/strong>，需要等待：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-02cfbd8572026087fc9b8e946b4d98bf_1440w.jpg" alt="">&lt;/p>
&lt;p>实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用&lt;strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。&lt;/strong>&lt;/p>
&lt;p>而真正的&lt;strong>异步 I/O&lt;/strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。&lt;/p>
&lt;p>当我们发起 &lt;code>aio_read&lt;/code> 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-b01988dd44a5edbe596a280d1c266033_1440w.jpg" alt="">&lt;/p>
&lt;p>下面这张图，总结了以上几种 I/O 模型：&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-1e7c3779cdf820da751a4fb1c84a602c_1440w.jpg" alt="">&lt;/p>
&lt;p>在前面我们知道了，I/O 是分为两个过程的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>数据准备的过程 ；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据从内核空间拷贝到用户进程缓冲区的过程；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。&lt;/p>
&lt;p>异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p>
&lt;blockquote>
&lt;p>用故事去理解这几种 I/O 模型&lt;/p>
&lt;/blockquote>
&lt;p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code>select&lt;/code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p>
&lt;p>异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p></description></item><item><title>Rust安装配置</title><link>https://justice.bj.cn/post/14.language/rust/rust%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/rust%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid><description>&lt;h1 id="rust安装配置">Rust安装配置&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>rust官方提供了&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;ul>
&lt;li>rust官方提供了&lt;code>rustup&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># 安装rustup, rustc, cargo&lt;/span>
curl https://sh.rustup.rs -sSf &lt;span class="p">|&lt;/span> sh
&lt;span class="c1"># 安装源码, rls&lt;/span>
rustup component add rust-src rls
&lt;span class="c1"># 启用国内rustup 清华镜像(bash)&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup&amp;#39;&lt;/span> &amp;gt;&amp;gt; ~/.bash_profile
&lt;span class="c1"># 启用国内rustup 清华镜像(fish)&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;set -x RUSTUP_DIST_SERVER https://mirrors.tuna.tsinghua.edu.cn/rustup&amp;#39;&lt;/span> &amp;gt;&amp;gt; ~/.config/fish/config.fish
&lt;span class="c1"># 切换nightly版&lt;/span>
rustup override &lt;span class="nb">set&lt;/span> nightly
&lt;span class="c1"># 切换stable版&lt;/span>
rustup override &lt;span class="nb">set&lt;/span> stable
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="使用科大-rust-镜像加速国内环境">使用科大 rust 镜像加速国内环境&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="c1"># ~/.cargo/config&lt;/span>
&lt;span class="k">[registry]&lt;/span>
&lt;span class="na">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;https://mirrors.ustc.edu.cn/crates.io-index/&amp;#34;&lt;/span>
&lt;span class="k">[source.crates-io]&lt;/span>
&lt;span class="na">registry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;https://github.com/rust-lang/crates.io-index&amp;#34;&lt;/span>
&lt;span class="na">replace-with&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#39;ustc&amp;#39;&lt;/span>
&lt;span class="k">[source.ustc]&lt;/span>
&lt;span class="na">registry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;https://mirrors.ustc.edu.cn/crates.io-index/&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="rustup">rustup&lt;/h2>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.jianshu.com/p/64d54d39cffb">https://www.jianshu.com/p/64d54d39cffb&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/wowotuo/article/details/76375395">https://blog.csdn.net/wowotuo/article/details/76375395&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://lotabout.me/2016/rust-lifetime/">https://lotabout.me/2016/rust-lifetime/&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Rust模块及包管理</title><link>https://justice.bj.cn/post/14.language/rust/80.rust%E5%8C%85%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 04 Jun 2022 10:26:13 +0800</pubDate><guid>https://justice.bj.cn/post/14.language/rust/80.rust%E5%8C%85%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="rust模块及包管理">Rust模块及包管理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Rust程序代码组织分为两个层级：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>包(crate)&lt;/strong>：是一个独立的可编译单元；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>模块(mod)&lt;/strong>：是包内代码组织单元；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="包crate">包(Crate)&lt;/h2>
&lt;p>包(&lt;code>crate&lt;/code>)是rust可独立编译的单元，包要点如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>包&lt;code>crate&lt;/code> 由一个或一批文件组成，可独立编译为二进制文件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>包有两种类型：库(lib)和可执行二进制文件(bin)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同一个包的文件一般放在同一个目录下；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个包有一个入口文件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>二进制包入口为&lt;code>main.rs&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>库的入口文件是&lt;code>lib.rs&lt;/code>;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>包由&lt;code>Cargo.toml&lt;/code>管理组织；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引入外部crate：&lt;code>extern crate xxx;&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用未发布的本地crate, 在&lt;code>Cargo.toml&lt;/code> &lt;code>dependencies&lt;/code>中声明；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="p">[&lt;/span>&lt;span class="nx">package&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;crate-name&amp;#34;&lt;/span>
&lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.1.0&amp;#34;&lt;/span>
&lt;span class="nx">authors&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;xxx&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">edition&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;2018&amp;#34;&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#xxx&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">features&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="c">#default = [&amp;#34;test&amp;#34;]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="模块module">模块（module）&lt;/h2>
&lt;p>模块(&lt;code>mod&lt;/code>)是包内部代码组织单元，模块要点如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>模块由关键字&lt;code>mod&lt;/code>定义：&lt;code>mod XXX { ... } &lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块的命名风格是 &lt;code>lower_snake_case&lt;/code>，跟其它的 Rust 的标识符一样；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块可以嵌套；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块中可以写任何合法的 Rust 代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个包默认实现了一个隐式的 &lt;code>根模块（root module）&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>独立的一个文件就是一个mod, mod名就是文件名，main.rs, lib.rs, mod.rs文件除外；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mod.rs&lt;/code>的模块名就是其所在目录的名字；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>main.rs&lt;/code>, &lt;code>lib.rs&lt;/code> 的模块名是其目录结构，如：&lt;code>exp/src/main.rs&lt;/code>或 &lt;code>lip/src/lib.rs&lt;/code> ;两者的mod名分别是exp和lip；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文件和文件夹内的mod及其内部定义的函数默认都是private的，除非pub声明公开；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>private元素只有本模块内的元素以及它的子模块可以访问；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>public元素上一层的模块就有权访问它；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果存在与文件同名的目录， 则在该目录下定义的模块都是该文件的子模块；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Rust 的多层模块遵循如下两条规则：&lt;/p>
&lt;ol>
&lt;li>优先查找&lt;code>xxx.rs&lt;/code> 文件
&lt;ol>
&lt;li>&lt;code>main.rs&lt;/code>、&lt;code>lib.rs&lt;/code>、&lt;code>mod.rs&lt;/code>中的&lt;code>mod xxx;&lt;/code> 默认优先查找同级目录下的 &lt;code>xxx.rs&lt;/code> 文件；&lt;/li>
&lt;li>其他文件&lt;code>yyy.rs&lt;/code>中的&lt;code>mod xxx;&lt;/code>默认优先查找同级目录的&lt;code>yyy&lt;/code>目录下的 &lt;code>xxx.rs&lt;/code> 文件；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>如果 &lt;code>xxx.rs&lt;/code> 不存在，则查找 &lt;code>xxx/mod.rs&lt;/code> 文件，即 &lt;code>xxx&lt;/code> 目录下的 &lt;code>mod.rs&lt;/code> 文件。&lt;/li>
&lt;/ol>
&lt;p>上述两种情况，加载成模块后，效果是相同的。Rust 就凭这两条规则，通过迭代使用，结合 &lt;code>pub&lt;/code> 关键字，实现了对深层目录下模块的加载；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">src
├── a
│ ├── b
│ │ ├── c
│ │ │ ├── d.rs
│ │ │ └── mod.rs
│ │ └── mod.rs
│ └── mod.rs
└── main.rs
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// a/b/c/d.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">print_ddd&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;i am ddd.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/b/c/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">d&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/b/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">c&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// a/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">b&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">a&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>::&lt;span class="n">b&lt;/span>::&lt;span class="n">c&lt;/span>::&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">d&lt;/span>::&lt;span class="n">print_ddd&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="模块路径">模块路径&lt;/h3>
&lt;p>想要调用一个函数，就需要知道它的路径，在 Rust 中，这种路径有两种形式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>绝对路径&lt;/strong>，从包根开始，路径名以包名或者 &lt;code>crate&lt;/code> 作为开头&lt;/li>
&lt;li>&lt;strong>相对路径&lt;/strong>，从当前模块开始，以 &lt;code>self&lt;/code>，&lt;code>super&lt;/code> 或当前模块的标识符作为开头&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">// src/lib.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">front_of_house&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">hosting&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">add_to_waitlist&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">eat_at_restaurant&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 绝对路径
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">crate&lt;/span>::&lt;span class="n">front_of_house&lt;/span>::&lt;span class="n">hosting&lt;/span>::&lt;span class="n">add_to_waitlist&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 相对路径
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">front_of_house&lt;/span>::&lt;span class="n">hosting&lt;/span>::&lt;span class="n">add_to_waitlist&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="模块系统">模块系统&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>单文件rust 中称为&lt;code>mod&lt;/code>，模块的名称就是文件的名称。&lt;/p>
&lt;p>模块内部的函数，只能在模块内部使用，如果要在模块外调用，需要用&lt;code>pub&lt;/code>关键词，显式声明函数可在外部使用。&lt;/p>
&lt;p>使用时，使用mod声明引入，mod name::&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//file: rustmod/src/functions.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">// 嵌套子模块
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">util&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rust/src/main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">functions&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//声明模块
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">functions&lt;/span>::&lt;span class="n">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">functions&lt;/span>::&lt;span class="n">util&lt;/span>::&lt;span class="n">hello2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用mod.rs, mod 会去对应目录下mod.rs中导入该目录下声明的mod&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="c1">//file: rustmod/src/util/functions.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, {}!&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rustmod/src/util/mod.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">functions&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">//file: rustmod/src/main.rs
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">mod&lt;/span> &lt;span class="nn">util&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">util&lt;/span>::&lt;span class="n">functions&lt;/span>::&lt;span class="n">util&lt;/span>::&lt;span class="n">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;{}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在同一层级不能同时存在文件夹和文件类型的模块，否则会名字冲突。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="典型rust项目结构">典型rust项目结构&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">.
├── Cargo.toml &lt;span class="c1">## cargo配置文件&lt;/span>
├── Cargo.lock
├── src
│ ├── main.rs &lt;span class="c1">## 默认二进制包入口&lt;/span>
│ ├── lib.rs &lt;span class="c1">## 默认lib包入口&lt;/span>
│ └── bin
│ └── main1.rs &lt;span class="c1">## 二进制可执行文件main1&lt;/span>
│ └── main2.rs &lt;span class="c1">## 二进制可执行文件main2&lt;/span>
├── tests
│ └── some_integration_tests.rs &lt;span class="c1">## 集成测试&lt;/span>
├── benches
│ └── simple_bench.rs &lt;span class="c1">## 性能测试&lt;/span>
└── examples
└── simple_example.rs &lt;span class="c1">## example&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://course.rs/basic/crate-module/intro.html#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97">Rust语言圣经(Rust Course)-包和模块&lt;/a>&lt;/li>
&lt;/ol></description></item></channel></rss>