<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Justice的小站</title><link>https://justice.bj.cn/</link><description>Recent content on Justice的小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 09 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://justice.bj.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Justice's Blog</title><link>https://justice.bj.cn/homepage/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/about/</guid><description>&lt;h2 id="self-introduction">Self Introduction&lt;/h2>
&lt;p>Cras ex dui, tristique a libero eget, consectetur semper ligula. Nunc augue arcu, malesuada a nisi et, molestie finibus metus. Sed lacus odio, ultricies a nisl vitae, sollicitudin tempor ipsum. Vivamus quis feugiat arcu. Sed mi nunc, efficitur quis tellus vitae, posuere mattis metus. Phasellus in mattis dui. Nullam blandit, augue non ullamcorper dapibus, lacus dui molestie massa, in iaculis purus lectus eu lectus. Duis hendrerit lacinia tellus, sit amet feugiat dolor placerat id. Aenean ac velit massa. Vivamus feugiat dui at magna viverra, ut dictum nunc rutrum. Duis eget sapien finibus, lobortis orci id, vestibulum tellus. Maecenas lobortis urna libero, quis fermentum lectus lobortis nec. Nullam laoreet volutpat libero, ac mattis magna ullamcorper quis. Duis eget ipsum eu nisi mattis cursus et vitae turpis.&lt;/p>
&lt;p>Aliquam pretium diam eget leo feugiat finibus. Donec malesuada commodo ipsum. Aenean a massa in lacus venenatis vestibulum. Duis vel sem quis elit iaculis consectetur et quis dolor. Morbi eu ipsum hendrerit, malesuada ante sed, dapibus est. Suspendisse feugiat nulla ut gravida convallis. Phasellus id massa posuere, rhoncus justo ut, porttitor dolor. Nulla ultrices malesuada egestas. Nunc fermentum tincidunt sem ac vulputate. Donec mollis sollicitudin justo eget varius. Donec ornare velit et felis blandit, id molestie sapien lobortis. Morbi eget tristique justo. Mauris posuere, nibh eu laoreet ultricies, ligula erat iaculis sapien, vel dapibus lacus libero ut diam. Etiam viverra ante felis, et scelerisque nunc pellentesque vitae. Praesent feugiat dictum molestie.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>Nunc pellentesque vitae:&lt;/p>
&lt;ul>
&lt;li>Morbi accumsan nibh efficitur diam molestie, non dignissim diam facilisis.&lt;/li>
&lt;li>Donec dignissim leo in mollis faucibus.&lt;/li>
&lt;li>Donec blandit lacus a pellentesque fermentum.&lt;/li>
&lt;/ul>
&lt;p>Donec mollis sollicitudin:&lt;/p>
&lt;ul>
&lt;li>Nunc dictum purus ornare purus consectetur, eu pellentesque massa ullamcorper.&lt;/li>
&lt;li>Aliquam eu leo vitae justo aliquam tincidunt.&lt;/li>
&lt;li>Fusce non massa id augue interdum feugiat sed et nulla.&lt;/li>
&lt;li>Vivamus molestie augue in tristique laoreet.&lt;/li>
&lt;/ul></description></item><item><title>Pages</title><link>https://justice.bj.cn/homepage/pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/pages/</guid><description/></item><item><title>Experiences</title><link>https://justice.bj.cn/homepage/experiences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/experiences/</guid><description/></item><item><title>Vintage</title><link>https://justice.bj.cn/homepage/vintage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/vintage/</guid><description/></item><item><title>Blank</title><link>https://justice.bj.cn/homepage/blank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/homepage/blank/</guid><description>
&lt;div style="text-align:center">
&lt;p>Write anything you like here!&lt;/p>
&lt;/div></description></item><item><title>Elasticsearch写流程</title><link>https://justice.bj.cn/post/30.architech/elasticsearch/es%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/elasticsearch/es%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/</guid><description>&lt;h1 id="elasticsearch写流程">Elasticsearch写流程&lt;/h1>
&lt;h2 id="lucene的写操作及其问题">lucene的写操作及其问题&lt;/h2>
&lt;p>Elasticsearch底层使用Lucene来实现doc的读写操作，Lucene通过&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">addDocument&lt;/span>&lt;span class="o">(...);&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">deleteDocuments&lt;/span>&lt;span class="o">(...);&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">updateDocument&lt;/span>&lt;span class="o">(...);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>三个方法来实现文档的写入，更新和删除操作。但是存在如下问题&lt;/p>
&lt;ol>
&lt;li>&lt;strong>没有并发设计&lt;/strong>。 lucene只是一个搜索引擎库，并没有涉及到分布式相关的设计，因此要想使用Lucene来处理海量数据，并利用分布式的能力，就必须在其之上进行分布式的相关设计。&lt;/li>
&lt;li>&lt;strong>非实时&lt;/strong>。 将文件写入lucence后并不能立即被检索，需要等待lucene生成一个完整的segment才能被检索&lt;/li>
&lt;li>&lt;strong>数据存储不可靠&lt;/strong>。 写入lucene的数据不会立即被持久化到磁盘，如果服务器宕机，那存储在内存中的数据将会丢失&lt;/li>
&lt;li>&lt;strong>不支持部分更新&lt;/strong> 。lucene中提供的updateDocuments仅支持对文档的全量更新，对部分更新不支持&lt;/li>
&lt;/ol>
&lt;h2 id="2-elasticsearch的写入方案">2. Elasticsearch的写入方案&lt;/h2>
&lt;p>针对Lucene的问题，ES做了如下设计&lt;/p>
&lt;h3 id="21-分布式设计">2.1 分布式设计：&lt;/h3>
&lt;p>为了支持对海量数据的存储和查询，Elasticsearch引入分片的概念，一个索引被分成多个分片，每个分片可以有一个主分片和多个副本分片，每个分片副本都是一个具有完整功能的lucene实例。分片可以分配在不同的服务器上，同一个分片的不同副本不能分配在相同的服务器上。&lt;/p>
&lt;p>在进行写操作时，ES会根据传入的_routing参数（或mapping中设置的_routing, 如果参数和设置中都没有则默认使用_id), 按照公式 &lt;code>shard_num=hash(\routing)%num_primary_shards&lt;/code>,计算出文档要分配到的分片，在从集群元数据中找出对应主分片的位置，将请求路由到该分片进行文档写操作。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-8ce7b65ede7b511a2d6d02530ed501d6_720w.jpg" alt="">&lt;/p>
&lt;h3 id="22-近实时性-refresh操作">2.2 近实时性-refresh操作&lt;/h3>
&lt;p>当一个文档写入Lucene后是不能被立即查询到的，Elasticsearch提供了一个refresh操作，会定时地调用lucene的reopen(新版本为openIfChanged)为内存中新写入的数据生成一个新的segment，此时被处理的文档均可以被检索到。refresh操作的时间间隔由 &lt;code>refresh_interval&lt;/code>参数控制，默认为1s, 当然还可以在写入请求中带上refresh表示写入后立即refresh，另外还可以调用refresh API显式refresh。&lt;/p>
&lt;h3 id="23-数据存储可靠性">2.3 数据存储可靠性&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>引入translog&lt;/strong> 当一个文档写入Lucence后是存储在内存中的，即使执行了refresh操作仍然是在文件系统缓存中，如果此时服务器宕机，那么这部分数据将会丢失。为此ES增加了translog， 当进行文档写操作时会先将文档写入Lucene，然后写入一份到translog，写入translog是落盘的(如果对可靠性要求不是很高，也可以设置异步落盘，可以提高性能，由配置 &lt;code>index.translog.durability&lt;/code>和 &lt;code>index.translog.sync_interval&lt;/code>控制)，这样就可以防止服务器宕机后数据的丢失。由于translog是追加写入，因此性能要比随机写入要好。与传统的分布式系统不同，这里是先写入Lucene再写入translog，原因是写入Lucene可能会失败，为了减少写入失败回滚的复杂度，因此先写入Lucene.&lt;/li>
&lt;li>&lt;strong>flush操作&lt;/strong> 另外每30分钟或当translog达到一定大小(由 &lt;code>index.translog.flush_threshold_size&lt;/code>控制，默认512mb), ES会触发一次flush操作，此时ES会先执行refresh操作将buffer中的数据生成segment，然后调用lucene的commit方法将所有内存中的segment fsync到磁盘。此时lucene中的数据就完成了持久化，会清空translog中的数据(6.x版本为了实现sequenceIDs,不删除translog)&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-9418f89986e3a141b3acf83cf158885a_720w.jpg" alt="">&lt;/p>
&lt;ol>
&lt;li>&lt;strong>merge操作&lt;/strong> 由于refresh默认间隔为1s中，因此会产生大量的小segment，为此ES会运行一个任务检测当前磁盘中的segment，对符合条件的segment进行合并操作，减少lucene中的segment个数，提高查询速度，降低负载。不仅如此，merge过程也是文档删除和更新操作后，旧的doc真正被删除的时候。用户还可以手动调用_forcemerge API来主动触发merge，以减少集群的segment个数和清理已删除或更新的文档。&lt;/li>
&lt;li>&lt;strong>多副本机制&lt;/strong> 另外ES有多副本机制，一个分片的主副分片不能分片在同一个节点上，进一步保证数据的可靠性。&lt;/li>
&lt;/ol>
&lt;h3 id="24-部分更新">2.4 部分更新&lt;/h3>
&lt;p>lucene仅支持对文档的整体更新，ES为了支持局部更新，在Lucene的Store索引中存储了一个_source字段，该字段的key值是文档ID， 内容是文档的原文。当进行更新操作时先从_source中获取原文，与更新部分合并后，再调用lucene API进行全量更新， 对于写入了ES但是还没有refresh的文档，可以从translog中获取。另外为了防止读取文档过程后执行更新前有其他线程修改了文档，ES增加了版本机制，当执行更新操作时发现当前文档的版本与预期不符，则会重新获取文档再更新。&lt;/p>
&lt;h2 id="3-es的写入流程">3. ES的写入流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>选择任意一个DataNode发送请求，例如：node2。此时，node2就成为一个 coordinating node（协调节点）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算得到文档要写入的分片 &lt;code>shard = hash(routing) % number_of_primary_shards&lt;/code> routing 是一个可变值，默认是文档的 _id ；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>coordinating node会进行路由，将请求转发给对应的primary shard所在的 DataNode（假设primary shard在node1、replica shard在node2） ；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>node1节点上的Primary Shard处理请求，写入数据到索引库中，并将数据同步到 Replica shard ；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Primary Shard和Replica Shard都保存好了文档，返回client；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>大致流程如下图：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-b0b0c96aaeadfde4da0685dae4b9908f_720w.jpg" alt="">&lt;/p>
&lt;h3 id="31-coordinating节点">3.1 coordinating节点&lt;/h3>
&lt;p>ES中接收并转发请求的节点称为&lt;code>coordinating&lt;/code>节点，ES中所有节点都可以接受并转发请求。当一个节点接受到写请求或更新请求后，会执行如下操作：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>ingest pipeline&lt;/strong> 查看该请求是否符合某个ingest pipeline的pattern, 如果符合则执行pipeline中的逻辑，一般是对文档进行各种预处理，如格式调整，增加字段等。如果当前节点没有ingest角色，则需要将请求转发给有ingest角色的节点执行。&lt;/li>
&lt;li>&lt;strong>自动创建索引&lt;/strong> 判断索引是否存在，如果开启了自动创建则自动创建，否则报错&lt;/li>
&lt;li>&lt;strong>设置routing&lt;/strong> 获取请求URL或mapping中的_routing，如果没有则使用_id, 如果没有指定_id则ES会自动生成一个全局唯一ID。该_routing字段用于决定文档分配在索引的哪个shard上。&lt;/li>
&lt;li>&lt;strong>构建BulkShardRequest&lt;/strong> 由于Bulk Request中包含多种(Index/Update/Delete)请求，这些请求分别需要到不同的shard上执行，因此协调节点，会将请求按照shard分开，同一个shard上的请求聚合到一起，构建BulkShardRequest&lt;/li>
&lt;li>&lt;strong>将请求发送给primary shard&lt;/strong> 因为当前执行的是写操作，因此只能在primary上完成，所以需要把请求路由到primary shard所在节点&lt;/li>
&lt;li>&lt;strong>等待primary shard返回&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>目前的Elasticsearch有两个明显的身份，一个是分布式搜索系统，另一个是分布式NoSQL数据库，对于这两种不同的身份，读写语义基本类似，但也有一点差异。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-aced78c779161b2a5baa366f63d86883_720w.jpg" alt="">&lt;/p>
&lt;h2 id="写操作">&lt;strong>写操作&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>实时性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>搜索系统的Index一般都是NRT（Near Real Time），近实时的，比如Elasticsearch中，Index的实时性是由refresh控制的，默认是1s，最快可到100ms，那么也就意味着Index doc成功后，需要等待一秒钟后才可以被搜索到。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NoSQL数据库的Write基本都是RT（Real Time），实时的，写入成功后，立即是可见的。Elasticsearch中的Index请求也能保证是实时的，因为Get请求会直接读内存中尚未Flush到存储介质的TransLog。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>可靠性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>搜索系统对可靠性要求都不高，一般数据的可靠性通过将原始数据存储在另一个存储系统来保证，当搜索系统的数据发生丢失时，再从其他存储系统导一份数据过来重新rebuild就可以了。在Elasticsearch中，通过设置TransLog的Flush频率可以控制可靠性，要么是按请求，每次请求都Flush；要么是按时间，每隔一段时间Flush一次。一般为了性能考虑，会设置为每隔5秒或者1分钟Flush一次，Flush间隔时间越长，可靠性就会越低。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NoSQL数据库作为一款数据库，必须要有很高的可靠性，数据可靠性是生命底线，决不能有闪失。如果把Elasticsearch当做NoSQL数据库，此时需要设置TransLog的Flush策略为每个请求都要Flush，这样才能保证当前Shard写入成功后，数据能尽量持久化下来。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="读操作">读操作&lt;/h2>
&lt;p>下一篇《Elasticsearch内核解析 - 查询篇》中再详细介绍。&lt;/p>
&lt;p>上面大概对比了下搜索和NoSQL在写方面的特点，接下来，我们看一下Elasticsearch 6.0.0版本中写入流程都做了哪些事情，希望能对大家有用。&lt;/p>
&lt;h2 id="关键点">&lt;strong>关键点&lt;/strong>&lt;/h2>
&lt;p>在考虑或分析一个分布式系统的写操作时，一般需要从下面几个方面考虑：&lt;/p>
&lt;ul>
&lt;li>可靠性：或者是持久性，数据写入系统成功后，数据不会被回滚或丢失。&lt;/li>
&lt;li>一致性：数据写入成功后，再次查询时必须能保证读取到最新版本的数据，不能读取到旧数据。&lt;/li>
&lt;li>原子性：一个写入或者更新操作，要么完全成功，要么完全失败，不允许出现中间状态。&lt;/li>
&lt;li>隔离性：多个写入操作相互不影响。&lt;/li>
&lt;li>实时性：写入后是否可以立即被查询到。&lt;/li>
&lt;li>性能：写入性能，吞吐量到底怎么样。&lt;/li>
&lt;/ul>
&lt;p>Elasticsearch作为分布式系统，也需要在写入的时候满足上述的四个特点，我们在后面的写流程介绍中会涉及到上述四个方面。&lt;/p>
&lt;p>接下来,我们一层一层剖析Elasticsearch内部的写机制。&lt;/p>
&lt;h2 id="lucene的写">&lt;strong>Lucene的写&lt;/strong>&lt;/h2>
&lt;p>众所周知，Elasticsearch内部使用了Lucene完成索引创建和搜索功能，Lucene中写操作主要是通过IndexWriter类实现，IndexWriter提供三个接口：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">addDocument&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">updateDocuments&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">deleteDocuments&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过这三个接口可以完成单个文档的写入，更新和删除功能，包括了分词，倒排创建，正排创建等等所有搜索相关的流程。只要Doc通过IndesWriter写入后，后面就可以通过IndexSearcher搜索了，看起来功能已经完善了，但是仍然有一些问题没有解：&lt;/p>
&lt;ol>
&lt;li>上述操作是单机的，而不是我们需要的分布式。&lt;/li>
&lt;li>文档写入Lucene后并不是立即可查询的，需要生成完整的Segment后才可被搜索，如何保证实时性？&lt;/li>
&lt;li>Lucene生成的Segment是在内存中，如果机器宕机或掉电后，内存中的Segment会丢失，如何保证数据可靠性 ？&lt;/li>
&lt;li>Lucene不支持部分文档更新，但是这又是一个强需求，如何支持部分更新？&lt;/li>
&lt;/ol>
&lt;p>上述问题，在Lucene中是没有解决的，那么就需要Elasticsearch中解决上述问题。&lt;/p>
&lt;p>Elasticsearch在解决上述问题时，除了我们在上一篇《Elasticsearch数据模型简介》中介绍的几种系统字段外，在引擎架构上也引入了多重机制来解决问题。我们再来看Elasticsearch中的写机制。&lt;/p>
&lt;h2 id="elasticsearch的写">&lt;strong>Elasticsearch的写&lt;/strong>&lt;/h2>
&lt;p>Elasticsearch采用多Shard方式，通过配置routing规则将数据分成多个数据子集，每个数据子集提供独立的索引和搜索功能。当写入文档的时候，根据routing规则，将文档发送给特定Shard中建立索引。这样就能实现分布式了。&lt;/p>
&lt;p>此外，Elasticsearch整体架构上采用了一主多副的方式：&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-8203d235d8cfc14849012e6ea229fa89_720w.jpg" alt="">&lt;/p>
&lt;p>Elasticsearch一主多副&lt;/p>
&lt;p>每个Index由多个Shard组成，每个Shard有一个主节点和多个副本节点，副本个数可配。但每次写入的时候，写入请求会先根据_routing规则选择发给哪个Shard，Index Request中可以设置使用哪个Filed的值作为路由参数，如果没有设置，则使用Mapping中的配置，如果mapping中也没有配置，则使用_id作为路由参数，然后通过_routing的Hash值选择出Shard（在OperationRouting类中），最后从集群的Meta中找出出该Shard的Primary节点。&lt;/p>
&lt;p>请求接着会发送给Primary Shard，在Primary Shard上执行成功后，再从Primary Shard上将请求同时发送给多个Replica Shard，请求在多个Replica Shard上执行成功并返回给Primary Shard后，写入请求执行成功，返回结果给客户端。&lt;/p>
&lt;p>这种模式下，写入操作的延时就等于latency = Latency(Primary Write) + Max(Replicas Write)。只要有副本在，写入延时最小也是两次单Shard的写入时延总和，写入效率会较低，但是这样的好处也很明显，避免写入后，单机或磁盘故障导致数据丢失，在数据重要性和性能方面，一般都是优先选择数据，除非一些允许丢数据的特殊场景。&lt;/p>
&lt;p>采用多个副本后，避免了单机或磁盘故障发生时，对已经持久化后的数据造成损害，但是Elasticsearch里为了减少磁盘IO保证读写性能，一般是每隔一段时间（比如5分钟）才会把Lucene的Segment写入磁盘持久化，对于写入内存，但还未Flush到磁盘的Lucene数据，如果发生机器宕机或者掉电，那么内存中的数据也会丢失，这时候如何保证？&lt;/p>
&lt;p>对于这种问题，Elasticsearch学习了数据库中的处理方式：增加CommitLog模块，Elasticsearch中叫TransLog。&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-20a780ddd33a74b37a81e18d3baf8983_720w.jpg" alt="">&lt;/p>
&lt;p>Refresh &amp;amp;&amp;amp; Flush&lt;/p>
&lt;p>在每一个Shard中，写入流程分为两部分，先写入Lucene，再写入TransLog。&lt;/p>
&lt;p>写入请求到达Shard后，先写Lucene文件，创建好索引，此时索引还在内存里面，接着去写TransLog，写完TransLog后，刷新TransLog数据到磁盘上，写磁盘成功后，请求返回给用户。这里有几个关键点，一是和数据库不同，数据库是先写CommitLog，然后再写内存，而Elasticsearch是先写内存，最后才写TransLog，一种可能的原因是Lucene的内存写入会有很复杂的逻辑，很容易失败，比如分词，字段长度超过限制等，比较重，为了避免TransLog中有大量无效记录，减少recover的复杂度和提高速度，所以就把写Lucene放在了最前面。二是写Lucene内存后，并不是可被搜索的，需要通过Refresh把内存的对象转成完整的Segment后，然后再次reopen后才能被搜索，一般这个时间设置为1秒钟，导致写入Elasticsearch的文档，最快要1秒钟才可被从搜索到，所以Elasticsearch在搜索方面是NRT（Near Real Time）近实时的系统。三是当Elasticsearch作为NoSQL数据库时，查询方式是GetById，这种查询可以直接从TransLog中查询，这时候就成了RT（Real Time）实时系统。四是每隔一段比较长的时间，比如30分钟后，Lucene会把内存中生成的新Segment刷新到磁盘上，刷新后索引文件已经持久化了，历史的TransLog就没用了，会清空掉旧的TransLog。&lt;/p>
&lt;p>上面介绍了Elasticsearch在写入时的两个关键模块，Replica和TransLog，接下来，我们看一下Update流程：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-e728bc042a75f8798925d708dc61b1ef_720w.jpg" alt="">&lt;/p>
&lt;p>Update&lt;/p>
&lt;p>Lucene中不支持部分字段的Update，所以需要在Elasticsearch中实现该功能，具体流程如下：&lt;/p>
&lt;ol>
&lt;li>收到Update请求后，从Segment或者TransLog中读取同id的完整Doc，记录版本号为V1。&lt;/li>
&lt;li>将版本V1的全量Doc和请求中的部分字段Doc合并为一个完整的Doc，同时更新内存中的VersionMap。获取到完整Doc后，Update请求就变成了Index请求。&lt;/li>
&lt;li>加锁。&lt;/li>
&lt;li>再次从versionMap中读取该id的最大版本号V2，如果versionMap中没有，则从Segment或者TransLog中读取，这里基本都会从versionMap中获取到。&lt;/li>
&lt;li>检查版本是否冲突(V1==V2)，如果冲突，则回退到开始的“Update doc”阶段，重新执行。如果不冲突，则执行最新的Add请求。&lt;/li>
&lt;li>在Index Doc阶段，首先将Version + 1得到V3，再将Doc加入到Lucene中去，Lucene中会先删同id下的已存在doc id，然后再增加新Doc。写入Lucene成功后，将当前V3更新到versionMap中。&lt;/li>
&lt;li>释放锁，部分更新的流程就结束了。&lt;/li>
&lt;/ol>
&lt;p>介绍完部分更新的流程后，大家应该从整体架构上对Elasticsearch的写入有了一个初步的映象，接下来我们详细剖析下写入的详细步骤。&lt;/p>
&lt;h2 id="elasticsearch写入请求类型">&lt;strong>Elasticsearch写入请求类型&lt;/strong>&lt;/h2>
&lt;p>Elasticsearch中的写入请求类型，主要包括下列几个：Index(Create)，Update，Delete和Bulk，其中前3个是单文档操作，后一个Bulk是多文档操作，其中Bulk中可以包括Index(Create)，Update和Delete。&lt;/p>
&lt;p>在6.0.0及其之后的版本中，前3个单文档操作的实现基本都和Bulk操作一致，甚至有些就是通过调用Bulk的接口实现的。估计接下来几个版本后，Index(Create)，Update，Delete都会被当做Bulk的一种特例化操作被处理。这样，代码和逻辑都会更清晰一些。&lt;/p>
&lt;p>下面，我们就以Bulk请求为例来介绍写入流程。&lt;/p>
&lt;h2 id="elasticsearch写入流程图">&lt;strong>Elasticsearch写入流程图&lt;/strong>&lt;/h2>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-4e32cd77e69ae4932665d110d6bf13a1_720w.jpg" alt="">&lt;/p>
&lt;p>写入流程图&lt;/p>
&lt;ul>
&lt;li>红色：Client Node。&lt;/li>
&lt;li>绿色：Primary Node。&lt;/li>
&lt;li>蓝色：Replica Node。&lt;/li>
&lt;/ul>
&lt;h2 id="注册action">&lt;strong>注册Action&lt;/strong>&lt;/h2>
&lt;p>在Elasticsearch中，所有action的入口处理方法都是注册在ActionModule.java中，比如Bulk Request有两个注册入口，分别是Rest和Transport入口：&lt;/p>
&lt;p>&lt;img src="https://pic1.zhimg.com/80/v2-7506f5d87f80ec63cbd2030b785441ec_720w.jpg" alt="">&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-ac3d0e6ee82d507d38110565d121febf_720w.jpg" alt="">&lt;/p>
&lt;p>如果请求是Rest请求，则会在RestBulkAction中Parse Request，构造出BulkRequest，然后发给后面的TransportAction处理。&lt;/p>
&lt;p>TransportShardBulkAction的基类TransportReplicationAction中注册了对Primary，Replica等的不同处理入口:&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-4ac69cd72079de47adfb2d81906579db_720w.jpg" alt="">&lt;/p>
&lt;p>这里对原始请求，Primary Node请求和Replica Node请求各自注册了一个handler处理入口。&lt;/p>
&lt;h2 id="client-node">&lt;strong>Client Node&lt;/strong>&lt;/h2>
&lt;p>Client Node 也包括了前面说过的Parse Request，这里就不再赘述了，接下来看一下其他的部分。&lt;/p>
&lt;p>&lt;strong>1. Ingest Pipeline&lt;/strong>&lt;/p>
&lt;p>在这一步可以对原始文档做一些处理，比如HTML解析，自定义的处理，具体处理逻辑可以通过插件来实现。在Elasticsearch中，由于Ingest Pipeline会比较耗费CPU等资源，可以设置专门的Ingest Node，专门用来处理Ingest Pipeline逻辑。&lt;/p>
&lt;p>如果当前Node不能执行Ingest Pipeline，则会将请求发给另一台可以执行Ingest Pipeline的Node。&lt;/p>
&lt;p>&lt;strong>2. Auto Create Index&lt;/strong>&lt;/p>
&lt;p>判断当前Index是否存在，如果不存在，则需要自动创建Index，这里需要和Master交互。也可以通过配置关闭自动创建Index的功能。&lt;/p>
&lt;p>&lt;strong>3. Set Routing&lt;/strong>&lt;/p>
&lt;p>设置路由条件，如果Request中指定了路由条件，则直接使用Request中的Routing，否则使用Mapping中配置的，如果Mapping中无配置，则使用默认的_id字段值。&lt;/p>
&lt;p>在这一步中，如果没有指定&lt;em>id字段，则会自动生成一个唯一的_id字段，目前使用的是UUID。&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>4. Construct BulkShardRequest&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>由于Bulk Request中会包括多个(Index/Update/Delete)请求，这些请求根据routing可能会落在多个Shard上执行，这一步会按Shard挑拣Single Write Request，同一个Shard中的请求聚集在一起，构建BulkShardRequest，每个BulkShardRequest对应一个Shard。&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>5. Send Request To Primary&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>这一步会将每一个BulkShardRequest请求发送给相应Shard的Primary Node。&lt;/em>&lt;/p>
&lt;h2 id="primary-node">&lt;strong>Primary Node&lt;/strong>&lt;/h2>
&lt;p>Primary 请求的入口是在PrimaryOperationTransportHandler的messageReceived，我们来看一下相关的逻辑流程。&lt;/p>
&lt;p>&lt;strong>1. Index or Update or Delete&lt;/strong>&lt;/p>
&lt;p>循环执行每个Single Write Request，对于每个Request，根据操作类型(&lt;em>CREATE/INDEX/UPDATE/DELETE&lt;/em>)选择不同的处理逻辑。&lt;/p>
&lt;p>其中，Create/Index是直接新增Doc，Delete是直接根据_id删除Doc，Update会稍微复杂些，我们下面就以Update为例来介绍。&lt;/p>
&lt;p>&lt;strong>2. Translate Update To Index or Delete&lt;/strong>&lt;/p>
&lt;p>这一步是Update操作的特有步骤，在这里，会将Update请求转换为Index或者Delete请求。首先，会通过GetRequest查询到已经存在的同_id Doc（如果有）的完整字段和值（依赖_source字段），然后和请求中的Doc合并。同时，这里会获取到读到的Doc版本号，记做V1。&lt;/p>
&lt;p>&lt;strong>3. Parse Doc&lt;/strong>&lt;/p>
&lt;p>这里会解析Doc中各个字段。生成ParsedDocument对象，同时会生成uid Term。在Elasticsearch中，_uid = type # _id，对用户，_Id可见，而Elasticsearch中存储的是_uid。这一部分生成的ParsedDocument中也有Elasticsearch的系统字段，大部分会根据当前内容填充，部分未知的会在后面继续填充ParsedDocument。&lt;/p>
&lt;p>&lt;strong>4. Update Mapping&lt;/strong>&lt;/p>
&lt;p>Elasticsearch中有个自动更新Mapping的功能，就在这一步生效。会先挑选出Mapping中未包含的新Field，然后判断是否运行自动更新Mapping，如果允许，则更新Mapping。&lt;/p>
&lt;p>&lt;strong>5. Get Sequence Id and Version&lt;/strong>&lt;/p>
&lt;p>由于当前是Primary Shard，则会从SequenceNumber Service获取一个sequenceID和Version。SequenceID在Shard级别每次递增1，SequenceID在写入Doc成功后，会用来初始化LocalCheckpoint。Version则是根据当前Doc的最大Version递增1。&lt;/p>
&lt;p>&lt;strong>6. Add Doc To Lucene&lt;/strong>&lt;/p>
&lt;p>这一步开始的时候会给特定_uid加锁，然后判断该_uid对应的Version是否等于之前Translate Update To Index步骤里获取到的Version，如果不相等，则说明刚才读取Doc后，该Doc发生了变化，出现了版本冲突，这时候会抛出一个VersionConflict的异常，该异常会在Primary Node最开始处捕获，重新从“Translate Update To Index or Delete”开始执行。&lt;/p>
&lt;p>如果Version相等，则继续执行，如果已经存在同id的Doc，则会调用Lucene的UpdateDocument(uid, doc)接口，先根据uid删除Doc，然后再Index新Doc。如果是首次写入，则直接调用Lucene的AddDocument接口完成Doc的Index，AddDocument也是通过UpdateDocument实现。&lt;/p>
&lt;p>这一步中有个问题是，如何保证Delete-Then-Add的原子性，怎么避免中间状态时被Refresh？答案是在开始Delete之前，会加一个Refresh Lock，禁止被Refresh，只有等Add完后释放了Refresh Lock后才能被Refresh，这样就保证了Delete-Then-Add的原子性。&lt;/p>
&lt;p>Lucene的UpdateDocument接口中就只是处理多个Field，会遍历每个Field逐个处理，处理顺序是invert index，store field，doc values，point dimension，后续会有文章专门介绍Lucene中的写入。&lt;/p>
&lt;p>&lt;strong>7. Write Translog&lt;/strong>&lt;/p>
&lt;p>写完Lucene的Segment后，会以keyvalue的形式写TransLog，Key是_id，Value是Doc内容。当查询的时候，如果请求是GetDocByID，则可以直接根据_id从TransLog中读取到，满足NoSQL场景下的实时性要去。&lt;/p>
&lt;p>需要注意的是，这里只是写入到内存的TransLog，是否Sync到磁盘的逻辑还在后面。&lt;/p>
&lt;p>这一步的最后，会标记当前SequenceID已经成功执行，接着会更新当前Shard的LocalCheckPoint。&lt;/p>
&lt;p>&lt;strong>8. Renew Bulk Request&lt;/strong>&lt;/p>
&lt;p>这里会重新构造Bulk Request，原因是前面已经将UpdateRequest翻译成了Index或Delete请求，则后续所有Replica中只需要执行Index或Delete请求就可以了，不需要再执行Update逻辑，一是保证Replica中逻辑更简单，性能更好，二是保证同一个请求在Primary和Replica中的执行结果一样。&lt;/p>
&lt;p>&lt;strong>9. Flush Translog&lt;/strong>&lt;/p>
&lt;p>这里会根据TransLog的策略，选择不同的执行方式，要么是立即Flush到磁盘，要么是等到以后再Flush。Flush的频率越高，可靠性越高，对写入性能影响越大。&lt;/p>
&lt;p>&lt;strong>10. Send Requests To Replicas&lt;/strong>&lt;/p>
&lt;p>这里会将刚才构造的新的Bulk Request并行发送给多个Replica，然后等待Replica的返回，这里需要等待所有Replica返回后（可能有成功，也有可能失败），Primary Node才会返回用户。如果某个Replica失败了，则Primary会给Master发送一个Remove Shard请求，要求Master将该Replica Shard从可用节点中移除。&lt;/p>
&lt;p>这里，同时会将SequenceID，PrimaryTerm，GlobalCheckPoint等传递给Replica。&lt;/p>
&lt;p>发送给Replica的请求中，Action Name等于原始ActionName + [R]，这里的R表示Replica。通过这个[R]的不同，可以找到处理Replica请求的Handler。&lt;/p>
&lt;p>&lt;strong>11. Receive Response From Replicas&lt;/strong>&lt;/p>
&lt;p>Replica中请求都处理完后，会更新Primary Node的LocalCheckPoint。&lt;/p>
&lt;h2 id="replica-node">&lt;strong>Replica Node&lt;/strong>&lt;/h2>
&lt;p>Replica 请求的入口是在ReplicaOperationTransportHandler的messageReceived，我们来看一下相关的逻辑流程。&lt;/p>
&lt;p>&lt;strong>1. Index or Delete&lt;/strong>&lt;/p>
&lt;p>根据请求类型是Index还是Delete，选择不同的执行逻辑。这里没有Update，是因为在Primary Node中已经将Update转换成了Index或Delete请求了。&lt;/p>
&lt;p>&lt;strong>2. Parse Doc&lt;/strong>&lt;/p>
&lt;p>&lt;strong>3. Update Mapping&lt;/strong>&lt;/p>
&lt;p>以上都和Primary Node中逻辑一致。&lt;/p>
&lt;p>&lt;strong>4. Get Sequence Id and Version&lt;/strong>&lt;/p>
&lt;p>Primary Node中会生成Sequence ID和Version，然后放入ReplicaRequest中，这里只需要从Request中获取到就行。&lt;/p>
&lt;p>&lt;strong>5. Add Doc To Lucene&lt;/strong>&lt;/p>
&lt;p>由于已经在Primary Node中将部分Update请求转换成了Index或Delete请求，这里只需要处理Index和Delete两种请求，不再需要处理Update请求了。比Primary Node会更简单一些。&lt;/p>
&lt;p>&lt;strong>6. Write Translog&lt;/strong>&lt;/p>
&lt;p>&lt;strong>7. Flush Translog&lt;/strong>&lt;/p>
&lt;p>以上都和Primary Node中逻辑一致。&lt;/p>
&lt;h2 id="最后">&lt;strong>最后&lt;/strong>&lt;/h2>
&lt;p>上面详细介绍了Elasticsearch的写入流程及其各个流程的工作机制，我们在这里再次总结下之前提出的分布式系统中的六大特性：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>可靠性&lt;/strong>：由于Lucene的设计中不考虑可靠性，在Elasticsearch中通过Replica和TransLog两套机制保证数据的可靠性。&lt;/li>
&lt;li>&lt;strong>一致性&lt;/strong>：Lucene中的Flush锁只保证Update接口里面Delete和Add中间不会Flush，但是Add完成后仍然有可能立即发生Flush，导致Segment可读。这样就没法保证Primary和所有其他Replica可以同一时间Flush，就会出现查询不稳定的情况，这里只能实现最终一致性。&lt;/li>
&lt;li>&lt;strong>原子性&lt;/strong>：Add和Delete都是直接调用Lucene的接口，是原子的。当部分更新时，使用Version和锁保证更新是原子的。&lt;/li>
&lt;li>&lt;strong>隔离性&lt;/strong>：仍然采用Version和局部锁来保证更新的是特定版本的数据。&lt;/li>
&lt;li>&lt;strong>实时性&lt;/strong>：使用定期Refresh Segment到内存，并且Reopen Segment方式保证搜索可以在较短时间（比如1秒）内被搜索到。通过将未刷新到磁盘数据记入TransLog，保证对未提交数据可以通过ID实时访问到。&lt;/li>
&lt;li>性能：性能是一个系统性工程，所有环节都要考虑对性能的影响，在Elasticsearch中，在很多地方的设计都考虑到了性能，一是不需要所有Replica都返回后才能返回给用户，只需要返回特定数目的就行；二是生成的Segment现在内存中提供服务，等一段时间后才刷新到磁盘，Segment在内存这段时间的可靠性由TransLog保证；三是TransLog可以配置为周期性的Flush，但这个会给可靠性带来伤害；四是每个线程持有一个Segment，多线程时相互不影响，相互独立，性能更好；五是系统的写入流程对版本依赖较重，读取频率较高，因此采用了versionMap，减少热点数据的多次磁盘IO开销。Lucene中针对性能做了大量的优化。后面我们也会有文章专门介绍Lucene中的优化思路。&lt;/li>
&lt;/ol></description></item><item><title>ElasticSearch集群</title><link>https://justice.bj.cn/post/30.architech/elasticsearch/es%E9%9B%86%E7%BE%A4/</link><pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/elasticsearch/es%E9%9B%86%E7%BE%A4/</guid><description>&lt;h1 id="elasticsearch集群">ElasticSearch集群&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>一个ES集群由多个节点(Node)组成；&lt;/li>
&lt;/ul>
&lt;h2 id="节点角色">节点角色&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个节点可以设置&lt;code>master&lt;/code>,&lt;code>data&lt;/code>两种属性状态；&lt;/p>
&lt;ul>
&lt;li>
&lt;p>master：true时，表示该节点可以参与选举；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>data: true时，表示该节点可以存储shard数据；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多个master节点会相互进行选择，产生唯一的一个leader；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果一个节点的master,data都为false，该节点将成为一个类似proxy的节点，只参与请求的转发、结果聚合等。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>每个node都可以执行任何请求并将请求进去转发到对应的node；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master 主节点负责shard的分配，移动和均衡；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="节点角色-1">节点角色&lt;/h2>
&lt;h2 id="节点发现">节点发现&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>ES通过ZenDiscovery实现的一套用于节点发现和选主等功能的模块；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个节点通过和&lt;code>discovery.zen.ping.unicast.hosts&lt;/code>中广播节点建立连接，形成一个联通图，从而保证所有节点能相互感知和访问；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>推荐将所有master节点设置为&lt;code>discovery.zen.ping.unicast.hosts&lt;/code>;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="master选举">master选举&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>es master选举是自己实现的一种基于quorum的多数派选举算法（es 7.xxx之后版本参考raft重新实现了选举算法）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master节点在自身不是leader且通过ZenDiscovery发现其他node(总数要多余quorum)都没有连接到leader节点时将发起选举；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>投票时，会根据clusterStateVersion,id两个字段按一定的顺序进行投票，从而保证能稳定的选出leader；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>获得多数投票的master将当选为leader；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/34830403">https://zhuanlan.zhihu.com/p/34830403&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.hugbg.com/archives/2196.html">08 | ElasticSearch 集群水平扩展 |&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://helloyoubeautifulthing.net/blog/2019/08/20/new-cluster-coordination-in-elasticsearch/">https://helloyoubeautifulthing.net/blog/2019/08/20/new-cluster-coordination-in-elasticsearch/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://easyice.cn/archives/332">深入理解 Elasticsearch 7.x 新的集群协调层 | easyice&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>ES之Master选举</title><link>https://justice.bj.cn/post/30.architech/elasticsearch/es%E4%B9%8Bmaster%E9%80%89%E4%B8%BE/</link><pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/elasticsearch/es%E4%B9%8Bmaster%E9%80%89%E4%B8%BE/</guid><description>&lt;h1 id="es之master选举">ES之Master选举&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>ES的所有节点通过Gossip协议建立一个Cluster；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cluster中的任意一个节点都可以设置 node.master 和 node.data 属性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对当前集群中所有的 Master Eligible Node 进行选举得到 master 节点；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>master\data&lt;/th>
&lt;th>true&lt;/th>
&lt;th>false&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>true&lt;/td>
&lt;td>既是 Master Eligible，又是 data 节点&lt;/td>
&lt;td>单纯的 Master Eligible 节点&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>false&lt;/td>
&lt;td>单纯的 data 节点&lt;/td>
&lt;td>&lt;strong>纯粹的&lt;/strong> Coordinating Node&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.nosuchfield.com/2019/03/18/How-Elasticsearch-elected-the-master/">Elasticsearch是如何选举出master的 - 御坂研究所&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>vim</title><link>https://justice.bj.cn/post/70.tool/vim/</link><pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/70.tool/vim/</guid><description>&lt;h1 id="vim">vim&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="基本操作">基本操作&lt;/h2>
&lt;h3 id="设置">设置&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">## 查看设置
:set shiftwidth?
:echo &amp;amp;option
## 重置为默认值
:set option&amp;amp;
## 查看option设置 在哪里配置
:verbose set option?
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="增加markdown-tagbar">增加markdown tagbar&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>~/.ctags 中增加:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> --langdef=markdown
--langmap=markdown:.md
--regex-markdown=/^#{1}[ \t]*([^#]+.*)/. \1/h,headings/
--regex-markdown=/^#{2}[ \t]*([^#]+.*)/. \1/h,headings/
--regex-markdown=/^#{3}[ \t]*([^#]+.*)/. \1/h,headings/
--regex-markdown=/^#{4}[ \t]*([^#]+.*)/. \1/h,headings/
--regex-markdown=/^#{5}[ \t]*([^#]+.*)/. \1/h,headings/
--regex-markdown=/^#{6}[ \t]*([^#]+.*)/. \1/h,headings/
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>vimrc tagbar中增加如下设置:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-vim" data-lang="vim"> &lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">tagbar_type_markdown&lt;/span> &lt;span class="p">=&lt;/span> {&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> \ &lt;span class="s1">&amp;#39;ctagstype&amp;#39;&lt;/span> : &lt;span class="s1">&amp;#39;markdown&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> \ &lt;span class="s1">&amp;#39;kinds&amp;#39;&lt;/span> : [&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> \ &lt;span class="s1">&amp;#39;h:headings&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> \ ]&lt;span class="p">,&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> \ &lt;span class="s1">&amp;#39;sort&amp;#39;&lt;/span> : &lt;span class="m">0&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> \ }&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="大小写转换">大小写转换&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">转换小写：u
转换大写：U
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="错误排查">错误排查&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ nvim -u NORC
:CheckHealth
$ vim --startuptime tmp.txt &lt;span class="c1">#查看启动时间&lt;/span>
$ strace -f -T -o vim.strace vim &lt;span class="c1">#&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="去掉json自动隐藏引号">去掉JSON自动隐藏引号&lt;/h3>
&lt;p>&lt;strong>: set cole&amp;amp;&lt;/strong>&lt;/p>
&lt;h3 id="去掉m">去掉&lt;code>^M&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="基本操作-1">基本操作&lt;/h2>
&lt;h3 id="光标命令">光标命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="n">h&lt;/span> &lt;span class="n">左移一个字符&lt;/span>
&lt;span class="n">l&lt;/span> &lt;span class="n">右移一个字符&lt;/span>
&lt;span class="n">j&lt;/span> &lt;span class="n">下移一行&lt;/span>
&lt;span class="n">k&lt;/span> &lt;span class="n">上移一行&lt;/span>
&lt;span class="n">w&lt;/span> &lt;span class="n">前移一个单词&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">光标停在下一个单词开头&lt;/span>
&lt;span class="n">W&lt;/span> &lt;span class="n">移动下一个单词开头&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">但忽略一些标点&lt;/span>
&lt;span class="n">e&lt;/span> &lt;span class="n">前移一个单词&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">光标停在下一个单词末尾&lt;/span>
&lt;span class="n">E&lt;/span> &lt;span class="n">移动到下一个单词末尾&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">如果词尾有标点&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">则移动到标点&lt;/span>
&lt;span class="n">b&lt;/span> &lt;span class="n">后移一个单词&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">光标停在上一个单词开头&lt;/span>
&lt;span class="n">B&lt;/span> &lt;span class="n">移动到上一个单词开头&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">忽略一些标点&lt;/span>
&lt;span class="p">(&lt;/span> &lt;span class="n">前移1句&lt;/span>
&lt;span class="p">)&lt;/span> &lt;span class="n">后移1句&lt;/span>
&lt;span class="err">{&lt;/span> &lt;span class="n">前移1段&lt;/span>
&lt;span class="err">}&lt;/span> &lt;span class="n">后移1段&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="滚屏命令">滚屏命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="n">ctrl&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">f&lt;/span> &lt;span class="n">下翻一屏&lt;/span>
&lt;span class="n">ctrl&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="n">上翻一屏&lt;/span>
&lt;span class="n">ctrl&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">d&lt;/span> &lt;span class="n">下翻半屏&lt;/span>
&lt;span class="n">ctrl&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">u&lt;/span> &lt;span class="n">上翻半屏&lt;/span>
&lt;span class="n">ctrl&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="n">向下滚动一行&lt;/span>
&lt;span class="n">ctrl&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="n">向上滚动一行&lt;/span>
&lt;span class="n">n&lt;/span>&lt;span class="err">%&lt;/span> &lt;span class="n">到文件n&lt;/span>&lt;span class="err">%&lt;/span>&lt;span class="n">的位置&lt;/span>
&lt;span class="n">zz&lt;/span> &lt;span class="n">将当前行移动到屏幕中央&lt;/span>
&lt;span class="n">zt&lt;/span> &lt;span class="n">将当前行移动到屏幕顶端&lt;/span>
&lt;span class="n">zb&lt;/span> &lt;span class="n">将当前行移动到屏幕底端&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="插入命令">插入命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="n">第一部分&lt;/span> &lt;span class="n">基本插入&lt;/span>
&lt;span class="n">I&lt;/span> &lt;span class="n">在当前行第一个非空字符前插入&lt;/span>
&lt;span class="n">gI&lt;/span> &lt;span class="n">在当前行第一列插入&lt;/span>
&lt;span class="n">a&lt;/span> &lt;span class="n">在光标后插入&lt;/span>
&lt;span class="n">A&lt;/span> &lt;span class="n">在当前行最后插入&lt;/span>
&lt;span class="n">o&lt;/span> &lt;span class="n">在下面新建一行插入&lt;/span>
&lt;span class="n">O&lt;/span> &lt;span class="n">在上面新建一行插入&lt;/span>
&lt;span class="n">第二部分&lt;/span> &lt;span class="n">改写插入&lt;/span>
&lt;span class="n">c&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">w&lt;/span> &lt;span class="n">改写光标后1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个词&lt;/span>
&lt;span class="n">c&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="n">改写光标后n个字母&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">vim中光标右移一个字符命令&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">c&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">h&lt;/span> &lt;span class="n">改写光标前n个字母&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">vim中光标左移一个字符命令&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">cc&lt;/span> &lt;span class="n">修改当前&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">行&lt;/span>
&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">s&lt;/span> &lt;span class="n">以输入的文本替代光标之后1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个字符&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">相当于c&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">l&lt;/span>
&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">S&lt;/span> &lt;span class="n">删除指定数目的行&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">并以所输入文本代替之&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="复制命令">复制命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="n">y&lt;/span> &lt;span class="n">复制在可视模式下选中的文本&lt;/span>
&lt;span class="n">yy&lt;/span> &lt;span class="kr">or&lt;/span> &lt;span class="n">Y&lt;/span> &lt;span class="n">复制整行文本&lt;/span>
&lt;span class="n">y&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">w&lt;/span> &lt;span class="n">复制一&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个词&lt;/span>
&lt;span class="n">y&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="n">复制光标右边1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个字符&lt;/span>
&lt;span class="n">y&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">h&lt;/span> &lt;span class="n">复制光标左边1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个字符&lt;/span>
&lt;span class="n">y&lt;/span>&lt;span class="err">$&lt;/span> &lt;span class="n">从光标当前位置复制到行尾&lt;/span>
&lt;span class="n">y0&lt;/span> &lt;span class="n">从光标当前位置复制到行首&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="剪切和粘贴命令">剪切和粘贴命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="n">剪切光标右边n个字符&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">相当于d&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">l&lt;/span>
&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">X&lt;/span> &lt;span class="n">剪切光标左边n个字符&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">相当于d&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">h&lt;/span>
&lt;span class="n">p&lt;/span> &lt;span class="n">在光标之后粘贴&lt;/span>
&lt;span class="n">P&lt;/span> &lt;span class="n">在光标之前粘贴&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="删除命令">删除命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="n">d&lt;/span> &lt;span class="n">删除&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">剪切&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="n">在可视模式下选中的文本&lt;/span>
&lt;span class="n">d&lt;/span>&lt;span class="err">$&lt;/span> &lt;span class="kr">or&lt;/span> &lt;span class="n">D&lt;/span> &lt;span class="n">删除&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">剪切&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="n">当前位置到行尾的内容&lt;/span>
&lt;span class="n">d&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">w&lt;/span> &lt;span class="n">删除&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">剪切&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个单词&lt;/span>
&lt;span class="n">d&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="n">删除&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">剪切&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="n">光标右边1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个字符&lt;/span>
&lt;span class="n">d&lt;/span>&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span>&lt;span class="n">h&lt;/span> &lt;span class="n">删除&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">剪切&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="n">光标左边1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">个字符&lt;/span>
&lt;span class="n">d0&lt;/span> &lt;span class="n">删除&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">剪切&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="n">当前位置到行首的内容&lt;/span>
&lt;span class="err">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">]&lt;/span> &lt;span class="n">dd&lt;/span> &lt;span class="n">删除&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">剪切&lt;/span>&lt;span class="err">）&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">行&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="撤销命令">撤销命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="n">u&lt;/span> &lt;span class="n">撤销最后执行的命令&lt;/span>
&lt;span class="n">U&lt;/span> &lt;span class="n">撤销对整行的修改&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="查找命令">查找命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="o">/&lt;/span>&lt;span class="n">word&lt;/span> &lt;span class="n">在后面的文本中查找word&lt;/span>
&lt;span class="err">?&lt;/span>&lt;span class="n">word&lt;/span> &lt;span class="n">在前面的文本中查找word&lt;/span>
&lt;span class="o">/&lt;/span>&lt;span class="n">pattern&lt;/span>&lt;span class="o">/+&lt;/span>&lt;span class="n">number&lt;/span> &lt;span class="n">将光标停在包含pattern的行后面第number行上&lt;/span>
&lt;span class="o">/&lt;/span>&lt;span class="n">pattern&lt;/span>&lt;span class="o">/-&lt;/span>&lt;span class="n">number&lt;/span> &lt;span class="n">将光标停在包含pattern的行前面第number行上&lt;/span>
&lt;span class="n">n&lt;/span> &lt;span class="n">向后查找下一个&lt;/span>
&lt;span class="n">N&lt;/span> &lt;span class="n">向前查找下一个&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="替换命令">替换命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="p">:&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">old&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="kr">new&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">g&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">可以替换&lt;/span> &lt;span class="n">old&lt;/span> &lt;span class="n">为&lt;/span> &lt;span class="kr">new&lt;/span>
&lt;span class="n">替换两行之间出现的每个匹配串&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">操作如下&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">old&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="kr">new&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">g&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">其中&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">#&lt;/span> &lt;span class="n">代表的是替换操作的若干行中首尾两行的行号&lt;/span>&lt;span class="err">。&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="err">%&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">old&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="kr">new&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">g&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">则是替换整个文件中的每个匹配串&lt;/span>&lt;span class="err">。&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="err">%&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">old&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="kr">new&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">gc&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">会找到整个文件中的每个匹配串&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">并且对每个匹配串提示是否进行替换&lt;/span>&lt;span class="err">。&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="排版命令">排版命令&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ada" data-lang="ada">&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">向左缩进一个shiftwidth&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">向右缩进一个shiftwidth&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">ce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">本行文字居中&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">le&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ft&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">本行文字靠左&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">ri&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ght&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">本行文字靠右&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="heading">&lt;/h1>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/24484514">https://zhuanlan.zhihu.com/p/24484514&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>ChubaoFS DataNode</title><link>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-datanode/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-datanode/</guid><description>&lt;h1 id="chubaofs-datanode">ChubaoFS DataNode&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>chubaofs datanode 是chubaofs中的数据存储节点，用于将chubaofs中的文件数据存储在磁盘中；&lt;/p>
&lt;p>chubaofs 中的datanode数据以&lt;code>dataPartition&lt;/code>为单位进行管理。&lt;code>dataPartition&lt;/code>是datanode中进行数据管理的最高单位。&lt;/p>
&lt;h2 id="大文件小文件">大文件/小文件&lt;/h2>
&lt;p>文件系统中，每个文件存在元数据。由于磁盘和内存的性能成本差别，导致同一个文件系统对于大小文件的操作管理成本存在显著的差异。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于小文件，其单个文件数据量少，平均磁盘操作成本巨大，且元数据数量膨胀快；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大文件数据文件大，顺序读写可以获得较低的磁盘操作成本，取得较高的性能，元数据相对总数据量成本低；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因此同一个文件系统对于大小文件很难使用同一策略来满足高效低费存储需求。&lt;/p>
&lt;p>chubaofs对于大小文件的读写使用了不同的策略，以此满足大小文件的不同需求。&lt;/p>
&lt;p>chubaofs中的小文件是客户端指定，小于一定大小（默认为：1MB）的文件。可以通过客户端配置参数&lt;code>tinySize&lt;/code>指定。&lt;/p>
&lt;p>每个客户端文件的前1MB字节内的文件都使用&lt;code>TinyExtent&lt;/code>进行存储管理，&lt;/p>
&lt;p>大于&lt;code>1MB&lt;/code>的文件部分使用&lt;code>NormalExtent&lt;/code>方式进行存储管理。&lt;/p>
&lt;h2 id="顺序写随机写">顺序写/随机写&lt;/h2>
&lt;p>ChubaoFS同时支持&lt;code>顺序写&lt;/code>和&lt;code>随机写&lt;/code>两种文件写入方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>顺序写&lt;/code>: 指写入的数据每次只往文件末尾追加;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>随机写&lt;/code>: 指覆盖之前已经写过的文件内容;&lt;/p>
&lt;p>客户端在发起写请求时，根据写入数据的偏移是否已经存在，来决定使用那种写入方式；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>顺序写&lt;/code>: 使用主从方式进行副本间同步数据, 对应的存储引擎；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>随机写&lt;/code>: 使用Raft协议来在数据副本间同步数据；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// sdk/data/stream/stream_writer.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Streamer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">flags&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">total&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">requests&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">writeSize&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ExtentKey&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//已存在旧写入数据extentkey
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">writeSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">doOverwrite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//随机覆盖写
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">writeSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">doWrite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FileOffset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//顺序写
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="datanode目录结构">datanode目录结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>datanode配置文件中的&lt;code>disks&lt;/code>指定了每个datanode dp的存储磁盘；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中包含一系列&lt;code>datapartition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>和命名的目录，用于存储对应dp；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中还可能包含&lt;code>expired_dataparition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>的过期dp，这些dp是在master中不存在的；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1">## datanode配置文件中的disks设置datanode管理的哪些disk； &lt;/span>
$ cat /opt/chubaofs/conf/datanode.json
...
&lt;span class="s2">&amp;#34;disks&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;/data/hdfs10:159978629365&amp;#34;&lt;/span>, //磁盘目录：可用大小
&lt;span class="s2">&amp;#34;/data/hdfs12:159978629365&amp;#34;&lt;/span>,
...
&lt;span class="o">]&lt;/span>,
...
&lt;span class="c1">## 每个disk中包含一系列的dp目录&lt;/span>
$ ls -1 /data/hdfs10
...
datapartition_1001_128849018880 //正常dp，1001：dpid，128849018880：dpsize
datapartition_1003_128849018880
datapartition_1004_128849018880
...
expired_datapartition_2004_128849018880 //过期dp，在master中 不存在的dp
...
&lt;span class="c1">## 每个dp包含一系列的extent file 和dp 元数据&lt;/span>
$ tree /data/hdfs10/datapartition_1001_128849018880
├── &lt;span class="m">1&lt;/span>
├── &lt;span class="m">10&lt;/span>
├── &lt;span class="m">11&lt;/span>
├── &lt;span class="m">12&lt;/span>
├── &lt;span class="m">13&lt;/span>
├── &lt;span class="m">14&lt;/span>
├── &lt;span class="m">15&lt;/span>
├── &lt;span class="m">16&lt;/span>
...
├── &lt;span class="m">63&lt;/span>
├── &lt;span class="m">64&lt;/span>
├── &lt;span class="m">7&lt;/span>
├── &lt;span class="m">8&lt;/span>
├── &lt;span class="m">9&lt;/span> //extent file， 1-64, tiny extent file&lt;span class="p">;&lt;/span> 1000-, normal extent file
├── APPLY //dp apply index, 里面存储了当前dp.appliedID&lt;span class="o">(&lt;/span>raft rsm apply index&lt;span class="o">)&lt;/span>
├── .apply //apply index临时文件
├── EXTENT_CRC //extent file crc,
├── EXTENT_META //extent meta
├── .meta //临时META文件，
├── META //dp meta
├── NORMALEXTENT_DELETE //
├── TINYEXTENT_DELETE
└── wal_1001 //raft wal
├── 0000000000000001-0000000000000001.log
└── META
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="datapartition">DataPartition&lt;/h2>
&lt;h3 id="dp存储">dp存储&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>datanode配置文件中的&lt;code>disks&lt;/code>指定了每个datanode dp的存储磁盘；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中包含一系列&lt;code>datapartition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>和命名的目录，用于存储对应dp；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个&lt;code>disk&lt;/code>中还可能包含&lt;code>expired_dataparition_&amp;lt;id&amp;gt;_&amp;lt;dp_size&amp;gt;&lt;/code>的过期dp，这些dp是在master中不存在的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个dp&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="apply文件">APPLY文件:&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>保存当前dp的&lt;code>appliedID&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dp的&lt;code>StartRaftLoggingSchedule()&lt;/code>协程周期性(10s)将dp的appliedID 写入到APPLY文件中(先写.apply,后move);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dp&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="meta文件">META文件&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>META保存了当前dp的配置元信息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当dp配置信息改变时，由&lt;code>PersistMetadata()&lt;/code>将dp的配置元信息持久化到该文件中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dp加载时(LoadDataPartition)，从META中读取dp元信息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写入时机包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>dp创建时；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>周期性truncate raft log时，lastTruncateID发生改变；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>raft 配置变更；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="err">//&lt;/span> &lt;span class="err">cat&lt;/span> &lt;span class="err">/data/hdfs&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="err">/datapartition_&lt;/span>&lt;span class="mi">1001&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="mi">128849018880&lt;/span>&lt;span class="err">/META&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;VolumeID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;weqewqe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;PartitionID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1001&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;PartitionSize&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">128849018880&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;CreateTime&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-11-29 18:26:21&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;Peers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;addr&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10.201.69.20:17310&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;addr&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10.201.74.33:17310&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;addr&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10.201.76.21:17310&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;Hosts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;10.201.74.33:17310&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;10.201.69.20:17310&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;10.201.76.21:17310&amp;#34;&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;DataPartitionCreateType&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;LastTruncateID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="extent_meta">EXTENT_META&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>metadataFp&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保存baseExtentID + PreAllocSpaceExtentID, 2个uint64, 总共16字节；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h3 id="extent_crc">EXTENT_CRC&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>verifyExtentFp: 保存dp所有normal extent crc;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>extent 加载时，根据extentID， 从EXTENT_CRC中加载对应extent 的crc到extent header 中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>normal extent写入时, 根据offset，size计算blockNo(128K为一个Block);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果刚好是一个整block, 将crc写入&lt;code>EXTENT_CRC&lt;/code>文件; 否则规整化后，写0&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>每个datapartition存储目录中有一个&lt;code>EXTENT_CRC&lt;/code>文件，用于保存该datapartition 所有&lt;code>normal_extent&lt;/code>的crc校验头；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>EXTENT_CRC&lt;/code>文件由多个4KB大小的校验块组成，每个校验块存储一个&lt;code>normal_extent&lt;/code>的crc校验；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个4KB的校验块由1000个4B的CRC检验数据组成；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>datanode节点在加载normal_extent时，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">|crc|
| 4 | 4 |... | 4 | 4 |... |
|--------------|--------------|---------------|
4k 4k
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="extent-file">extent file&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>TinyExtent file(id: 1-64):&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Normal Extent file:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>写请求追加写到extent文件末尾；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>normal extent file最大128MB, 写入前会对写入数据offset，size进行检查，超出128MB时无法写入；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="normalextent_delete">NORMALEXTENT_DELETE&lt;/h3>
&lt;h3 id="tinyextent_delete">TINYEXTENT_DELETE&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>记录本dp已经删除过的tiny extent 数据块, 在第一次调用fallocate puchhole后记录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个被删除的tiny extent 数据块记录为24Byte，按&lt;code>&amp;lt;extentID&amp;gt;&amp;lt;offset&amp;gt;&amp;lt;size&amp;gt;&lt;/code>这个依次追加到该文件中；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h4 id="status">&lt;strong>Status&lt;/strong>&lt;/h4>
&lt;h2 id="extent">Extent&lt;/h2>
&lt;p>每个dp包含多个&lt;code>extent&lt;/code>, 每个extent 对应一个extent file，用于存储数据。&lt;/p>
&lt;p>extent file大小限制为128MB, 每个datapartition 包含的extent 个数不超过2000个(256GB)&lt;/p>
&lt;p>extent分为&lt;code>NormalExtent&lt;/code> 和 &lt;code>TinyExtent&lt;/code> 两种类型。&lt;/p>
&lt;h3 id="tinyextent">TinyExtent&lt;/h3>
&lt;ul>
&lt;li>id范围: [1, 64]&lt;/li>
&lt;li>在每个dp加载时，会通过&lt;/li>
&lt;/ul>
&lt;h3 id="normalextent">NormalExtent&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>id: [1000, +)&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="extentstore">ExtentStore&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>datanode 数据存储目录结构&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>EXTENT_META&lt;/code>: &lt;code>metadataFp&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>EXTENT_CRC&lt;/code>: &lt;code>verifyExtentFp&lt;/code>, 存储当前datapartition 的所有&lt;code>normal_extent&lt;/code>crc校验数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TINYEXTENT_DELETE&lt;/code>: &lt;code>tinyExtentDeleteFp&lt;/code>,&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tinyextent中的删除">TinyExtent中的删除&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>删除的extent数据段offset必须是4K对齐的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先通过seek从文件中找到从offset开始的DATA起始位置newoffset；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过newoffset 和 offset之间的关系判断要删除的数据段是否已被删除；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>总共有以下4种情形：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>其中第2中的数据完全落在Hole中，其中数据已经删除过；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其他情况都需要通过fallocate PunchHole来打洞删除从offset开始的size长的数据；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// 情形1：待删除数据区offset+size完全落在DATA区域, newoffset == offset
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^-----+
offset size
// 情形2：待删除数据区offset+size完全落在HOLE区域， newoffset - offset &amp;gt; size
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^---+ ^
offset newoffset
// 情形3：待删除数据区offset+size部分落在DATA区域；
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^----------+
offset size
// 情形4：待删除数据区offset+size部分落在DATA区域；
data hole data hole
|-------------|xxxxxxxxx|--------------|xxxxxxxx|--------
^-------------+
offset ^newoffset
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="datapartition加载">DataPartition加载&lt;/h2>
&lt;h2 id="datapartition修复">DataPartition修复&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个dp在新建和加载后会启动一个&lt;code>statusUpdateScheduler()&lt;/code>协程;&lt;/p>
&lt;ul>
&lt;li>
&lt;p>该协程每过1min会先更新一下dp状态(计算usage，更新status)，并交替启动repair任务(TinyExtent, NormalExtent交替分开)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每5min会启动&lt;code>ReloadSnapshot()&lt;/code>任务；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Repair任务由&lt;code>LaunchRepair()&lt;/code>启动；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先检查dp状态, &lt;code>Unavailable&lt;/code>状态的dp不参与修复；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后&lt;code>updateRelicas()&lt;/code>从master获取最新的副本ip；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查是否为leader，非leader退出，不启动 修复；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后由&lt;code>repair()&lt;/code>函数执行修复任务；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="复制">复制&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个datanode在接受每个客户端tcp连接时，会为该连接新建一个复制服务(ReplProtocol)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制服务会启动3个后台协程：&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">go&lt;/span> &lt;span class="nx">rp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">OperatorAndForwardPktGoRoutine&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//从toBeProcessCh管道读取待处理的packet，判断pkt是本地处理还是转发follower给
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">go&lt;/span> &lt;span class="nx">rp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ReceiveResponseFromFollowersGoRoutine&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//接收follower响应并处理
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">go&lt;/span> &lt;span class="nx">rp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">writeResponseToClientGoRroutine&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>最后通过&lt;code>readPkgAndPrepare()&lt;/code>持续接收client conn发送的packet，先经过Prepare()对Packet做一下检查设置，然后将packet放入toBeProcessCh，交由&lt;code>OperatorAndForwardPktGoRoutine()&lt;/code>协程处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Prepare()&lt;/code>在检查packet有效性后，最后会根据packet类型，增加extent info：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>leader上的tinyExtent的Write请求，通过&lt;code>store.GetAvailableTinyExtent()&lt;/code>选择一个有效的tinyExtent ID；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>createExtent请求，通过&lt;code>store.NextExtentID()&lt;/code>设置下一个extentID作为新extentID；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后将packet.Data复制到packet.OrgBuf上；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>OperatorAndForwardPktGoRoutine()&lt;/code>协程主要从&lt;code>toBeProcessCh&lt;/code>接收请求，然后转发处理，具体流程如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>根据&lt;code>packet.RemainingFollowers&lt;/code>判断是否需要转发给follower;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>packet.RemainingFollower&lt;/code>==0,&lt;/p>
&lt;ul>
&lt;li>
&lt;p>则调用&lt;code>(datanode*)OperatorPacket()&lt;/code>在本地处理，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>处理完成后, 将reply放入&lt;code>rp.responseCh&lt;/code>管道，通知 &lt;code>writeResponseToClientGoRroutine()&lt;/code>协程处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>packet.RemainingFollower&lt;/code>&amp;gt;0,&lt;/p>
&lt;ul>
&lt;li>
&lt;p>则通过&lt;code>rp.sendRequestToAllFollowers()&lt;/code>将packet复制并发送个所有follower；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若发送成功，则：&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ReceiveResponseFromFollowersGoRoutine()&lt;/code>协程：&lt;/p>
&lt;ul>
&lt;li>接收&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>writeResponseToClientGoRroutine()&lt;/code>协程：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>主要调用&lt;code>writeResponse()&lt;/code>处理响应；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先检查&lt;code>reply&lt;/code>中是否有错误；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在调用&lt;code>(*datanode)Post()&lt;/code> 根据reply 添加一些额外的后续 处理：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果是&lt;code>master&lt;/code>发送的命令，则将&lt;code>reply.NeedReply&lt;/code>标记为&lt;code>true&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果是&lt;code>read&lt;/code>命令，则将&lt;code>reply.NeedReply&lt;/code>标记为false(Read请求的reply 在Operation 的相关handle中已经处理);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>cleanupPkt()&lt;/code>清理回收；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置metric；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>根据&lt;code>reply.NeedReply&lt;/code>判断是否需要响应，如果false，则返回, 否则将reply通过sourceConn发送回对端；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>STL容器</title><link>https://justice.bj.cn/post/14.language/c++/stl/stl%E5%AE%B9%E5%99%A8/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/c++/stl/stl%E5%AE%B9%E5%99%A8/</guid><description>&lt;h1 id="stl容器">STL容器&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>容器库是类模板与算法的汇集，允许程序员简单地访问常见数据结构，例如队列、链表和栈。&lt;/p>
&lt;p>有三类容器——顺序容器、关联容器和无序关联容器——每种都被设计为支持不同组的操作。&lt;/p>
&lt;p>容器管理为其元素分配的存储空间，并提供直接或间接地通过迭代器（拥有类似指针属性的对象）访问它们的函数。&lt;/p>
&lt;p>大多数容器拥有至少几个常见的成员函数，并共享功能。&lt;/p>
&lt;p>特定应用的最佳容器不仅依赖于提供的功能，还依赖于对于不同工作量的效率。&lt;/p>
&lt;h3 id="顺序容器">顺序容器&lt;/h3>
&lt;p>顺序容器是实现能按顺序访问的数据结构。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>容器类型&lt;/th>
&lt;th>版本&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/array" title="cpp/container/array">array&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>静态的连续数组 (类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/vector" title="cpp/container/vector">vector&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;td>动态的连续数组(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/deque" title="cpp/container/deque">deque&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;td>双端队列(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/forward_list" title="cpp/container/forward list">forward_list&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>单链表(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/list" title="cpp/container/list">list&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;td>双链表(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="c1">// vector
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="c1">// C++11 初始化器列表语法：
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;the&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;frogurt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;is&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;also&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;cursed&amp;#34;&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words1: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// words2 == words1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">words1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">words1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words2: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words2&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// words3 == words1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">words1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words3: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words3&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// words4 为 {&amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;, &amp;#34;Mo&amp;#34;}
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">words4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Mo&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;words4: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">words4&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="关联容器">关联容器&lt;/h3>
&lt;p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>容器类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/set" title="cpp/container/set">set&lt;/a>&lt;/td>
&lt;td>唯一键的集合，按照键排序 (类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/map" title="cpp/container/map">map&lt;/a>&lt;/td>
&lt;td>键值对的集合，按照键排序，键是唯一的(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/multiset" title="cpp/container/multiset">multiset&lt;/a>&lt;/td>
&lt;td>键的集合，按照键排序(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/multimap" title="cpp/container/multimap">multimap&lt;/a>&lt;/td>
&lt;td>键值对的集合，按照键排序(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="无序关联容器">无序关联容器&lt;/h3>
&lt;p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>版本&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_set" title="cpp/container/unordered set">unordered_set&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>唯一键的集合，按照键生成散列 (类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_map" title="cpp/container/unordered map">unordered_map&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>键值对的集合，按照键生成散列，键是唯一的(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_multiset" title="cpp/container/unordered multiset">unordered_multiset&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>键的集合，按照键生成散列(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_multimap" title="cpp/container/unordered multimap">unordered_multimap&lt;/a>&lt;/td>
&lt;td>(C++11 起)&lt;/td>
&lt;td>键值对的集合，按照键生成散列&lt;br>(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="容器适配器">容器适配器&lt;/h3>
&lt;p>容器适配器提供顺序容器的不同接口。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;a href="https://zh.cppreference.com/w/cpp/container/stack" title="cpp/container/stack">stack&lt;/a>&lt;/th>
&lt;th>适配一个容器以提供栈（LIFO 数据结构） &lt;br>(类模板)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/queue" title="cpp/container/queue">queue&lt;/a>&lt;/td>
&lt;td>适配一个容器以提供队列（FIFO 数据结构）&lt;br>(类模板)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://zh.cppreference.com/w/cpp/container/priority_queue" title="cpp/container/priority queue">priority_queue&lt;/a>&lt;/td>
&lt;td>适配一个容器以提供优先级队列&lt;br>(类模板)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="span">span&lt;/h3>
&lt;p>&lt;code>span&lt;/code> 是相接的对象序列上的非占有视图，某个其他对象占有序列的存储。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;a href="https://zh.cppreference.com/w/cpp/container/span" title="cpp/container/span">span&lt;/a>&lt;br>&lt;br>(C++20)&lt;/th>
&lt;th>对象的连续序列上的无所有权视图 &lt;br>(类模板)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h3 id="迭代器非法化">迭代器非法化&lt;/h3>
&lt;p>只读方法决不非法化迭代器或引用。修改容器内容的方法可能非法化迭代器和/或引用，总结于此表格。&lt;/p>
&lt;p>此处&lt;strong>插入&lt;/strong>指代任何添加一或多个元素到容器的方法，而&lt;strong>擦除&lt;/strong>指代任何从容器移除一或多个元素的方法。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>插入方法的例子是 &lt;a href="https://zh.cppreference.com/w/cpp/container/set/insert" title="cpp/container/set/insert">std::set::insert&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/map/emplace" title="cpp/container/map/emplace">std::map::emplace&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/vector/push_back" title="cpp/container/vector/push back">std::vector::push_back&lt;/a> 和 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque/push_front" title="cpp/container/deque/push front">std::deque::push_front&lt;/a> 。&lt;/p>
&lt;ul>
&lt;li>注意 &lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_map/operator_at" title="cpp/container/unordered map/operator at">std::unordered_map::operator[]&lt;/a> 也算，因为它可能插入元素到 map 中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>擦除方法的例子是 &lt;a href="https://zh.cppreference.com/w/cpp/container/set/erase" title="cpp/container/set/erase">std::set::erase&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back" title="cpp/container/vector/pop back">std::vector::pop_back&lt;/a> 、 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque/pop_front" title="cpp/container/deque/pop front">std::deque::pop_front&lt;/a> 和 &lt;a href="https://zh.cppreference.com/w/cpp/container/map/clear" title="cpp/container/map/clear">std::map::clear&lt;/a> 。&lt;/p>
&lt;ul>
&lt;li>&lt;code>clear&lt;/code> 非法化所有迭代器和引用。因为它擦除所有元素，这在技术上遵照上述规则。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>尾后迭代器需要特别留意。通常像指向未被擦除元素的正常迭代器一般非法化此迭代器。故 &lt;a href="https://zh.cppreference.com/w/cpp/container/set/end" title="cpp/container/set/end">std::set::end&lt;/a> 决不被非法化， &lt;a href="https://zh.cppreference.com/w/cpp/container/unordered_set/end" title="cpp/container/unordered set/end">std::unordered_set::end&lt;/a> 仅在重哈希时被非法化， &lt;a href="https://zh.cppreference.com/w/cpp/container/vector/end" title="cpp/container/vector/end">std::vector::end&lt;/a> 始终被非法化（因为它始终出现在被修改元素后），以此类推。&lt;/p>
&lt;ul>
&lt;li>例外：删除 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque" title="cpp/container/deque">std::deque&lt;/a> 末元素的擦除操作&lt;em>会&lt;/em>非法化尾后迭代器，尽管它不是容器的被擦除元素（或者说根本不是元素）。与 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque" title="cpp/container/deque">std::deque&lt;/a> 迭代器的通用规则结合后，最终结果是&lt;em>不&lt;/em>非法化 &lt;a href="https://zh.cppreference.com/w/cpp/container/deque/end" title="cpp/container/deque/end">std::deque::end&lt;/a> 的唯一修改操作是删除首元素，而非末元素的擦除。&lt;/li>
&lt;/ul>
&lt;h3 id="线程安全">线程安全&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>能同时在不同容器上由不同线程调用所有容器函数。更广泛而言， C++ 标准库函数不读取能通过其他线程访问的对象，除非这些对象能直接或间接地经由函数参数，包含 this 指针访问;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能同时在同一容器上由不同线程调用 const 成员函数。而且，成员函数 &lt;code>begin()&lt;/code> 、 &lt;code>end()&lt;/code>, &lt;code>rbegin()&lt;/code> 、 &lt;code>rend()&lt;/code> 、 &lt;code>front()&lt;/code> 、 &lt;code>back()&lt;/code> 、 &lt;code>data()&lt;/code> 、 &lt;code>find()&lt;/code> 、 &lt;code>lower_bound()&lt;/code> 、 &lt;code>upper_bound()&lt;/code> 、 &lt;code>equal_range()&lt;/code> 、 &lt;code>at()&lt;/code> 和除了关联容器中的 &lt;code>operator[]&lt;/code> 对于线程安全的目标表现如同 const （即它们亦能同时在同一容器上由不同线程调用）。更广泛而言， C++ 标准库函数不修改对象，除非这些对象能直接或间接地经由函数参数，包含 this 指针访问。&lt;br>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同一容器中不同元素能由不同线程同时修改，除了 std::vector&lt;bool> 的元素（例如， &lt;a href="https://zh.cppreference.com/w/cpp/thread/future" title="cpp/thread/future">std::future&lt;/a> 对象的 vector 能从多个线程接收值）;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>迭代器操作（例如自增迭代器）读但不修改底层容器，而且能与同一容器上的其他迭代器操作同时由 const 成员函数执行。非法化任何迭代器的容器操作修改容器，且不能与任何在既存迭代器上的操作同时执行，即使这些迭代器未被非法化;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同一容器上的元素可以同时由不指定为访问这些元素的函数修改。更广泛而言， C++ 标准库函数不间接读取能从其参数访问的对象（包含容器的其他对象），除非其规定要求如此；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何情况下，容器操作（还有算法，或其他 C++ 标准库函数）可于内部并行化，只要不更改用户可见的结果（例如 &lt;a href="https://zh.cppreference.com/w/cpp/algorithm/transform" title="cpp/algorithm/transform">std::transform&lt;/a> 可并行化，但指定了按顺序观览序列的每个元素的 &lt;a href="https://zh.cppreference.com/w/cpp/algorithm/for_each" title="cpp/algorithm/for each">std::for_each&lt;/a> 不行） | (C++11 起)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="成员函数表格">成员函数表格&lt;/h3></description></item><item><title>Chubao-Raft</title><link>https://justice.bj.cn/post/40.storage/chubaofs/chubao-raft/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/40.storage/chubaofs/chubao-raft/</guid><description>&lt;h1 id="chubao-raft">Chubao-Raft&lt;/h1>
&lt;hr>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Chubao Raft 是 chubaofs 项目使用的multigroup-raft 库，是在 etcd raft 库上进行了重构和优化。&lt;/p>
&lt;h2 id="特性">特性&lt;/h2>
&lt;p>chubao-raft 有以下特性：&lt;/p>
&lt;ul>
&lt;li>multi-raft：支持多组 raft；&lt;/li>
&lt;li>read-lease:&lt;/li>
&lt;li>batch/pipeline:&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="组成">组成&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>FSM：算法状态机，负责基本的raft算法逻辑状态机封装；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Log: 日志模块，负责raft日志的记录及同步；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Storage: 存储接口，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Transport：传输模块，负责raft副本间的数据传输；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>StateMachine：指令状态机接口模块，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="状态机">状态机&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">graph TB
F(Follower)
C(Candidate)
L(Leader)
E(ElectionAck)
S((START)) --&amp;gt; F
F --timeout--&amp;gt; C
C --timeout/vote req--&amp;gt; C
C --electAck/append/hb/minor votes--&amp;gt; F
C -- quorum:lease_off --&amp;gt; L
C -- quorum:lease_on --&amp;gt; E
L -- lease offline --&amp;gt; F
E -- vote req --&amp;gt; E
E --electAck/append/hb--&amp;gt; F
E --quorum--&amp;gt; L
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="重要数据结构">重要数据结构&lt;/h2>
&lt;h3 id="proposal提案">Proposal(提案)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>外部给raft状态机执行的命令；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//raft/raft.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">proposal&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">cmdType&lt;/span> &lt;span class="nx">proto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EntryType&lt;/span> &lt;span class="c1">//提案类型，分为normal()
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">future&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Future&lt;/span>
&lt;span class="nx">data&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="future">Future&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>future&lt;/code>是raft中用于描述raft输出结果的一个数据结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>future&lt;/code>内部有2个长度为1的&lt;code>chan&lt;/code>，分别代表着&lt;code>正常输出&lt;/code>和&lt;code>错误输出&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>future&lt;/code>主要提供以下2个外部调用来获取输出：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Response()&lt;/code>: 获取同步输出结果；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>AsyncResponse&lt;/code>: 异步输出；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">respErr&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">errCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Future&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">respErr&lt;/span>
&lt;span class="nx">respCh&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Future&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Response&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">resp&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nb">error&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">resp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">respCh&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Future&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">AsyncResponse&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">respCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">errCh&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">respCh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">errCh&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>inflight(复制环形数组)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// 复制环形数组(滑窗)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">inflight&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">start&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">//有效元素起始idx
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">count&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">//有效元素个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">//最大元素个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">buffer&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">uint64&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="关键流程">关键流程&lt;/h2>
&lt;h3 id="新建raftserver">新建RaftServer&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>chubao raft的multi-raft, 多个raft主要通过&lt;code>RaftServer-&amp;gt;rafts&lt;/code>进行管理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动入口为&lt;code>raft/server.go&lt;/code>中的&lt;code>NewRaftServer&lt;/code>, 通过输入参数&lt;code>config&lt;/code>生成一个新的&lt;code>RaftSever&lt;/code>结构体对象，并启动后台服务协程&lt;code>run()&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>RaftServer-&amp;gt;run()&lt;/code>协程监听如下事件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>rs-&amp;gt;stopC&lt;/code>: &lt;code>RaftServer&lt;/code>结束消息，接收该消息，立马结束&lt;code>run&lt;/code>服务协程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>fatalStopC&lt;/code>: 关闭raft消息，从&lt;code>rs-&amp;gt;rafts&lt;/code> map中删除对应的raft；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rs-&amp;gt;heartc&lt;/code>: 遍历所有&lt;code>raft&lt;/code>, 将msg放入&lt;code>raft-&amp;gt;recv&lt;/code>中处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rs-&amp;gt;ticker.C&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>递增&lt;code>ticks&lt;/code>计数器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果&lt;code>ticks&lt;/code>达到配置的&lt;code>HeartbeatTick&lt;/code>值，则将计数器置0，并给所有非&lt;code>Leader&lt;/code>节点发送&lt;code>ReqMsgHeartBeat&lt;/code>消息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果节点不在恢复快照状态，则依次给所有&lt;code>raft&lt;/code> tickc发送数据，激活各raft &lt;code>tick()&lt;/code>；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="新建raft">新建Raft&lt;/h3>
&lt;p>RaftSever启动后，通过&lt;code>RaftServer-&amp;gt;CreateRaft()&lt;/code>函数可新建&lt;code>raft&lt;/code>, 并将raft加入到&lt;code>RaftSever-&amp;gt;rafts&lt;/code>中。&lt;code>newRaft()&lt;/code>流程如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>校验config;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据配置，生成新&lt;code>raftFsm&lt;/code>实例；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>初始化&lt;code>raft&lt;/code>实例；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动&lt;code>Raft.runApply（）&lt;/code>协程，该协程主要用于监听&lt;code>raft-&amp;gt;applyc&lt;/code>channel上的事件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动&lt;code>Raft.run()&lt;/code>协程,&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="raft主处理流程">Raft主处理流程&lt;/h3>
&lt;p>&lt;code>raft.run()&lt;/code>是各个raft主要用来处理各个事件的总协程入口，其处理如下事件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>s.stopc&lt;/code>: 退出信号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>s.tickc&lt;/code>: 计数器信号，调用&lt;code>raftFsm.tick()&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>s.propc&lt;/code>:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="选举">选举&lt;/h3>
&lt;h4 id="选举发生条件">选举发生条件&lt;/h4>
&lt;ul>
&lt;li>&lt;code>Follower&lt;/code>或&lt;code>Candidate&lt;/code>节点&lt;code>选举计时器&lt;/code>超时（lease off） 或收到 Leader 的 Lease TimeOut 消息（lease on）；&lt;/li>
&lt;li>ElectionAck 状态时，选举计时器超时；&lt;/li>
&lt;li>外界选举信号；&lt;/li>
&lt;/ul>
&lt;h4 id="选举过程">选举过程&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>当选举条件达到时，raft 状态机会产生一个&lt;code>LocalMsgHup&lt;/code>消息中断当前任期，发起选举；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非 Leader 节点收到 LocalMsgHup 消息，如果可以提升为 Leader，且 raft 中没有待处理的配置变更日志，则举行选举(campaign)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>发起节点先将自己变成候选人(Candidate);&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断得票数。如果达到法定票数(大于总数一半)&lt;/p>
&lt;ul>
&lt;li>启用 Lease，则直接当选为领导人(Leader)，选举结束;&lt;/li>
&lt;li>未启用 Lease，则进入选举确认(ElectionAck)状态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>否则，如果未达到法定票数，则给各个复制节点发送&lt;code>ReqMsgVote&lt;/code>拉票消息，强制各节点投票；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>拉票消息，投反对票，并回复 RespMsgVote 消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>拉票消息后，&lt;/p>
&lt;ul>
&lt;li>如果满足投票条件(条件：未设置 lease，或没有 leader 节点 并且 未投票给其他节点 且 日志为最新)，投赞成票，回复 RespMsgVote 消息给拉票节点；&lt;/li>
&lt;li>否则，投反对票；回复 RespMsgVote 消息给拉票节点；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Leader&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>消息，投反对票，回复&lt;code>RespMsgVote&lt;/code>消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ElectionAck&lt;/code>节点收到&lt;code>ReqMsgVote&lt;/code>消息，投反对票；回复 RespMsgVote 消息给拉票节点；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Candidate&lt;/code> 收到 &lt;code>RespMsgVote&lt;/code>投票消息后，统计有效票数：&lt;/p>
&lt;ul>
&lt;li>如果赞成票达多数
&lt;ul>
&lt;li>如果未启用 lease，则成为 Leader；&lt;/li>
&lt;li>否则，进入 ElectionAck 状态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果反对票达多数，则成为&lt;code>Follower&lt;/code>；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Follower&lt;/code>给拉票候选人投赞成票条件：&lt;/p>
&lt;ul>
&lt;li>无 leader（或未启用 lease）;&lt;/li>
&lt;li>未给其他节点投过票；&lt;/li>
&lt;li>该候选人的 term 和 index 均为最新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="选举确认electionack">选举确认（ElectionAck）&lt;/h4>
&lt;p>如果启用 Lease，节点获得多数票后，不会直接当选，需先进入 ElectionAck 状态，对选举进行确认；&lt;/p>
&lt;p>在 ElectionAck 状态，ElectionAck 节点将向其他节点发送选举确认请求消息(ReqMsgElectAck)，待其他节点回复确认消息(RespMsgElectAck)后，统计确认票数，如果确认票数达到法定票数，才当选为领导人(Leader)。&lt;/p>
&lt;ul>
&lt;li>Follower 节点收到 ReqMsgElectAck 消息，将重置选举计数器，并将发送节点设为 Leader 后，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>Candidate 节点收到 ReqMsgElectAck 消息，将自己转变成 Follower，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>其他 ElectAck 节点收到 ReqMsgElectAck 消息，同样将自己转变成 Follower，回复 RespMsgElectAck 消息；&lt;/li>
&lt;li>ElectAck 节点收到 RespMsgElectAck 消息后，记录确认消息(ack)数。如果确认消息数大于等于法定当选票数，则当选为 Leader。并立即广播 append；&lt;/li>
&lt;/ul>
&lt;h3 id="日志复制流程">日志复制流程&lt;/h3>
&lt;h4 id="任何节点收到消息">任何节点收到消息：&lt;/h4>
&lt;ul>
&lt;li>如果是 LocalMsgHup 消息：
&lt;ul>
&lt;li>如果是非 Leader，且有副本节点，
&lt;ul>
&lt;li>如果包含配置变更消息且 comitted &amp;gt; applied, 则忽略；&lt;/li>
&lt;li>否则，举行选举；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果是 Leader 节点，则忽略；&lt;/li>
&lt;li>返回；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>否则，判断消息任期(Term):
&lt;ul>
&lt;li>如果 Term==0， 忽略；&lt;/li>
&lt;li>如果消息任期(m.Term) &amp;gt; 节点任期(r.term), 则继续判断
&lt;ul>
&lt;li>如果为请求投票消息(ReqMsgVote)，判断 lease：
&lt;ul>
&lt;li>如果是 Follower 节点，且启用了 lease，且消息不是来自旧 Leader 节点，则给旧 Leader 回复 LeaseMsgOffline 消息，通知旧 Leader Lease 下线；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变成 Follower。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果消息里任期小于节点任期(m.Term&amp;lt;r.term)，则忽略；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>转入不同角色状态处理；&lt;/li>
&lt;/ul>
&lt;h4 id="角色状态消息处理">角色状态消息处理&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>Follower&lt;/p>
&lt;ul>
&lt;li>LocalPropMsg：
&lt;ul>
&lt;li>如果没有 Leader，则不处理（报警提示）；&lt;/li>
&lt;li>如果有 Leader，转发 Leader 处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgAppend：
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;li>执行 append 操作：
&lt;ul>
&lt;li>如果消息 index 小于本节点 committed，则回复 RespMsgAppend 本节点 committe index；&lt;/li>
&lt;li>否则，尝试 append
&lt;ul>
&lt;li>如果 append 成功，则回复 RespMsgAppend（index = lastIndex）；&lt;/li>
&lt;li>否则，回复 RespMsgAppend，Reject=true；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgHeartBeat：
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqCheckQuorum:
&lt;ul>
&lt;li>重置选举计数器；&lt;/li>
&lt;li>设置 Leader 为消息发送者；&lt;/li>
&lt;li>回应发送者 RespCheckQuorum 消息；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgVote:
&lt;ul>
&lt;li>如果满足投票条件，则重置选举计数器，并回复发送者 RespMsgVote（赞成票，Reject=false）；&lt;/li>
&lt;li>否则回复发送者 RespMsgVote（反对票，Reject=true）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LeaseMsgTimeout
&lt;ul>
&lt;li>如果消息来自 Leader，则重置选举计数器，并发送 LocalMsgHup 消息;&lt;/li>
&lt;li>否则忽略；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Candidate&lt;/p>
&lt;ul>
&lt;li>LocalMsgProp:
&lt;ul>
&lt;li>忽略&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgAppend：
&lt;ul>
&lt;li>先转变为 Follower；&lt;/li>
&lt;li>再执行 append:&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgHeartBeat：
&lt;ul>
&lt;li>转变为 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgElectAck
&lt;ul>
&lt;li>先转变为 Follower；&lt;/li>
&lt;li>回复发送者 RespMsgElectAck 消息(Reject=false)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ReqMsgVote：
&lt;ul>
&lt;li>回复发送者 RespMsgVote 消息, 投反对票(Reject=true)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RespMsgVote:
&lt;ul>
&lt;li>统计收到的赞成票数；&lt;/li>
&lt;li>如果赞成票已达多数：
&lt;ul>
&lt;li>如果启用 LeaseCheck，则转变为 ElectionAck 状态；&lt;/li>
&lt;li>否则未启用 LeaseCheck，则当选为 Leader，并广播 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果反对票已达多数，则变成 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Leader&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LocalMsgProp:&lt;/p>
&lt;ul>
&lt;li>空消息或没有副本节点，则忽略该消息；&lt;/li>
&lt;li>否则，检查是否有配置变更消息；&lt;/li>
&lt;li>append；&lt;/li>
&lt;li>向副本节点广播 append。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgVote:&lt;/p>
&lt;ul>
&lt;li>向发送者回复 RespMsgVote，投反对票(Reject=true);&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgAppend:&lt;/p>
&lt;ul>
&lt;li>更新复制信道(pr)状态；&lt;/li>
&lt;li>如果 Reject, 则 pr 可能要回退，并转变到探测状态，在发送 append&lt;/li>
&lt;li>否则，更新信道状态，并尝试 commit：
&lt;ul>
&lt;li>如果 commit 成功，则广播 append；&lt;/li>
&lt;li>如果信道暂停过，则发送 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgHeartBeat:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="更新信道状态">更新信道状态&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>LeaseMsgOffline:&lt;/p>
&lt;ul>
&lt;li>给所有副本节点发送 LeaseMsgTimeOut 消息；&lt;/li>
&lt;li>转变为 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgSnapShot:&lt;/p>
&lt;ul>
&lt;li>如果信道状态不是 replicaStateSnapshot, 则忽略；&lt;/li>
&lt;li>如果消息被拒绝，则快照失败，信道转入探测状态；&lt;/li>
&lt;li>否则，更新信道并继续探测；&lt;/li>
&lt;li>信道暂停；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespCheckQuorum:&lt;/p>
&lt;ul>
&lt;li>接收 Ack；&lt;/li>
&lt;li>如果收到确认节点数+1(本节点)，则 readOnly-&amp;gt;advance;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ElectionAck&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LocalMsgProp:&lt;/p>
&lt;ul>
&lt;li>忽略&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgAppend:&lt;/p>
&lt;ul>
&lt;li>转变为 Follower；&lt;/li>
&lt;li>执行 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgHeartBeat:&lt;/p>
&lt;ul>
&lt;li>变成 Follower；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgElectAck:&lt;/p>
&lt;ul>
&lt;li>变成 Follower；&lt;/li>
&lt;li>回复 ResqMsgElectAck;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ReqMsgVote:&lt;/p>
&lt;ul>
&lt;li>回复 RespMsgVote，投反对票(Reject=true)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespCheckQuorum:&lt;/p>
&lt;ul>
&lt;li>recvAck&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RespMsgElectAck:&lt;/p>
&lt;ul>
&lt;li>统计 ack 数；&lt;/li>
&lt;li>如果确认数&amp;gt;=法定票数，则成为 Leader，并广播 append；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="计时器tick">计时器(Tick)&lt;/h3>
&lt;p>计时器和消息一起用于驱动 raft 状态机的状态变更，主要包括三种种计时器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>心跳计数器(tickHeartBeat)：用于 Leader 向 Follower 发送存活信号。&lt;/p>
&lt;p>用于 Leader 节点，其频率&amp;raquo;选举计时器，约为选举计数器频率的 10 倍,用于 Leader 和 Follower 节点间确认信道状态。流程如下：&lt;/p>
&lt;ul>
&lt;li>心跳计数器+1，选举计数器+1；&lt;/li>
&lt;li>如果选举计数器到达阈值：
&lt;ul>
&lt;li>重置选举计数器为 0；&lt;/li>
&lt;li>如果启用 lease 且 lease 失效，则 Leader 状态转变为 Follower 状态；
&lt;ul>
&lt;li>如果是非 Leader 节点，忽略；&lt;/li>
&lt;li>如果心跳计数器到达阈值：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重置心跳计数器为 0；&lt;/li>
&lt;li>检查所有副本状态，如果不是快照状态，则副本继续；&lt;/li>
&lt;li>广播 ReadOnly；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>选举计时器(tickElection)：&lt;/p>
&lt;p>用于 Follower 和 Candidate 节点，用来计算一个任期是超时时间，如果一个任期内选举计时器超时，则将触发重新选举操作，流程如下：&lt;/p>
&lt;ul>
&lt;li>如果节点无法；&lt;/li>
&lt;li>选举计数器+1；&lt;/li>
&lt;li>判断是否超时：
&lt;ul>
&lt;li>如果超时，则重重置选举计数器为 0；状态机输入 LocalMsgHup 消息，中断当前任期；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>当选确认计数器(tickElectAck)：&lt;/p>
&lt;p>当选确认计数器主要用作当选确认状态节点中，流程如下：&lt;/p>
&lt;ul>
&lt;li>选举计数器+1；&lt;/li>
&lt;li>如果选举计数器超时，则：
&lt;ul>
&lt;li>重置选举计数器为 0；&lt;/li>
&lt;li>状态机输入 LocalMsgHup 消息，中断当前任期；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="成员变更">成员变更&lt;/h3>
&lt;ul>
&lt;li>成员变更在一次只变更一个节点(增加或删除一个节点)的情况下，可以当做普通的raft write请求来处理；&lt;/li>
&lt;li>将日志分为普通和成员变更两种类型，普通日志走正常的fsm流程，成员变更类型日志&lt;/li>
&lt;/ul>
&lt;h3 id="readonly">ReadOnly&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>使用readOnly来处理读请求；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>raft算法的leader完整性确保leader一定拥有最新的已提交数据，为此只读请求在leader中需要保证当前的leader有效();&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实现两种读请求优化 ：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>readIndex:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>readLease&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="不足">不足&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>缺乏test；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/47117804">线性一致性和 Raft&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/35697913">Raft 的 PreVote 实现机制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/50455478">Etcd 之 Lease read&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5af066f1f265da0b715634b9">Raft 协议精解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI3NDIxNTQyOQ==&amp;amp;mid=2247484499&amp;amp;idx=1&amp;amp;sn=79acb9b4b2f8baa3296f2288c4a0a45b&amp;amp;scene=0#wechat_redirect">TiKV 源码解析系列 - Lease Read&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/solotzg/article/details/80669924">Raft TLA+形式化验证&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Chubaofs Fuse Client</title><link>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-client/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-client/</guid><description>&lt;h1 id="chubaofs-fuse-client">Chubaofs Fuse Client&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="源码">源码&lt;/h2>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Super&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="write">write&lt;/h3>
&lt;h2 id="参考">参考&lt;/h2></description></item><item><title>ChubaoFS MetaNode</title><link>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-metanode/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-metanode/</guid><description>&lt;h1 id="chubaofs-metanode">ChubaoFS MetaNode&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="源码分析">源码分析&lt;/h2>
&lt;hr>
&lt;h3 id="启动流程">启动流程&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">main=&amp;gt;start: main
doStart=&amp;gt;subroutine: 启动
et=&amp;gt;end: 结束
main-&amp;gt;doStart-&amp;gt;et
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">doStart=&amp;gt;start: doStart
parseConfig=&amp;gt;operation: 解析配置
et=&amp;gt;end: 结束
doStart-&amp;gt;parseConfig
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// cmd/cmd.go
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">MetaNode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">server&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Start&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">doStart&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">// metanode.go
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">func&lt;/span> &lt;span class="nf">doStart&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">parseConfig&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//解析配置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">register&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//将本metanode节点注册到master上
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startRaftServer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//启动RaftServer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startMetaManager&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//启动meta管理器, metaManager-&amp;gt; start() -&amp;gt; onStart() -&amp;gt; loadPartitions()
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">registerAPIHandler&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//注册api处理函数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">exporter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Init&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//初始化监控
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">checkLocalPartitionMatchWithMaster&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startServer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//启动主服务
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">exporter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">RegistConsul&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//注册监控Consul
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// manager.go
&lt;/span>&lt;span class="c1">// 加载所有metaPartition
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">metaManager&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">loadPartitions&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="metapartition">metaPartition&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// metaPartition 启动
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">metaPartition&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">onStart&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">load&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//加载metadata、inode、dentry、extend、multipart、applyID
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startSchedule&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//启动一个协程管理内存数据持久化
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startFreeList&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//启动FreeList清理相关工作
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startRaft&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//后台清理服务
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">metaPartition&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">startFreeList&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">delInodeFp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">OpenFile&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">updateVolWorker&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">deleteWorker&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startDeleteExtents&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="基本数据结构">基本数据结构&lt;/h2>
&lt;h3 id="inode">Inode&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Inode代表mp中的一个文件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mp的所有inode 通过btree组织为起来，key为Inode ID;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过btree，可以对所有的inode进行get和范围scan;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Inode中的&lt;code>Extents&lt;/code>记录该文件的有序extent记录，通过extents可从datanode上读取文件数据；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">Inode&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RWMutex&lt;/span>
&lt;span class="nx">Inode&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="c1">// Inode ID
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Type&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;span class="nx">Uid&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;span class="nx">Gid&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;span class="nx">Size&lt;/span> &lt;span class="kt">uint64&lt;/span>
&lt;span class="nx">Generation&lt;/span> &lt;span class="kt">uint64&lt;/span>
&lt;span class="nx">CreateTime&lt;/span> &lt;span class="kt">int64&lt;/span>
&lt;span class="nx">AccessTime&lt;/span> &lt;span class="kt">int64&lt;/span>
&lt;span class="nx">ModifyTime&lt;/span> &lt;span class="kt">int64&lt;/span>
&lt;span class="nx">LinkTarget&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span> &lt;span class="c1">// SymLink target name
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">NLink&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// NodeLink counts
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Flag&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;span class="nx">Reserved&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="c1">// reserved space
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//Extents *ExtentsTree
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Extents&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">SortedExtents&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="dentry">Dentry&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Dentry代表文件名和Inode之间的映射关系，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过ParentId将所有的文件名组织为一个树形结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dentry Btree以ParentID + Name为key进行排序；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Dentry&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ParentId&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="c1">// FileID value of the parent inode.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="c1">// Name of the current dentry.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Inode&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="c1">// FileID value of the current inode.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Type&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="extend">Extend&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>extend用于记录文件的扩展属性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>extend btree 以 inode id 为key；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展属性以kv形式存储在dataMap字段；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Extend&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">inode&lt;/span> &lt;span class="kt">uint64&lt;/span>
&lt;span class="nx">dataMap&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">][]&lt;/span>&lt;span class="kt">byte&lt;/span>
&lt;span class="nx">mu&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RWMutex&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="操作">操作&lt;/h2>
&lt;h3 id="创建软连接">创建软连接&lt;/h3>
&lt;ul>
&lt;li>新建一个新的Inode，Inode的LinkTarget为软连接目标文件的文件路径；&lt;/li>
&lt;li>新建dentry， dentry Inode为新Inode ID；&lt;/li>
&lt;/ul>
&lt;h3 id="创建硬链接">创建硬链接&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>增加旧inode的NLink计数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新增dentry，dentry Inode为旧Inode ID；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="mp分裂">mp分裂&lt;/h3>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>ChubaoFS 读写分析</title><link>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-%E8%AF%BB%E5%86%99%E5%88%86%E6%9E%90/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/40.storage/chubaofs/chubaofs-%E8%AF%BB%E5%86%99%E5%88%86%E6%9E%90/</guid><description>&lt;h1 id="chubaofs-读写分析">ChubaoFS 读写分析&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>ExtentClient&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ExtentHandler&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sdk">sdk&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">ExtentClient&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">streamers&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">uint64&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Streamer&lt;/span>
&lt;span class="nx">dataWrapper&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Wrapper&lt;/span>
&lt;span class="c1">//...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Streamer&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">extents&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ExtentCache&lt;/span>
&lt;span class="nx">handler&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ExtentHandler&lt;/span>
&lt;span class="nx">dirtylist&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">DirtyExtentList&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">ExtentHandler&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="write">Write&lt;/h2>
&lt;p>chubaofs 客户端写操作由&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// sdk 写数据入口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ExtentClient&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">inode&lt;/span> &lt;span class="kt">uint64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">offset&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">data&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetStreamer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">inode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">once&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Do&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">(){&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetExtents&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IssueWriteRequest&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//streamer处理写请求, 获取一个写请求，然后将请求放入s.request 通道
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Streamer&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 准备写请求
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">requests&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">extents&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">PrepareWriteRequests&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">//...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">requests&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">doWrite&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// streamer 通过extenthandler 将数据写入到datanode中
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Streamer&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">doWrite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// set storeMode
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">storeMode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">tailOff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">tinySizeLimit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">tailOff&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">tinySizeLimit&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">proto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NormalExtentType&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">proto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TinyExtentType&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}(&lt;/span>&lt;span class="nx">offset&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tinySizeLimit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">//重试写入
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">MaxNewHandlerRetry&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">ek&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">handler&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">direct&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 写成功
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">ek&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">break&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 写
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">eh&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ExtentHandler&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">write&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">total&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">eh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">flushPacket&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// eh.request &amp;lt;- packet
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 发送协程,
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">eh&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ExtentHandler&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">sender&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">packet&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">eh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">request&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 接收协程
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">eh&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ExtentHandler&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">receiver&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">reply&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">eh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">re&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="streamer处理追加写请求">streamer处理追加写请求&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>追加写入口在&lt;code>(streamer)doWrite()&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>首先根据写入请求在文件中的最大偏移(offset+size)来决定了extent类型：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&amp;lt;= 1MB, 使用TinyExtent；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>&amp;gt;&lt;/code>1MB, 使用NormalExtent;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>再获取extentHandler, 通过extentHandler将数据发送；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>//doWrite: 处理追加写请求
// 1. 根据offset+size确定extent类型;
// * &amp;lt;= 1MB，为tinyExtent;
// * &amp;gt; 1MB, normalExtent；
// 2. 获取extentHandler, 通过handler的write调用将数据写入, 失败的话，最多重试3次；
// 3. 写入成功的话，将handler加入到dirtylist, 并将write获取的ek加入到extents缓存中;
// 4. 返回写入的size;
// 5. 上面步骤中出错时，中断流程，返回错误；&lt;/p>
&lt;h3 id="streamer处理覆盖写请求streamerdooverwrite">streamer处理覆盖写请求(streamer.doOverwrite())&lt;/h3>
&lt;p>// 处理覆盖写请求
// 1. flush dirtylist;
// 2. 根据 file offset 从 extents 缓存中查找extentKey，如果为nil, 返回错误;
// 3. 根据extentKey从缓存partitions中获取dp;
// 4. 获取一个到主dp副本的conn;
// 5. 根据size发送OverWrite请求到conn，并获取结果;
// 6. 发送时，先试着往主副本发送, 如果失败，会依次重试往其他从副本发送，直到有一个返回成功；
// 7. 接收到OverWriteReq的datanode如果是leader，则直接通过raft 将该指令执行，如果是从副本dn，则转发到leader上，由leader执行；&lt;/p></description></item><item><title>Golang Runtime</title><link>https://justice.bj.cn/post/14.language/golang/golang-runtime/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang-runtime/</guid><description>&lt;h1 id="golang-runtime">Golang Runtime&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;h2 id="go调度器的演化">Go调度器的演化&lt;/h2>
&lt;h2 id="源码分析">源码分析&lt;/h2>
&lt;p>Go 程序启动后需要对自身运行时进行初始化，其真正的程序入口由 runtime 包控制。 以 AMD64 架构上的 Linux 和 macOS 为例，分别位于：&lt;code>src/runtime/rt0_linux_amd64.s&lt;/code> 和 &lt;code>src/runtime/rt0_darwin_amd64.s&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
JMP _rt0_amd64(SB)
TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8
JMP _rt0_amd64(SB)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>两者均跳转到了 &lt;code>_rt0_amd64&lt;/code> 函数:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">TEXT _rt0_amd64(SB),NOSPLIT,$-8
MOVQ 0(SP), DI // argc
LEAQ 8(SP), SI // argv
JMP runtime·rt0_go(SB)
TEXT runtime·rt0_go(SB),NOSPLIT,$0
// 将参数向前复制到一个偶数栈上
MOVQ DI, AX // argc
MOVQ SI, BX // argv
SUBQ $(4*8+7), SP // 2args 2auto
ANDQ $~15, SP
MOVQ AX, 16(SP)
MOVQ BX, 24(SP)
// 初始化 g0 执行栈
MOVQ $runtime·g0(SB), DI // DI = g0
LEAQ (-64*1024+104)(SP), BX
MOVQ BX, g_stackguard0(DI) // g0.stackguard0 = SP + (-64*1024+104)
MOVQ BX, g_stackguard1(DI) // g0.stackguard1 = SP + (-64*1024+104)
MOVQ BX, (g_stack+stack_lo)(DI) // g0.stack.lo = SP + (-64*1024+104)
MOVQ SP, (g_stack+stack_hi)(DI) // g0.stack.hi = SP
// 确定 CPU 处理器的信息
MOVL $0, AX
CPUID // CPUID 会设置 AX 的值
MOVL AX, SI
(...)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/01/25-16-54-30-2021-01-25-16-54-23-image.png" alt="golang-runtime启动流程">&lt;/p>
&lt;h2 id="sysmon">sysmon&lt;/h2>
&lt;p>在main.main执行之前，Go语言的runtime库会初始化一些后台任务，其中一个任务就是sysmon。&lt;/p>
&lt;p>sysmon是一个物理线程，主要处理两个事件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于网络的epoll;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占式调度的检测: sysmon会根据系统当前的繁忙程度睡一小段时间，然后每隔10ms至少进行一次epoll并唤醒相应的goroutine&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">newm&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sysmon&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nil&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//sysmon 是一个m, 物理线程；
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="p">(;;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">usleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">delay&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lastpoll&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">lastpoll&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1000&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">netpoll&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">retake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 根据每个P的状态和运行时间决定是否要进行抢占
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="scavenger">scavenger&lt;/h2>
&lt;p>scavenger是一个goroutine，执行的是runtime·MHeap_Scavenger函数。&lt;/p>
&lt;p>它将一些不再使用的内存归还给操作系统，用于执行内存回收；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="n">newproc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">scavenger&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="n">main&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//scavenger 是一个goroutine
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="go-关键字">go 关键字&lt;/h2>
&lt;p>Go语言中，表达式go f(x, y, z)会启动一个新的goroutine运行函数f(x, y, z)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">go&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">//go 关键字是如下语句的一个包装
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">newproc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="defer">defer&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>defer关键字的实现跟go关键字很类似，不同的是它调用的是runtime.deferproc而不是runtime.newproc。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在defer出现的地方，插入了指令&lt;code>call runtime.deferproc&lt;/code>，然后在函数返回之前的地方，插入指令&lt;code>call runtime.deferreturn&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>goroutine的控制结构中，有一张表记录defer，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用runtime.deferproc时会将需要defer的表达式记录在表中，而在调用&lt;code>runtime.deferreturn&lt;/code>的时候，则会依次从defer表中出栈并执行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//无defer函数返回
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">add&lt;/span> &lt;span class="nx">xx&lt;/span> &lt;span class="nx">SP&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="c1">//defer 函数返回
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">call&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">deferreturn&lt;/span>&lt;span class="err">，&lt;/span>
&lt;span class="nx">add&lt;/span> &lt;span class="nx">xx&lt;/span> &lt;span class="nx">SP&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="go-routine-栈">Go Routine 栈&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>每个goroutine需要能够运行，都有自己的栈。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>初始时只给栈分配很小的空间，然后随着使用过程中的需要自动地增长&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go1.3版本之后则使用的是continuous stack；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个Go函数调用的前几条指令，先比较栈指针寄存器跟g-&amp;gt;stackguard，检测是否发生栈溢出。如果栈指针寄存器值超越了stackguard就需要扩展栈空间；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.bookstack.cn/read/go-internals/zh-04.1.md">Go语言程序初始化过程 - 系统初始化 - 《深入解析Go》 - 书栈网 · BookStack&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05life/boot/">https://golang.design/under-the-hood/zh-cn/part1basic/ch05life/boot/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.cnblogs.com/mafeng/p/10305419.html">深入理解golang 的栈 - ma_fighting - 博客园&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.huamo.online/2019/06/25/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6goroutine%E6%A0%88/">深入研究goroutine栈 | 花木兰&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/237870981">https://zhuanlan.zhihu.com/p/237870981&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://segmentfault.com/a/1190000019570427">https://segmentfault.com/a/1190000019570427&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Golang 内存管理</title><link>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/14.language/golang/golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="golang-内存管理">Golang 内存管理&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Golang内存管理采用类似&lt;code>tcmalloc&lt;/code>的分级分配算法，主要由&lt;code>MHeap&lt;/code>、&lt;code>MCentral&lt;/code>、&lt;code>MCache&lt;/code> 3 级组成。按分配对象的大小不同，选择相应的区域进行分配。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2021/12/28-10-17-33-2021-12-28-10-17-27-image.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/01/24-16-34-34-2022-01-24-16-34-31-image.png" alt="">&lt;/p>
&lt;h2 id="内存布局">内存布局&lt;/h2>
&lt;p>golang程序启动时，会根据OS类型向OS申请一大块连续虚拟内存空间如下：&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-49-34-2020-05-04-09-32-44-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>arena&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>由连续的page(8KB)组成，用于具体的对象分配；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>spans&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>存放了&lt;code>mspan&lt;/code>的指针(8Byte)，表示arena区中的某一页(page)属于哪个&lt;code>mspan&lt;/code>，用于管理arena；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bitmap&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用于标记&lt;code>arena&lt;/code>(即heap)中的对象, 每个对象使用两个bit进行标记，分别表示gc状态和是否分配；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>高地址部分指向arena区域的低地址部分，地址是由高地址向低地址增长的；&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-49-42-2020-05-04-09-36-04-image.png" alt="">&lt;/p>
&lt;h2 id="基本数据结构">基本数据结构&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MHeap&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>代表了golang的整个堆内存;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局唯一的;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大对象(&amp;gt;32KB)直接在MHeap中分配；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mheap 包含free，large两个域：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>free: free包含一个256单元的数组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>large:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>给MCentral和MCache等下层提供空间；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-49-48-2020-05-04-09-39-31-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MCentral&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>集中管理不同类型（67种）的MSpan，对应TCMalloc中的CentralCache；&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>每个mcentral包含两个mspan列表:
&lt;ul>
&lt;li>noempty: 表示已被mcache的mspan list；&lt;/li>
&lt;li>empty: 表示未被使用(empty)的mspan 链表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当某个goroutine中的mcache内存不够时，就会从mcentral的empty链表中分配对应的mspan。&lt;/li>
&lt;li>如果mcentral内存不够，就会从MHeap中分配；&lt;/li>
&lt;li>mcentral中有锁，以为多个goroutine分配提供互斥；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-49-08-2020-05-04-09-38-29-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MCache&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是各个goroutine自有的局部内存;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>向&lt;code>mcentral&lt;/code>申请得到的;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>小对象(&amp;lt;=32KB)的分配直接在goroutine内部进行，不用加锁，提高分配速度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mcache 内存不够时，会向mcentral重新申请；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-49-13-2020-05-04-09-38-54-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MSpan&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>内存管理基本单元，由一片连续的8KB页组成的双向链表，进行内存对象的数据分配;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为满足不同大小对象分配的需要，减少内存碎片，同时兼顾内存利用率，golang将span分层不同的大小类型（总共67种）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对象分配内存时，根据对象大小，选择最合适的mspan进行分配。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2020/11/22-13-49-19-2020-05-04-09-37-59-image.png" alt="">&lt;/p>
&lt;h2 id="内存分配">内存分配&lt;/h2>
&lt;p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：&lt;/p>
&lt;ul>
&lt;li>Tiny对象： (0, 16B]，使用mcache的tiny分配器分配，多个tiny对象可组合在一个mspan中&lt;/li>
&lt;li>Small对象：(16B, 32KB ]，在mcache中选择相应规格大小的mspan进行分配；&lt;/li>
&lt;li>大对象：&amp;gt;32KB, 直接从MHeap中分配；&lt;/li>
&lt;/ul>
&lt;p>golang变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。&lt;/p>
&lt;p>通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小。&lt;/p>
&lt;p>分配顺序：&lt;/p>
&lt;ul>
&lt;li>首先通过计算使用的大小规格&lt;/li>
&lt;li>然后&lt;code>mcache&lt;/code>中对应大小规格的块分配。&lt;/li>
&lt;li>如果&lt;code>mcache&lt;/code> free 链表不够分配&lt;/li>
&lt;li>如果&lt;code>mcentral&lt;/code>中没有可用的块，则向&lt;code>mheap&lt;/code>申请，并根据算法找到最合适的&lt;code>mspan&lt;/code>。&lt;/li>
&lt;li>如果申请到的&lt;code>mspan&lt;/code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。&lt;/li>
&lt;li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。&lt;/li>
&lt;/ul>
&lt;h2 id="gc流程">GC流程&lt;/h2>
&lt;h3 id="gc时机">GC时机&lt;/h3>
&lt;p>golang gc的触发是由gcpercent变量控制的，当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。&lt;/p>
&lt;p>比如，gcpercent=100，当前使用了4M的内存，那么当内存分配到达8M时就会再次gc。&lt;/p>
&lt;p>如果回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。&lt;/p>
&lt;p>也就是说，并不是内存分配越多，垃圾回收频率越高，这个算法使得垃圾回收的频率比较稳定，适合应用的场景。&lt;/p>
&lt;p>gcpercent的值是通过环境变量GOGC获取的，如果不设置这个环境变量，默认值是100。&lt;/p>
&lt;p>如果将它设置成off，则是关闭垃圾回收。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/27807169">https://zhuanlan.zhihu.com/p/27807169&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/2904efc7f1a8">图解Golang的内存分配&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/29216091">https://zhuanlan.zhihu.com/p/29216091&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/76802887">https://zhuanlan.zhihu.com/p/76802887&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yq.aliyun.com/articles/652551">&lt;strong>简单易懂的 Go 内存分配原理解读&lt;/strong>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5c888a79e51d456ed11955a8">https://juejin.im/post/5c888a79e51d456ed11955a8&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/225190602">白话Go语言内存管理三部曲（一）内存分配原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000022499402">go怎样做stw&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw">https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>HBase事务</title><link>https://justice.bj.cn/post/30.architech/hbase/hbase%E4%BA%8B%E5%8A%A1/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/30.architech/hbase/hbase%E4%BA%8B%E5%8A%A1/</guid><description>&lt;h1 id="hbase事务">HBase事务&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>HBase本身仅支持行级ACID事务一致性保证，通过行锁(RowLock) + MVCC实现。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;h2 id="行锁">行锁&lt;/h2>
&lt;p>行锁是基于行的独占锁来保证对同一行写的独立性，可用于保证写操作的一致性。基本流程如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>获取行锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写WAL文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新MemStore：将每个cell写入到memstore&lt;/p>
&lt;/li>
&lt;li>
&lt;p>释放行锁&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="hbase同步机制">HBase同步机制&lt;/h2>
&lt;p>HBase提供了两种同步机制:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是基于CountDownLatch实现的互斥锁，常见的使用场景是行数据更新时所持的行锁。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一种是基于ReentrantReadWriteLock实现的读写锁，该锁可以给临界资源加上read-lock或者write-lock。其中read-lock允许并发的读取操作，而write-lock是完全的互斥操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="countdownlatch">CountDownLatch&lt;/h2>
&lt;p>Java中，CountDownLatch是一个同步辅助类，在完成一组其他线程执行的操作之前，它允许一个或多个线程阻塞等待。CountDownLatch使用给定的计数初始化，核心的两个方法是countDown()和await()，前者可以实现给定计数倒数一次，后者是等待计数倒数到0，如果没有到达0，就一直阻塞等待。结合线程安全的map容器，基于test-and-set机制，CountDownLatch可以实现基本的互斥锁，原理如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>初始化：CountDownLatch初始化计数为1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>test过程：线程首先将临界资源作为key，latch作为value尝试插入线程安全的map中。如果返回失败，表示其他线程已经持有了该锁，调用await方法阻塞到该latch上，等待其他线程释放锁；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>set过程：如果返回成功，就表示已经持有该锁，其他线程必然插入失败。持有该锁之后执行各种操作，执行完成之后释放锁，释放锁首先将map中对应的KeyValue移除，再调用latch的countDown方法，该方法会将计数减1，变为0之后就会唤醒其他阻塞线程。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="reentrantreadwritelock">ReentrantReadWriteLock&lt;/h2>
&lt;p>读写锁分为读锁、写锁，和互斥锁相比可以提供更高的并行性。&lt;/p>
&lt;p>读锁允许多个线程同时以读模式占有锁资源，而写锁只能由一个线程以写模式占有。&lt;/p>
&lt;p>如果读写锁是写加锁状态，在锁释放之前，所有试图对该锁占有的线程都会被阻塞；&lt;/p>
&lt;p>如果是读加锁状态，所有其他对该锁的读请求都会并行执行，但是写请求会被阻塞。&lt;/p>
&lt;p>显而易见，读写锁适合于读多写少的场景，也因为读锁可以共享，写锁只能某个线程独占，&lt;/p>
&lt;p>读写锁也被称为共享－独占锁，即经常见到的S锁和X锁。&lt;/p>
&lt;p>Java中，ReentrantReadWriteLock是读写锁的实现类，该类中有两个方法readLock()和writeLock()分别用来获取读锁和写锁。&lt;/p>
&lt;h2 id="hbase中行锁的具体实现">HBase中行锁的具体实现&lt;/h2>
&lt;p>HBase采用行锁实现更新的原子性，要么全部更新成功，要么失败。&lt;/p>
&lt;p>所有对HBase行级数据的更新操作，都需要首先获取该行的行锁，并且在更新完成之后释放，等待其他线程获取。&lt;/p>
&lt;p>因此，HBase中对同一行数据的更新操作都是串行操作。&lt;/p>
&lt;h2 id="行锁相关数据结构">行锁相关数据结构&lt;/h2>
&lt;p>&lt;img src="https://sslstatic.ktanx.com/images/release/201610/201610/8iP73qpadTOSq1g9.jpg" alt="">&lt;/p>
&lt;p>如上图所示，HBase中行锁相关的主要结构有RowLock和RowLockContext两个类，&lt;/p>
&lt;p>其中RowLockContext类存储行锁相关上下文信息，包括持锁线程、被锁对象以及可以实现互斥锁的CountDownLatch对象等等，RowLockContext是RowLock的一个属性，&lt;/p>
&lt;p>除此之外，RowLock还包含表征行锁是否已经释放的release字段。具体字段如下图所示：&lt;/p>
&lt;p>&lt;img src="https://sslstatic.ktanx.com/images/release/201610/201610/8DWRTNclsRfLZLcB.jpg" alt="">&lt;/p>
&lt;p>&lt;img src="https://sslstatic.ktanx.com/images/release/201610/201610/jCXIojnWC2ThEUIc.jpg" alt="">&lt;/p>
&lt;h2 id="更新加锁流程">更新加锁流程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>首先使用rowkey以及自身线程对象生成行锁上下文RowLockContext对象&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再将rowkey作为key，RowLockContext对象作为value调用putIfAbsert方法写入全局map中。key的唯一性，保证map中最多只有一个RowLockContext。putIfAbsent方法会返回一个existingContext对象，该对象表示key插入前map中对应该key的value值，根据existingContext是否为null、是否是自身线程创建，可以分为如下三种情况：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>（1）existingContext对象为null，表示该行锁没有被其他线程持有，可以根据创建的上下文对象持有该锁&lt;/p>
&lt;p>（2）existingContext是自身线程创建，表示自身线程已经再创建RowLockContext对象，直接使用存在的RowLockContext对象持有该锁。这种情况会出现在批量更新线程中，一次批量更新可能前前后后对某一行数据更新多次，需要多次持有该行数据的行锁，在HBase中是被允许的。&lt;/p>
&lt;p>（3）existingContext是其他线程创建，则该线程会阻塞在此上下文所持锁上，直至所持行锁被释放或者阻塞超时。如果所持行锁释放，该线程会重新竞争写全局map，一旦竞争成功就持有该行锁，否则继续阻塞。而如果阻塞超时，就会抛出异常，不会再去竞争该锁。&lt;/p>
&lt;h2 id="释放流程">释放流程&lt;/h2>
&lt;p>在线程更新完成操作之后，必须在finnally方法中执行行锁释放操作，即调用rowLock.release()方法，该方法主要执行如下两个操作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从lockedRows这个全局map中将该row对应的RowLockContext移除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用latch.countDown()方法，唤醒其他阻塞在await上等待该行锁的线程&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="hbase中读写锁的使用">HBase中读写锁的使用&lt;/h2>
&lt;p>HBase中除了使用互斥锁实现行级数据的一致性之外，也使用读写锁实现store级别操作以及region级别操作的并发控制。比如：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Region更新读写锁：HBase在执行数据更新操作之前都会加一把Region级别的读锁（共享锁），所有更新操作线程之间不会相互阻塞；然而，HBase在将memstore数据落盘时会加一把Region级别的写锁（独占锁）。因此，在memstore数据落盘时，数据更新操作线程（Put操作、Append操作、Delete操作）都会阻塞等待至该写锁释放。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Region Close保护锁：HBase在执行close操作以及split操作时会首先加一把Region级别的写锁（独占锁），阻塞对region的其他操作，比如compact操作、flush操作以及其他更新操作，这些操作都会持有一把读锁（共享锁）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Store snapshot保护锁：HBase在执行flush memstore的过程中首先会基于memstore做snapshot，这个阶段会加一把store级别的写锁（独占锁），用以阻塞其他线程对该memstore的各种更新操作；清除snapshot时也相同，会加一把写锁阻塞其他对该memstore的更新操作。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="hbase中mvcc机制的实现">HBase中MVCC机制的实现&lt;/h2>
&lt;p>如上文所述，HBase分别提供了行锁和读写锁来实现行级数据、Store级别以及Region级别的并发控制。&lt;/p>
&lt;p>除此之外，HBase还提供了MVCC机制实现数据的读写并发控制。&lt;/p>
&lt;p>MVCC，即多版本并发控制技术，它使得事务引擎不再单纯地使用行锁实现数据读写的并发控制，&lt;/p>
&lt;p>取而代之的是，把行锁与行的多个版本结合起来，经过简单的算法就可以实现非锁定读，进而大大的提高系统的并发性能。&lt;/p>
&lt;p>HBase正是使用&lt;strong>行锁 ＋ MVCC&lt;/strong>保证高效的并发读写以及读写数据一致性。&lt;/p>
&lt;h2 id="mvcc机制简介">MVCC机制简介&lt;/h2>
&lt;p>在了解HBase如何实现MVCC之前，我们首先需要了解当前仅基于行锁实现的更新操作对于读请求有什么影响。&lt;/p>
&lt;p>下图为HBase基于行锁实现的数据更新时序示意图：&lt;/p>
&lt;p>&lt;img src="https://sslstatic.ktanx.com/images/release/201610/201610/Oi7sncjyfrK2OpQI.jpg" alt="">&lt;/p>
&lt;p>上图中简单地表述了数据更新流程（后续文章会对HBase数据写入进行深入的介绍），简单来说，数据更新可以分为如下几个阶段：获取行锁、更新WAL、数据写入本地缓存memstore、释放行锁。&lt;/p>
&lt;p>如上图所示，前后分别有两次对同一行数据的更新操作。假如第二次更新过程在将列簇cf1更新为t2_cf1之后中有一次读请求进来，此时读到的第一列数据将是第二次更新后的数据t2_cf1，然而第二列数据却是第一次更新后的数据t1_cf2，很显然，只针对更行操作加行锁会产生读取数据不一致的情况。最简单的数据不一致解决方案是读写线程公用一把行锁，这样可以保证读写之间互斥，但是读写线程同时抢占行锁必然会极大地影响性能。&lt;/p>
&lt;p>为此，HBase采用MVCC解决方案避免读线程去获取行锁。MVCC解决方案对上述数据更新操作时序和读操作都进行了一定的修正，主要新增了一个写序号和读序号，其实就是数据的版本号。修正后的更新操作时序示意图为：&lt;/p>
&lt;p>&lt;img src="https://sslstatic.ktanx.com/images/release/201610/201610/EXcq89hRMQxgwoKJ.jpg" alt="">&lt;/p>
&lt;p>如上图所示，修正后的更新操作主要新增了‘获取写序号’和’结束写序号’两个步骤，并且每个cell数据写memstore操作都会携带该写序号。那读请求需要经过什么样的修正呢？HBase的做法如下：&lt;/p>
&lt;p>（1）每个读操作开始时都会分配一个读序号，称为读取点&lt;/p>
&lt;p>（2）读取点的值是所有的写操作完成序号中的最大整数&lt;/p>
&lt;p>（3）一次读操作的结果就是读取点对应的所有cell值的集合&lt;/p>
&lt;p>如下图所示，第一次更新获取的写序号为1，第二次更新获取的写序号为2。读请求进来时写操作完成序号中的最大整数为wn ＝ 1，因此对应的读取点为wn ＝ 1，读取的结果为wn ＝ 1所对应的所有cell值集合，即为t1_cf1和t1_cf2，这样就可以实现以无锁的方式读取到一致的数据。&lt;/p>
&lt;p>&lt;img src="https://sslstatic.ktanx.com/images/release/201610/201610/mVteoMgUa1NwXLlX.jpg" alt="">&lt;/p>
&lt;h2 id="hbase中mvcc实现">HBase中MVCC实现&lt;/h2>
&lt;p>HBase中，MVCC的具体实现类为MultiVersionConsistencyControl，该类维护了两个long型的变量、一个WriteEntry对象和一个writeQueue队列：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>long memstoreRead：记录当前全局的读取点，读请求进来之后首先会获取该读取点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>long memstoreWrite：记录当前全局的写序号，根据它为下一个更新线程分配新的写序号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>writeEntry：记录更新操作的写序号对象，主要包含两个变量，一个是writeNumber，表示写序号；一个是布尔类型的completed，表示该次更新是否完成&lt;/p>
&lt;/li>
&lt;li>
&lt;p>writeQueue：当前所有更新操作的写序号对象集合&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="获取写序号">获取写序号&lt;/h2>
&lt;p>根据上文中更新数据时序图可知，更新线程获取行锁之后就需要获取写序号，对应的方法为beginMemstoreInsert，该方法将memstoreWrite加1，生成writeEntry对象并插入到队列writeQueue，返回writeEntry对象。Note：生成的writeEntry对象中包含写序号writeNumber，更新线程会将该writeNumber设置为cell数据的一个属性。&lt;/p>
&lt;h2 id="结束写序号">结束写序号&lt;/h2>
&lt;p>数据更新完成之后，释放行锁之前，更新线程会调用completeMemstoreInsert方法更新writeEntry对象以及memstoreRead变量，具体分为如下两步：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先将该writeEntry对象标记为’已完成’，再将全局读取点memstoreRead尽可能多地往前移。前移算法为遍历队列writeQueue中所有的writeEntry对象，移除掉已经标记为’已完成’的writeEntry直至遇到未完成的writeEntry，最后将memstoreRead变量更新为最新已完成的writeNumber。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注意上述memstoreRead变量有可能并不等于当前更新线程的writeNumber，这种情况下该更新线程对数据的更新操作对用户并不可见。为了实现更新完成之后更新结果即对用户可见，需要等待memstoreRead变量前移到当前更新线程的witeNumber。因此它会阻塞当前线程，等待其他线程对应的writeEntry对象标记为’已完成’，直至memstoreRead等于当前线程的writeNumber。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>HBase提供了各种锁机制和MVCC机制来保证数据的原子性、一致性等特性，其中使用互斥锁实现的行锁保证了行级数据的原子性，使用JDK提供的读写锁实现了Store级别、Region级别的数据一致性，同时使用行锁+MVCC机制实现了在高性能非锁定读场景下的数据一致性。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>ß&lt;a href="https://www.ktanx.com/blog/p/4517">HBase 事务和并发控制机制原理 - 每一个程序员都有一个大梦想&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Paxos算法</title><link>https://justice.bj.cn/post/31.distribute/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/paxos%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/31.distribute/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/paxos%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="paxos算法">Paxos算法&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>Paxos算法是Leslie Lamport在1990年提出的一种基于消息传递的一致性算法。由于算法难以理解，起初并没有引起大家的重视，Lamport在1998年将论文重新发表到TOCS上，即便如此Paxos算法还是没有得到重视，2001年Lamport用可读性比较强的叙述性语言给出算法描述。&lt;/p>
&lt;p>2006年Google发布了三篇论文，其中在Chubby锁服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。&lt;/p>
&lt;p>基于Paxos协议的数据同步与传统主备方式最大的区别在于：&lt;/p>
&lt;p>Paxos只需超过半数的副本在线且相互通信正常，就可以保证服务的持续可用，且数据不丢失。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol></description></item><item><title>Percolator模型</title><link>https://justice.bj.cn/post/31.distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8Bpercolar/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://justice.bj.cn/post/31.distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8Bpercolar/</guid><description>&lt;h1 id="percolator模型">Percolator模型&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Percolator模型是Google提出的构建在BigTable之上的分布式事务解决方案;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Percolator主要包括以下技术要点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BigTable的行级事务模型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MVCC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TSO&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Percolator是一个2pc协议，分为prewrite阶段和commit阶段；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="tikv中percolator的实现">TiKV中Percolator的实现&lt;/h2>
&lt;p>TiKV 的读写事务分为两个阶段：1、Prewrite 阶段；2、Commit 阶段。&lt;/p>
&lt;p>客户端会缓存本地的写操作，在客户端调用 client.Commit() 时，开始进入分布式事务 prewrite 和 commit 流程。&lt;/p>
&lt;p>&lt;img src="https://gitee.com/justice/gitnote-img-bed/raw/master/2022/03/30-15-53-39-2022-03-30-15-53-17-image.png" alt="">&lt;/p>
&lt;h3 id="prewrite">Prewrite&lt;/h3>
&lt;p>Prewrite 对应传统 2PC 的第一阶段：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先在所有行的写操作中选出一个作为 primary row，其他的为 secondary rows&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PrewritePrimary: 对 primaryRow 写入锁（修改 meta key 加入一个标记），锁中记录本次事务的开始时间戳。上锁前会检查：&lt;/p>
&lt;ul>
&lt;li>该行是否已经有别的客户端已经上锁 (Locking)&lt;/li>
&lt;li>是否在本次事务开始时间之后，检查versions ，是否有更新 [startTs, +Inf) 的写操作已经提交 (Conflict)&lt;/li>
&lt;/ul>
&lt;p>在这两种种情况下会返回事务冲突。否则，就成功上锁。将行的内容写入 row 中，版本设置为 startTs&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 primaryRow 的锁上好了以后，进行 secondaries 的 prewrite 流程：&lt;/p>
&lt;ul>
&lt;li>类似 primaryRow 的上锁流程，只不过锁的内容为事务开始时间 startTs 及 primaryRow 的信息&lt;/li>
&lt;li>检查的事项同 primaryRow 的一致&lt;/li>
&lt;li>当锁成功写入后，写入 row，时间戳设置为 startTs&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>以上 Prewrite 流程任何一步发生错误，都会进行回滚：删除 meta 中的 Lock 标记 , 删除版本为 startTs 的数据。&lt;/p>
&lt;p>当 Prewrite 阶段完成以后，进入 Commit 阶段，当前时间戳为 commitTs，TSO 会保证 commitTs &amp;gt; startTs&lt;/p>
&lt;p>&lt;strong>Commit 的流程是，对应 2PC 的第二阶段：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>commit primary: 写入 meta 添加一个新版本，时间戳为 commitTs，内容为 startTs, 表明数据的最新版本是 startTs 对应的数据&lt;/li>
&lt;li>删除 Lock 标记&lt;/li>
&lt;/ol>
&lt;p>值得注意的是，如果 primary row 提交失败的话，全事务回滚，回滚逻辑同 prewrite 失败的回滚逻辑。&lt;/p>
&lt;p>如果 commit primary 成功，则可以异步的 commit secondaries，流程和 commit primary 一致， 失败了也无所谓。Primary row 提交的成功与否标志着整个事务是否提交成功。&lt;/p>
&lt;p>事务中的读操作：&lt;/p>
&lt;ol>
&lt;li>检查该行是否有 Lock 标记，如果有，表示目前有其他事务正占用此行，如果这个锁已经超时则尝试清除，否则等待超时或者其他事务主动解锁。注意此时不能直接返回老版本的数据，否则会发生幻读的问题。&lt;/li>
&lt;li>读取至 startTs 时该行最新的数据，方法是：读取 meta ，找出时间戳为 [0, startTs], 获取最大的时间戳 t，然后读取为于 t 版本的数据内容。&lt;/li>
&lt;/ol>
&lt;p>由于锁是分两级的，Primary 和 Seconary row，只要 Primary row 的锁去掉，就表示该事务已经成功提交，这样的好处是 Secondary 的 commit 是可以异步进行的，只是在异步提交进行的过程中，如果此时有读请求，可能会需要做一下锁的清理工作。因为即使 Secondary row 提交失败，也可以通过 Secondary row 中的锁，找到 Primary row，根据检查 Primary row 的 meta，确定这个事务到底是被客户端回滚还是已经成功提交。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/349445778">https://zhuanlan.zhihu.com/p/349445778&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/404605493">https://zhuanlan.zhihu.com/p/404605493&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://pingcap.com/zh/blog/tikv-source-code-reading-13">https://pingcap.com/zh/blog/tikv-source-code-reading-13&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://pingcap.com/zh/blog/tikv-source-code-reading-12">https://pingcap.com/zh/blog/tikv-source-code-reading-12&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://tikv.org/deep-dive/distributed-transaction/percolator/">https://tikv.org/deep-dive/distributed-transaction/percolator/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://pingcap.com/zh/blog/mvcc-in-tikv">https://pingcap.com/zh/blog/mvcc-in-tikv&lt;/a>&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol></description></item></channel></rss>